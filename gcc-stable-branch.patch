acsawdey (2):
      2018-02-15  Aaron Sawdey  <acsawdey@linux.vnet.ibm.com>
      2018-04-23  Aaron Sawdey  <acsawdey@linux.ibm.com>

amodra (4):
      PR84033, powerpc64le -moptimize-swaps bad code with vec_vbpermq
      fix changelog typo
      gcc testsuite changes for new linker messages
      [RS6000] Correct save_reg_p

anlauf (4):
      2019-02-10  Harald Anlauf  <anlauf@gmx.de>
      2019-03-03  Harald Anlauf  <anlauf@gmx.de> 	    Steven G. Kargl  <kargl@gcc.gnu.org>
      2019-03-31  Harald Anlauf  <anlauf@gmx.de>
      2019-04-10  Harald Anlauf  <anlauf@gmx.de>

avieira (3):
      gcc/ 2018-06-22  Andre Vieira  <andre.simoesdiasvieira@arm.com>
      gcc/ 2018-06-22  Andre Vieira  <andre.simoesdiasvieira@arm.com>
      Backport of r269499 and related testism fix r269596.

bergner (16):
      gcc/ 	Back port from mainline 	2018-01-10  Peter Bergner  <bergner@vnet.ibm.com>
      Back port from mainline 	2018-02-01  Peter Bergner  <bergner@vnet.ibm.com>
      gcc/ 	Back port from mainline 	2018-02-13  Peter Bergner  <bergner@vnet.ibm.com>
      Back port from mainline 	2018-02-13  Peter Bergner  <bergner@vnet.ibm.com>
      PR target/84390 	* gcc.target/powerpc/vsxcopy.c: Also match lxv when compiling 	with -mcpu=power9.
      gcc/ 	Backport from mainline 	2018-02-22  Vladimir Makarov  <vmakarov@redhat.com>
      Backport from mainline 	2018-03-20  Peter Bergner  <bergner@vnet.ibm.com>
      Backport from mainline 	2018-03-30  Peter Bergner  <bergner@vnet.ibm.com>
      Backport from mainline 	2018-02-08  Peter Bergner  <bergner@vnet.ibm.com>
      gcc/ 	Backport from mainline 	2018-03-28  Peter Bergner  <bergner@vnet.ibm.com>
      gcc/ 	Backport from mainline 	2018-04-04  Peter Bergner  <bergner@vnet.ibm.com>
      gcc/ 	Backport from mainline 	2018-03-09  Peter Bergner  <bergner@vnet.ibm.com>
      Backport from mainline 	2018-06-06  Peter Bergner  <bergner@vnet.ibm.com>
      gcc/ 	Backport from mainline 	2018-06-08  Peter Bergner  <bergner@vnet.ibm.com>
      gcc/ 	Backport from mainline 	2018-12-07  Peter Bergner  <bergner@linux.ibm.com>
      libitm/ 	Backport from mainline 	2018-12-13  Peter Bergner  <bergner@linux.ibm.com>

carll (5):
      gcc/ChangeLog
      gcc/ChangeLog 2018-03-06  Carl Love  <cel@us.ibm.com>
      gcc/ChangeLog:
      gcc/testsuite/ChangeLog:
      2018-07-10  Carl Love  <cel@us.ibm.com>

cesar (1):
      PR target/85056

danglin (10):
      Backport from mainline 	2018-02-01  Aldy Hernandez  <aldyh@redhat.com>
      * config/pa/pa.c (hppa_profile_hook): Mark SYMBOL_REF for _mcount as 	function label.
      Backport from mainline 	2018-03-06  John David Anglin  <danglin@gcc.gnu.org>
      Backport from mainline 	2018-03-06  John David Anglin  <danglin@gcc.gnu.org>
      Backport from mainline 	2018-02-14  John David Anglin  <danglin@gcc.gnu.org>
      PR target/83451 	* config/pa/pa.c (pa_emit_move_sequence):  Always emit secondary reload 	insn for floating-point loads and stores.
      * config/pa/pa.c (pa_output_addr_vec): Align address table. 	* config/pa/pa.h (JUMP_TABLES_IN_TEXT_SECTION): Revise comment. 	* config/pa/pa32-linux.h (JUMP_TABLES_IN_TEXT_SECTION): Define.
      Backport from mainline 	2018-08-11  John David Anglin  <danglin@gcc.gnu.org>
      * config/pa/pa.md (atomic_storeqi): Restore deleted expander. 	(atomic_storehi): Likewise. 	(atomic_storesi): Likewise. 	(atomic_loaddi): Restore compare and swap exchange loop code.
      PR libgfortran/79540 	* io/write_float.def (build_float_string): Don't copy digits when 	ndigits is negative.

denisc (1):
      Backport from mainline 	2018-02-07  Georg-Johann Lay  <avr@gjlay.de>

dje (2):
      2018-06-27  David Edelsohn  <dje.gcc@gmail.com>
      Backport from mainline         2019-04-11  David Edelsohn  <dje.gcc@gmail.com>         * xcoffout.h (xcoff_private_rodata_section_name): Declare.         * xcoffout.c (xcoff_private_rodata_section_name): Define.         * config/rs6000/rs6000.c (rs6000_xcoff_asm_init_sections): Create         read_only_private_data_section using coff_private_rodata_section_name.         (rs6000_xcoff_file_start): Generate coff_private_rodata_section_name.

doko (4):
      2018-05-31  Matthias Klose  <doko@ubuntu.com>
      2018-11-26  Matthias Klose  <doko@ubuntu.com>
      gcc/cp/
      2019-03-21  Matthias Klose  <doko@ubuntu.com>

dominiq (5):
      2018-12-30  Dominique d'Humieres  <dominiq@gcc.gnu.org>
      2019-01-05  Dominique d'Humieres  <dominiq@gcc.gnu.org>
      2019-01-26  Manfred Schwarb  <manfred99@gmx.ch>
      2019-01-26  Dominique d'Humieres  <dominiq@gcc.gnu.org>
      2019-01-30  Manfred Schwarb  <manfred99@gmx.ch>

ebotcazou (47):
      PR rtl-optimization/84071 	* combine.c (record_dead_and_set_regs_1): Record the source unmodified 	for a paradoxical SUBREG on a WORD_REGISTER_OPERATIONS target.
      PR rtl-optimization/84071 	* doc/tm.texi.in (WORD_REGISTER_OPERATIONS): Add explicit case. 	* doc/tm.texi: Regenerate.
      PR ada/84277 	* gnat.dg/array11.adb (Array11): Tweak index and remove warning. 	* gnat.dg/dispatch1.adb: Rename into... 	* gnat.dg/disp1.adb: ...this. 	* gnat.dg/dispatch1_p.ads: Rename into... 	* gnat.dg/disp1_pkg.ads: ...this. 	* gnat.dg/disp2.adb: Rename into... 	* gnat.dg/dispatch2.adb: ...this. 	* gnat.dg/dispatch2_p.ads: Rename into... 	* gnat.dg/disp2_pkg.ads: ...this. 	* gnat.dg/dispatch2_p.adb: Rename into... 	* gnat.dg/disp2_pkg.adb: this. 	* gnat.dg/generic_dispatch.adb: Rename into... 	* gnat.dg/generic_disp.adb: this. 	* gnat.dg/generic_dispatch_p.ads: Rename into... 	* gnat.dg/generic_disp_pkg.ads: ...this. 	* gnat.dg/generic_dispatch_p.adb: Rename into... 	* gnat.dg/generic_disp_pkg.adb: ...this. 	* gnat.dg/null_pointer_deref1.adb (Null_Pointer_Deref1): Robustify. 	* gnat.dg/null_pointer_deref2.adb (Null_Pointer_Deref2): Likewise. 	* gnat.dg/object_overflow1.adb: Tweak index. 	* gnat.dg/object_overflow2.adb: Likewise. 	* gnat.dg/object_overflow3.adb: Likewise. 	* gnat.dg/object_overflow4.adb: Likewise. 	* gnat.dg/object_overflow5.adb: Likewise.
      PR rtl-optimization/83496 	* reorg.c (steal_delay_list_from_target): Change REDUNDANT array from 	booleans to RTXes.  Call fix_reg_dead_note on every non-null element. 	(steal_delay_list_from_fallthrough): Call fix_reg_dead_note on a 	redundant insn, if any. 	(relax_delay_slots): Likewise. 	(update_reg_unused_notes): Rename REDUNDANT_INSN to OTHER_INSN.
      * gcc-interface/trans.c (convert_with_check): Fix typo in the condition 	guarding the overflow check emitted for the upper bound of a floating- 	point conversion.
      * gcc-interface/trans.c (node_has_volatile_full_access) <N_Identifier>: 	Consider only entities for objects.
      PR ada/82813 	* gcc-interface/misc.c (gnat_post_options): Disable string overflow 	warnings.
      PR target/85196 	* config/sparc/sparc.c (sparc_expand_move): Deal with symbolic operands 	based on LABEL_REF.  Remove useless assertion. 	(pic_address_needs_scratch): Fix formatting. 	(sparc_legitimize_pic_address): Minor tweaks. 	(sparc_delegitimize_address): Adjust assertion accordingly. 	* config/sparc/sparc.md (movsi_pic_label_ref): Change label_ref_operand 	into symbolic_operand. 	(movsi_high_pic_label_ref): Likewise. 	(movsi_lo_sum_pic_label_ref): Likewise. 	(movdi_pic_label_ref): Likewise. 	(movdi_high_pic_label_ref): Likewise. 	(movdi_lo_sum_pic_label_ref): Likewise.
      PR middle-end/85496 	* expr.c (store_field): In the bitfield case, if the value comes from 	a function call and is returned in registers by means of a PARALLEL, 	do not change the mode of the temporary unless BLKmode and VOIDmode.
      Backport from mainline 	2018-05-31  Eric Botcazou  <ebotcazou@adacore.com>
      * gcc-interface/ada-tree.h (TYPE_PADDING_FOR_COMPONENT): New macro. 	* gcc-interface/decl.c (gnat_to_gnu_component_type): Cache the padding 	type built for an aliased component with variable size.
      Add missing directive
      Backport from mainline 	2018-06-11  Eric Botcazou  <ebotcazou@adacore.com>
      Backpor from mainline 	2018-06-02  Eric Botcazou  <ebotcazou@adacore.com>
      * gcc-interface/decl.c (gnat_to_gnu_entity) <E_Constant>: Do not get 	the expression of a dispatch table that is not being defined. 	<E_Record_Subtype>: Remove obsolete kludge.
      * gcc-interface/ada-tree.h (TYPE_RETURN_BY_DIRECT_REF_P): Change from 	using TYPE_LANG_FLAG_4 to using TYPE_LANG_FLAG_0. 	(TYPE_ALIGN_OK): Move around. 	(TYPE_PADDING_FOR_COMPONENT): Remove superfluous parentheses. 	* gcc-interface/decl.c (change_qualified_type): Move to... 	(gnat_to_gnu_entity): Adjust comment. 	* gcc-interface/gigi.h (change_qualified_type): ...here; make inline. 	(ceil_pow2): Use ceil_log2. 	* gcc-interface/utils.c (finish_subprog_decl): Add couple of comments 	and do not set TREE_SIDE_EFFECTS. 	(handle_noreturn_attribute): Use change_qualified_type.
      * gimplify.c (gimplify_init_constructor): Really never clear for an 	incomplete constructor if CONSTRUCTOR_NO_CLEARING is set.
      * gcc-interface/decl.c (gnat_to_gnu_entity) <E_Variable>: Deal with 	more rvalues in the expression of a renaming.
      * gcc-interface/decl.c (choices_to_gnu): Rename parameters.  Deal with 	an operand of Character type.  Factor out range generation to the end. 	Check that the bounds are literals and convert them to the type of the 	operand before building the ranges. 	* gcc-interface/utils.c (make_dummy_type): Minor tweak. 	(make_packable_type): Propagate TYPE_DEBUG_TYPE. 	(maybe_pad_type): Likewise.
      Backport from mainline 	2018-07-31  Eric Botcazou  <ebotcazou@adacore.com>
      * config/rs6000/rs6000.c (rs6000_function_ok_for_sibcall): Return false 	if the call takes a static chain.
      Fix thinko
      PR middle-end/87623 	* fold-const.c (fold_truth_andor_1): If the right side is not constant, 	bail out if both sides do not have the same storage order.
      * gcc-interface/trans.c (Pragma_to_gnu) <Pragma_Inspection_Point>: Use 	a simple memory constraint in all cases.
      * gcc-interface/utils.c (unchecked_convert): Use local variables for 	the biased and reverse SSO attributes of both types. 	Further extend the processing of integral types in the presence of 	reverse SSO to all scalar types.
      * fe.h (Suppress_Checks): Declare. 	* gcc-interface/misc.c (gnat_init_gcc_eh): Set -fnon-call-exceptions 	only if checks are not suppressed and -faggressive-loop-optimizations 	only if they are. 	* gcc-interface/trans.c (struct loop_info_d): Remove has_checks and 	warned_aggressive_loop_optimizations fields. 	(gigi): Do not clear warn_aggressive_loop_optimizations here. 	(Raise_Error_to_gnu): Do not set has_checks. 	(gnat_to_gnu) <N_Indexed_Component>: Remove support for aggressive 	loop optimizations.
      * gcc-interface/misc.c (gnat_init_gcc_eh): Set -fnon-call-exceptions 	for the runtime on platforms where System.Machine_Overflow is true.
      * gcc-interface/misc.c (gnat_init_gcc_eh): Do not override the switch 	-fnon-call-exceptions passed on the command line in -gnatp mode.
      2018-11-20  Eric Botcazou  <ebotcazou@adacore.com>
      Backport from mainline 	2018-11-21  Jakub Jelinek  <jakub@redhat.com>
      * doc/invoke.texi (-Os): Add reference to -finline-functions. 	(-finline-small-functions): Add references to -O3 and -Os. 	(-findirect-inlining): Likewise. 	(-finline-functions): Add references to -Os, -fprofile-use and 	-fauto-profile.
      PR target/84010 	* config/sparc/sparc.c (sparc_legitimize_tls_address): Only use Pmode 	consistently in TLS address generation and adjust code to the renaming 	of patterns.  Mark calls to __tls_get_addr as const. 	* config/sparc/sparc.md (tgd_hi22): Turn into... 	(tgd_hi22<P:mode>): ...this and use Pmode throughout. 	(tgd_lo10): Turn into... 	(tgd_lo10<P:mode>): ...this and use Pmode throughout. 	(tgd_add32): Merge into... 	(tgd_add64): Likewise. 	(tgd_add<P:mode>): ...this and use Pmode throughout. 	(tldm_hi22): Turn into... 	(tldm_hi22<P:mode>): ...this and use Pmode throughout. 	(tldm_lo10): Turn into... 	(tldm_lo10<P:mode>): ...this and use Pmode throughout. 	(tldm_add32): Merge into... 	(tldm_add64): Likewise. 	(tldm_add<P:mode>): ...this and use Pmode throughout. 	(tldm_call32): Merge into... 	(tldm_call64): Likewise. 	(tldm_call<P:mode>): ...this and use Pmode throughout. 	(tldo_hix22): Turn into... 	(tldo_hix22<P:mode>): ...this and use Pmode throughout. 	(tldo_lox10): Turn into... 	(tldo_lox10<P:mode>): ...this and use Pmode throughout. 	(tldo_add32): Merge into... 	(tldo_add64): Likewise. 	(tldo_add<P:mode>): ...this and use Pmode throughout. 	(tie_hi22): Turn into... 	(tie_hi22<P:mode>): ...this and use Pmode throughout. 	(tie_lo10): Turn into... 	(tie_lo10<P:mode>): ...this and use Pmode throughout. 	(tie_ld64): Use DImode throughout. 	(tie_add32): Merge into... 	(tie_add64): Likewise. 	(tie_add<P:mode>): ...this and use Pmode throughout. 	(tle_hix22_sp32): Merge into... 	(tle_hix22_sp64): Likewise. 	(tle_hix22<P:mode>): ...this and use Pmode throughout. 	(tle_lox22_sp32): Merge into... 	(tle_lox22_sp64): Likewise. 	(tle_lox22<P:mode>): ...this and use Pmode throughout. 	(*tldo_ldub_sp32): Merge into... 	(*tldo_ldub_sp64): Likewise. 	(*tldo_ldub<P:mode>): ...this and use Pmode throughout. 	(*tldo_ldub1_sp32): Merge into... 	(*tldo_ldub1_sp64): Likewise. 	(*tldo_ldub1<P:mode>): ...this and use Pmode throughout. 	(*tldo_ldub2_sp32): Merge into... 	(*tldo_ldub2_sp64): Likewise. 	(*tldo_ldub2<P:mode>): ...this and use Pmode throughout. 	(*tldo_ldsb1_sp32): Merge into... 	(*tldo_ldsb1_sp64): Likewise. 	(*tldo_ldsb1<P:mode>): ...this and use Pmode throughout. 	(*tldo_ldsb2_sp32): Merge into... 	(*tldo_ldsb2_sp64): Likewise. 	(*tldo_ldsb2<P:mode>): ...this and use Pmode throughout. 	(*tldo_ldub3_sp64): Use DImode throughout. 	(*tldo_ldsb3_sp64): Likewise. 	(*tldo_lduh_sp32): Merge into... 	(*tldo_lduh_sp64): Likewise. 	(*tldo_lduh<P:mode>): ...this and use Pmode throughout. 	(*tldo_lduh1_sp32): Merge into... 	(*tldo_lduh1_sp64): Likewise. 	(*tldo_lduh1<P:mode>): ...this and use Pmode throughout. 	(*tldo_ldsh1_sp32): Merge into... 	(*tldo_ldsh1_sp64): Likewise. 	(*tldo_ldsh1<P:mode>): ...this and use Pmode throughout. 	(*tldo_lduh2_sp64): Use DImode throughout. 	(*tldo_ldsh2_sp64): Likewise. 	(*tldo_lduw_sp32): Merge into... 	(*tldo_lduw_sp64): Likewise. 	(*tldo_lduw<P:mode>): ...this and use Pmode throughout. 	(*tldo_lduw1_sp64): Use DImode throughout. 	(*tldo_ldsw1_sp64): Likewise. 	(*tldo_ldx_sp64): Likewise. 	(*tldo_stb_sp32): Merge into... 	(*tldo_stb_sp64): Likewise. 	(*tldo_stb<P:mode>): ...this and use Pmode throughout. 	(*tldo_sth_sp32): Merge into... 	(*tldo_sth_sp64): Likewise. 	(*tldo_sth<P:mode>): ...this and use Pmode throughout. 	(*tldo_stw_sp32): Merge into... 	(*tldo_stw_sp64): Likewise. 	(*tldo_stw<P:mode>): ...this and use Pmode throughout. 	(*tldo_stx_sp64): Use DImode throughout.
      * gcc-interface/decl.c (annotate_value) <INTEGER_CST>: Use test on 	the sign bit instead of on the sign of the value. 	<PLUS_EXPR>: Turn addition of negative constant into subtraction. 	<BIT_AND_EXPR>: Simplify.
      * gcc-interface/trans.c (struct loop_info_d): Remove artificial field. 	(Loop_Statement_to_gnu): Do not set it.
      * gcc-interface/trans.c (gnat_to_gnu) <N_Assignment_Statement>: Use 	DECL_SIZE_UNIT instead of TYPE_SIZE_UNIT for the size to be assigned 	by a call to memset if the LHS is a DECL.
      * gcc-interface/decl.c (array_type_has_nonaliased_component): Return 	the same value for every dimension of a multidimensional array type.
      * config/i386/i386.c (ix86_expand_prologue): Emit a memory blockage 	after restoring registers saved to allocate the frame on Windows.
      Backport from mainline 	2017-09-05  Eric Botcazou  <ebotcazou@adacore.com>
      * s-linux-sparc.ads (ETIMEDOUT): Set to correct value.
      Backport from mainline 	2018-06-11  Segher Boessenkool  <segher@kernel.crashing.org>
      * gcc-interface/trans.c (Regular_Loop_to_gnu): Replace tests on 	individual flag_unswitch_loops and flag_tree_loop_vectorize switches 	with test on global optimize switch. 	(Raise_Error_to_gnu): Likewise.
      Fix function name
      * gcc.target/sparc/struct-ret-check-1.c: Add -fno-pie option.
      PR ada/89349 	Backport from mainline 	2018-05-25  Arnaud Charlet  <charlet@adacore.com>
      PR ada/81956 	Backport from mainline 	2017-09-06  Ed Schonberg  <schonberg@adacore.com>
      Backport from mainline 	2019-02-19  Eric Botcazou  <ebotcazou@adacore.com>
      * c-ada-spec.c (print_destructor): Deal with deleting destructors. 	(dump_ada_declaration) <FUNCTION_DECL>: Likewise.

emsr (2):
      2018-04-30  Edward Smith-Rowland  <3dw4rd@verizon.net>
      2018-05-07  Edward Smith-Rowland  <3dw4rd@verizon.net> 	    Jonathan Wakely  <jwakely@redhat.com>

fdumont (2):
      2018-07-05  François Dumont  <fdumont@gcc.gnu.org>
      2018-11-28  François Dumont  <fdumont@gcc.gnu.org>

foreese (5):
      2018-06-25  Fritz Reese  <fritzoreese@gmail.com>
      2018-06-28  Fritz Reese  <fritzoreese@gmail.com>
      Revert r262224 (backport of r262221) as PDTs are not supported in 7-branch.
      2018-07-16  Fritz Reese  <fritzoreese@gmail.com>
      2018-07-16  Fritz Reese  <fritzoreese@gmail.com>

gccadmin (478):
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.

gerald (1):
      Backport from trunk 	* io/close.c [!HAVE_UNLINK_OPEN_FILE]: Include <string.h>.

hjl (13):
      i386: Use const reference of struct ix86_frame to avoid copy
      Replace -mfunction-return== with -mfunction-return=
      i386: Pass INVALID_REGNUM as invalid register number
      i386: Update -mfunction-return= for return with pop
      i386: Add TARGET_INDIRECT_BRANCH_REGISTER
      i386: Don't generate alias for function return thunk
      i386: Enable AVX/AVX512 features only if supported by OSXSAVE
      libsanitizer: Use pre-computed size of struct ustat for Linux
      x86: Always update EH return address in word_mode
      i386: Don't pass -msse2avx to assembler for -mavx
      i386: Correct _mm512_mask3_fmaddsub_round_pd
      i386: Use TImode for BLKmode values in 2 integer registers
      x32: Add addr32 prefix to VSIB address

iains (15):
      darwin - backport r26355, remove unused target hook.
      darwin - backport r263763 to fix PR81033
      fix Darwin target/81685
      Fix Darwin PR libstdc++/70694
      Fix tree-prof section tests on Darwin.
      Fix three tests for targets using _USER_LABEL_PREFIX_
      Don't try to use pthread_barrier in tests on Darwin.
      Fix target/78444 on x86/Darwin.
      Fix libstdc++/64883 for Darwin.
      Fix build warnigns on Darwin, don't try to export construction vtable symbols.
      Fix PR c++/87380 (ABI breakage) for Darwin.
      Fix Ada boostrap for Darwin9 and earlier.
      Fix target/67974 for Darwin by adding AVX asm shim.
      fix PR target/88343 for 32b powerpc.
      revert fix for pr88343

ian (4):
      syscall: remove Ustat
      PR go/86331     os: check return value as well as error from waitid
      compiler: handle abstract type in builtin numeric const value
      syscall: change RLIM_INFINITY from 0xffffffffffffffff to -1

jakub (115):
      PR rtl-optimization/83985 	* dce.c (deletable_insn_p): Return false for separate shrink wrapping 	REG_CFA_RESTORE insns. 	(delete_unmarked_insns): Don't ignore separate shrink wrapping 	REG_CFA_RESTORE insns here.
      Backported from mainline 	2018-01-05  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-01-09  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-01-16  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-01-18  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-01-20  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-01-20  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-01-23  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-01-23  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-01-24  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-01-25  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-01-27  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-01-27  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-01-29  Christoph Spiel  <cspiel@freenet.de> 		    Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-01-30  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-01-31  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-01-31  Jason Merrill  <jason@redhat.com> 		    Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-01-31  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-02-01  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-02-07  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-02-07  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-02-09  Marek Polacek  <polacek@redhat.com> 		    Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-02-09  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-02-10  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-02-10  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-02-12  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-02-13  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-02-16  Marek Polacek  <polacek@redhat.com> 		    Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-02-16  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-02-16  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-02-19  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-02-19  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-02-19  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-02-20  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-02-20  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-02-22  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-02-23  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-02-26  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-02-26  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-02-26  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-03-02  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-03-02  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-03-02  Jakub Jelinek  <jakub@redhat.com> 		    Richard Biener  <rguenther@suse.de>
      PR target/84524 	* config/i386/sse.md (*<code><mode>3): Replace <mask_prefix3> with 	orig,vex. 	(*<plusminus_insn><mode>3): Likewise.  Remove <mask_operand3> uses.
      Backported from mainline 	2018-03-02  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-03-05  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-03-08  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-03-08  Jason Merrill  <jason@redhat.com> 		    Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-03-09  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-03-09  Jason Merrill  <jason@redhat.com> 		    Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-03-09  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-03-13  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-03-13  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-03-13  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-03-15  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-03-15  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-03-15  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-03-15  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-03-16  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-03-16  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-03-16  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-03-16  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-03-22  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-03-20  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-03-20  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-03-21  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-03-21  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-03-22  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-03-23  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-03-23  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-03-23  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-03-27  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-03-27  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-03-28  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-03-30  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-04-03  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-04-03  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-04-03  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-04-04  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-04-05  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-04-06  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-04-06  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-04-07  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-04-10  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-04-10  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-04-17  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-04-17  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-04-18  Jakub Jelinek  <jakub@redhat.com>
      2018-06-22  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-04-19  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-04-27  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-05-01  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-05-06  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-06-22  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-05-11  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-05-11  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-05-29  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-06-04  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-06-14  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-06-15  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-06-20  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-06-20  Jakub Jelinek  <jakub@redhat.com>
      PR target/84786 	* config/i386/sse.md (vshift_count): New mode attr. 	(<shift_insn><mode>3<mask_name>): Use <vshift_count>N instead of vN 	as last operand's constraint for VI2_AVX2_AVX512BW shifts.  Use YvN 	instead of vN as last operand's constraint for VI48_AVX2 shifts.
      PR c++/86291 	* parser.c (cp_parser_omp_for_loop_init): Change for_block argument 	type from vec<tree, va_gc> * to vec<tree, va_gc> *&.
      PR target/86314 	* config/i386/i386.md (setcc + movzbl to xor + setcc peephole2s): 	Check reg_overlap_mentioned_p in addition to reg_set_p with the same 	operands.
      PR target/87467 	* config/i386/avx512fintrin.h (_mm512_abs_pd, _mm512_mask_abs_pd): Use 	__m512d type for __A argument rather than __m512.
      Backported from mainline 	2018-07-16  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-07-26  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-07-10  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-07-17  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-07-17  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-07-24  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-08-27  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-09-12  Jakub Jelinek  <jakub@redhat.com>
      Backported from mainline 	2018-10-10  Jakub Jelinek  <jakub@redhat.com>

jamborm (6):
      [hsa] Set program allocation for static local variables
      Fix location handling in ipa_modify_call_arguments
      Check is_single_const in intersect_with_plats
      Remove spurious $HOME include from BRIG FE Makefile
      [PR 88214] Check that an argument is a pointer
      Zero local estimated benefit for cloning extern inline function

janus (2):
      2018-09-07  Janus Weil  <janus@gcc.gnu.org>
      fix PR 71861

jason (48):
      PR c++/82461 - constexpr list-initialized member
      PR c++/84045 - ICE with typedef and noexcept. 	* except.c (build_noexcept_spec): Use strip_typedefs_expr.
      PR c++/83227 - C++17 ICE with init-list derived-to-base conversion.
      PR c++/82764 - C++17 ICE with empty base
      PR c++/82664 - ICE with reference to function template parm.
      PR c++/83835 - C++17 error with constructor ctors.
      PR c++/84420 - ICE with structured binding in lambda.
      PR c++/81853 - using-directive and constexpr.
      PR c++/84151 - unnecessary volatile load with static member.
      PR c++/84015 - ICE with class deduction and auto template parm.
      PR c++/81589 - error with is_trivially_constructible.
      PR c++/84520 - ICE with generic lambda in NSDMI.
      PR c++/84441 - ICE with base initialized from ?:
      PR c++/84496 - ICE with generic lambda in lambda.
      PR c++/71784 - ICE with ref-qualifier and explicit specialization.
      PR c++/71569 - ICE with redundant args on member variable template.
      PR c++/71569 - decltype of template.
      PR c++/84489 - dependent default template argument
      Fix MIPS16 ICE.
      PR c++/84686 - missing volatile loads.
      PR c++/84785 - ICE with alias template and default targs.
      PR c++/82336 - link error with list-init default argument.
      PR c++/84355 - ICE with deduction for member class template.
      PR c++/84798 - ICE with auto in abstract function declarator.
      PR c++/84839 - ICE with decltype of parameter pack.
      PR c++/80227 - SFINAE and negative array size.
      PR c++/84937 - ICE with class deduction and auto.
      PR c++/71834 - template-id with too few arguments.
      PR c++/78489 - Substitution in wrong order
      PR c++/85060 - wrong-code with call to base member in template.
      PR c++/64095 - auto... parameter pack.
      Fix noexcept merging with system headers.
      PR c++/85113 - ICE with constexpr and __builtin_constant_p.
      PR c++/85148 - ICE with 'this' in array NSDMI.
      PR c++/85118 - wrong error with generic lambda and std::bind.
      PR c++/85006 - -fconcepts ICE with A<auto...> return type
      PR c++/84665 - ICE with array of empty class.
      PR c++/82152 - ICE with class deduction and inherited ctor.
      PR c++/85279 - dump_expr doesn't understand decltype.
      PR c++/85470 - wrong error with static data member.
      PR c++/85646 - lambda visibility.
      PR c++/86060 - ICE on range for with -std=c++98.
      PR c++/85815 - reference to member of enclosing template.
      PR c++/80290 - memory-hog with std::pair.
      PR c++/86378 - functional cast in noexcept-specifier.
      PR c++/86728 - C variadic generic lambda.
      PR c++/87075 - ICE with constexpr array initialization.
      PR c++/84281

jb (2):
      Make module files reproducible
      Initialize backtrace state once

jcmvbkbc (4):
      libgcc: xtensa: fix build with -mtext-section-literals
      xtensa: fix PR target/65416
      gcc: xtensa: fix NAND code in xtensa_expand_atomic
      gcc: xtensa: don't force PIC for uclinux target

joel (1):
      2018-04-06  Amaan Cheval  <amaan.cheval@gmail.com>

jozefl (2):
      2018-08-02  Jozef Lawrynowicz  <jozef.l@mittosystems.com>
      Backport from mainline

jsm28 (3):
      Fix m68k-linux-gnu libgcc build for ColdFire (PR target/68467).
      Use -fno-show-column in libstdc++ installed testing.
      Fix diagnostics for never-defined inline and nested functions (PR c/88720, PR c/88726).

jvdelisle (7):
      2018-02-18  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
      2018-02-19  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
      2018-02-23  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
      2018-06-01  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
      2018-06-09  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
      Add ChangeLog entry
      2019-01-13  Jerry DeLisle  <jvdelisle@gcc.gnu.org>

kargl (49):
      2018-02-07  Steven G. Kargl  <kargl@gcc.gnu.org>
      2018-02-07  Steven G. Kargl  <kargl@gcc.gnu.org>
      2018-02-12  Steven G. Kargl  <kargl@gcc.gnu.org>
      2018-02-12  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>
      2018-02-23  Steven G. Kargl  <kargl@gcc.gnu.org>
      2018-02-23  Steven G. Kargl  <kargl@gcc.gnu.org>
      2018-02-24  Steven G. Kargl <kargl@gcc.gnu.org>
      2018-02-25  Steven G. Kargl  <kargl@gcc.gnu.org>
      2018-02-25  Steven G. Kargl  <kargl@gcc.gnu.org>
      2018-03-03  Steven G. Kargl  <kargl@gcc.gnu.org>
      2018-03-03  Harald Anlauf  <anlauf@gmx.de>
      2018-03-06  Steven G. Kargl  <kargl@gcc.gnu.org>
      2018-03-08  Steven G. Kargl  <kargl@gcc.gnu.org>
      2018-03-10  Steven G. Kargl  <kargl@gcc.gnu.org>
      2018-03-12  Steven G. Kargl  <kargl@gcc.gnu.org>
      2018-03-15  Steven G. Kargl  <kargl@gcc.gnu.org>
      Commit ChangeLog entries for revision 258582.
      2018-03-19  Steven G. Kargl  <kargl@gcc.gnu.org>
      2018-03-19  Steven G. Kargl  <kargl@gcc.gnu.org>
      2018-03-20  Steven G. Kargl  <kargl@gcc.gnu.org>
      2018-04-24  Steven G. Kargl  <kargl@gcc.gnu.org>
      2018-05-11  Steven G. Kargl  <kargl@gcc.gnu.org>
      2018-05-11  Steven G. Kargl  <kargl@gcc.gnu.org>
      2018-05-11  Steven G. Kargl  <kargl@gcc.gnu.org>
      2018-05-12  Steven G. Kargl  <kargl@gcc.gnu.org>
      2018-05-25  Steven G. Kargl  <kargl@gcc.gnu.org>
      2018-05-25  Steven G. Kargl  <kargl@gcc.gnu.org>
      2018-05-25  Steven G. Kargl  <kargl@gcc.gnu.org>
      2018-05-25  Steven G. Kargl  <kargl@gcc.gnu.org>
      2018-06-04  Steven G. Kargl  <kargl@gcc.gnu.org>
      2018-06-07  Steven G. Kargl  <kargl@gcc.gnu.org>
      2018-06-09  Steven G. Kargl  <kargl@gcc.gnu.org>
      2018-06-09  Steven G. Kargl  <kargl@gcc.gnu.org>
      2018-06-09  Steven G. Kargl  <kargl@gcc.gnu.org>
      2018-06-09  Steven G. Kargl  <kargl@gcc.gnu.org>
      2018-06-09  Steven G. Kargl  <kargl@gcc.gnu.org>
      2018-06-12  Steven G. Kargl  <kargl@gcc.gnu.org>
      2018-06-13  Steven G. Kargl  <kargl@gcc.gnu.org>
      2018-12-09  Fritz Reese  <fritzoreese@gmail.com>
      2018-12-09  Steven G. Kargl  <kargl@gcc.gnu.org>
      2018-12-09  Steven G. Kargl  <kargl@gcc.gnu.org>
      2018-12-10  Steven G. Kargl  <kargl@gcc.gnu.org>
      2018-12-11  Steven G. Kargl  <kargl@gcc.gnu.org>
      2018-12-11  Steven G. Kargl  <kargl@gcc.gnu.org>
      2018-12-15  Steven G. Kargl  <kargl@gcc.gnu.org>
      2018-12-21  Steven G. Kargl  <kargl@gcc.gnu.org>
      2018-12-22  Steven G . Kargl  <kargl@gcc.gnu.org>
      2019-01-11  Steven G. Kargl  <kargl@gcc.gnu.org>
      2019-01-15  Steven G. Kargl  <kargl@gcc.gnu.org>

kelvin (5):
      gcc/ChangeLog:
      gcc/ChangeLog:
      gcc/ChangeLog:
      gcc/ChangeLog:
      gcc/ChangeLog:

krebbel (12):
      S/390: Disable branch prediction for indirect branches
      S/390: Fix PR84295
      S/390: libatomic: Fix 16 byte atomic exchange
      IBM Z: Spectre: Prevent thunk cfi to be emitted with -fno-dwarf2-cfi-asm
      S/390: Fix __builtin_tbeginc signature
      S/390: Use proper rounding mode for DFP to BFD conversions
      S/390: Fix problem with vec_init expander
      S/390: Document z14/arch12 -march option.
      S/390: Fix flogr RTX.
      S/390: Use VEC_INEXACT/VEC_NOINEXACT instead of magic numbers.
      S/390: Fix zvector vec_double builtin
      S/390: Remove load and test fp splitter

ktkachov (9):
      [arm] PR target/82518: Return false in ARRAY_MODE_SUPPORTED_P for BYTES_BIG_ENDIAN
      [arm] PR target/85026: Fix ldrsh length estimate in Thumb state
      Fix up ChangeLog date from my previous commit
      [AArch64] PR target/84748: Mark *compare_cstore<mode>_insn as clobbering CC reg
      [arm] PR target/82518: Return false in ARRAY_MODE_SUPPORTED_P for BYTES_BIG_ENDIAN pt2
      Avoid assembler warnings from AArch64 constructor/destructor priorities
      [libgfortran] Fix uninitialized variable use in fallback_access
      [arm] Avoid STRD with odd register for TARGET_ARM in output_move_double
      ARM: fix -masm-syntax-unified (PR88648)

kugan (1):
      gcc/testsuite/ChangeLog:

law (1):
      2018-02-16  Jozef Lawrynowicz <jozefl.gcc@gmail.com>

linkw (1):
      2019-01-30  Kewen Lin  <linkw@gcc.gnu.org>     Backport from mainline.     gcc/

luoxhu (4):
      backport r268834 from mainline to gcc-7-branch
      This is a backport of r250477, r255555, r257253 and r258137 from trunk to gcc-7-branch to support built-in functions.
      backport r257541, r259936, r260294, r260623, r261098, r261333, r268585 from trunk
      gcc/testsuite/ChangeLog:

marxin (35):
      Backport r253729
      Backport r257183
      Backport r257343
      Backport r257412
      Backport r257442
      Backport r257490
      Backport r257877
      Backport r257939
      Fix IPA profile merging, fixed in trunk with r253910.
      Backport r247342
      Backport r255818
      Backport r256989
      Backport r257383
      Backport r257384
      Backport r257803
      Backport r257842
      Backport r257932
      Backport r258480
      Backport r258705
      Backport r258924
      Backport r259265
      Backport r259274
      Backport r259429
      Backport r259431
      Backport r259459
      Backport r259490
      Partial backport r256656
      Clean up gcc/ChangeLog file.
      Backport r263246
      Backport r268762
      Backport r268873
      Backport r268789
      Backport r268981
      Backport r265786
      Backport r269492

matmal01 (1):
      Backport of r270226 from mainline to gcc-7-branch

meissner (4):
      [gcc] 2018-01-25  Michael Meissner  <meissner@linux.vnet.ibm.com>
      [gcc] 2018-02-15  Michael Meissner  <meissner@linux.vnet.ibm.com>
      2018-06-25  Michael Meissner  <meissner@linux.vnet.ibm.com>
      Backport pr 87033 to gcc 7

mpolacek (4):
      PR c++/84684 	* constexpr.c (cxx_bind_parameters_in_call): Unshare evaluated 	arguments.
      PR c++/84854 	* semantics.c (finish_if_stmt_cond): Check if the type of the condition 	is boolean.
      PR c++/84927 	* constexpr.c (cxx_eval_bare_aggregate): Update constructor's flags 	as we evaluate the elements. 	(cxx_eval_constant_expression): Verify constructor's flags 	unconditionally.
      PR c++/71638, ICE with NSDMI and reference. 	* constexpr.c (cxx_eval_bare_aggregate): Update constructor's flags 	even when we replace an element.

mrs (1):
      2018-02-08  Iain Sandoe  <iain@codesourcery.com>

msebor (1):
      PR middle-end/82063 - issues with arguments enabled by -Wall

nathan (2):
      [C++/82878] backport fix
      [debug/88006] -fdebug-types-section gives undefined ref

nsz (1):
      Restrict the pr86763 test to *-*-linux* targets

pault (20):
      2018-03-03  Paul Thomas  <pault@gcc.gnu.org>
      2018-03-03  Paul Thomas  <pault@gcc.gnu.org>
      2018-03-04  Paul Thomas  <pault@gcc.gnu.org>
      2018-05-12  Paul Thomas  <pault@gcc.gnu.org>
      2018-05-16  Paul Thomas  <pault@gcc.gnu.org>
      2018-16-05  Paul Thomas  <pault@gcc.gnu.org>
      2018-05-16  Paul Thomas  <pault@gcc.gnu.org>
      2017-05-17  Paul Thomas  <pault@gcc.gnu.org>
      2018-05-19  Paul Thomas  <pault@gcc.gnu.org>
      2018-05-20  Paul Thomas  <pault@gcc.gnu.org>
      2018-05-20  Paul Thomas  <pault@gcc.gnu.org>
      2018-06-25  Paul Thomas  <pault@gcc.gnu.org>
      2018-07-03  Paul Thomas  <pault@gcc.gnu.org>
      2018-09-13  Paul Thomas  <pault@gcc.gnu.org>
      2018-11-24  Paul Thomas  <pault@gcc.gnu.org>
      2018-12-23  Paul Thomas  <pault@gcc.gnu.org>
      2018-12-29  Paul Thomas  <pault@gcc.gnu.org>
      2019-01-27  Paul Thomas  <pault@gcc.gnu.org>
      2019-02-03  Paul Thomas  <pault@gcc.gnu.org>
      2019-02-23  Paul Thomas  <pault@gcc.gnu.org>

pthaugen (1):
      PR target/85698 	* config/rs6000/rs6000.c (rs6000_output_move_128bit): Check dest operand.

ramana (1):
      [Patch AArch64] Add __ARM_FEATURE_ATOMICS

rdapp (1):
      S/390: Fix mtune default.

rearnsha (1):
      PR target/90075 Prefer bsl/bit/bif for copysignf. (backport GCC-7)

redi (74):
      PR libstdc++/83830 Define std::has_unique_object_representations_v
      PR libstdc++/81076 make __byte_operand SFINAE-friendly
      PR libstdc++/83833 fix chi_squared_distribution::param(const param&)
      PR libstdc++/83658 fix exception-safety in std::any::emplace
      PR libstdc++/83833 fix failing test on ia32
      Fix lambdas in template default argument of inherited ctor.
      PR libstdc++/81797 Add .NOTPARALLEL to include/Makefile for darwin
      PR libstdc++/84532 prevent unwrapping of reference_wrapper arguments
      PR libstdc++/84671 handle digit separators in duration literals
      Fix spelling of -mclflushopt in manual
      PR libstdc++/84773 use aligned alloc functions for FreeBSD and MinGW cross-compilers
      PR libstdc++/84769 qualify std::get and std::get_if to avoid ADL
      PR libstdc++/85222 allow catching iostream errors as gcc4-compatible ios::failure
      Fix comments that misspell names of files and classes
      Fix __iosfail_type_info hack to work on darwin
      Fix broken sed command from previous commit
      PR libstdc++/85442 fix duplicate debuginfo for cxx11-ios_failure.cc
      PR c++/85464 - missing location for -Wignored-qualifiers diagnostic
      PR libstdc++/85632 fix wraparound in filesystem::space
      PR libstdc++/84769 qualify call to std::get<0>
      Document Dual ABI for std::ios_base::failure
      PR libstdc++/82966 fix swapping of node handles
      PR libstdc++/67554 Do not pass null pointers to memcpy
      PR libstdc++/85812 fix memory leak in std::make_exception_ptr
      Only define __cpp_lib_constexpr_char_traits for C++17
      PR libstdc++/86169 unshare COW string when non-const data() called
      Remove unused <exception> header from <utility>
      * config/abi/post/x86_64-linux-gnu/baseline_symbols.txt: Update.
      PR libstdc++/86138 prevent implicit instantiation of COW empty rep
      PR libstdc++/84087 add default arguments to basic_string members (LWG 2268)
      PR libstdc++/83982 fix exception-safety guarantee of std::vector::resize
      PR libstdc++/85671 allow copy elision in path concatenation
      PR libstdc++/85098 add missing definitions for static constants
      PR target/85904 check for aligned_alloc on netbsd cross-compilation
      Add workaround to std::variant for Clang bug 31852
      Add another workaround to std::variant for Clang bug 31852
      Qualify std::__invoke in <variant> to prevent ADL
      Qualify another call in <variant>
      PR libstdc++/86127 avoid unnecessary allocator conversions
      LWG 3050 Fix cv-qualification of convertibility constraints
      Use non-throwing is_directory in filesystem::create_directory
      Fix std::codecvt_utf8<wchar_t> for Mingw
      PR libstdc++/86734 use addressof in reverse_iterator::operator->
      Add workaround for aligned_alloc bug on AIX
      PR libstdc++/86861 Meet precondition for Solaris memalign
      PR libstdc++/60555 std::system_category() should recognise POSIX errno values
      Improve libstdc++ docs w.r.t newer C++ standards
      PR libstdc++/86292 fix exception safety of std::vector<InputIterator> constructor
      PR libstdc++/68519 use native duration to avoid rounding errors
      PR libstdc++/80893 Fix null dereference in vector<bool>
      PR libstdc++/84654 Disable __float128 specializations for -mno-float128
      Declare some explicit instantiations for strings in Debug Mode
      Fix docs on C++17 and LFTS headers
      Fix Docbook markup to remove empty table cell
      Prevent internal aligned_alloc clashing with libc version
      Revert "libstdc++-v3: Have aligned_alloc() on Newlib"
      Add -Waligned-new to Option Summary
      PR other/87353 fix formatting and grammar in manual
      PR libstdc++/87538 fix std::not_fn exception specifications
      PR libstdc++/77854 document size_type for containers
      PR libstdc++/70966 make pmr::new_delete_resource() immortal
      Fix experimental::pmr typedefs and add tests
      Fix __gnu_cxx::_Pointer_adapter for long long arithmetic
      PR libstdc++/78595 implement insertion into maps in terms of emplace
      PR libstdc++/86751 default assignment operators for std::pair
      Adjust test to pass with latest glibc
      PR libstdc++/87641 correctly initialize accumulator in valarray::sum()
      PR libstdc++/79433 no #error for including TS headers with wrong -std
      PR libstdc++/87704 fix unique_ptr(nullptr_t) constructors
      PR libstdc++/87749 fix (and optimize) string move construction
      PR libstdc++/87822 fix layout change for nested std::pair
      PR libstdc++/89446 fix null pointer dereference in char_traits
      PR libstdc++/89629 fix _Hash_bytes for lengths > INT_MAX
      PR libstdc++/90105 make forward_list::sort stable

renlin (1):
      [PR83370][AARCH64]Use tighter register constraint for sibcall patterns.

rguenth (25):
      2018-01-25  Richard Biener  <rguenther@suse.de>
      2018-02-01  Richard Biener  <rguenther@suse.de>
      2018-02-08  Richard Biener  <rguenther@suse.de>
      2018-02-16  Richard Biener  <rguenther@suse.de>
      2018-03-06  Richard Biener  <rguenther@suse.de>
      2018-04-26  Richard Biener  <rguenther@suse.de>
      2018-06-07  Richard Biener  <rguenther@suse.de>
      2018-06-07  Richard Biener  <rguenther@suse.de>
      2018-07-12  Richard Biener  <rguenther@suse.de>
      2018-08-01  Richard Biener  <rguenther@suse.de>
      2018-08-17  Richard Biener  <rguenther@suse.de>
      2018-10-12  Richard Biener  <rguenther@suse.de>
      2018-11-20  Richard Biener  <rguenther@suse.de>
      2018-11-26  Richard Biener  <rguenther@suse.de>
      2018-11-26  Richard Biener  <rguenther@suse.de>
      2018-10-19  Richard Biener  <rguenther@suse.de>
      2018-11-28  Richard Biener  <rguenther@suse.de>
      Update ChangeLog and version files for release
      2018-12-06  Richard Biener  <rguenther@suse.de>
      2019-01-24  Richard Biener  <rguenther@suse.de>
      2019-01-31  Richard Biener  <rguenther@suse.de>
      2019-03-14  Richard Biener  <rguenther@suse.de>
      2019-03-26  Richard Biener  <rguenther@suse.de>
      2019-02-26  Richard Biener  <rguenther@suse.de>
      2019-04-03  Richard Biener  <rguenther@suse.de>

ro (5):
      Guard against incomplete AVX512F support in Solaris as
      Disable SHF_MERGE on Solaris 10/x86 (PR bootstrap/84017)
      Avoid cc1 SEGV in gcc.dg/rtl/x86_64/final.c (PR target/79975)
      xfail experimental/memory_resource/resource_adaptor.cc on 32-bit Solaris/x86 (PR libstdc++/77691)
      Fix make install-gcc-specs with empty GCC_SPECS_FILES

rsandifo (3):
      Don't vectorise zero-step rmw operations (PR 84485)
      Fix phi backedge detection in backprop (PR85989)
      Fix output_constructor_bitfield handling of wide bitfields (PR89037)

saaadhu (1):
      2018-12-17  Senthil Kumar Selvaraj  <senthilkumar.selvaraj@microchip.com>

segher (8):
      rs6000: Fix safe-indirect-jump-[18].c
      rs6000: -mreadonly-in-sdata (PR82411)
      Backport from mainline 	2018-06-19  Segher Boessenkool  <segher@kernel.crashing.org>
      Backport from mainline 	2018-05-09  Segher Boessenkool  <segher@kernel.crashing.org>
      Backport patch for PR86989 to 7
      Backport from trunk 	2018-12-14  Segher Boessenkool  <segher@kernel.crashing.org>
      Backport from trunk 	2018-12-19  Segher Boessenkool  <segher@kernel.crashing.org>
      Backport of the "asm inline" patches

sh (5):
      Ada: Fix s-oscons.ads generation
      RTEMS: Prefer int for int32_t
      RISC-V: Add custom RTEMS multilibs
      libstdc++-v3: Have aligned_alloc() on Newlib
      [RTEMS] Change multilibs for ARM

speryt (1):
      2018-03-29  Sebastian Peryt  <sebastian.peryt@intel.com>

sudi (5):
      Fix emit_store_flag_force () function to fix ICE in int_mode_for_mode, at stor-layout.c:403 with arm-linux-gnueabi.
      Adding the missing LTGT to plug the ICE in PR81228. This is a backport of r255625 of trunk.
      [ARM][PR82989] Fix unexpected use of NEON instructions for shifts
      [PR81647][AARCH64] Fix handling of Unordered Comparisons in aarch64-simd.md
      [ARM][PR target/84826] Fix ICE in extract_insn, at recog.c:2304 on arm-linux-gnueabihf

thopre01 (4):
      2017-03-01  Thomas Preud'homme  <thomas.preudhomme@arm.com>
      [ARM] Fix PR85203: cmse_nonsecure_caller returns wrong result
      [ARM] Fix PR85261: ICE with FPSCR setter builtin
      2018-11-21  Mihail Ionescu  <mihail.ionescu@arm.com>

tkoenig (27):
      2018-02-12  Thomas Koenig  <tkoenig@gcc.gnu.org>
      2018-02-17  Thomas Koenig  <tkoenig@gcc.gnu.org>
      2018-02-22  Thomas Koenig  <tkoenig@gcc.gnu.org>
      2018-02-25  Thomas Koenig  <tkoenig@gcc.gnu.org>
      2018-03-19  Thomas Koenig  <tkoenig@gcc.gnu.org>
      2018-03-28  Thomas Koenig  <tkoenig@gcc.gnu.org>
      2018-06-07  Thomas Koenig  <tkoenig@gcc.gnu.org>
      2019-11-03  Tobias Burnus  <burnus@net-b.de> 	Thomas Koenig  <tkoenig@gcc.gnu.org>
      2018-11-25  Thomas Koenig  <tkoenig@gcc.gnu.org>
      2018-12-22  Thomas Koenig  <tkoenig@gcc.gnu.org>
      2019-02-02  Thomas Koenig  <tkoenig@gcc.gnu.org>
      2019-02-02  Thomas Koenig  <tkoenig@gcc.gnu.org>
      2019-02-05  Thomas Koenig  <tkoenig@gcc.gnu.org>
      2019-02-09  Thomas Koenig  <tkoenig@gcc.gnu.org>
      2019-02-10  Thomas Koenig  <tkoenig@gcc.gnu.org>
      2019-02-23  Thomas Koenig  <tkoenig@gcc.gnu.org>
      2019-03-03  Thomas Koenig  <tkoenig@gcc.gnu.org>
      2019-03-06  Thomas Koenig  <tkoenig@gcc.gnu.org>
      2019-03-10  Thomas Koenig  <tkoenig@gcc.gnu.org> 	Steven G. Kargl  <kargl@gcc.gnu.org>
      2019-03-10  Thomas Koenig  <tkoenig@gcc.gnu.org>
      2019-03-13  Thomas Koenig  <tkoenig@gcc.gnu.org>
      2019-03-16  Thomas Koenig  <tkoenig@gcc.gnu.org>
      2019-03-16  Thomas Koenig  <tkoenig@gcc.gnu.org>
      2019-03-17  Thomas Koenig  <tkoenig@gcc.gnu.org>
      2019-03-23  Thomas Koenig  <tkoeng@gcc.gnu.org>
      2019-04-14  Thomas Koenig  <tkoenig@gcc.gnu.org>
      2019-05-05  Thomas Koenig  <tkoenig@gcc.gnu.org>

tschwinge (5):
      [nvptx] Add support for CUDA 9
      [PR target/85056] Address -Wmaybe-uninitialized diagnostic
      [testsuite, Fortran] Consistently set 'DEFAULT_FFLAGS'
      [testsuite, Fortran] Apply DejaGnu 1.4.4 work-around also to 'gfortran.dg/coarray/caf.exp:dg-compile-aux-modules'
      [testsuite] Fix 'dg-compile-aux-modules' diagnostic

uros (23):
      Backport from mainline 	2018-01-17  Uros Bizjak  <ubizjak@gmail.com>
      Backport from mainline 	2018-01-26  Uros Bizjak  <ubizjak@gmail.com>
      PR rtl-optimization/84123 	* combine.c (change_zero_ext): Check if hard register satisfies 	can_change_dest_mode before calling gen_lowpart_SUBREG.
      * gfortran.dg/dec_parameter_1.f (sub1): Remove statement with no effect. 	* gfortran.dg/dec_parameter_2.f90 (sub1): Ditto.
      * config/i386/i386.c (emit_i387_cw_initialization): Always use logic 	instructions when changing rounding bits to preserve precision bits 	in the x87 control word.
      PR target/85193 	* config/i386/i386.md (define_attr "memory"): Handle rotate1 type.
      * config/alpha/alpha.md (stack_probe_internal): Rename 	from "probe_stack".  Update all callers.
      * config/i386/sse.md (cvtusi2<ssescalarmodesuffix>64<round_name>): 	Add {q} suffix to insn mnemonic.
      Backport from mainline 	2018-09-28  Uros Bizjak  <ubizjak@gmail.com>
      Backport from mainline 	2018-11-04  Uros Bizjak  <ubizjak@gmail.com>
      Backport from mainline 	2018-11-11  Uros Bizjak  <ubizjak@gmail.com>
      Backport from mainline 	2018-11-16  Uros Bizjak  <ubizjak@gmail.com>
      * testsuite/ChangeLog: Fix whitespace.
      Backport from mainline 	2018-12-10  Uros Bizjak  <ubizjak@gmail.com>
      * ChangeLog: Add my last entry.
      * config/alpha/alpha.c (alpha_gimplify_va_arg): 	Handle split indirect COMPLEX_TYPE arguments.
      PR target/88938 	* config/i386/i386.c (ix86_expand_builtin) [case IX86_BUILTIN_BEXTRI32, 	case IX86_BUILTIN_BEXTRI64]: Sanitize operands.
      PR target/88998 	* config/i386/sse.md (sse2_cvtpi2pd): Add SSE alternatives. 	Disparage MMX alternative. 	(sse2_cvtpd2pi): Ditto. 	(sse2_cvttpd2pi): Ditto.
      PR target/88948 	* rtl.h (prepare_copy_insn): New prototype. 	* gcse.c (prepare_copy_insn): New function, split out from 	process_insert_insn. 	(process_insert_insn): Use prepare_copy_insn. 	* store-motion.c (replace_store_insn): Use prepare_copy_insn 	instead of gen_move_insn.
      PR fortran/70696 	* gfortran.dg/coarray/event_3.f0: Add save attribue to x.
      2019-02-03  Uroš Bizjak  <ubizjak@gmail.com>
      PR target/89397 	* config/i386/i386.c (ix86_atomic_assign_expand_fenv): Check 	TARGET_SSE in addition to TARGET_SSE_MATH.
      PR target/89945 	* config/i386/i386.md (anddi_1 to andsi_1_zext splitter): 	Avoid calling gen_lowpart with SYMBOL_REF and LABEL_REF operand.

vehre (2):
      gcc/fortran/ChangeLog:
      gcc/fortran/ChangeLog:

ville (3):
      Implement P0962
      Implement P0961
      Implement P0969

vries (5):
      backport "[tail-merge] Don't merge bbs with bb_has_abnormal_pred"
      backport "[openacc] Fix ICE when compiling tile loop containing infinite loop"
      backport "[tail-merge] Fix side-effect test in stmt_local_def"
      backport "[c++] Fix DECL_BY_REFERENCE of clone parms"
      Backport "[vms] Add missing vmsdbgout_early_finish"

wilco (1):
      [AArch64] Fix PR87511

willschm (2):
      [testsuite]
      2018-03-05  Will Schmidt  <will_schmidt@vnet.ibm.com>

wschmidt (8):
      2018-01-25  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
      [gcc]
      2018-06-01  Bill Schmidt  <wschmidt@linux.ibm.com>
      [gcc]
      2018-12-19  Bill Schmidt  <wschmidt@linux.ibm.com>
      2018-01-31  Bill Schmidt  <wschmidt@linux.ibm.com>
      2019-02-04  Bill Schmidt  <wshmidt@linux.ibm.com>
      2019-03-21  Bill Schmidt  <wschmidt@linux.ibm.com>

xguo (1):
      Backport from mainline         2018-11-05  Xuepeng Guo  <xuepeng.guo@intel.com>

diff --git a/ChangeLog b/ChangeLog
index 670d2bb20fd..56a7217496a 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,3 +1,15 @@
+2018-12-06  Release Manager
+
+	* GCC 7.4.0 released.
+
+2018-06-22  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-04-18  David Malcolm  <dmalcolm@redhat.com>
+
+	PR jit/85384
+	* configure: Regenerate.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
diff --git a/config/ChangeLog b/config/ChangeLog
index abce453d1f7..478b7a72c73 100644
--- a/config/ChangeLog
+++ b/config/ChangeLog
@@ -1,3 +1,15 @@
+2018-12-06  Release Manager
+
+	* GCC 7.4.0 released.
+
+2018-06-22  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-04-18  David Malcolm  <dmalcolm@redhat.com>
+
+	PR jit/85384
+	* acx.m4 (GCC_BASE_VER): Remove \$\$ from sed expression.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
diff --git a/config/acx.m4 b/config/acx.m4
index aa1d34b2b49..87c1b5e2932 100644
--- a/config/acx.m4
+++ b/config/acx.m4
@@ -246,7 +246,7 @@ AC_DEFUN([GCC_BASE_VER],
   [AS_HELP_STRING([--with-gcc-major-version-only], [use only GCC major number in filesystem paths])],
   [if test x$with_gcc_major_version_only = xyes ; then
     changequote(,)dnl
-    get_gcc_base_ver="sed -e 's/^\([0-9]*\).*\$\$/\1/'"
+    get_gcc_base_ver="sed -e 's/^\([0-9]*\).*/\1/'"
     changequote([,])dnl
   fi
   ])
diff --git a/configure b/configure
index 32a38633ad8..32ee91f949e 100755
--- a/configure
+++ b/configure
@@ -6620,7 +6620,7 @@ fi
 # Check whether --with-gcc-major-version-only was given.
 if test "${with_gcc_major_version_only+set}" = set; then :
   withval=$with_gcc_major_version_only; if test x$with_gcc_major_version_only = xyes ; then
-        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*\$\$/\1/'"
+        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*/\1/'"
       fi
 
 fi
diff --git a/contrib/ChangeLog b/contrib/ChangeLog
index fb94d319326..5ec3d1aa4da 100644
--- a/contrib/ChangeLog
+++ b/contrib/ChangeLog
@@ -1,3 +1,7 @@
+2018-12-06  Release Manager
+
+	* GCC 7.4.0 released.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
diff --git a/contrib/header-tools/ChangeLog b/contrib/header-tools/ChangeLog
index dfacf7a361f..3a8a7ec0265 100644
--- a/contrib/header-tools/ChangeLog
+++ b/contrib/header-tools/ChangeLog
@@ -1,3 +1,7 @@
+2018-12-06  Release Manager
+
+	* GCC 7.4.0 released.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
diff --git a/contrib/reghunt/ChangeLog b/contrib/reghunt/ChangeLog
index b398ce8a078..3d127b9aef5 100644
--- a/contrib/reghunt/ChangeLog
+++ b/contrib/reghunt/ChangeLog
@@ -1,3 +1,7 @@
+2018-12-06  Release Manager
+
+	* GCC 7.4.0 released.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
diff --git a/contrib/regression/ChangeLog b/contrib/regression/ChangeLog
index 87a1afd0573..3d77c4252ae 100644
--- a/contrib/regression/ChangeLog
+++ b/contrib/regression/ChangeLog
@@ -1,3 +1,7 @@
+2018-12-06  Release Manager
+
+	* GCC 7.4.0 released.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
diff --git a/fixincludes/ChangeLog b/fixincludes/ChangeLog
index 1472c9fe265..1157c939e6c 100644
--- a/fixincludes/ChangeLog
+++ b/fixincludes/ChangeLog
@@ -1,3 +1,15 @@
+2018-12-06  Release Manager
+
+	* GCC 7.4.0 released.
+
+2018-06-22  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-04-18  David Malcolm  <dmalcolm@redhat.com>
+
+	PR jit/85384
+	* configure: Regenerate.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
diff --git a/fixincludes/configure b/fixincludes/configure
index ab97983f327..e4b03fd588c 100755
--- a/fixincludes/configure
+++ b/fixincludes/configure
@@ -5401,7 +5401,7 @@ _ACEOF
 # Check whether --with-gcc-major-version-only was given.
 if test "${with_gcc_major_version_only+set}" = set; then :
   withval=$with_gcc_major_version_only; if test x$with_gcc_major_version_only = xyes ; then
-        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*\$\$/\1/'"
+        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*/\1/'"
       fi
 
 fi
diff --git a/gcc/BASE-VER b/gcc/BASE-VER
index 1502020768a..815da58b7a9 100644
--- a/gcc/BASE-VER
+++ b/gcc/BASE-VER
@@ -1 +1 @@
-7.3.0
+7.4.1
diff --git a/gcc/ChangeLog b/gcc/ChangeLog
index 758a832a113..6ed560907a4 100644
--- a/gcc/ChangeLog
+++ b/gcc/ChangeLog
@@ -1,3 +1,3017 @@
+2019-05-15  David Edelsohn  <dje.gcc@gmail.com>
+
+	Backport from mainline
+	2019-04-11  David Edelsohn  <dje.gcc@gmail.com>
+	* xcoffout.h (xcoff_private_rodata_section_name): Declare.
+	* xcoffout.c (xcoff_private_rodata_section_name): Define.
+	* config/rs6000/rs6000.c (rs6000_xcoff_asm_init_sections): Create
+	read_only_private_data_section using coff_private_rodata_section_name.
+	(rs6000_xcoff_file_start): Generate coff_private_rodata_section_name.
+
+	2018-12-04  David Edelsohn  <dje.gcc@gmail.com>
+	2018-12-13  David Edelsohn  <dje.gcc@gmail.com>
+	PR target/61976
+	* config/rs6000/rs6000.c (rs6000_function_arg): Don't pass aggregates
+	in FPRs on AIX. Ensure type is non-NULL.
+	(rs6000_arg_partial_bytes): Same.
+
+2019-05-15  Sebastian Huber  <sebastian.huber@embedded-brains.de>
+
+	* config/arm/t-rtems: Replace -march=armv7-m multilibs with
+	-mcpu=cortex-m3 and -mcpu=cortex-m4 multilibs.
+
+2019-05-13  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	Backport from mainline.
+	2019-05-06  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	PR target/89424
+	* config/rs6000/rs6000.c (rs6000_expand_vector_extract): Add
+	handling of V1TImode.
+
+2019-05-07  Richard Sandiford  <richard.sandiford@arm.com>
+
+	Backport from mainline:
+	2019-01-25  Richard Sandiford  <richard.sandiford@arm.com>
+
+	PR middle-end/89037
+	* varasm.c (output_constructor_bitfield): Use wi::extract_uhwi
+	instead of accessing TREE_INT_CST_ELT directly.
+
+2019-05-01  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>
+
+	Backport from mainline.
+        2019-04-30  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>
+	PR target/86538
+	* config/aarch64/aarch64-c.c (aarch64_update_cpp_builtins):
+	Define __ARM_FEATURE_ATOMICS
+
+2019-04-30  Srinath Parvathaneni  <srinath.parvathaneni@arm.com>
+
+	PR target/90075
+	* config/aarch64/iterators.md (V_INT_EQUIV): Add mode for
+	integer equivalent of floating point values.
+
+	Backport from mainline
+	2018-12-11  Richard Earnshaw  <Richard.Earnshaw@arm.com>
+	PR target/37369
+	* config/aarch64/iterators.md (sizem1): Add sizes for
+	SFmode and DFmode.
+	(Vbtype): Add SFmode mapping.
+	* config/aarch64/aarch64.md (copysigndf3, copysignsf3): Delete.
+	(copysign<GPF:mode>3): New expand pattern.
+	(copysign<GPF:mode>3_insn): New insn pattern.
+
+2019-04-22  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	Backport from mainline
+	2019-03-15  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	PR target/87532
+	* config/rs6000/rs6000-c.c (altivec_resolve_overloaded_builtin):
+	When handling vec_extract, use modular arithmetic to allow
+	constant selectors greater than vector length.
+	* config/rs6000/rs6000.c (rs6000_expand_vector_extract): Allow
+	V1TImode vectors to have constant selector values greater than 0.
+	Use modular arithmetic to compute vector index.
+	(rs6000_split_vec_extract_var): Use modular arithmetic to compute
+	index for in-memory vectors.  Correct code generation for
+	in-register vectors.  Use inner mode of vector rather than mode of
+	destination for move instruction.
+	(altivec_expand_vec_ext_builtin): Use modular arithmetic to
+	compute index.
+
+	2019-04-12  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	PR target/87532
+	* config/rs6000/vsx.md (*vsx_extract_<mode>_<VS_scalar>mode_var):
+	Use QI inner mode with V16QI vector mode.
+
+2019-04-19  Xiong Hu Luo  <luoxhu@linux.ibm.com>
+
+	Backport from trunk
+	2018-05-23  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	* doc/sourcebuild.texi (Endianness): New subsubsection.
+
+2019-04-11  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2019-03-08  Martin Liska  <mliska@suse.cz>
+
+	PR target/86952
+	* config/i386/i386.c (ix86_option_override_internal): Disable
+	jump tables when retpolines are used.
+
+2019-04-10  Matthew Malcomson  <matthew.malcomson@arm.com>
+
+	PR target/90024
+	* config/arm/arm.c (neon_valid_immediate): Disallow VOIDmode parameter.
+	* config/arm/constraints.md (Dm, DN, Dn): Split previous Dn constraint
+	into three.
+	* config/arm/neon.md (*neon_mov<mode>): Account for TImode and DImode
+	differences directly.
+	(*smax<mode>3_neon, vashl<mode>3, vashr<mode>3_imm): Use Dm constraint.
+
+2019-04-07  Uroš Bizjak  <ubizjak@gmail.com>
+
+	PR target/89945
+	* config/i386/i386.md (anddi_1 to andsi_1_zext splitter):
+	Avoid calling gen_lowpart with SYMBOL_REF and LABEL_REF operand.
+
+2019-04-06  Eric Botcazou  <ebotcazou@adacore.com>
+
+	Backport from mainline
+	2019-02-19  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* rtlanal.c (get_initial_register_offset): Fall back to the estimate
+	as long as the epilogue isn't completed.
+
+2019-04-03  Richard Biener  <rguenther@suse.de>
+
+	PR lto/89896
+	* lto-wrapper.c (run_gcc): Avoid implicit rules making
+	the all target phony.
+
+2019-04-02  Xiong Hu Luo <luoxhu@linux.ibm.com>
+
+	Backport from trunk r250477.
+
+	2017-07-24  Carl Love  <cel@us.ibm.com>
+
+	* config/rs6000/rs6000-c.c: Add support for built-in functions
+	vector float vec_extract_fp32_from_shorth (vector unsigned short);
+	vector float vec_extract_fp32_from_shortl (vector unsigned short);
+	* config/rs6000/altivec.h (vec_extract_fp_from_shorth,
+	vec_extract_fp_from_shortl): Add defines for the two builtins.
+	* config/rs6000/rs6000-builtin.def (VEXTRACT_FP_FROM_SHORTH,
+	VEXTRACT_FP_FROM_SHORTL): Add BU_P9V_OVERLOAD_1 and BU_P9V_VSX_1
+	new builtins.
+	* config/rs6000/vsx.md vsx_xvcvhpsp): Add define_insn.
+	(vextract_fp_from_shorth, vextract_fp_from_shortl): Add define_expands.
+	* doc/extend.texi: Update the built-in documentation file for the
+	new built-in function.
+
+	Backport from trunk r255555.
+
+	2017-12-11  Carl Love  <cel@us.ibm.com>
+
+	* config/rs6000/altivec.h (vec_extract_fp32_from_shorth,
+	vec_extract_fp32_from_shortl]): Add #defines.
+	* config/rs6000/rs6000-builtin.def (VSLDOI_2DI): Add macro expansion.
+	* config/rs6000/rs6000-c.c (ALTIVEC_BUILTIN_VEC_UNPACKH,
+	ALTIVEC_BUILTIN_VEC_UNPACKL, ALTIVEC_BUILTIN_VEC_AND,
+	ALTIVEC_BUILTIN_VEC_SLD, ALTIVEC_BUILTIN_VEC_SRL,
+	ALTIVEC_BUILTIN_VEC_SRO, ALTIVEC_BUILTIN_VEC_SLD,
+	ALTIVEC_BUILTIN_VEC_SLL): Add expansions.
+	* doc/extend.texi: Add documentation for the added builtins.
+
+2019-03-28  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-11-05  Martin Liska  <mliska@suse.cz>
+
+	PR web/87829
+	* doc/invoke.texi: Remove options that are
+	not disabled with -Os.
+
+2019-02-26  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-02-12  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/89253
+	* tree-ssa-loop-split.c (tree_ssa_split_loops): Check we can
+	duplicate the loop.
+
+	2019-02-08  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/89223
+	* tree-data-ref.c (initialize_matrix_A): Fail if constant
+	doesn't fit in HWI.
+	(analyze_subscript_affine_affine): Handle failure from
+	initialize_matrix_A.
+
+	2019-01-28  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/88739
+	* tree-ssa-sccvn.c (vn_reference_lookup_3): Avoid generating
+	BIT_FIELD_REFs of non-mode-precision integral operands.
+
+2019-03-26  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-01-08  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/86554
+	* tree-ssa-sccvn.c (visit_nary_op): When value-numbering to
+	expressions with different overflow behavior make sure there's an
+	available expression on the path.
+
+	2018-11-20  Richard Biener  <rguenther@suse.de>
+ 
+	PR tree-optimization/88105
+	* tree-ssa-dom.c (pass_dominator::execute): Do not walk
+	backedges.
+
+	2018-03-08  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/84552
+	* tree-scalar-evolution.c: Include tree-into-ssa.h.
+	(follow_copies_to_constant): Do not follow SSA names registered
+	for update.
+
+2019-03-21  Bill Schmidt  <wschmidt@linux.ibm.com>
+
+        * config/rs6000/rs6000.c (rs6000_analyze_swaps): Rebuild
+        ud- and du-chains between phases.
+
+2019-03-21  Matthias Klose  <doko@ubuntu.com>
+
+	Backport from mainline
+	2019-02-26  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/89505
+	* tree-ssa-structalias.c (compute_dependence_clique): Make sure
+	to handle restrict pointed-to vars with multiple subvars
+	correctly.
+
+2019-03-17  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline
+	2019-03-14  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR target/89523
+	* config/i386/i386.c (ix86_print_operand): Handle 'M' to add
+	addr32 prefix to VSIB address for X32.
+	* config/i386/sse.md (*avx512pf_gatherpf<mode>sf_mask): Prepend
+	"%M2" to opcode.
+	(*avx512pf_gatherpf<mode>df_mask): Likewise.
+	(*avx512pf_scatterpf<mode>sf_mask): Likewise.
+	(*avx512pf_scatterpf<mode>df_mask): Likewise.
+	(*avx2_gathersi<mode>): Prepend "%M3" to opcode.
+	(*avx2_gathersi<mode>_2): Prepend "%M2" to opcode.
+	(*avx2_gatherdi<mode>): Prepend "%M3" to opcode.
+	(*avx2_gatherdi<mode>_2): Prepend "%M2" to opcode.
+	(*avx2_gatherdi<mode>_3): Prepend "%M3" to opcode.
+	(*avx2_gatherdi<mode>_4): Prepend "%M2" to opcode.`
+	(*avx512f_gathersi<mode>): Prepend "%M4" to opcode.
+	(*avx512f_gathersi<mode>_2): Prepend "%M3" to opcode.
+	(*avx512f_gatherdi<mode>): Prepend "%M4" to opcode.
+	(*avx512f_gatherdi<mode>_2): Prepend "%M3" to opcode.
+	(*avx512f_scattersi<mode>): Prepend "%M0" to opcode.
+	(*avx512f_scatterdi<mode>): Likewise.
+
+2019-03-14  Martin Jambor  <mjambor@suse.cz>
+
+	Backport from mainline
+	2019-03-07  Martin Jambor  <mjambor@suse.cz>
+
+	PR lto/87525
+	* ipa-cp.c (perform_estimation_of_a_value): Account zero time benefit
+	for extern inline functions.
+
+2019-03-14  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2018-02-16  Jakub Jelinek  <jakub@redhat.com>
+ 
+	PR target/84272
+	* config/aarch64/cortex-a57-fma-steering.c (fma_forest::merge_forest):
+	Use ++iter rather than iter++ for std::list iterators.
+	(func_fma_steering::dfs): Likewise.  Don't delete nodes right away,
+	defer deleting them until all nodes in the forest are processed.  Do
+	free even leaf nodes.  Change to_process into auto_vec.
+
+2019-03-13  Andre Vieira  <andre.simoesdiasvieira@arm.com>
+
+	Backport from mainline
+	2019-03-08  Andre Vieira  <andre.simoesdiasvieira@arm.com>
+
+	* config/arm/arm.h (TARGET_FP16_TO_DOUBLE): Add TARGET_VFP_DOUBLE
+	requirement.
+
+2019-03-11  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2019-02-11  David Malcolm  <dmalcolm@redhat.com>
+
+	PR lto/88147
+	* input.c (selftest::test_line_offset_overflow): New selftest.
+	(selftest::input_c_tests): Call it.
+
+2019-03-07  Xiong Hu Luo  <luoxhu@linux.ibm.com>
+
+	Backport of r268834 from mainline to gcc-7-branch.
+	2019-02-13  Xiong Hu Luo  <luoxhu@linux.vnet.ibm.com>
+
+	* config/rs6000/altivec.h (vec_sbox_be, vec_cipher_be,
+	vec_cipherlast_be, vec_ncipher_be, vec_ncipherlast_be): New #defines.
+	* config/rs6000/crypto.md (CR_vqdi): New define_mode_iterator.
+	(crypto_vsbox_<mode>, crypto_<CR_insn>_<mode>): New define_insns.
+	* config/rs6000/rs6000-builtin.def (VSBOX_BE): New BU_CRYPTO_1.
+	(VCIPHER_BE, VCIPHERLAST_BE, VNCIPHER_BE, VNCIPHERLAST_BE):
+	New BU_CRYPTO_2.
+	* config/rs6000/rs6000.c (builtin_function_type)
+	<CRYPTO_BUILTIN_VSBOX_BE, CRYPTO_BUILTIN_VCIPHER_BE,
+	CRYPTO_BUILTIN_VCIPHERLAST_BE, CRYPTO_BUILTIN_VNCIPHER_BE,
+	CRYPTO_BUILTIN_VNCIPHERLAST_BE>: New switch options.
+	* doc/extend.texi (vec_sbox_be, vec_cipher_be, vec_cipherlast_be,
+	vec_ncipher_be, vec_ncipherlast_be): New builtin functions.
+
+2019-02-27  Uroš Bizjak  <ubizjak@gmail.com>
+
+	PR target/89397
+	* config/i386/i386.c (ix86_atomic_assign_expand_fenv): Check
+	TARGET_SSE in addition to TARGET_SSE_MATH.
+
+	(ix86_excess_precision): Ditto.
+	(ix86_float_exceptions_rounding_supported_p): Ditto.
+	(use_rsqrt_p): Ditto.
+	* config/i386/sse.md (rsqrt<mode>2): Ditto.
+
+2019-02-15  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2019-02-14  Martin Liska  <mliska@suse.cz>
+
+	PR rtl-optimization/89242
+	* dce.c (delete_unmarked_insns): Call free_dominance_info we
+	process a transformation.
+
+2019-02-15  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2019-02-11  Martin Liska  <mliska@suse.cz>
+
+	PR ipa/89009
+	* ipa-cp.c (build_toporder_info): Remove usage of a param.
+	* ipa-inline.c (inline_small_functions): Likewise.
+	* ipa-pure-const.c (propagate_pure_const): Likewise.
+	(propagate_nothrow): Likewise.
+	* ipa-reference.c (propagate): Likewise.
+	* ipa-utils.c (struct searchc_env): Remove unused field.
+	(searchc): Always search across AVAIL_INTERPOSABLE.
+	(ipa_reduced_postorder): Always allow AVAIL_INTERPOSABLE as
+	the only called IPA pure const can properly not propagate
+	across interposable boundary.
+	* ipa-utils.h (ipa_reduced_postorder): Remove param.
+
+2019-02-11  Stefan Agner  <stefan@agner.ch>
+
+	Backport from mainline.
+	2019-01-10  Stefan Agner  <stefan@agner.ch>
+
+	PR target/88648
+	* config/arm/arm.c (arm_option_override_internal): Force
+	opts->x_inline_asm_unified to true only if TARGET_THUMB2_P.
+
+2019-02-09  Alan Modra  <amodra@gmail.com>
+
+	PR target/88343
+	* config/rs6000/rs6000.c (rs6000_reg_live_or_pic_offset_p): Match
+	logic in rs6000_emit_prologue emitting pic_offset_table setup.
+
+2019-02-08  Eric Botcazou  <ebotcazou@adacore.com>
+
+	Backport from mainline
+	2018-06-11  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	PR target/85755
+	* config/rs6000/rs6000.md (*movdi_internal32): Put constraint modifiers
+	on the correct operand.
+	(*movdi_internal64): Ditto.
+
+2019-02-06  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	Backport from mainline.
+	2019-01-30  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+	* config/rs6000/rs6000-c.c (altivec-resolve_overloaded_builtin):
+	Change handling of ALTIVEC_BUILTIN_VEC_EXTRACT.  Coerce result to
+	type of vector element when vec_extract is implemented by direct
+	move.
+
+2019-02-06  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* config/i386/i386.c (ix86_expand_prologue): Emit a memory blockage
+	after restoring registers saved to allocate the frame on Windows.
+
+2019-02-05  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	Backport from mainline
+	2019-02-05  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	PR target/88856
+	* config/s390/s390.md: Remove load and test FP splitter.
+
+2019-02-04  Bill Schmidt  <wshmidt@linux.ibm.com>
+
+	PR target/87064
+	Backport from mainline
+
+	2019-01-30  Bill Schmidt  <wschmidt@linux.ibm.com>
+
+	PR target/87064
+	* config/rs6000/vsx.md (*vsx_reduc_<VEC_reduc_name>_v4sf_scalar):
+	Disable for little-endian.
+
+	2019-01-22  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/87064
+	* config/rs6000/vsx.md (*vsx_reduc_<VEC_reduc_name>_v2df_scalar):
+	Disable for little endian.
+
+2018-01-31  Bill Schmidt  <wschmidt@linux.ibm.com>
+
+	Backport from mainline
+	2018-01-31  Bill Schmidt  <wschmidt@linux.ibm.com>
+
+	PR tree-optimization/89008
+	* gimple-ssa-strength-reduction.c (slsr_process_mul): Don't
+	process anything of the form X * 0.
+
+2019-01-31  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-01-31  Richard Biener  <rguenther@suse.de>
+
+	PR rtl-optimization/89115
+	* lra.c (lra_rtx_hash): Properly hash CONST_INT values.
+
+	2019-01-30  Richard Biener  <rguenther@suse.de>
+
+	PR rtl-optimization/89115
+	* opts.c (default_options_optimization): Reduce
+	PARAM_MAX_DSE_ACTIVE_LOCAL_STORES by a factor of 10 at -O1.
+	Make PARAM_LOOP_INVARIANT_MAX_BBS_IN_LOOP reduction relative
+	to the default.
+
+2019-01-30  Kewen Lin  <linkw@gcc.gnu.org>
+
+	Backport from mainline.
+	2019-01-17  Kewen Lin  <linkw@gcc.gnu.org>
+
+	* doc/extend.texi: Add four new prototypes for vec_ld and seven new
+	prototypes for vec_st.
+	* config/rs6000/rs6000-c.c (altivec_overloaded_builtins): Add entries
+	for scalar address type variants of altivec_vec_ld/altivec_vec_st,
+	mainly on signed/unsigned long long and double.
+
+2019-01-27  Uroš Bizjak  <ubizjak@gmail.com>
+
+	PR target/88948
+	* rtl.h (prepare_copy_insn): New prototype.
+	* gcse.c (prepare_copy_insn): New function, split out from
+	process_insert_insn.
+	(process_insert_insn): Use prepare_copy_insn.
+	* store-motion.c (replace_store_insn): Use prepare_copy_insn
+	instead of gen_move_insn.
+
+2019-01-24  Uroš Bizjak  <ubizjak@gmail.com>
+
+	PR target/88998
+	* config/i386/sse.md (sse2_cvtpi2pd): Add SSE alternatives.
+	Disparage MMX alternative.
+	(sse2_cvtpd2pi): Ditto.
+	(sse2_cvttpd2pi): Ditto.
+
+2019-01-24  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-01-23  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/89008
+	* tree-ssa-reassoc.c (eliminate_using_constants): For * 0 do
+	not leave another stray operand.
+
+2019-01-22  Uroš Bizjak  <ubizjak@gmail.com>
+
+	PR target/88938
+	* config/i386/i386.c (ix86_expand_builtin) [case IX86_BUILTIN_BEXTRI32,
+	case IX86_BUILTIN_BEXTRI64]: Sanitize operands.
+
+2019-01-18  Uroš Bizjak  <ubizjak@gmail.com>
+
+	* config/alpha/alpha.c (alpha_gimplify_va_arg):
+	Handle split indirect COMPLEX_TYPE arguments.
+
+2019-01-16  Martin Jambor  <mjambor@suse.cz>
+
+	Backported from mainline
+	2018-12-10  Martin Jambor  <mjambor@suse.cz>
+
+	PR ipa/88214
+	* ipa-prop.c (determine_locally_known_aggregate_parts): Make sure
+	we check pointers against pointers.
+
+2019-01-09  Eric Botcazou  <ebotcazou@adacore.com>
+	    James Clarke  <jrtc27@jrtc27.com>
+
+	PR target/84010
+	* config/sparc/sparc.c (sparc_legitimize_tls_address): Only use Pmode
+	consistently in TLS address generation and adjust code to the renaming
+	of patterns.  Mark calls to __tls_get_addr as const.
+	* config/sparc/sparc.md (tgd_hi22): Turn into...
+	(tgd_hi22<P:mode>): ...this and use Pmode throughout.
+	(tgd_lo10): Turn into...
+	(tgd_lo10<P:mode>): ...this and use Pmode throughout.
+	(tgd_add32): Merge into...
+	(tgd_add64): Likewise.
+	(tgd_add<P:mode>): ...this and use Pmode throughout.
+	(tldm_hi22): Turn into...
+	(tldm_hi22<P:mode>): ...this and use Pmode throughout.
+	(tldm_lo10): Turn into...
+	(tldm_lo10<P:mode>): ...this and use Pmode throughout.
+	(tldm_add32): Merge into...
+	(tldm_add64): Likewise.
+	(tldm_add<P:mode>): ...this and use Pmode throughout.
+	(tldm_call32): Merge into...
+	(tldm_call64): Likewise.
+	(tldm_call<P:mode>): ...this and use Pmode throughout.
+	(tldo_hix22): Turn into...
+	(tldo_hix22<P:mode>): ...this and use Pmode throughout.
+	(tldo_lox10): Turn into...
+	(tldo_lox10<P:mode>): ...this and use Pmode throughout.
+	(tldo_add32): Merge into...
+	(tldo_add64): Likewise.
+	(tldo_add<P:mode>): ...this and use Pmode throughout.
+	(tie_hi22): Turn into...
+	(tie_hi22<P:mode>): ...this and use Pmode throughout.
+	(tie_lo10): Turn into...
+	(tie_lo10<P:mode>): ...this and use Pmode throughout.
+	(tie_ld64): Use DImode throughout.
+	(tie_add32): Merge into...
+	(tie_add64): Likewise.
+	(tie_add<P:mode>): ...this and use Pmode throughout.
+	(tle_hix22_sp32): Merge into...
+	(tle_hix22_sp64): Likewise.
+	(tle_hix22<P:mode>): ...this and use Pmode throughout.
+	(tle_lox22_sp32): Merge into...
+	(tle_lox22_sp64): Likewise.
+	(tle_lox22<P:mode>): ...this and use Pmode throughout.
+	(*tldo_ldub_sp32): Merge into...
+	(*tldo_ldub_sp64): Likewise.
+	(*tldo_ldub<P:mode>): ...this and use Pmode throughout.
+	(*tldo_ldub1_sp32): Merge into...
+	(*tldo_ldub1_sp64): Likewise.
+	(*tldo_ldub1<P:mode>): ...this and use Pmode throughout.
+	(*tldo_ldub2_sp32): Merge into...
+	(*tldo_ldub2_sp64): Likewise.
+	(*tldo_ldub2<P:mode>): ...this and use Pmode throughout.
+	(*tldo_ldsb1_sp32): Merge into...
+	(*tldo_ldsb1_sp64): Likewise.
+	(*tldo_ldsb1<P:mode>): ...this and use Pmode throughout.
+	(*tldo_ldsb2_sp32): Merge into...
+	(*tldo_ldsb2_sp64): Likewise.
+	(*tldo_ldsb2<P:mode>): ...this and use Pmode throughout.
+	(*tldo_ldub3_sp64): Use DImode throughout.
+	(*tldo_ldsb3_sp64): Likewise.
+	(*tldo_lduh_sp32): Merge into...
+	(*tldo_lduh_sp64): Likewise.
+	(*tldo_lduh<P:mode>): ...this and use Pmode throughout.
+	(*tldo_lduh1_sp32): Merge into...
+	(*tldo_lduh1_sp64): Likewise.
+	(*tldo_lduh1<P:mode>): ...this and use Pmode throughout.
+	(*tldo_ldsh1_sp32): Merge into...
+	(*tldo_ldsh1_sp64): Likewise.
+	(*tldo_ldsh1<P:mode>): ...this and use Pmode throughout.
+	(*tldo_lduh2_sp64): Use DImode throughout.
+	(*tldo_ldsh2_sp64): Likewise.
+	(*tldo_lduw_sp32): Merge into...
+	(*tldo_lduw_sp64): Likewise.
+	(*tldo_lduw<P:mode>): ...this and use Pmode throughout.
+	(*tldo_lduw1_sp64): Use DImode throughout.
+	(*tldo_ldsw1_sp64): Likewise.
+	(*tldo_ldx_sp64): Likewise.
+	(*tldo_stb_sp32): Merge into...
+	(*tldo_stb_sp64): Likewise.
+	(*tldo_stb<P:mode>): ...this and use Pmode throughout.
+	(*tldo_sth_sp32): Merge into...
+	(*tldo_sth_sp64): Likewise.
+	(*tldo_sth<P:mode>): ...this and use Pmode throughout.
+	(*tldo_stw_sp32): Merge into...
+	(*tldo_stw_sp64): Likewise.
+	(*tldo_stw<P:mode>): ...this and use Pmode throughout.
+	(*tldo_stx_sp64): Use DImode throughout.
+
+2019-01-09  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* doc/invoke.texi (-Os): Add reference to -finline-functions.
+	(-finline-small-functions): Add references to -O3 and -Os.
+	(-findirect-inlining): Likewise.
+	(-finline-functions): Add references to -Os, -fprofile-use and
+	-fauto-profile.
+
+2019-01-03  Iain Sandoe  <iain@sandoe.co.uk>
+
+	revert:
+	2018-12-30  Iain Sandoe  <iain@sandoe.co.uk>
+
+	backport from mainline.
+	2018-12-12 Segher Boessenkool  <segher@kernel.crashing.org>
+		   Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR target/88343
+	* config/rs6000/rs6000.c (save_reg_p): Do not save the picbase reg
+	unless it has been used.
+	(first_reg_to_save): Remove dead code.
+
+2019-01-02  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	Backport from trunk
+	2018-12-06  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	PR inline-asm/55681
+	* doc/extend.texi (Basic Asm): Update grammar.
+	(Extended Asm): Update grammar.
+
+	Backport from trunk
+	2018-12-06  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	* doc/extend.texi (Using Assembly Language with C): Document asm inline.
+	(Size of an asm): Fix typo.  Document asm inline.
+	* gimple-pretty-print.c (dump_gimple_asm): Handle asm inline.
+	* gimple.h (enum gf_mask): Add GF_ASM_INLINE.
+	(gimple_asm_set_volatile): Fix typo.
+	(gimple_asm_inline_p): New.
+	(gimple_asm_set_inline): New.
+	* gimplify.c (gimplify_asm_expr): Propagate the asm inline flag from
+	tree to gimple.
+	* ipa-icf-gimple.c (func_checker::compare_gimple_asm): Compare the
+	gimple_asm_inline_p flag, too.
+	* tree-core.h (tree_base): Document that protected_flag is ASM_INLINE_P
+	in an ASM_EXPR.
+	* tree-inline.c (estimate_num_insns): If gimple_asm_inline_p return
+	a minimum size for an asm.
+	* tree.h (ASM_INLINE_P): New.
+
+2018-12-30  Iain Sandoe  <iain@sandoe.co.uk>
+
+	backport from mainline.
+	2018-12-12 Segher Boessenkool  <segher@kernel.crashing.org>
+		   Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR target/88343
+	* config/rs6000/rs6000.c (save_reg_p): Do not save the picbase reg
+	unless it has been used.
+	(first_reg_to_save): Remove dead code.
+
+2018-12-24  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2018-12-06  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR c++/87380
+	* config/darwin.h (TARGET_WEAK_NOT_IN_ARCHIVE_TOC) Remove, use the
+	default.
+	* config/rs6000/darwin7.h (TARGET_WEAK_NOT_IN_ARCHIVE_TOC): New.
+
+2018-12-24  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2018-12-06  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR target/78444
+	* config/i386/darwin.h (STACK_BOUNDARY): Remove macro.
+	* config/i386/i386.c (ix86_compute_frame_layout): Ensure at least 128b
+	stack alignment in non-leaf functions.
+
+2018-12-24  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2018-08-15  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR target/81685
+	* config/darwin.h: (DEBUG_STR_OFFSETS_SECTION, DEBUG_LOCLISTS_SECTION,
+	DEBUG_RNGLISTS_SECTION) new macros.  (DEBUG_PUBNAMES_SECTION,
+	DEBUG_PUBTYPES_SECTION) update to include GNU variant.
+
+2018-12-21  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline
+	2018-12-10  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/88418
+	* config/i386/i386.c (ix86_expand_sse_cmp): For vector modes,
+	check operand 1 with vector_operand predicate.
+	(ix86_expand_sse_movcc): For vector modes, check op_true with
+	vector_operand, not nonimmediate_operand.
+
+2018-12-19  Bill Schmidt  <wschmidt@linux.ibm.com>
+
+	Backport from mainline
+	2018-12-18  Bill Schmidt  <wschmidt@linux.ibm.com>
+
+	* doc/extend.texi (PowerPC Altivec/VSX Built-in Functions):
+	Describe when a typedef name can be used as the type specifier for
+	a vector type, and when it cannot.
+
+2018-12-19  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	Backport from trunk
+	2018-12-19  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	PR target/88213
+	* config/rs6000/vsx.md (*vsx_extract_<P:mode>_<VSX_D:mode>_load):
+	Require TARGET_POWERPC64.
+
+2018-12-17  Senthil Kumar Selvaraj  <senthilkumar.selvaraj@microchip.com>
+
+	Backport from trunk
+	2018-12-17  Senthil Kumar Selvaraj  <senthilkumar.selvaraj@microchip.com>
+
+	PR rtl-optimization/88253
+	* combine.c (combine_simplify_rtx): Test for side-effects before
+	substituting by zero.
+
+2018-12-15  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	Backport from trunk
+	2018-12-14  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	PR rtl-optimization/88001
+	* function.c (match_asm_constraints_1): Don't invalidly share RTL.
+
+2018-12-13  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	Backport from mainline
+	2018-12-13  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	* config/s390/s390-builtins.def (s390_vec_double_s64): Map to
+	s390_vec_double_s64 instead of s390_vcdgb.
+	(s390_vec_double_u64): Map to s390_vec_double_u64 instead of
+	s390_vcdlgb.
+
+2018-12-13  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	Backport from mainline
+	2018-12-13  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	* config/s390/vx-builtins.md ("vec_ctd_s64", "vec_ctd_u64")
+	("vec_ctsl", "vec_ctul"): Replace 0 with VEC_NOINEXACT.
+	("vec_double_s64", "vec_double_u64"): Replace 4 with VEC_INEXACT.
+
+2018-12-12  Peter Bergner  <bergner@linux.ibm.com>
+
+	Backport from mainline
+	2018-12-07  Peter Bergner  <bergner@linux.ibm.com>
+
+	PR target/87496
+	* config/rs6000/rs6000.c (rs6000_option_override_internal): Disallow
+	-mabi=ieeelongdouble and -mabi=ibmlongdouble without -mlong-double-128.
+	Do not error for -mabi=ibmlongdouble and no ISA 2.06 support.
+	* doc/invoke.texi: Document -mabi=ibmlongdouble and -mabi=ieeelongdouble
+	require -mlong-double-128.
+
+2018-12-06  Richard Biener  <rguenther@suse.de>
+
+	* BASE-VER: Increment to 7.4.1.
+
+2018-12-06  Release Manager
+
+	* GCC 7.4.0 released.
+
+2018-11-28  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/79351
+	* tree-ssa-sccvn.c (vn_reference_lookup_3): For assignments from
+	empty CONSTRUCTORs ensure the store is at a constant position.
+
+2018-11-26  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2018-08-22  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR bootstrap/81033
+	PR target/81733
+	PR target/52795
+	* gcc/dwarf2out.c (FUNC_SECOND_SECT_LABEL): New.
+	(dwarf2out_switch_text_section): Generate a local label for the second
+	function sub-section and apply it as the second FDE start label.
+	* gcc/final.c (final_scan_insn_1): Emit second FDE label after the
+	second sub-section start.
+
+2018-11-26  Iain Sandoe  <iain@sandoe.co.uk>
+
+	2018-08-15  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/darwin.c
+	(darwin_function_switched_text_sections): Delete.
+	* gcc/config/darwin.h
+	(TARGET_ASM_FUNCTION_SWITCHED_TEXT_SECTIONS): Likewise.
+
+2018-11-26  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	Backport from mainline
+	2018-11-20  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	* config/s390/s390.md ("clztidi2"): Swap the RTX's written to the
+	DImode parts of the target operand.
+
+2018-11-26  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	Backport from mainline
+	2018-11-26  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	* doc/invoke.texi: Document z14/arch12 -march option.
+
+2018-10-19  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/87645
+	Backport from mainline
+	2018-07-12  Richard Biener  <rguenther@suse.de>
+
+	* gimple-match-head.c (gimple_resimplify1): Apply recursion
+	limit.
+	(gimple_resimplify2): Likewise.
+	(gimple_resimplify3): Likewise.
+	(gimple_resimplify4): Likewise.
+
+2018-11-26  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2018-10-15  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/87610
+	* tree-ssa-structalias.c (struct vls_data): Add escaped_p member.
+	(visit_loadstore): When a used restrict tag escaped verify that
+	the points-to solution of "other" pointers do not include
+	escaped.
+	(compute_dependence_clique): If a used restrict tag escaped
+	communicated that down to visit_loadstore.
+
+	2018-10-25  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/87665
+	PR tree-optimization/87745
+	* tree-vectorizer.h (get_earlier_stmt): Remove.
+	(get_later_stmt): Pick up UID from the original non-pattern stmt.
+
+	2018-10-24  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/87665
+	* tree-vect-data-refs.c (vect_preserves_scalar_order_p): Adjust
+	to reflect reality.
+
+2018-11-26  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2018-06-14  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/86139
+	* tree-vect-generic.c (build_word_mode_vector_type): Remove
+	duplicate and harmful type_hash_canon.
+
+	2018-06-15  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/86076
+	* tree-cfg.c (move_stmt_op): unshare invariant addresses
+	before adjusting their block.
+
+2018-11-22  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline
+	2018-11-16  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/88051
+	* config/i386/sse.md (UNSPEC_MOVDI_TO_SSE): New UNSPEC.
+	(movdi_to_sse): Rewrite using UNSPEC_MOVDI_TO_SSE unspec.
+
+2018-11-22  Tom de Vries  <tom@codesourcery.com>
+
+	backport from trunk:
+	2017-11-19  Tom de Vries  <tom@codesourcery.com>
+
+	PR target/82961
+	* vmsdbgout.c (vmsdbgout_early_finish): New function.
+	(vmsdbg_debug_hooks): Set early_finish field to vmsdbgout_early_finish.
+
+2018-11-21  Mihail Ionescu  <mihail.ionescu@arm.com>
+
+	PR target/87867
+	Backport from mainiline
+	2018-09-26  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* config/arm/arm.c (arm_reorg): Skip Thumb reorg pass for thunks.
+	(arm32_output_mi_thunk): Deal with long calls.
+
+2018-11-20  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2018-03-12  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/84777
+	* tree-ssa-loop-ch.c (should_duplicate_loop_header_p): For
+	force-vectorize loops ignore whether we are optimizing for size.
+
+	2018-01-26  Richard Biener  <rguenther@suse.de>
+
+	PR rtl-optimization/84003
+	* dse.c (record_store): Only record redundant stores when
+	the earlier store aliases at least all accesses the later one does.
+
+2018-11-20  Xuepeng Guo  <xuepeng.guo@intel.com>
+
+	Backport from mainline
+	2018-11-05  Xuepeng Guo  <xuepeng.guo@intel.com>
+
+	PR target/87853
+	* config/i386/emmintrin.h (__v16qs): New to cope with option
+	-funsigned-char.
+	(_mm_cmpeq_epi8): Replace __v16qi with __v16qs.
+	(_mm_cmplt_epi8): Likewise.
+	(_mm_cmpgt_epi8): Likewise.
+
+2018-11-20  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR rtl-optimization/85925
+	* rtl.h (word_register_operation_p): New predicate.
+	* combine.c (record_dead_and_set_regs_1): Only apply specific handling
+	for WORD_REGISTER_OPERATIONS targets to word_register_operation_p RTX.
+	* rtlanal.c (nonzero_bits1): Likewise.  Adjust couple of comments.
+	(num_sign_bit_copies1): Likewise.
+
+2018-11-18  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline
+	2018-11-11  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/87928
+	* config/i386/i386.h (STACK_BOUNDARY): Use TARGET_64BIT_MS_ABI
+	instead of (TARGET_64BIT && ix86_abi == MS_ABI).
+	* config/i386/darwin.h (STACK_BOUNDARY): Ditto.
+	* config/i386/cygming.h (STACK_BOUNDARY): Remove.
+
+2018-11-15  Nathan Sidwell  <nathan@acm.org>
+
+	PR debug/88006
+	PR debug/87462
+	* dwarf2out.c (dwarf2out_finish): Apply resolve_addr to comdat
+	type list.
+
+2018-11-11  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline
+	2018-11-04  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR middle-end/58372
+	* cfgexpand.c (pass_expand::execute): Move the call to
+	finish_eh_generation in front of the call to expand_stack_alignment.
+
+2018-11-07  Max Filippov  <jcmvbkbc@gmail.com>
+
+	Backport from mainline
+	2018-11-05  Max Filippov  <jcmvbkbc@gmail.com>
+
+	* config/xtensa/uclinux.h (XTENSA_ALWAYS_PIC): Change to 0.
+
+2018-10-26  Bill Schmidt  <wschmidt@linux.ibm.com>
+
+	Backport from mainline
+	2018-10-19  Bill Schmidt  <wschmidt@linux.ibm.com>
+
+	PR tree-optimization/87473
+	* gimple-ssa-strength-reduction.c (record_phi_increments): For
+	phi arguments identical to the base expression of the phi
+	candidate, record a phi-adjust increment of zero minus the index
+	expression of the hidden basis.
+	(phi_incr_cost): For phi arguments identical to the base
+	expression of the phi candidate, the difference to compare against
+	the increment is zero minus the index expression of the hidden
+	basis, and there is no potential savings from replacing the (phi)
+	statement.
+	(ncd_with_phi): For phi arguments identical to the base expression
+	of the phi candidate, the difference to compare against the
+	increment is zero minus the index expression of the hidden basis.
+	(all_phi_incrs_profitable): For phi arguments identical to the
+	base expression of the phi candidate, the increment to be checked
+	for profitability is zero minus the index expression of the hidden
+	basis.
+
+2018-10-19  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	Backport from mainline
+	2018-10-15  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	* config/s390/s390.c (s390_expand_vec_init): Force vector element
+	into reg if it isn't a general operand.
+
+2018-10-17  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR middle-end/87623
+	* fold-const.c (fold_truth_andor_1): If the right side is not constant,
+	bail out if both sides do not have the same storage order.
+
+2018-10-16  Wilco Dijkstra  <wdijkstr@arm.com>
+
+	Backported from mainline
+	PR target/87511
+	* config/aarch64/aarch64.c (aarch64_mask_and_shift_for_ubfiz_p):
+	Use HOST_WIDE_INT_1U for shift.
+
+2018-10-12  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-10-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/87550
+	* config/i386/i386-builtin.def (IX86_BUILTIN_RDPMC): Move from args set
+	to special_args set.
+
+	2018-09-12  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/87248
+	* fold-const.c (fold_ternary_loc) <case COND_EXPR>: Verify also that
+	BIT_AND_EXPR's second operand is a power of two.  Formatting fix.
+
+	2018-08-27  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/87065
+	* combine.c (simplify_if_then_else): Formatting fix.
+	(if_then_else_cond): Guard MULT optimization with SCALAR_INT_MODE_P
+	check.
+	(known_cond): Don't return const_true_rtx for vector modes.  Use
+	CONST0_RTX instead of const0_rtx.  Formatting fixes.
+
+	2018-07-24  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/86627
+	* expmed.c (expand_divmod): Punt if d == HOST_WIDE_INT_MIN
+	and size > HOST_BITS_PER_WIDE_INT.  For size > HOST_BITS_PER_WIDE_INT
+	and abs_d == d, do the power of two handling if profitable.
+
+	2018-07-17  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/86542
+	* omp-low.c (create_task_copyfn): Copy over also fields corresponding
+	to _looptemp_ clauses, other than the first two.
+
+	PR middle-end/86539
+	* gimplify.c (gimplify_omp_for): Ensure taskloop firstprivatized init
+	and cond temporaries don't have reference type if iterator has
+	pointer type.  For init use &for_pre_body instead of pre_p if
+	for_pre_body is non-empty.
+
+	2018-07-26  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/86660
+	* omp-low.c (scan_sharing_clauses): Don't ignore map clauses for
+	declare target to variables if they have always,{to,from,tofrom} map
+	kinds.
+
+2018-10-12  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2018-08-23  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/87024
+	* tree-inline.c (copy_bb): Drop unused __builtin_va_arg_pack_len
+	calls.
+
+	2018-08-17  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/86505
+	* tree-inline.c (copy_bb): When inlining __builtin_va_arg_pack_len ()
+	across a va-arg-pack using call adjust its return value accordingly.
+
+2018-10-09  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline
+	2018-09-29  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR target/87370
+	* config/i386/i386.c (construct_container): Use TImode for
+	BLKmode values in 2 integer registers.
+
+2018-10-08  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline
+	2018-10-08  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR target/87517
+	* config/i386/avx512fintrin.h (_mm512_mask_fmaddsub_round_pd):
+	Defined with __builtin_ia32_vfmaddsubpd512_mask.
+
+2018-10-05  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline
+	2018-10-05  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR target/87522
+	* config/i386/gnu-user.h (ASM_SPEC): Don't pass -msse2avx to
+	assembler for -mavx.
+	* config/i386/gnu-user64.h (ASM_SPEC): Likewise.
+
+2018-10-03  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline
+	2018-09-28  Uros Bizjak  <ubizjak@gmail.com>
+
+	* config/i386/i386.h (SSE_REGNO): Fix check for FIRST_REX_SSE_REG.
+	(GET_SSE_REGNO): Rename from SSE_REGNO.  Update all uses for rename.
+
+2018-10-03  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR other/87353
+	* doc/invoke.texi (Link Options): Fix formatting and grammar.
+
+2018-10-01  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backport from mainline
+	2018-06-29  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	* config/arm/arm.c (output_move_double): Don't allow STRD instructions
+	if starting source register is not even.
+
+2018-09-29  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/87467
+	* config/i386/avx512fintrin.h (_mm512_abs_pd, _mm512_mask_abs_pd): Use
+	__m512d type for __A argument rather than __m512.
+
+2018-09-27  Michael Meissner  <meissner@linux.ibm.com>
+
+	Backport from mainline
+	2018-08-20  Michael Meissner  <meissner@linux.ibm.com>
+
+	PR target/87033
+	* config/rs6000/rs6000.md (extendsi<mode>2): Change constraints
+	from 'Y' to 'YZ' to enable the LWAX instruction to be generated
+	for indexed loads.
+
+2018-09-21  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* config/rs6000/rs6000.c (rs6000_function_ok_for_sibcall): Return false
+	if the call takes a static chain.
+
+2018-09-19  John David Anglin  <danglin@gcc.gnu.org>
+
+	* config/pa/pa.md (atomic_storeqi): Restore deleted expander.
+	(atomic_storehi): Likewise.
+	(atomic_storesi): Likewise.
+	(atomic_loaddi): Restore compare and swap exchange loop code.
+
+2018-09-12  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	Backport from trunk
+	2018-08-24  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	PR target/86989
+	* config/rs6000/rs6000.c (toc_relative_expr_p): Check that the base is
+	the TOC register.
+
+2018-09-12  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	Backport from mainline
+	2018-09-12  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	* config/s390/s390.md (PFPO_RND_MODE_DFP, PFPO_RND_MODE_BFP): New
+	constants.
+	("trunc<BFP:mode><DFP_ALL:mode>2")
+	("trunc<DFP_ALL:mode><BFP:mode>2")
+	("extend<BFP:mode><DFP_ALL:mode>2")
+	("extend<DFP_ALL:mode><BFP:mode>2"): Set proper rounding mode
+	according to the target operand type.
+
+2018-09-04  Max Filippov  <jcmvbkbc@gmail.com>
+
+	Backport from mainline
+	2018-09-04  Max Filippov  <jcmvbkbc@gmail.com>
+
+	* config/xtensa/xtensa.c (xtensa_expand_atomic): Reorder AND and
+	XOR operations in NAND case.
+
+2018-09-04  Jonathan Wakely  <jwakely@redhat.com>
+
+	* doc/invoke.texi (Option Summary): Add -Waligned-new.
+
+2018-09-03  Tom de Vries  <tdevries@suse.de>
+
+	backport from trunk:
+	2018-06-21  Tom de Vries  <tdevries@suse.de>
+
+	PR tree-optimization/85859
+	* tree-ssa-tail-merge.c (stmt_local_def): Copy gimple_is_call
+	test with comment from bb_no_side_effects_p.
+
+2018-08-25  Jozef Lawrynowicz  <jozef.l@mittosystems.com>
+
+	Backport from mainline
+	PR target/86662
+	* gcc/tree.c (build_common_tree_nodes): Initialize integer_types array
+	with all enabled __intN types.
+
+	* gcc/testsuite/gcc.target/msp430/pr86662.c: New test.
+
+2018-08-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline
+	2018-08-20  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR target/87014
+	* config/i386/i386.md (eh_return): Always update EH return
+	address in word_mode.
+
+2018-08-17  John David Anglin  <danglin@gcc.gnu.org>
+
+	Backport from mainline
+	2018-08-11  John David Anglin  <danglin@gcc.gnu.org>
+
+	* config/pa/pa.md (UNSPEC_MEMORY_BARRIER): New unspec enum.
+	Update comment for atomic instructions.
+	(atomic_storeqi, atomic_storehi, atomic_storesi, atomic_storesf,
+	atomic_loaddf, atomic_loaddf_1, atomic_storedf, atomic_storedf_1):
+	Remove.
+	(atomic_loaddi): Revise fence expansion to only emit fence prior to
+	load for __ATOMIC_SEQ_CST model.
+	(atomic_loaddi_1): Remove float register target.
+	(atomic_storedi): Handle CONST_INT values.
+	(atomic_storedi_1): Remove float register source.  Add special case
+	for zero value.
+	(memory_barrier): New expander and insn.
+
+2018-08-13  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	Backport from mainline
+	2018-05-09  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	PR rtl-optimization/85645
+	* regrename.c (build_def_use): Also kill the chains that include the
+	destination of a REG_CFA_REGISTER note.
+
+	PR rtl-optimization/85645
+	*  regcprop.c (copyprop_hardreg_forward_1): Don't propagate into an
+	insn that has a REG_CFA_REGISTER note.
+
+2018-08-10  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	Backport from mainline
+	2018-06-19  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	PR target/86197
+	* config/rs6000/rs6000.md (rs6000_discover_homogeneous_aggregate): An
+	ieee128 argument takes up only one (vector) register, not two (floating
+	point) registers.
+
+2018-08-02  Jozef Lawrynowicz  <jozef.l@mittosystems.com>
+
+	Backport from mainline
+	2018-07-31  Jozef Lawrynowicz  <jozef.l@mittosystems.com>
+
+	PR middle-end/86705
+	* gcc/cfgexpand.c (set_parm_rtl): Use the alignment of Pmode when
+	MAX_SUPPORTED_STACK_ALIGNMENT would otherwise be exceeded by the
+	requested variable alignment.
+	(expand_one_ssa_partition): Likewise.
+	(expand_one_var): Likewise.
+
+2018-08-01  Richard Biener  <rguenther@suse.de>
+
+	PR bootstrap/86724
+	* graphite.h: Include isl/id.h and isl/space.h to allow build
+	with ISL 0.20.
+
+2018-07-29  John David Anglin  <danglin@gcc.gnu.org>
+
+	* config/pa/pa.c (pa_output_addr_vec): Align address table.
+	* config/pa/pa.h (JUMP_TABLES_IN_TEXT_SECTION): Revise comment.
+	* config/pa/pa32-linux.h (JUMP_TABLES_IN_TEXT_SECTION): Define.
+
+2018-07-17  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backport from mainline
+	PR target/84168
+	2017-09-28  Joseph Myers  <joseph@codesourcery.com>
+
+	* config/aarch64/aarch64.c (aarch64_elf_asm_constructor)
+	(aarch64_elf_asm_destructor): Pass SECTION_NOTYPE to get_section
+	when creating .init_array and .fini_array sections with priority
+	specified.
+
+2018-07-12  Richard Biener  <rguenther@suse.de>
+
+	PR target/84829
+	* config/gnu-user.h (GNU_USER_TARGET_NO_PTHREADS_LIB_SPEC):
+	Remove -mieee-fp handling.
+
+2018-07-10  Carl Love  <cel@us.ibm.com>
+
+	Backport from mainline
+	2017-09-07  Carl Love  <cel@us.ibm.com>
+
+	* config/rs6000/vsx.md (define_insn "*stxvl"): Add missing argument to
+	the sldi instruction.
+
+2018-06-29  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-01-10  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	* lex.c (search_line_fast): Remove illegal coercion of an
+	unaligned pointer value to vector pointer type and replace with
+	use of __builtin_vec_vsx_ld () built-in function, which operates
+	on unaligned pointer values.
+
+2018-06-27  David Edelsohn  <dje.gcc@gmail.com>
+
+	2018-06-19  Tony Reix  <tony.reix@atos.com>
+	    Damien Bergamini  <damien.bergamini@atos.com>
+	    David Edelsohn  <dje.gcc@gmail.com>
+
+	* collect2.c (static_obj): New variable.
+	(static_libs): New variable.
+	(is_in_list): Uncomment declaration.
+	(main): Track AIX libraries linked statically.
+	(is_in_list): Uncomment definition.
+	(scan_prog_file): Don't add AIX shared libraries initializer
+	to constructor list if linking statically.
+
+2018-06-26  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	Backported from mainline
+	2018-06-20  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	* config/rs6000/rs6000-c.c (altivec_overloaded_builtins): Change
+	behavior of vec_packsu (vector unsigned long long, vector unsigned
+	long long) to match behavior of vec_packs with same signature.
+
+2018-06-26  Robin Dapp  <rdapp@linux.vnet.ibm.com>
+
+	* config/s390/s390.h (enum processor_flags): Do not use
+	default tune parameter when -march was specified.
+
+2018-06-26  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/86314
+	* config/i386/i386.md (setcc + movzbl to xor + setcc peephole2s):
+	Check reg_overlap_mentioned_p in addition to reg_set_p with the same
+	operands.
+
+2018-06-25  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	Back port from trunk
+	2018-04-17  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	PR target/85424
+	* config/rs6000/rs6000.md (pack<mode>): Do not try handle a pack
+	where the inputs overlap with the output.
+
+2018-06-25  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/84786
+	* config/i386/sse.md (vshift_count): New mode attr.
+	(<shift_insn><mode>3<mask_name>): Use <vshift_count>N instead of vN
+	as last operand's constraint for VI2_AVX2_AVX512BW shifts.  Use YvN
+	instead of vN as last operand's constraint for VI48_AVX2 shifts.
+
+2018-06-23  Richard Sandiford  <richard.sandiford@linaro.org>
+
+	PR tree-optimization/85989
+	* gimple-ssa-backprop.c (backprop::m_visited_phis): New member
+	variable.
+	(backprop::intersect_uses): Check it when deciding whether this
+	is a backedge reference.
+	(backprop::process_block): Add each phi to m_visited_phis
+	after visiting it, then clear it at the end.
+
+2018-06-22  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-06-20  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/86231
+	* tree-vrp.c (union_ranges): For (  [  )  ] or (   )[   ] range and
+	anti-range don't overwrite *vr0min before using it to compute *vr0max.
+
+	2018-06-15  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/85878
+	* expr.c (expand_assignment): Only call store_expr for halves if the
+	mode is the same.
+
+	2018-06-14  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/85945
+	* lower-subreg.c (find_decomposable_subregs): Don't decompose float
+	subregs of multi-word pseudos unless the float mode has word size.
+
+	2018-06-04  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/86025
+	* tree.c (inchash::add_expr): Handle IDENTIFIER_NODE.
+
+	2018-05-06  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/85659
+	* cfgexpand.c (expand_asm_stmt): Don't create a temporary if
+	the type is addressable.  Don't force op into register if it has
+	BLKmode.
+
+	2018-05-01  Jakub Jelinek  <jakub@redhat.com>
+
+	PR web/85578
+	* doc/install.texi2html: Replace _002d with - and _002a with * in
+	generated html files using sed.
+
+	2018-04-27  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/85529
+	* tree-ssa-reassoc.c (optimize_range_tests_var_bound): Add FIRST_BB
+	argument.  Don't call get_nonzero_bits if opcode is ERROR_MARK_NODE,
+	rhs2 def stmt's bb is dominated by first_bb and it isn't an obvious
+	zero extension or masking of the MSB bit.
+	(optimize_range_tests): Add FIRST_BB argument, pass it through
+	to optimize_range_tests_var_bound.
+	(maybe_optimize_range_tests, reassociate_bb): Adjust
+	optimize_range_tests callers.
+
+	2018-04-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/85446
+	* match.pd ((intptr_t) x eq/ne CST to x eq/ne (typeof x) cst): Require
+	the integral and pointer types to have the same precision.
+
+	2018-04-18  David Malcolm  <dmalcolm@redhat.com>
+
+	PR jit/85384
+	* configure.ac (gcc-driver-name.h): Honor --with-gcc-major-version
+	by using gcc_base_ver to generate a gcc_driver_version, and use
+	it when generating GCC_DRIVER_NAME.
+	* configure: Regenerate.
+
+	2018-04-17  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/85431
+	* dse.c (record_store): Ignore zero width stores.
+
+	PR target/85430
+	* config/i386/i386.md (*ashlqi3_1_slp): Use alu1 type instead of alu.
+
+	2018-04-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/85300
+	* combine.c (subst): Handle subst of CONST_SCALAR_INT_P new_rtx also
+	into FLOAT and UNSIGNED_FLOAT like ZERO_EXTEND, return a CLOBBER if
+	simplify_unary_operation fails.
+
+	2018-04-07  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/85257
+	* fold-const.c (native_encode_vector): If not all elts could fit
+	and off is -1, return 0 rather than offset.
+	* tree-ssa-sccvn.c (vn_reference_lookup_3): Pass
+	(offset - offset2) / BITS_PER_UNIT as 4th argument to
+	native_encode_expr.  Verify len * BITS_PER_UNIT >= maxsizei.  Don't
+	adjust buffer in native_interpret_expr call.
+
+	2018-04-06  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/85252
+	* dwarf2out.c (rtl_for_decl_init): For STRING_CST initializer only
+	build CONST_STRING if TYPE_MAX_VALUE is non-NULL and is INTEGER_CST.
+
+	2018-04-03  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/85167
+	* shrink-wrap.c (move_insn_for_shrink_wrap): Don't set bb_uses and
+	bb_defs if *split_p, instead preinitialize it to NULL.
+
+	2018-03-28  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/85095
+	* config/i386/i386.md (*add<mode>3_carry_0, *addsi3_carry_zext_0,
+	*sub<mode>3_carry_0, *subsi3_carry_zext_0): New patterns.
+
+	2018-03-23  Jakub Jelinek  <jakub@redhat.com>
+
+	PR inline-asm/85022
+	* emit-rtl.c (init_emit_regs): Indicate that VOIDmode MEMs don't have
+	known size by default.
+
+	PR inline-asm/85034
+	* function.c (match_asm_constraints_1): Don't optimize if input
+	doesn't satisfy general_operand predicate for output's mode.
+
+	PR inline-asm/85022
+	* alias.c (write_dependence_p): Don't require for x_canonicalized
+	non-VOIDmode if x has VOIDmode.
+
+	2018-03-22  Jakub Jelinek  <jakub@redhat.com>
+
+	PR inline-asm/84941
+	* function.c (match_asm_constraints_1): Don't do the optimization
+	if input isn't a REG, SUBREG, MEM or constant.
+
+	PR sanitizer/85018
+	* dwarf2asm.c (dw2_output_indirect_constant_1): Set
+	DECL_INITIAL (decl) to decl at the end.
+	* varasm.c (use_blocks_for_decl_p): Revert the 2018-03-20 change,
+	adjust the comment.
+
+	2018-03-20  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/84875
+	* dce.c (delete_unmarked_insns): Don't remove frame related noop moves
+	holding REG_CFA_RESTORE notes, instead turn them into a USE.
+
+	PR c/84953
+	* builtins.c (fold_builtin_strpbrk): For strpbrk(x, "") use type
+	instead of TREE_TYPE (s1) for the return value.
+
+	PR target/84990
+	* dwarf2asm.c (dw2_output_indirect_constant_1): Temporarily turn off
+	flag_section_anchors.
+	* varasm.c (use_blocks_for_decl_p): Remove hack for
+	dw2_force_const_mem.
+
+	2018-03-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR sanitizer/78651
+	* dwarf2asm.c: Include fold-const.c.
+	(dw2_output_indirect_constant_1): Set DECL_INITIAL (decl) to ADDR_EXPR
+	of decl rather than decl itself.
+
+	2018-03-19  Maxim Ostapenko  <m.ostapenko@samsung.com>
+
+	PR sanitizer/78651
+	* dwarf2asm.c (dw2_output_indirect_constant_1): Disable ASan before
+	calling assemble_variable.
+
+	2018-03-16  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/84899
+	* postreload.c (reload_combine_recognize_pattern): Perform
+	INTVAL addition in unsigned HOST_WIDE_INT type to avoid UB and
+	truncate_int_for_mode the result for the destination's mode.
+
+	PR tree-optimization/84841
+	* tree-ssa-reassoc.c (INTEGER_CONST_TYPE): Change to 1 << 4 from
+	1 << 3.
+	(FLOAT_ONE_CONST_TYPE): Define.
+	(constant_type): Return FLOAT_ONE_CONST_TYPE for -1.0 and 1.0.
+	(sort_by_operand_rank): Put entries with higher constant_type last
+	rather than first to match comments.
+
+	2018-03-15  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/79085
+	* calls.c (expand_call): For TREE_ADDRESSABLE rettype ignore alignment
+	check and use address of target always.
+
+	PR target/84860
+	* optabs.c (emit_conditional_move): Pass address of cmode's copy
+	rather than address of cmode as last argument to prepare_cmp_insn.
+
+	2018-03-13  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/84834
+	* match.pd ((A & C) != 0 ? D : 0): Use INTEGER_CST@2 instead of
+	integer_pow2p@2 and test integer_pow2p in condition.
+	(A < 0 ? C : 0): Similarly for @1.
+
+	PR target/84827
+	* config/i386/i386.md (round<mode>2): For 387 fancy math, disable
+	pattern if -ftrapping-math -fno-fp-int-builtin-inexact.
+
+	PR target/84786
+	* config/i386/sse.md (sse2_loadhpd): Use Yv constraint rather than v
+	on the last operand.
+
+	2018-03-09  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/84772
+	* config/rs6000/rs6000.c (rs6000_gimplify_va_arg): Mark va_arg_tmp
+	temporary TREE_ADDRESSABLE before gimplification of BUILT_IN_MEMCPY.
+
+	PR c++/84767
+	* tree-inline.c (copy_tree_body_r): For INDIRECT_REF of a remapped
+	decl, use remap_type if we want to use the type.
+
+	2018-03-08  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/84739
+	* tree-tailcall.c (find_tail_calls): Check call arguments against
+	DECL_ARGUMENTS (current_function_decl) rather than
+	DECL_ARGUMENTS (func) when checking for tail recursion.
+
+	2018-03-05  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/84700
+	* combine.c (combine_simplify_rtx): Don't try to simplify if
+	if_then_else_cond returned non-NULL, but either true_rtx or false_rtx
+	are equal to x.
+
+2018-06-22  Andre Vieira  <andre.simoesdiasvieira@arm.com>
+
+	Backport from mainline
+	2018-06-05  Andre Vieira  <andre.simoesdiasvieira@arm.com>
+
+	* config/arm/arm_cmse.h (cmse_nsfptr_create): Change typeof to
+	__typeof__.
+	(cmse_check_pointed_object): Likewise.
+
+2018-06-22  Andre Vieira  <andre.simoesdiasvieira@arm.com>
+
+	Backport from mainline
+	2018-05-17  Jerome Lambourg  <lambourg@adacore.com>
+
+	* config/arm/arm_cmse.h (cmse_nsfptr_create, cmse_is_nsfptr): Remove
+	#include <stdint.h>.  Replace intptr_t with __INTPTR_TYPE__.
+
+2018-06-21  Sebastian Huber  <sebastian.huber@embedded-brains.de>
+
+	Backport from mainline
+	2018-06-15  Sebastian Huber  <sebastian.huber@embedded-brains.de>
+
+	* config.gcc (riscv*-*-elf* | riscv*-*-rtems*): Use custom
+	multilibs for *-*-rtems*.
+	* config/riscv/t-rtems: New file.
+
+2018-06-19  Max Filippov  <jcmvbkbc@gmail.com>
+
+	Backport from mainline
+	2018-06-19  Max Filippov  <jcmvbkbc@gmail.com>
+
+	* config/xtensa/xtensa.md (UNSPEC_FRAME_BLOCKAGE): New unspec
+	constant.
+	(allocate_stack, frame_blockage, *frame_blockage): New patterns.
+
+2018-06-19  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gimplify.c (gimplify_init_constructor): Really never clear for an
+	incomplete constructor if CONSTRUCTOR_NO_CLEARING is set.
+
+2018-06-18  Martin Sebor  <msebor@redhat.com>
+
+	PR middle-end/82063
+	* calls.c (alloc_max_size): Correct a logic error/typo.
+	Treat excessive arguments as infinite.  Warn for invalid arguments.
+	* doc/invoke.texi (-Walloc-size-larger-than): Update.
+
+2018-06-14  Sebastian Huber  <sebastian.huber@embedded-brains.de>
+
+	Backport from mainline
+	2018-06-14  Sebastian Huber  <sebastian.huber@embedded-brains.de>
+
+	* config/rtems.h (STDINT_LONG32): Define.
+
+2018-06-11  Peter Bergner  <bergner@vnet.ibm.com>
+
+	Backport from mainline
+	2018-06-08  Peter Bergner  <bergner@vnet.ibm.com>
+
+	PR target/85755
+	* config/rs6000/rs6000.c (mem_operand_gpr): Enable PRE_INC and PRE_DEC
+	addresses.
+
+2018-06-07  Peter Bergner  <bergner@vnet.ibm.com>
+
+	Backport from mainline
+	2018-06-06  Peter Bergner  <bergner@vnet.ibm.com>
+
+	PR target/63177
+	* /config/rs6000/rs6000.h (ASM_CPU_SPEC): Add support for -mpower9.
+	Don't handle -mcpu=power8 if -mpower9-vector is also used.
+
+2018-06-07  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2018-05-04  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/85588
+	* fold-const.c (negate_expr_p): Restrict negation of operand
+	zero of a division to when we know that can happen without
+	overflow.
+	(fold_negate_expr_1): Likewise.
+
+	2018-05-02  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/85567
+	* gimplify.c (gimplify_save_expr): When in SSA form allow
+	SAVE_EXPRs to compute to SSA vars.
+
+	2018-05-02  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/85597
+	* tree-vect-stmts.c (vectorizable_operation): For ternary SLP
+	do not use split vect_get_vec_defs call but call vect_get_slp_defs
+	directly.
+
+2018-06-05  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	Backport from mainline
+	2018-06-05  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	* config/s390/s390-builtin-types.def: Add void function type.
+	* config/s390/s390-builtins.def: Use the function type for the
+	tbeginc builtin.
+
+2018-06-01  Bill Schmidt  <wschmidt@linux.ibm.com>
+
+	PR tree-optimization/85712
+	Backport from mainline:
+	2018-05-23  Bill Schmidt  <wschmidt@linux.ibm.com>
+
+	PR tree-optimization/85712
+	* gimple-ssa-strength-reduction.c (struct slsr_cand_d): Add
+	first_interp field.
+	(alloc_cand_and_find_basis): Initialize first_interp field.
+	(slsr_process_mul): Modify first_interp field.
+	(slsr_process_add): Likewise.
+	(slsr_process_cast): Modify first_interp field for each new
+	interpretation.
+	(slsr_process_copy): Likewise.
+	(dump_candidate): Dump first_interp field.
+	(replace_mult_candidate): Process all interpretations, not just
+	subsequent ones.
+	(replace_rhs_if_not_dup): Likewise.
+	(replace_one_candidate): Likewise.
+
+	Backport from mainline:
+	2018-05-25  Bill Schmidt  <wschmidt@linux.ibm.com>
+
+	PR tree-optimization/85712
+	* gimple-ssa-strength-reduction.c (replace_one_candidate): Skip if
+	this candidate has already been replaced in-situ by a copy.
+
+2018-05-24  Uros Bizjak  <ubizjak@gmail.com>
+
+	* config/i386/sse.md (cvtusi2<ssescalarmodesuffix>64<round_name>):
+	Add {q} suffix to insn mnemonic.
+
+2018-05-24  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/85903
+	* config/i386/sse.md (movdi_to_sse): Do not generate pseudo
+	when memory input operand is handled.
+
+2018-05-21  Pat Haugen  <pthaugen@us.ibm.com>
+
+	Backport from mainline
+	2018-05-17  Pat Haugen  <pthaugen@us.ibm.com>
+		    Segher Boessenkool  <segher@kernel.crashing.org>
+
+	PR target/85698
+	* config/rs6000/rs6000.c (rs6000_output_move_128bit): Check
+	dest operand.
+
+2018-05-17  Martin Jambor  <mjambor@suse.cz>
+
+	Backport from mainline
+	2018-05-11  Martin Jambor  <mjambor@suse.cz>
+
+	PR ipa/85655
+	* ipa-cp.c (intersect_with_plats): Check that the lattice contains
+	single const.
+
+2018-05-01  Tom de Vries  <tom@codesourcery.com>
+
+	backport from trunk:
+	2018-04-16  Cesar Philippidis  <cesar@codesourcery.com>
+		    Tom de Vries  <tom@codesourcery.com>
+
+	PR middle-end/84955
+	* omp-expand.c (expand_oacc_for): Add dummy false branch for
+	tiled basic blocks without omp continue statements.
+
+2018-04-26  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2018-04-09  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/85284
+	* tree-ssa-loop-niter.c (number_of_iterations_exit_assumptions):
+	Only use the niter constraining form of simple_iv when the exit
+	is always executed.
+
+	2018-04-06  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/85244
+	* tree-dfa.c (get_ref_base_and_extent): Reset seen_variable_array_ref
+	after seeing a component reference with an adjacent field.  Treat
+	refs to arrays at struct end of external decls similar to
+	refs to unconstrained commons.
+
+	2018-04-04  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/85168
+	* tree-ssa-sccvn.c (vn_reference_maybe_forwprop_address): Avoid
+	propagating abnormals.
+
+2018-04-24  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-04-17  Martin Liska  <mliska@suse.cz>
+
+	PR lto/85405
+	* ipa-devirt.c (odr_types_equivalent_p): Remove trailing
+	in message, remote space in between '_G' and '('.
+
+2018-04-24  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-04-17  Jan Hubicka  <jh@suse.cz>
+
+	PR lto/85405
+	* ipa-devirt.c (odr_types_equivalent_p): Handle bit fields.
+
+2018-04-24  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-03-28  Jakub Jelinek  <jakub@redhat.com>
+		    Martin Liska  <mliska@suse.cz>
+
+	PR sanitizer/85081
+	* gimplify.c (asan_poison_variable): Don't do the check for
+	gimplify_omp_ctxp here.
+	(gimplify_decl_expr): Do it here.
+	(gimplify_target_expr): Likewise.
+
+2018-04-24  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-03-21  Martin Liska  <mliska@suse.cz>
+
+	PR ipa/84963
+	* ipa-icf.c (sem_item_optimizer::fixup_points_to_sets): Remove
+	not intended return statement.
+
+2018-04-24  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-03-13  Martin Liska  <mliska@suse.cz>
+
+	PR ipa/84658.
+	* (sem_item_optimizer::sem_item_optimizer): Initialize new
+	vector.
+	(sem_item_optimizer::~sem_item_optimizer): Release it.
+	(sem_item_optimizer::merge_classes): Register variable aliases.
+	(sem_item_optimizer::fixup_pt_set): New function.
+	(sem_item_optimizer::fixup_points_to_sets): Likewise.
+	* ipa-icf.h: Declare new variables and functions.
+
+2018-04-23  Aaron Sawdey  <acsawdey@linux.ibm.com>
+
+	Backport from mainline
+	2018-04-16  Aaron Sawdey  <acsawdey@linux.ibm.com>
+
+	PR target/83660
+	* config/rs6000/rs6000-c.c (altivec_resolve_overloaded_builtin): Mark
+	vec_extract expression as having side effects to make sure it gets
+	a cleanup point.
+
+2018-04-23  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR middle-end/85496
+	* expr.c (store_field): In the bitfield case, if the value comes from
+	a function call and is returned in registers by means of a PARALLEL,
+	do not change the mode of the temporary unless BLKmode and VOIDmode.
+
+2018-04-20  Peter Bergner  <bergner@vnet.ibm.com>
+
+	Backport from mainline
+	2018-03-09  Peter Bergner  <bergner@vnet.ibm.com>
+
+	PR target/83969
+	* config/rs6000/rs6000.c (rs6000_offsettable_memref_p): New prototype.
+	Add strict argument and use it.
+	(rs6000_split_multireg_move): Update for new strict argument.
+	(mem_operand_gpr): Disallow all non-offsettable addresses.
+	* config/rs6000/rs6000.md (*movdi_internal64): Use YZ constraint.
+
+2018-04-18  Thomas Preud'homme  <thomas.preudhomme@arm.com>
+
+	Backport from mainline
+	2018-04-11  Thomas Preud'homme  <thomas.preudhomme@arm.com>
+
+	PR target/85261
+	* config/arm/arm-builtins.c (arm_expand_builtin): Force input operand
+	into register.
+
+2018-04-12  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2018-04-12  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	* config/s390/s390.c (s390_output_indirect_thunk_function): Check
+	also for flag_dwarf2_cfi_asm.
+
+2018-04-11  Uros Bizjak  <ubizjak@gmail.com>
+
+	* config/alpha/alpha.md (stack_probe_internal): Rename
+	from "probe_stack".  Update all callers.
+
+2018-04-11  Thomas Preud'homme  <thomas.preudhomme@arm.com>
+
+	Backport from mainline
+	2018-04-04  Thomas Preud'homme  <thomas.preudhomme@arm.com>
+
+	PR target/85203
+	* config/arm/arm-builtins.c (arm_expand_builtin): Change
+	expansion to perform a bitwise AND of the argument followed by a
+	boolean negation of the result.
+
+2018-04-10  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backport from mainline
+	2018-03-08  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	PR target/84748
+	* config/aarch64/aarch64.md (*compare_cstore<mode>_insn): Mark pattern
+	as clobbering CC_REGNUM.
+
+2018-04-06  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR target/85196
+	* config/sparc/sparc.c (sparc_expand_move): Deal with symbolic operands
+	based on LABEL_REF.  Remove useless assertion.
+	(pic_address_needs_scratch): Fix formatting.
+	(sparc_legitimize_pic_address): Minor tweaks.
+	(sparc_delegitimize_address): Adjust assertion accordingly.
+	* config/sparc/sparc.md (movsi_pic_label_ref): Change label_ref_operand
+	into symbolic_operand.
+	(movsi_high_pic_label_ref): Likewise.
+	(movsi_lo_sum_pic_label_ref): Likewise.
+	(movdi_pic_label_ref): Likewise.
+	(movdi_high_pic_label_ref): Likewise.
+	(movdi_lo_sum_pic_label_ref): Likewise.
+
+2018-04-06  Amaan Cheval  <amaan.cheval@gmail.com>
+
+	* config.gcc (x86_64-*-rtems*): Add rtems.h to tm_file for
+	custom LIB_SPEC setup.
+
+2018-04-05  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/85193
+	* config/i386/i386.md (define_attr "memory"): Handle rotate1 type.
+
+2018-04-04  Peter Bergner  <bergner@vnet.ibm.com>
+
+	Backport from mainline
+	2018-04-04  Peter Bergner  <bergner@vnet.ibm.com>
+
+	PR rtl-optimization/84878
+	* ddg.c (add_cross_iteration_register_deps): Use DF_REF_BB to determine
+	the basic block.  Assert the use reference is not artificial and that
+	it has an associated insn.
+
+2018-04-03  Uros Bizjak  <ubizjak@gmail.com>
+
+	* config/i386/i386.c (emit_i387_cw_initialization): Always use logic
+	instructions when changing rounding bits to preserve precision bits
+	in the x87 control word.
+
+2018-04-03  Cesar Philippidis  <cesar@codesourcery.com>
+
+	Backport from mainline
+	2018-03-27  Cesar Philippidis  <cesar@codesourcery.com>
+
+	PR target/85056
+	* config/nvptx/nvptx.c (nvptx_assemble_decl_begin): Add '[]' to
+	extern array declarations.
+
+2018-04-02  Peter Bergner  <bergner@vnet.ibm.com>
+
+	Backport from mainline
+	2018-03-28  Peter Bergner  <bergner@vnet.ibm.com>
+
+	PR target/84912
+	* config/rs6000/rs6000.h: Update copyright date.
+	(RS6000_BTM_POWERPC64): New define.
+	(RS6000_BTM_COMMON): Add RS6000_BTM_POWERPC64.
+	* config/rs6000/rs6000.c: Update copyright date.
+	(rs6000_builtin_mask_calculate): Add support for RS6000_BTM_POWERPC64.
+	(rs6000_invalid_builtin): Add handling for RS6000_BTM_POWERPC64
+	(rs6000_builtin_mask_names): Add RS6000_BTM_POWERPC64.
+	* config/rs6000/rs6000-builtin.def: Update copyright date.
+	(BU_P7_POWERPC64_MISC_2): New macro definition.
+	(DIVDE): Use it.
+	(DIVDEU): Likewise.
+
+	Backport from mainline
+	2018-03-28  Peter Bergner  <bergner@vnet.ibm.com>
+
+	PR target/84912
+	* config/rs6000/rs6000-builtin.def (DIVWEO): Delete macro expansion.
+	(DIVWEUO): Likewise.
+	(DIVDEO): Likewise.
+	(DIVDEUO): Likewise.
+	* config/rs6000/rs6000.c (builtin_function_type): Remove support for
+	DIVWEUO and DIVDEUO.
+	* config/rs6000/rs6000.md: Update copyright date.
+	(UNSPEC_DIVEO, UNSPEC_DIVEUO): Delete unspecs.
+	(UNSPEC_DIV_EXTEND): Remove deleted unspecs.
+	(div_extend): Likewise.
+	* doc/extend.texi: Update copyright date.
+	(__builtin_divweo): Remove documentation for deleted builtin function.
+	(__builtin_divweuo): Likewise.
+	(__builtin_divdeo): Likewise.
+	(__builtin_divdeuo): Likewise.
+
+2018-04-02  Peter Bergner  <bergner@vnet.ibm.com>
+
+	Backport from mainline
+	2018-03-30  Peter Bergner  <bergner@vnet.ibm.com>
+
+	PR target/80546
+	* config/rs6000/vsx.md (??r): New mode attribute.
+	(*vsx_mov<mode>_64bit): Use it.
+	(*vsx_mov<mode>_32bit): Likewise.
+
+2018-03-29  Sebastian Peryt  <sebastian.peryt@intel.com>
+
+	PR c++/84783
+	* config/i386/avx512vlintrin.h (_mm256_permutexvar_epi64)
+	(_mm256_permutexvar_epi32, _mm256_permutex_epi64): New intrinsics.
+
+2018-03-29  Sudakshina Das  <sudi.das@arm.com>
+
+	Backport from mainline
+	2018-03-22  Sudakshina Das  <sudi.das@arm.com>
+
+	PR target/84826
+	* config/arm/arm.h (machine_function): Add static_chain_stack_bytes.
+	* config/arm/arm.c (arm_compute_static_chain_stack_bytes): Avoid
+	re-computing once computed.
+	(arm_expand_prologue): Compute machine->static_chain_stack_bytes.
+	(arm_init_machine_status): Initialize
+	machine->static_chain_stack_bytes.
+
+2018-03-28  Sudakshina Das  <sudi.das@arm.com>
+
+	2018-03-19  Sudakshina Das  <sudi.das@arm.com>
+	PR target/81647
+
+	* config/aarch64/aarch64-simd.md (vec_cmp<mode><v_cmp_result>): Modify
+	instructions for UNLT, UNLE, UNGT, UNGE, UNEQ, UNORDERED and ORDERED.
+
+2018-03-28  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backport from mainline
+	2018-03-23  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	PR target/85026
+	* config/arm/arm.md (unaligned_loadhis): Remove first alternative.
+	Clean up attributes.
+
+2018-03-28  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	Backport from mainline
+	2018-03-08  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	PR target/82411
+	* config/rs6000/rs6000.c (rs6000_elf_in_small_data_p): Don't put
+	readonly data in sdata, if that is disabled.
+	* config/rs6000/sysv4.opt (mreadonly-in-sdata): New option.
+	* doc/invoke.texi (RS/6000 and PowerPC Options): Document
+	-mreadonly-in-sdata option.
+
+2018-03-27  Sudakshina Das  <sudi.das@arm.com>
+
+	Backport from mainline:
+	2018-03-20  Sudakshina Das  <sudi.das@arm.com>
+
+	PR target/82989
+	* config/arm/neon.md (ashldi3_neon): Update ?s for constraints
+	to favor GPR over NEON registers.
+	(<shift>di3_neon): Likewise.
+
+2018-03-27  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backport from mainline
+	2018-03-20  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	PR target/82518
+	* config/arm/arm.c (arm_array_mode_supported_p): Return false for
+	BYTES_BIG_ENDIAN.
+
+2018-03-23  Peter Bergner  <bergner@vnet.ibm.com>
+
+	Backport from mainline
+	2018-03-20  Peter Bergner  <bergner@vnet.ibm.com>
+
+	PR target/83789
+	* config/rs6000/altivec.md (altivec_lvx_<mode>_2op): Delete define_insn.
+	(altivec_lvx_<mode>_1op): Likewise.
+	(altivec_stvx_<mode>_2op): Likewise.
+	(altivec_stvx_<mode>_1op): Likewise.
+	(altivec_lvx_<VM2:mode>): New define_expand.
+	(altivec_stvx_<VM2:mode>): Likewise.
+	(altivec_lvx_<VM2:mode>_2op_<P:mptrsize>): New define_insn.
+	(altivec_lvx_<VM2:mode>_1op_<P:mptrsize>): Likewise.
+	(altivec_stvx_<VM2:mode>_2op_<P:mptrsize>): Likewise.
+	(altivec_stvx_<VM2:mode>_1op_<P:mptrsize>): Likewise.
+	* config/rs6000/rs6000.c (altivec_expand_lv_builtin): Likewise.
+	(altivec_expand_stv_builtin): Likewise.
+	(altivec_expand_builtin): Likewise.
+	* config/rs6000/vector.md: Likewise.
+
+2018-03-23  Carl Love  <cel@us.ibm.com>
+
+	Backport from mainline:
+	2018-03-14  Carl Love  <cel@us.ibm.com>
+
+	* config/rs6000/r6000.c (rtx_is_swappable_p): Add case UNSPEC_VPERMXOR.
+
+2018-03-22  Tom de Vries  <tom@codesourcery.com>
+
+	backport from trunk:
+	2018-03-22  Tom de Vries  <tom@codesourcery.com>
+
+	PR tree-optimization/84956
+	* tree-ssa-tail-merge.c (find_clusters_1): Skip bbs with
+	bb_has_abnormal_pred.
+
+2018-03-19  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline
+	2018-03-15  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR target/84574
+	* config/i386/i386.c (indirect_thunk_needed): Update comments.
+	(indirect_thunk_bnd_needed): Likewise.
+	(indirect_thunks_used): Likewise.
+	(indirect_thunks_bnd_used): Likewise.
+	(indirect_return_needed): New.
+	(indirect_return_bnd_needed): Likewise.
+	(output_indirect_thunk_function): Add a bool argument for
+	function return.
+	(output_indirect_thunk_function): Don't generate alias for
+	function return thunk.
+	(ix86_code_end): Call output_indirect_thunk_function to generate
+	function return thunks.
+	(ix86_output_function_return): Set indirect_return_bnd_needed
+	and indirect_return_needed instead of indirect_thunk_bnd_needed
+	and indirect_thunk_needed.
+
+2018-03-14  John David Anglin  <danglin@gcc.gnu.org>
+
+	PR target/83451
+	* config/pa/pa.c (pa_emit_move_sequence):  Always emit secondary reload
+	insn for floating-point loads and stores.
+
+2018-03-12  Jonathan Wakely  <jwakely@redhat.com>
+
+	* doc/invoke.texi (-mclflushopt): Fix spelling of option.
+
+2018-03-12  Richard Sandiford  <richard.sandiford@linaro.org>
+
+	PR tree-optimization/84485
+	* tree-vect-data-refs.c (vect_analyze_data_ref_dependence): Return
+	true for zero dependence distances if the step might be zero,
+	and if there is no metadata that guarantees correctness.
+	(vect_analyze_data_ref_access): Check safelen as well as
+	force_vectorize.
+
+2018-03-11  John David Anglin  <danglin@gcc.gnu.org>
+
+	Backport from mainline
+	2018-02-14  John David Anglin  <danglin@gcc.gnu.org>
+
+	PR target/83984
+	* config/pa/pa.md: Load address of PIC label using the linkage table
+	if the label is nonlocal.
+
+	Backport from mainline
+	2018-03-06  John David Anglin  <danglin@gcc.gnu.org>
+
+	* config/pa/pa.h (ASM_GENERATE_INTERNAL_LABEL): Revise to use
+	sprint_ul.
+	(ASM_OUTPUT_ADDR_VEC_ELT): Revise for above change.
+	(ASM_OUTPUT_ADDR_DIFF_ELT): Likewise.
+	* config/pa/pa64-hpux.h (ASM_GENERATE_INTERNAL_LABEL): Revise as above.
+
+2018-03-09  Kugan Vivekanandarajah  <kuganv@linaro.org>
+
+	Backport from mainline
+	2017-09-13  Kugan Vivekanandarajah  <kuganv@linaro.org>
+
+	* config/aarch64/aarch64.c (aarch64_override_options_after_change_1):
+	Disable pc relative literal load irrespective of
+	TARGET_FIX_ERR_A53_84341 for default.
+
+2018-03-06  Denis Chertykov  <chertykov@gmail.com>
+
+	Backport from mainline
+	2018-02-07  Georg-Johann Lay  <avr@gjlay.de>
+
+	PR target/84209
+	* config/avr/avr.h (GENERAL_REGNO_P, GENERAL_REG_P): New macros.
+	* config/avr/avr.md: Only post-reload split REG-REG moves if
+	either register is GENERAL_REG_P.
+
+2018-03-06  Carl Love  <cel@us.ibm.com>
+
+	Backport from mainline
+	2/16/18  commit 257748  Carl Love  <cel@us.ibm.com>
+
+	* config/rs6000/altivec.h: Remove vec_vextract4b and vec_vinsert4b.
+	* config/rs6000/rs6000-builtin.def: Remove macro expansion for
+	VINSERT4B_DI and VINSERT4B.
+	* config/rs6000/rs6000.c: Remove case statements for
+	P9V_BUILTIN_VINSERT4B, P9V_BUILTIN_VINSERT4B_DI,
+	and P9V_BUILTIN_VEC_VINSERT4B.
+	* config/rs6000/rs6000-c.c (altivec_expand_builtin): Remove entries for
+	P9V_BUILTIN_VEC_VEXTRACT4B and P9V_BUILTIN_VEC_VINSERT4B.
+	* config/rs6000/vsx.md:  Remove define_expand vinsert4b,
+	define_insn *vinsert4b_internal, define_insn "*vinsert4b_di_internal.
+	* doc/extend.texi: Remove vec_vextract4b, non ABI definitions for
+	vec_insert4b.
+
+2018-03-06  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-02-20  Martin Liska  <mliska@suse.cz>
+
+	PR c/84310
+	PR target/79747
+	* final.c (shorten_branches): Build align_tab array with one
+	more element.
+	* opts.c (finish_options): Add alignment option limit check.
+	(MAX_CODE_ALIGN): Likewise.
+	(MAX_CODE_ALIGN_VALUE): Likewise.
+	* doc/invoke.texi: Document maximum allowed option value for
+	all -falign-* options.
+
+2018-03-06  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-02-19  Martin Liska  <mliska@suse.cz>
+
+	PR other/80589
+	* doc/invoke.texi: Fix typo.
+	* params.def (PARAM_MAX_LOOP_HEADER_INSNS): Likewise.
+
+2018-03-06  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-02-05  Martin Liska  <mliska@suse.cz>
+
+	PR gcov-profile/84137
+	* doc/gcov.texi: Fix typo in documentation.
+
+2018-03-06  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-02-05  Martin Liska  <mliska@suse.cz>
+
+	PR gcov-profile/83879
+	* doc/gcov.texi: Document necessity of --dynamic-list-data when
+	using dlopen functionality.
+
+2018-03-06  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2017-12-19  Martin Liska  <mliska@suse.cz>
+
+	PR rtl-optimization/82675
+	* loop-unroll.c (unroll_loop_constant_iterations): Allocate one
+	more element in sbitmap.
+
+2018-03-06  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-03-05  Martin Liska  <mliska@suse.cz>
+
+	* ipa-utils.c (ipa_merge_profiles): Do not merge alias or
+	a function without profile.
+
+2018-03-06  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-02-21  Jan Hubicka  <hubicka@ucw.cz>
+
+	PR c/84229
+	* ipa-cp.c (determine_versionability): Do not version functions caling
+	va_arg_pack.
+
+2018-03-06  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-02-08  Jan Hubicka  <hubicka@ucw.cz>
+
+	PR ipa/81360
+	* cgraph.h (symtab_node::output_to_lto_symbol_table_p): Declare
+	* symtab.c: Include builtins.h
+	(symtab_node::output_to_lto_symbol_table_p): Move here
+	from lto-streamer-out.c:output_symbol_p.
+	* lto-streamer-out.c (write_symbol): Turn early exit to assert.
+	(output_symbol_p): Move all logic to symtab.c
+	(produce_symtab): Update.
+
+2018-03-06  Peter Bergner  <bergner@vnet.ibm.com>
+
+	Backport from mainline
+	2018-02-22  Vladimir Makarov  <vmakarov@redhat.com>
+
+	PR target/81572
+	* lra-int.h (LRA_UNKNOWN_ALT, LRA_NON_CLOBBERED_ALT): New macros.
+	* lra.c (lra_set_insn_recog_data, lra_update_insn_recog_data): Use
+	LRA_UNKNOWN_ALT.
+	* lra-constraints.c (curr_insn_transform): Set up
+	LRA_NON_CLOBBERED_ALT for moves processed on the fast path.  Use
+	LRA_UNKNOWN_ALT.
+	(remove_inheritance_pseudos): Use LRA_UNKNOWN_ALT.
+	* lra-eliminations.c (spill_pseudos): Ditto.
+	(process_insn_for_elimination): Ditto.
+	* lra-lives.c (reg_early_clobber_p): Use the new macros.
+	* lra-spills.c (spill_pseudos): Use LRA_UNKNOWN_ALT and
+	LRA_NON_CLOBBERED_ALT.
+
+2018-03-06  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2018-03-05  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/84486
+	* tree-ssa-pre.c (create_expression_by_pieces): Remove dead code.
+	When inserting a __builtin_assume_aligned call set the LHS
+	SSA name alignment info accordingly.
+
+	2018-02-28  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/84607
+	* genmatch.c (capture_info::walk_match): Do not mark
+	captured expressions without operands as expr_p given
+	they act more like predicates and should be subject to
+	"lost tail" side-effect preserving.
+
+2018-03-05  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/84524
+	* config/i386/sse.md (*<code><mode>3): Replace <mask_prefix3> with
+	orig,vex.
+	(*<plusminus_insn><mode>3): Likewise.  Remove <mask_operand3> uses.
+
+2018-03-03  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-03-02  Jakub Jelinek  <jakub@redhat.com>
+		    Richard Biener  <rguenther@suse.de>
+
+	PR ipa/84628
+	* expr.c (expand_expr_real_1) <case CALL_EXPR>: Don't emit diagnostics
+	for error or warning attributes if CALL_FROM_THUNK_P is set.
+	Formatting fixes.
+
+	2018-03-02  Jakub Jelinek  <jakub@redhat.com>
+
+	PR inline-asm/84625
+	* config/i386/i386.c (ix86_print_operand): Use conditional
+	output_operand_lossage instead of gcc_assert if CONST_VECTOR is not
+	zero vector.
+
+	2018-02-23  Jakub Jelinek  <jakub@redhat.com>
+
+	* ipa-prop.c (ipa_vr_ggc_hash_traits::hash): Hash p->min and
+	p->max as pointers rather than using iterative_hash_expr.
+
+	2017-11-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR bootstrap/82916
+	* gimple-ssa-store-merging.c
+	(pass_store_merging::terminate_all_aliasing_chains): For
+	gimple_store_p stmts also call refs_output_dependent_p.
+
+	2018-02-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/84444
+	* builtins.c (builtin_mathfn_code): Don't check if CALL_EXPR_FN (t)
+	is ADDR_EXPR.
+
+	2018-02-16  Jakub Jelinek  <jakub@redhat.com>
+
+	PR ipa/84425
+	* ipa-inline.c (inline_small_functions): Fix a typo.
+
+	2018-02-13  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/82210
+	* stor-layout.c (place_field): For variable length fields, adjust
+	offset_align afterwards not just based on the field's alignment,
+	but also on the size.
+
+	2018-02-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR sanitizer/83987
+	* omp-low.c (maybe_remove_omp_member_access_dummy_vars,
+	remove_member_access_dummy_vars): New functions.
+	(lower_omp_for, lower_omp_taskreg, lower_omp_target,
+	lower_omp_1, execute_lower_omp): Use them.
+
+	PR rtl-optimization/84308
+	* shrink-wrap.c (spread_components): Release todo vector.
+
+	2018-02-09  Jakub Jelinek  <jakub@redhat.com>
+
+	PR sanitizer/84285
+	* gcc.c (STATIC_LIBASAN_LIBS, STATIC_LIBTSAN_LIBS,
+	STATIC_LIBLSAN_LIBS, STATIC_LIBUBSAN_LIBS): Handle -static like
+	-static-lib*san.
+
+	2018-02-09  Marek Polacek  <polacek@redhat.com>
+		    Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/83659
+	* fold-const.c (fold_indirect_ref_1): Use VECTOR_TYPE_P macro.
+	Formatting fixes.  Verify first that tree_fits_shwi_p (op01).
+	Sync some changes from cxx_fold_indirect_ref.
+
+	2018-02-07  Jakub Jelinek  <jakub@redhat.com>
+
+	* tree-eh.c (operation_could_trap_helper_p): Ignore honor_trapv for
+	*DIV_EXPR and *MOD_EXPR.
+
+	2018-02-01  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/81661
+	PR tree-optimization/84117
+	* tree-eh.h (rewrite_to_non_trapping_overflow): Declare.
+	* tree-eh.c: Include gimplify.h.
+	(find_trapping_overflow, replace_trapping_overflow,
+	rewrite_to_non_trapping_overflow): New functions.
+	* tree-vect-loop.c: Include tree-eh.h.
+	(vect_get_loop_niters): Use rewrite_to_non_trapping_overflow.
+
+	2018-01-30  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/83986
+	* sched-deps.c (sched_analyze_insn): For frame related insns, add anti
+	dependence against last_pending_memory_flush in addition to
+	pending_jump_insns.
+
+	2018-01-27  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/84040
+	* sched-deps.c (sched_macro_fuse_insns): Return immediately if
+	!insn_set.
+
+	2018-01-24  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/83977
+	* tree-inline.c (tree_function_versioning): Remove "omp declare simd"
+	attributes from DECL_ATTRIBUTES (new_decl) without affecting
+	DECL_ATTRIBUTES (old_decl).
+
+	2018-01-20  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/83945
+	* tree-emutls.c: Include gimplify.h.
+	(lower_emutls_2): New function.
+	(lower_emutls_1): If ADDR_EXPR is a gimple invariant and walk_tree
+	with lower_emutls_2 callback finds some TLS decl in it, unshare_expr
+	it before further processing.
+
+	PR target/83930
+	* simplify-rtx.c (simplify_binary_operation_1) <case UMOD>: Use
+	UINTVAL (trueop1) instead of INTVAL (op1).
+
+	2018-01-09  Jakub Jelinek  <jakub@redhat.com>
+
+	PR preprocessor/83722
+	* gcc.c (try_generate_repro): Pass
+	&temp_stderr_files[RETRY_ICE_ATTEMPTS - 1] rather than
+	&temp_stdout_files[RETRY_ICE_ATTEMPTS - 1] as last argument to
+	do_report_bug.
+
+	2018-01-05  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/83605
+	* gimple-ssa-strength-reduction.c: Include tree-eh.h.
+	(find_candidates_dom_walker::before_dom_children): Ignore stmts that
+	can throw.
+
+2018-03-01  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline
+	2018-02-26  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR target/84039
+	* config/i386/constraints.md (Bs): Replace
+	ix86_indirect_branch_register with
+	TARGET_INDIRECT_BRANCH_REGISTER.
+	(Bw): Likewise.
+	* config/i386/i386.md (indirect_jump): Likewise.
+	(tablejump): Likewise.
+	(*sibcall_memory): Likewise.
+	(*sibcall_value_memory): Likewise.
+	Peepholes of indirect call and jump via memory: Likewise.
+	(*sibcall_GOT_32): Disallowed for TARGET_INDIRECT_BRANCH_REGISTER.
+	(*sibcall_value_GOT_32): Likewise.
+	* config/i386/predicates.md (indirect_branch_operand): Likewise.
+	(GOT_memory_operand): Likewise.
+	(call_insn_operand): Likewise.
+	(sibcall_insn_operand): Likewise.
+	(GOT32_symbol_operand): Likewise.
+	* config/i386/i386.h (TARGET_INDIRECT_BRANCH_REGISTER): New.
+
+2018-03-01  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline
+	2018-02-26  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* config/i386/i386.c (ix86_output_indirect_jmp): Update comments.
+
+	2018-02-26  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR target/84530
+	* config/i386/i386-protos.h (ix86_output_indirect_jmp): Remove
+	the bool argument.
+	(ix86_output_indirect_function_return): New prototype.
+	(ix86_split_simple_return_pop_internal): Likewise.
+	* config/i386/i386.c (indirect_return_via_cx): New.
+	(indirect_return_via_cx_bnd): Likewise.
+	(indirect_thunk_name): Handle return va CX_REG.
+	(output_indirect_thunk_function): Create alias for
+	__x86_return_thunk_[re]cx and __x86_return_thunk_[re]cx_bnd.
+	(ix86_output_indirect_jmp): Remove the bool argument.
+	(ix86_output_indirect_function_return): New function.
+	(ix86_split_simple_return_pop_internal): Likewise.
+	* config/i386/i386.md (*indirect_jump): Don't pass false
+	to ix86_output_indirect_jmp.
+	(*tablejump_1): Likewise.
+	(simple_return_pop_internal): Change it to define_insn_and_split.
+	Call ix86_split_simple_return_pop_internal to split it for
+	-mfunction-return=.
+	(simple_return_indirect_internal): Call
+	ix86_output_indirect_function_return instead of
+	ix86_output_indirect_jmp.
+
+2017-03-02  Thomas Schwinge  <thomas@codesourcery.com>
+
+	Backport from trunk r256891:
+	2018-01-19  Cesar Philippidis  <cesar@codesourcery.com>
+
+	PR target/83790
+	* config/nvptx/nvptx.c (output_init_frag): Don't use generic address
+	spaces for function labels.
+
+2018-02-26  Carl Love  <cel@us.ibm.com>
+
+	Backport from mainline: commit 257747 on 2018-02-16.
+
+	* config/rs6000/altivec.h: Add builtin names vec_extract4b
+	vec_insert4b.
+	* config/rs6000/rs6000-builtin.def: Add INSERT4B and EXTRACT4B
+	definitions.
+	* config/rs6000/rs6000-c.c: Add the definitions for
+	P9V_BUILTIN_VEC_EXTRACT4B and P9V_BUILTIN_VEC_INSERT4B.
+	* config/rs6000/rs6000.c (altivec_expand_builtin): Add
+	P9V_BUILTIN_EXTRACT4B and P9V_BUILTIN_INSERT4B case statements.
+	* config/rs6000/vsx.md: Add define_insn extract4b.  Add define_expand
+	definition for insert4b and define insn *insert3b_internal.
+	* doc/extend.texi: Add documentation for vec_extract4b.
+
+2018-02-26  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR rtl-optimization/83496
+	* reorg.c (steal_delay_list_from_target): Change REDUNDANT array from
+	booleans to RTXes.  Call fix_reg_dead_note on every non-null element.
+	(steal_delay_list_from_fallthrough): Call fix_reg_dead_note on a
+	redundant insn, if any.
+	(relax_delay_slots): Likewise.
+	(update_reg_unused_notes): Rename REDUNDANT_INSN to OTHER_INSN.
+
+2018-02-22  Sudakshina Das  <sudi.das@arm.com>
+	    Bin Cheng  <bin.cheng@arm.com>
+
+	Backport from mainline:
+	2017-12-14  Sudakshina Das  <sudi.das@arm.com>
+		    Bin Cheng  <bin.cheng@arm.com>
+
+	PR target/81228
+	* config/aarch64/aarch64.c (aarch64_select_cc_mode): Move LTGT to
+	CCFPEmode.
+	* config/aarch64/aarch64-simd.md (vec_cmp<mode><v_cmp_result>): Add
+	LTGT.
+
+2018-02-16  Jozef Lawrynowicz <jozefl.gcc@gmail.com>
+
+	PR target/79242
+	* machmode.def: Define a complex mode for PARTIAL_INT.
+	* genmodes.c (complex_class): Return MODE_COMPLEX_INT for
+	MODE_PARTIAL_INT.
+	* doc/rtl.texi: Document CSPImode.
+	* config/msp430/msp430.c (msp430_hard_regno_nregs): Add CPSImode
+	handling.
+	(msp430_hard_regno_nregs_with_padding): Likewise.
+
+2018-02-16  Sudakshina Das  <sudi.das@arm.com>
+
+	Backport from trunk
+	2018-01-10  Sudakshina Das  <sudi.das@arm.com>
+
+	PR target/82096
+	* expmed.c (emit_store_flag_force): Swap if const op0
+	and change VOIDmode to mode of op0.
+
+2018-02-16  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/84190
+	* tree-ssa.c (non_rewritable_mem_ref_base): Do not touch
+	volatile accesses if the decl isn't volatile.
+
+2018-02-15  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	Back port from trunk
+	2018-02-07  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	PR target/84154
+	* config/rs6000/rs6000.md (fix_trunc<SFDF:mode><QHI:mode>2):
+	Convert from define_expand to be define_insn_and_split.  Rework
+	float/double/_Float128 conversions to QI/HI/SImode to work with
+	both ISA 2.07 (power8) or ISA 3.0 (power9).  Fix regression where
+	conversions to QI/HImode types did a store and then a load to
+	truncate the value.  For conversions to VSX registers, don't split
+	the insn, instead emit the code directly.  Use the code iterator
+	any_fix to combine signed and unsigned conversions.
+	(fix<uns>_trunc<SFDF:mode>si2_p8): Likewise.
+	(fixuns_trunc<SFDF:mode><QHI:mode>2): Likewise.
+	(fix_trunc<IEEE128:mode><QHI:mode>2): Likewise.
+	(fix<uns>_trunc<SFDF:mode><QHI:mode>2): Likewise.
+	(fix_<mode>di2_hw): Likewise.
+	(fixuns_<mode>di2_hw): Likewise.
+	(fix_<mode>si2_hw): Likewise.
+	(fixuns_<mode>si2_hw): Likewise.
+	(fix<uns>_<IEEE128:mode><SDI:mode>2_hw): Likewise.
+	(fix<uns>_trunc<IEEE128:mode><QHI:mode>2): Likewise.
+	(fctiw<u>z_<mode>_smallint): Rename fctiw<u>z_<mode>_smallint to
+	fix<uns>_trunc<SFDF:mode>si2_p8.
+	(fix_trunc<SFDF:mode><QHI:mode>2_internal): Delete, no longer
+	used.
+	(fixuns_trunc<SFDF:mode><QHI:mode>2_internal): Likewise.
+	(fix<uns>_<mode>_mem): Likewise.
+	(fctiw<u>z_<mode>_mem): Likewise.
+	(fix<uns>_<mode>_mem): Likewise.
+	(fix<uns>_trunc<SFDF:mode><QHSI:mode>2_mem): On ISA 3.0, prevent
+	the register allocator from doing a direct move to the GPRs to do
+	a store, and instead use the ISA 3.0 store byte/half-word from
+	vector register instruction.  For IEEE 128-bit floating point,
+	also optimize stores of 32-bit ints.
+	(fix<uns>_trunc<IEEE128:mode><QHSI:mode>2_mem): Likewise.
+
+2018-02-15  Aaron Sawdey  <acsawdey@linux.vnet.ibm.com>
+
+	Back port from mainline
+	2018-01-30  Aaron Sawdey  <acsawdey@linux.vnet.ibm.com>
+
+	PR target/83758
+	* config/rs6000/rs6000.c (rs6000_internal_arg_pointer): Only return
+	a reg rtx.
+
+2018-02-14  Peter Bergner  <bergner@vnet.ibm.com>
+
+	Back port from mainline
+	2018-02-13  Peter Bergner  <bergner@vnet.ibm.com>
+
+	PR target/84279
+	* config/rs6000/rs6000.c (mem_operand_gpr): Disallow altivec addresses.
+
+2018-02-14  Martin Jambor  <mjambor@suse.cz>
+
+	PR c++/83990
+	* ipa-prop.c (ipa_modify_call_arguments): Use location of call
+	statements, also set location of a load to a temporary.
+
+2018-02-10  John David Anglin  <danglin@gcc.gnu.org>
+
+	* config/pa/pa.c (hppa_profile_hook): Mark SYMBOL_REF for _mcount as
+	function label.
+
+	Backport from mainline
+	2018-02-01  Aldy Hernandez  <aldyh@redhat.com>
+
+	PR target/84089
+	* config/pa/predicates.md (base14_operand): Handle VOIDmode.
+
+2018-02-09  Martin Jambor  <mjambor@suse.cz>
+
+	Backport from mainline
+	2018-02-08  Martin Jambor  <mjambor@suse.cz>
+
+	* hsa-gen.c (get_symbol_for_decl): Set program allocation for
+	static local variables.
+
+2018-02-09  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2018-02-09  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	PR target/PR84295
+	* config/s390/s390.c (s390_set_current_function): Invoke
+	s390_indirect_branch_settings also if fndecl didn't change.
+
+2018-02-08  Iain Sandoe  <iain@codesourcery.com>
+
+	PR target/84113
+	* config/rs6000/altivec.md (*restore_world): Remove LR use.
+	* config/rs6000/predicates.md (restore_world_operation): Adjust op
+	count, remove one USE.
+
+2018-02-08  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2018-02-08  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	* config/s390/s390-opts.h (enum indirect_branch): Define.
+	* config/s390/s390-protos.h (s390_return_addr_from_memory)
+	(s390_indirect_branch_via_thunk)
+	(s390_indirect_branch_via_inline_thunk): Add function prototypes.
+	(enum s390_indirect_branch_type): Define.
+	* config/s390/s390.c (struct s390_frame_layout, struct
+	machine_function): Remove.
+	(indirect_branch_prez10thunk_mask, indirect_branch_z10thunk_mask)
+	(indirect_branch_table_label_no, indirect_branch_table_name):
+	Define variables.
+	(INDIRECT_BRANCH_NUM_OPTIONS): Define macro.
+	(enum s390_indirect_branch_option): Define.
+	(s390_return_addr_from_memory): New function.
+	(s390_handle_string_attribute): New function.
+	(s390_attribute_table): Add new attribute handler.
+	(s390_execute_label): Handle UNSPEC_EXECUTE_JUMP patterns.
+	(s390_indirect_branch_via_thunk): New function.
+	(s390_indirect_branch_via_inline_thunk): New function.
+	(s390_function_ok_for_sibcall): When jumping via thunk disallow
+	sibling call optimization for non z10 compiles.
+	(s390_emit_call): Force indirect branch target to be a single
+	register.  Add r1 clobber for non-z10 compiles.
+	(s390_emit_epilogue): Emit return jump via return_use expander.
+	(s390_reorg): Handle JUMP_INSNs as execute targets.
+	(s390_option_override_internal): Perform validity checks for the
+	new command line options.
+	(s390_indirect_branch_attrvalue): New function.
+	(s390_indirect_branch_settings): New function.
+	(s390_set_current_function): Invoke s390_indirect_branch_settings.
+	(s390_output_indirect_thunk_function):  New function.
+	(s390_code_end): Implement target hook.
+	(s390_case_values_threshold): Implement target hook.
+	(TARGET_ASM_CODE_END, TARGET_CASE_VALUES_THRESHOLD): Define target
+	macros.
+	* config/s390/s390.h (struct s390_frame_layout)
+	(struct	machine_function): Move here from s390.c.
+	(TARGET_INDIRECT_BRANCH_NOBP_RET)
+	(TARGET_INDIRECT_BRANCH_NOBP_JUMP)
+	(TARGET_INDIRECT_BRANCH_NOBP_JUMP_THUNK)
+	(TARGET_INDIRECT_BRANCH_NOBP_JUMP_INLINE_THUNK)
+	(TARGET_INDIRECT_BRANCH_NOBP_CALL)
+	(TARGET_DEFAULT_INDIRECT_BRANCH_TABLE)
+	(TARGET_INDIRECT_BRANCH_THUNK_NAME_EXRL)
+	(TARGET_INDIRECT_BRANCH_THUNK_NAME_EX)
+	(TARGET_INDIRECT_BRANCH_TABLE): Define macros.
+	* config/s390/s390.md (UNSPEC_EXECUTE_JUMP)
+	(INDIRECT_BRANCH_THUNK_REGNUM): Define constants.
+	(mnemonic attribute): Add values which aren't recognized
+	automatically.
+	("*cjump_long", "*icjump_long", "*basr", "*basr_r"): Disable
+	pattern for branch conversion.  Fix mnemonic attribute.
+	("*c<code>", "*sibcall_br", "*sibcall_value_br", "*return"): Emit
+	indirect branch via thunk if requested.
+	("indirect_jump", "<code>"): Expand patterns for branch conversion.
+	("*indirect_jump"): Disable for branch conversion using out of
+	line thunks.
+	("indirect_jump_via_thunk<mode>_z10")
+	("indirect_jump_via_thunk<mode>")
+	("indirect_jump_via_inlinethunk<mode>_z10")
+	("indirect_jump_via_inlinethunk<mode>", "*casesi_jump")
+	("casesi_jump_via_thunk<mode>_z10", "casesi_jump_via_thunk<mode>")
+	("casesi_jump_via_inlinethunk<mode>_z10")
+	("casesi_jump_via_inlinethunk<mode>", "*basr_via_thunk<mode>_z10")
+	("*basr_via_thunk<mode>", "*basr_r_via_thunk_z10")
+	("*basr_r_via_thunk", "return<mode>_prez10"): New pattern.
+	("*indirect2_jump"): Disable for branch conversion.
+	("casesi_jump"): Turn into expander and expand patterns for branch
+	conversion.
+	("return_use"): New expander.
+	("*return"): Emit return via thunk and rename it to ...
+	("*return<mode>"): ... this one.
+	* config/s390/s390.opt: Add new options and and enum for the
+	option values.
+
+2018-02-08  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/84233
+	* tree-ssa-phiprop.c (propagate_with_phi): Use separate
+	changed flag instead of boguously re-using phi_inserted.
+
+2018-02-07  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2018-02-06  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	* config/rs6000/rs6000.c (rs6000_option_override_internal):
+	Display warning message for -mno-speculate-indirect-jumps.
+
+2018-02-05  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	Backport from mainline
+	2018-01-30  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	PR bootstrap/84017
+	* configure.ac (gcc_cv_as_shf_merge): Disable on Solaris 10/x86.
+	* configure: Regenerate.
+
+2018-02-05  Peter Bergner  <bergner@vnet.ibm.com>
+
+	Back port from mainline
+	2018-02-01  Peter Bergner  <bergner@vnet.ibm.com>
+
+	PR target/56010
+	PR target/83743
+	* config/rs6000/driver-rs6000.c: #include "diagnostic.h".
+	#include "opts.h".
+	(rs6000_supported_cpu_names): New static variable.
+	(linux_cpu_translation_table): Likewise.
+	(elf_platform) <cpu>: Define new static variable and use it.
+	Translate kernel AT_PLATFORM name to canonical name if needed.
+	Error if platform name is unknown.
+
+2018-02-02  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline
+	2018-02-02  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* config/i386/i386.c (ix86_output_function_return): Pass
+	INVALID_REGNUM, instead of -1, as invalid register number to
+	indirect_thunk_name and output_indirect_thunk.
+
+2018-02-01  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline
+	2018-01-31  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR rtl-optimization/84123
+	* combine.c (change_zero_ext): Check if hard register satisfies
+	can_change_dest_mode before calling gen_lowpart_SUBREG.
+
+2018-02-01  Renlin Li  <renlin.li@arm.com>
+
+	Backport from mainline
+	2018-02-01  Renlin Li  <renlin.li@arm.com>
+
+	PR target/83370
+	* config/aarch64/aarch64.c (aarch64_class_max_nregs): Handle
+	TAILCALL_ADDR_REGS.
+	(aarch64_register_move_cost): Likewise.
+	* config/aarch64/aarch64.h (reg_class): Rename CALLER_SAVE_REGS to
+	TAILCALL_ADDR_REGS.
+	(REG_CLASS_NAMES): Likewise.
+	(REG_CLASS_CONTENTS): Rename CALLER_SAVE_REGS to
+	TAILCALL_ADDR_REGS. Remove IP registers.
+	* config/aarch64/aarch64.md (Ucs): Update register constraint.
+
+2018-02-01  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2017-11-02  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/82795
+	* tree-if-conv.c (predicate_mem_writes): Remove bogus assert.
+
+2018-01-31  Richard Biener <rguenther@suse.de>
+	    Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	Backport from mainline
+	2018-01-29  Richard Biener <rguenther@suse.de>
+		    Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	PR bootstrap/80867
+	* tree-vect-stmts.c (vectorizable_call): Don't call
+	targetm.vectorize_builtin_md_vectorized_function if callee is
+	NULL.
+
+2018-01-31  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR rtl-optimization/84071
+	* doc/tm.texi.in (WORD_REGISTER_OPERATIONS): Add explicit case.
+	* doc/tm.texi: Regenerate.
+
+2018-01-31  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR rtl-optimization/84071
+	* combine.c (record_dead_and_set_regs_1): Record the source unmodified
+	for a paradoxical SUBREG on a WORD_REGISTER_OPERATIONS target.
+
+2018-01-29  Joseph Myers  <joseph@codesourcery.com>
+
+	Backport from mainline
+	2018-01-24  Joseph Myers  <joseph@codesourcery.com>
+
+	PR target/68467
+	* config/m68k/m68k.c (m68k_promote_function_mode): New function.
+	(TARGET_PROMOTE_FUNCTION_MODE): New macro.
+
+2018-01-29  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline
+	2018-01-26  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/81763
+	* config/i386/i386.md (*andndi3_doubleword): Add earlyclobber
+	to (=&r,r,rm) alternative. Add (=r,0,rm) and (=r,r,0) alternatives.
+
+2018-01-29  Alan Modra  <amodra@gmail.com>
+
+	Backport from mainline
+	2018-01-26  Alan Modra  <amodra@gmail.com>
+	PR target/84033
+	* config/rs6000/rs6000.c (rtx_is_swappable_p): Exclude
+	UNSPEC_VBPERMQ.
+
+2018-01-27  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline
+	2018-01-27  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* doc/invoke.texi: Replace -mfunction-return==@var{choice} with
+	-mfunction-return=@var{choice}.
+
+2018-01-27  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline
+	2018-01-23  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR target/83905
+	* config/i386/i386.c (ix86_expand_prologue): Use cost reference
+	of struct ix86_frame.
+	(ix86_expand_epilogue): Likewise.  Add a local variable for
+	the reg_save_offset field in struct ix86_frame.
+
+2018-01-26  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/83985
+	* dce.c (deletable_insn_p): Return false for separate shrink wrapping
+	REG_CFA_RESTORE insns.
+	(delete_unmarked_insns): Don't ignore separate shrink wrapping
+	REG_CFA_RESTORE insns here.
+
+2018-01-25  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline
+	2018-01-17  Uros Bizjak  <ubizjak@gmail.com>
+
+	* config/i386/i386.c (indirect_thunk_name): Declare regno
+	as unsigned int.  Compare regno with INVALID_REGNUM.
+	(output_indirect_thunk): Ditto.
+	(output_indirect_thunk_function): Ditto.
+	(ix86_code_end): Declare regno as unsigned int.  Use INVALID_REGNUM
+	in the call to output_indirect_thunk_function.
+
+2018-01-25  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	Back port from trunk
+	2018-01-22  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	PR target/83862
+	* config/rs6000/rs6000-protos.h (rs6000_split_signbit): Delete,
+	no longer used.
+	* config/rs6000/rs6000.c (rs6000_split_signbit): Likewise.
+	* config/rs6000/rs6000.md (signbit<mode>2): Change code for IEEE
+	128-bit to produce an UNSPEC move to get the double word with the
+	signbit and then a shift directly to do signbit.
+	(signbit<mode>2_dm): Replace old IEEE 128-bit signbit
+	implementation with a new version that just does either a direct
+	move or a regular move.  Move memory interface to separate insns.
+	Move insns so they are next to the expander.
+	(signbit<mode>2_dm_mem_be): New combiner insns to combine load
+	with signbit move.  Split big and little endian case.
+	(signbit<mode>2_dm_mem_le): Likewise.
+	(signbit<mode>2_dm_<su>ext): Delete, no longer used.
+	(signbit<mode>2_dm2): Likewise.
+
+2018-01-25  Peter Bergner  <bergner@vnet.ibm.com>
+
+	Back port from mainline
+	2018-01-10  Peter Bergner  <bergner@vnet.ibm.com>
+
+	PR target/83399
+	* config/rs6000/rs6000.c (print_operand) <'y'>: Use
+	VECTOR_MEM_ALTIVEC_OR_VSX_P.
+	* config/rs6000/vsx.md (*vsx_le_perm_load_<mode> for VSX_D): Use
+	indexed_or_indirect_operand predicate.
+	(*vsx_le_perm_load_<mode> for VSX_W): Likewise.
+	(*vsx_le_perm_load_v8hi): Likewise.
+	(*vsx_le_perm_load_v16qi): Likewise.
+	(*vsx_le_perm_store_<mode> for VSX_D): Likewise.
+	(*vsx_le_perm_store_<mode> for VSX_W): Likewise.
+	(*vsx_le_perm_store_v8hi): Likewise.
+	(*vsx_le_perm_store_v16qi): Likewise.
+	(eight unnamed splitters): Likewise.
+
+2018-01-25  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2018-01-02  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	* config/rs6000/rs6000-p8swap.c (swap_feeds_both_load_and_store):
+	New function.
+	(rs6000_analyze_swaps): Mark a web unoptimizable if it contains a
+	swap associated with both a load and a store.
+
+2018-01-25  Richard Biener  <rguenther@suse.de>
+
+	* BASE-VER: Increment to 7.3.1.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
diff --git a/gcc/ada/ChangeLog b/gcc/ada/ChangeLog
index 29fea56a411..6722542b230 100644
--- a/gcc/ada/ChangeLog
+++ b/gcc/ada/ChangeLog
@@ -1,3 +1,231 @@
+2019-05-07  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	* gcc-interface/Makefile.in (install-gcc-specs): Use foreach.
+	Honor DESTDIR.
+
+2019-02-26  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR ada/81956
+	Backport from mainline
+	2017-09-06  Ed Schonberg  <schonberg@adacore.com>
+
+	* exp_ch6.adb (Expand_Call_Helper): Do not optimize calls to
+	null procedures when GNAT coverage is used, so that their (empty)
+	bodies are properly covered.
+
+	2017-09-06  Ed Schonberg  <schonberg@adacore.com>
+
+	* exp_ch6.adb (Expand_Call_Helper): Replace call to null
+	procedure by a single null statement, after evaluating the
+	actuals that require it.
+
+2019-02-23  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR ada/89349
+	Backport from mainline
+	2018-05-25  Arnaud Charlet  <charlet@adacore.com>
+
+	* osint.ads (Unknown_Attributes): No longer pretend this is a constant.
+	(No_File_Info_Cache): Initialize separately.
+	* osint.adb (No_File_Info_Cache): Update initializer.
+
+2019-02-08  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/trans.c (Loop_Statement_to_gnu): Replace tests on
+	individual flag_unswitch_loops and flag_tree_loop_vectorize switches
+	with test on global optimize switch.
+	(Raise_Error_to_gnu): Likewise.
+
+2019-02-07  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* s-linux-sparc.ads (ETIMEDOUT): Set to correct value.
+
+2019-02-06  Eric Botcazou  <ebotcazou@adacore.com>
+
+	Backport from mainline
+	2017-09-05  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/decl.c (annotate_value): Tidy up.
+	<INTEGER_CST>: Set TCODE instead of recursing.
+	<COMPONENT_REF>: Set TCODE instead of calling Create_Node manually.
+	<MULT_EXPR, PLUS_EXPR>: Fold conversions into inner operations.
+	<BIT_AND_EXPR>: Adjust.
+	<CALL_EXPR>: Do not fall through.
+
+2019-01-27  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/decl.c (array_type_has_nonaliased_component): Return
+	the same value for every dimension of a multidimensional array type.
+
+2019-01-26  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/trans.c (gnat_to_gnu) <N_Assignment_Statement>: Use
+	DECL_SIZE_UNIT instead of TYPE_SIZE_UNIT for the size to be assigned
+	by a call to memset if the LHS is a DECL.
+
+2019-01-26  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/trans.c (struct loop_info_d): Remove artificial field.
+	(Loop_Statement_to_gnu): Do not set it.
+
+2019-01-26  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/decl.c (annotate_value) <INTEGER_CST>: Use test on
+	the sign bit instead of on the sign of the value.
+	<PLUS_EXPR>: Turn addition of negative constant into subtraction.
+	<BIT_AND_EXPR>: Simplify.
+
+2018-12-24  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* adaint.c [__APPLE__] (__gnat_lwp_self): Ensure that the system
+	interface used is available on the target.
+
+2018-12-06  Release Manager
+
+	* GCC 7.4.0 released.
+
+2018-11-15  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/misc.c (gnat_init_gcc_eh): Do not override the switch
+	-fnon-call-exceptions passed on the command line in -gnatp mode.
+
+2018-11-13  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/misc.c (gnat_init_gcc_eh): Set -fnon-call-exceptions
+	for the runtime on platforms where System.Machine_Overflow is true.
+
+2018-11-08  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* fe.h (Suppress_Checks): Declare.
+	* gcc-interface/misc.c (gnat_init_gcc_eh): Set -fnon-call-exceptions
+	only if checks are not suppressed and -faggressive-loop-optimizations
+	only if they are.
+	* gcc-interface/trans.c (struct loop_info_d): Remove has_checks and
+	warned_aggressive_loop_optimizations fields.
+	(gigi): Do not clear warn_aggressive_loop_optimizations here.
+	(Raise_Error_to_gnu): Do not set has_checks.
+	(gnat_to_gnu) <N_Indexed_Component>: Remove support for aggressive
+	loop optimizations.
+
+2018-10-22  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/utils.c (unchecked_convert): Use local variables for
+	the biased and reverse SSO attributes of both types.
+	Further extend the processing of integral types in the presence of
+	reverse SSO to all scalar types.
+
+2018-10-22  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/trans.c (Pragma_to_gnu) <Pragma_Inspection_Point>: Use
+	a simple memory constraint in all cases.
+
+2018-09-13  Eric Botcazou  <ebotcazou@adacore.com>
+
+	Backport from mainline
+	2018-07-31  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* s-osinte-solaris.ads (upad64_t): New private type.
+	(mutex_t): Use it for 'lock' and 'data' components.
+	(cond_t): Likewise for 'data' and use single 'flags' component.
+
+2018-07-17  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/decl.c (choices_to_gnu): Rename parameters.  Deal with
+	an operand of Character type.  Factor out range generation to the end.
+	Check that the bounds are literals and convert them to the type of the
+	operand before building the ranges.
+	* gcc-interface/utils.c (make_dummy_type): Minor tweak.
+	(make_packable_type): Propagate TYPE_DEBUG_TYPE.
+	(maybe_pad_type): Likewise.
+
+2018-07-17  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Variable>: Deal with
+	more rvalues in the expression of a renaming.
+
+2018-06-12  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/ada-tree.h (TYPE_RETURN_BY_DIRECT_REF_P): Change from
+	using TYPE_LANG_FLAG_4 to using TYPE_LANG_FLAG_0.
+	(TYPE_ALIGN_OK): Move around.
+	(TYPE_PADDING_FOR_COMPONENT): Remove superfluous parentheses.
+	* gcc-interface/decl.c (change_qualified_type): Move to...
+	(gnat_to_gnu_entity): Adjust comment.
+	* gcc-interface/gigi.h (change_qualified_type): ...here; make inline.
+	(ceil_pow2): Use ceil_log2.
+	* gcc-interface/utils.c (finish_subprog_decl): Add couple of comments
+	and do not set TREE_SIDE_EFFECTS.
+	(handle_noreturn_attribute): Use change_qualified_type.
+
+2018-06-12  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Constant>: Do not get
+	the expression of a dispatch table that is not being defined.
+	<E_Record_Subtype>: Remove obsolete kludge.
+
+2018-06-12  Eric Botcazou  <ebotcazou@adacore.com>
+
+	Backpor from mainline
+	2018-06-02  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Constant>: If this is
+	not a definition, retrieve the expression only if it's a compile-time
+	known value if we are just annotating types.
+
+	* gcc-interface/utils.c (convert): Do not try to upcast properly for a
+	conversion between tagged types in type_annotate_only mode.
+
+2018-06-12  Eric Botcazou  <ebotcazou@adacore.com>
+
+	Backport from mainline
+	2018-06-11  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Array_Type>: Reuse the
+	existing fields of a dummy fat pointer type, if any.  Clear the
+	TYPE_DECL_SUPPRESS_DEBUG on the fat pointer type after completing it.
+
+2018-06-02  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/ada-tree.h (TYPE_PADDING_FOR_COMPONENT): New macro.
+	* gcc-interface/decl.c (gnat_to_gnu_component_type): Cache the padding
+	type built for an aliased component with variable size.
+
+2018-06-02  Eric Botcazou  <ebotcazou@adacore.com>
+
+	Backport from mainline
+	2018-05-31  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/trans.c (Call_to_gnu): If this is a function call and
+	there is no target, also create a temporary for the return value for
+	an allocator if the type is an unconstrained record type with default
+	discriminant.
+
+2018-04-12  Sebastian Huber  <sebastian.huber@embedded-brains.de>
+
+	Backport from mainline
+	2018-03-07  Sebastian Huber  <sebastian.huber@embedded-brains.de>
+
+	* gcc-interface/Makefile.in (OSCONS_CPP): Remove redundant
+	$(GNATLIBCFLAGS).
+	(OSCONS_EXTRACT): Add $(GNATLIBCFLAGS_FOR_C).
+
+2018-03-12  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR ada/82813
+	* gcc-interface/misc.c (gnat_post_options): Disable string overflow
+	warnings.
+
+2018-03-10  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/trans.c (node_has_volatile_full_access) <N_Identifier>:
+	Consider only entities for objects.
+
+2018-03-06  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/trans.c (convert_with_check): Fix typo in the condition
+	guarding the overflow check emitted for the upper bound of a floating-
+	point conversion.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
diff --git a/gcc/ada/adaint.c b/gcc/ada/adaint.c
index bff875a6822..0915a3ffc45 100644
--- a/gcc/ada/adaint.c
+++ b/gcc/ada/adaint.c
@@ -3174,9 +3174,13 @@ __gnat_lwp_self (void)
 #endif
 
 #if defined (__APPLE__)
-#include <mach/thread_info.h>
-#include <mach/mach_init.h>
-#include <mach/thread_act.h>
+# if __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ >= 1060
+#  include <mach/thread_info.h>
+#  include <mach/mach_init.h>
+#  include <mach/thread_act.h>
+# else
+#  include <pthread.h>
+# endif
 
 /* System-wide thread identifier.  Note it could be truncated on 32 bit
    hosts.
@@ -3184,6 +3188,7 @@ __gnat_lwp_self (void)
 void *
 __gnat_lwp_self (void)
 {
+#if __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ >= 1060
   thread_identifier_info_data_t data;
   mach_msg_type_number_t count = THREAD_IDENTIFIER_INFO_COUNT;
   kern_return_t kret;
@@ -3194,6 +3199,9 @@ __gnat_lwp_self (void)
     return (void *)(uintptr_t)data.thread_id;
   else
     return 0;
+#else
+  return (void *)pthread_mach_thread_np (pthread_self ());
+#endif
 }
 #endif
 
diff --git a/gcc/ada/exp_ch6.adb b/gcc/ada/exp_ch6.adb
index e9f13319ed5..1713581f3c5 100644
--- a/gcc/ada/exp_ch6.adb
+++ b/gcc/ada/exp_ch6.adb
@@ -3937,6 +3937,23 @@ package body Exp_Ch6 is
               Unchecked_Convert_To
                 (RTE (RE_Address), Relocate_Node (First_Actual (Call_Node))));
             return;
+
+         --  A call to a null procedure is replaced by a null statement, but we
+         --  are not allowed to ignore possible side effects of the call, so we
+         --  make sure that actuals are evaluated.
+         --  We also suppress this optimization for GNATCoverage.
+
+         elsif Is_Null_Procedure (Subp)
+           and then not Opt.Suppress_Control_Flow_Optimizations
+         then
+            Actual := First_Actual (Call_Node);
+            while Present (Actual) loop
+               Remove_Side_Effects (Actual);
+               Next_Actual (Actual);
+            end loop;
+
+            Rewrite (Call_Node, Make_Null_Statement (Loc));
+            return;
          end if;
 
          --  Handle inlining. No action needed if the subprogram is not inlined
diff --git a/gcc/ada/fe.h b/gcc/ada/fe.h
index 6d31ae1a565..d02b55fe441 100644
--- a/gcc/ada/fe.h
+++ b/gcc/ada/fe.h
@@ -177,6 +177,7 @@ extern Boolean In_Same_Source_Unit              (Node_Id, Node_Id);
 #define GNAT_Mode                      opt__gnat_mode
 #define List_Representation_Info       opt__list_representation_info
 #define No_Strict_Aliasing_CP          opt__no_strict_aliasing
+#define Suppress_Checks                opt__suppress_checks
 
 typedef enum {
   Front_End_SJLJ, Back_End_ZCX, Back_End_SJLJ
@@ -191,6 +192,7 @@ extern Boolean Generate_SCO_Instance_Table;
 extern Boolean GNAT_Mode;
 extern Int List_Representation_Info;
 extern Boolean No_Strict_Aliasing_CP;
+extern Boolean Suppress_Checks;
 
 #define ZCX_Exceptions            opt__zcx_exceptions
 #define SJLJ_Exceptions           opt__sjlj_exceptions
diff --git a/gcc/ada/gcc-interface/Makefile.in b/gcc/ada/gcc-interface/Makefile.in
index 7a570196a88..8110261b6dd 100644
--- a/gcc/ada/gcc-interface/Makefile.in
+++ b/gcc/ada/gcc-interface/Makefile.in
@@ -2660,9 +2660,8 @@ gnatlink-re: ../stamp-tools gnatmake-re
 install-gcc-specs:
 #	Install all the requested GCC spec files.
 
-	for f in $(GCC_SPEC_FILES); do \
-	    $(INSTALL_DATA_DATE) $(srcdir)/ada/$$f $(libsubdir)/; \
-	done
+	$(foreach f,$(GCC_SPEC_FILES), \
+	    $(INSTALL_DATA_DATE) $(srcdir)/ada/$(f) $(DESTDIR)$(libsubdir)/;)
 
 install-gnatlib: ../stamp-gnatlib-$(RTSDIR) install-gcc-specs
 	$(RMDIR) $(DESTDIR)$(ADA_RTL_OBJ_DIR)
@@ -2756,9 +2755,9 @@ OSCONS_CC=$(subst ./xgcc,../../xgcc,$(subst -B./, -B../../,$(GCC_FOR_TARGET)))
 # ada/types.h does not conflict with a same-named system header (VxWorks
 # has a <types.h> header).
 
-OSCONS_CPP=$(OSCONS_CC) $(GNATLIBCFLAGS) $(GNATLIBCFLAGS_FOR_C) -E -C \
+OSCONS_CPP=$(OSCONS_CC) $(GNATLIBCFLAGS_FOR_C) -E -C \
   -DTARGET=\"$(target)\" -iquote $(fsrcpfx)ada $(fsrcpfx)ada/s-oscons-tmplt.c > s-oscons-tmplt.i
-OSCONS_EXTRACT=$(OSCONS_CC) -S s-oscons-tmplt.i
+OSCONS_EXTRACT=$(OSCONS_CC) $(GNATLIBCFLAGS_FOR_C) -S s-oscons-tmplt.i
 
 # Note: if you need to build with a non-GNU compiler, you could adapt the
 # following definitions (written for VMS DEC-C)
diff --git a/gcc/ada/gcc-interface/ada-tree.h b/gcc/ada/gcc-interface/ada-tree.h
index a3d38b1b22e..852e2a5138b 100644
--- a/gcc/ada/gcc-interface/ada-tree.h
+++ b/gcc/ada/gcc-interface/ada-tree.h
@@ -6,7 +6,7 @@
  *                                                                          *
  *                              C Header File                               *
  *                                                                          *
- *          Copyright (C) 1992-2016, Free Software Foundation, Inc.         *
+ *          Copyright (C) 1992-2018, Free Software Foundation, Inc.         *
  *                                                                          *
  * GNAT is free software;  you can  redistribute it  and/or modify it under *
  * terms of the  GNU General Public License as published  by the Free Soft- *
@@ -83,6 +83,12 @@ do {							 \
   ((TREE_CODE (NODE) == INTEGER_TYPE || TREE_CODE (NODE) == ARRAY_TYPE) \
    && TYPE_PACKED_ARRAY_TYPE_P (NODE))
 
+/* For FUNCTION_TYPEs, nonzero if the function returns by direct reference,
+   i.e. the callee returns a pointer to a memory location it has allocated
+   and the caller only needs to dereference the pointer.  */
+#define TYPE_RETURN_BY_DIRECT_REF_P(NODE) \
+  TYPE_LANG_FLAG_0 (FUNCTION_TYPE_CHECK (NODE))
+
 /* For INTEGER_TYPE, nonzero if this is a modular type with a modulus that
    is not equal to two to the power of its mode's size.  */
 #define TYPE_MODULAR_P(NODE) TYPE_LANG_FLAG_1 (INTEGER_TYPE_CHECK (NODE))
@@ -152,12 +158,6 @@ do {							 \
 #define TYPE_CONVENTION_FORTRAN_P(NODE) \
   TYPE_LANG_FLAG_4 (ARRAY_TYPE_CHECK (NODE))
 
-/* For FUNCTION_TYPEs, nonzero if the function returns by direct reference,
-   i.e. the callee returns a pointer to a memory location it has allocated
-   and the caller only needs to dereference the pointer.  */
-#define TYPE_RETURN_BY_DIRECT_REF_P(NODE) \
-  TYPE_LANG_FLAG_4 (FUNCTION_TYPE_CHECK (NODE))
-
 /* For RECORD_TYPE, UNION_TYPE and ENUMERAL_TYPE, nonzero if this is a dummy
    type, made to correspond to a private or incomplete type.  */
 #define TYPE_DUMMY_P(NODE) \
@@ -186,6 +186,9 @@ do {							 \
 /* True for a dummy type if TYPE appears in a profile.  */
 #define TYPE_DUMMY_IN_PROFILE_P(NODE) TYPE_LANG_FLAG_6 (NODE)
 
+/* True if objects of this type are guaranteed to be properly aligned.  */
+#define TYPE_ALIGN_OK(NODE) TYPE_LANG_FLAG_7 (NODE)
+
 /* True for types that implement a packed array and for original packed array
    types.  */
 #define TYPE_IMPL_PACKED_ARRAY_P(NODE) \
@@ -199,9 +202,6 @@ do {							 \
    alignment value the type ought to have.  */
 #define TYPE_MAX_ALIGN(NODE) (TYPE_PRECISION (RECORD_OR_UNION_CHECK (NODE)))
 
-/* True if objects of tagged types are guaranteed to be properly aligned.  */
-#define TYPE_ALIGN_OK(NODE) TYPE_LANG_FLAG_7 (NODE)
-
 /* For an UNCONSTRAINED_ARRAY_TYPE, this is the record containing both the
    template and the object.
 
@@ -232,6 +232,11 @@ do {							 \
    refer to the routine gnat_to_gnu_entity.  */
 #define TYPE_CI_CO_LIST(NODE) TYPE_LANG_SLOT_1 (FUNCTION_TYPE_CHECK (NODE))
 
+/* For an ARRAY_TYPE with variable size, this is the padding type built for
+   the array type when it is itself the component type of another array.  */
+#define TYPE_PADDING_FOR_COMPONENT(NODE) \
+  TYPE_LANG_SLOT_1 (ARRAY_TYPE_CHECK (NODE))
+
 /* For a VECTOR_TYPE, this is the representative array type.  */
 #define TYPE_REPRESENTATIVE_ARRAY(NODE) \
   TYPE_LANG_SLOT_1 (VECTOR_TYPE_CHECK (NODE))
diff --git a/gcc/ada/gcc-interface/decl.c b/gcc/ada/gcc-interface/decl.c
index e226f256b47..ebc441ccc94 100644
--- a/gcc/ada/gcc-interface/decl.c
+++ b/gcc/ada/gcc-interface/decl.c
@@ -206,7 +206,6 @@ static tree gnat_to_gnu_component_type (Entity_Id, bool, bool);
 static tree gnat_to_gnu_subprog_type (Entity_Id, bool, bool, tree *);
 static tree gnat_to_gnu_field (Entity_Id, tree, int, bool, bool);
 static tree gnu_ext_name_for_subprog (Entity_Id, tree);
-static tree change_qualified_type (tree, int);
 static void set_nonaliased_component_on_array_type (tree);
 static void set_reverse_storage_order_on_array_type (tree);
 static bool same_discriminant_p (Entity_Id, Entity_Id);
@@ -592,17 +591,22 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)
       /* If we have a constant that we are not defining, get the expression it
 	 was defined to represent.  This is necessary to avoid generating dumb
 	 elaboration code in simple cases, but we may throw it away later if it
-	 is not a constant.  But do not retrieve it if it is an allocator since
-	 the designated type might still be dummy at this point.  */
+	 is not a constant.  But do not do it for dispatch tables because they
+	 are only referenced indirectly and we need to have a consistent view
+	 of the exported and of the imported declarations of the tables from
+	 external units for them to be properly merged in LTO mode.  Moreover
+	 simply do not retrieve the expression it if it is an allocator since
+	 the designated type might still be dummy at this point.  Note that we
+	 invoke gnat_to_gnu_external and not gnat_to_gnu because the expression
+	 may contain N_Expression_With_Actions nodes and thus declarations of
+	 objects from other units that we need to discard.  */
       if (!definition
 	  && !No_Initialization (Declaration_Node (gnat_entity))
-	  && Present (Expression (Declaration_Node (gnat_entity)))
-	  && Nkind (Expression (Declaration_Node (gnat_entity)))
-	     != N_Allocator)
-	  /* The expression may contain N_Expression_With_Actions nodes and
-	     thus object declarations from other units.  Discard them.  */
-	gnu_expr
-	  = gnat_to_gnu_external (Expression (Declaration_Node (gnat_entity)));
+	  && !Is_Dispatch_Table_Entity (gnat_entity)
+	  && Present (gnat_temp = Expression (Declaration_Node (gnat_entity)))
+	  && Nkind (gnat_temp) != N_Allocator
+	  && (!type_annotate_only || Compile_Time_Known_Value (gnat_temp)))
+	gnu_expr = gnat_to_gnu_external (gnat_temp);
 
       /* ... fall through ... */
 
@@ -968,8 +972,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)
 	       function call is a constant object.  Therefore, it can be the
 	       inner object of a constant renaming and the renaming must be
 	       fully instantiated, i.e. it cannot be a reference to (part of)
-	       an existing object.  And treat other rvalues (addresses, null
-	       expressions, constructors and literals) the same way.  */
+	       an existing object.  And treat other rvalues the same way.  */
 	    tree inner = gnu_expr;
 	    while (handled_component_p (inner) || CONVERT_EXPR_P (inner))
 	      inner = TREE_OPERAND (inner, 0);
@@ -980,11 +983,11 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)
 	      inner = TREE_OPERAND (inner, 1);
 	    if ((TREE_CODE (inner) == CALL_EXPR
 		 && !call_is_atomic_load (inner))
-		|| TREE_CODE (inner) == ADDR_EXPR
-		|| TREE_CODE (inner) == NULL_EXPR
-		|| TREE_CODE (inner) == PLUS_EXPR
 		|| TREE_CODE (inner) == CONSTRUCTOR
 		|| CONSTANT_CLASS_P (inner)
+		|| COMPARISON_CLASS_P (inner)
+		|| BINARY_CLASS_P (inner)
+		|| EXPRESSION_CLASS_P (inner)
 		/* We need to detect the case where a temporary is created to
 		   hold the return value, since we cannot safely rename it at
 		   top level as it lives only in the elaboration routine.  */
@@ -1006,7 +1009,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)
 		   underlying object lives only in the elaboration routine.  */
 		|| (TREE_CODE (inner) == INDIRECT_REF
 		    && (inner
-			  = remove_conversions (TREE_OPERAND (inner, 0), true))
+			= remove_conversions (TREE_OPERAND (inner, 0), true))
 		    && TREE_CODE (inner) == VAR_DECL
 		    && DECL_RETURN_VALUE_P (inner)))
 	      ;
@@ -2063,11 +2066,16 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)
 	  {
 	    gnu_fat_type = TYPE_MAIN_VARIANT (TYPE_POINTER_TO (gnu_type));
 	    TYPE_NAME (gnu_fat_type) = NULL_TREE;
-	    /* Save the contents of the dummy type for update_pointer_to.  */
-	    TYPE_POINTER_TO (gnu_type) = copy_type (gnu_fat_type);
 	    gnu_ptr_template =
-	      TREE_TYPE (TREE_CHAIN (TYPE_FIELDS (gnu_fat_type)));
+	      TREE_TYPE (DECL_CHAIN (TYPE_FIELDS (gnu_fat_type)));
 	    gnu_template_type = TREE_TYPE (gnu_ptr_template);
+
+	    /* Save the contents of the dummy type for update_pointer_to.  */
+	    TYPE_POINTER_TO (gnu_type) = copy_type (gnu_fat_type);
+	    TYPE_FIELDS (TYPE_POINTER_TO (gnu_type))
+	      = copy_node (TYPE_FIELDS (gnu_fat_type));
+	    DECL_CHAIN (TYPE_FIELDS (TYPE_POINTER_TO (gnu_type)))
+	      = copy_node (DECL_CHAIN (TYPE_FIELDS (gnu_fat_type)));
 	  }
 	else
 	  {
@@ -2088,29 +2096,39 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)
 
 	/* Build the fat pointer type.  Use a "void *" object instead of
 	   a pointer to the array type since we don't have the array type
-	   yet (it will reference the fat pointer via the bounds).  */
-	tem
-	  = create_field_decl (get_identifier ("P_ARRAY"), ptr_type_node,
-			       gnu_fat_type, NULL_TREE, NULL_TREE, 0, 0);
-	DECL_CHAIN (tem)
-	  = create_field_decl (get_identifier ("P_BOUNDS"), gnu_ptr_template,
-			       gnu_fat_type, NULL_TREE, NULL_TREE, 0, 0);
-
+	   yet (it will reference the fat pointer via the bounds).  Note
+	   that we reuse the existing fields of a dummy type because for:
+
+	     type Arr is array (Positive range <>) of Element_Type;
+	     type Array_Ref is access Arr;
+	     Var : Array_Ref := Null;
+
+	   in a declarative part, Arr will be frozen only after Var, which
+	   means that the fields used in the CONSTRUCTOR built for Null are
+	   those of the dummy type, which in turn means that COMPONENT_REFs
+	   of Var may be built with these fields.  Now if COMPONENT_REFs of
+	   Var are also built later with the fields of the final type, the
+	   aliasing machinery may consider that the accesses are distinct
+	   if the FIELD_DECLs are distinct as objects.  */
 	if (COMPLETE_TYPE_P (gnu_fat_type))
 	  {
-	    /* We are going to lay it out again so reset the alias set.  */
-	    alias_set_type alias_set = TYPE_ALIAS_SET (gnu_fat_type);
-	    TYPE_ALIAS_SET (gnu_fat_type) = -1;
-	    finish_fat_pointer_type (gnu_fat_type, tem);
-	    TYPE_ALIAS_SET (gnu_fat_type) = alias_set;
+	    tem = TYPE_FIELDS (gnu_fat_type);
+	    TREE_TYPE (tem) = ptr_type_node;
+	    TREE_TYPE (DECL_CHAIN (tem)) = gnu_ptr_template;
+	    TYPE_DECL_SUPPRESS_DEBUG (TYPE_STUB_DECL (gnu_fat_type)) = 0;
 	    for (t = gnu_fat_type; t; t = TYPE_NEXT_VARIANT (t))
-	      {
-		TYPE_FIELDS (t) = tem;
-		SET_TYPE_UNCONSTRAINED_ARRAY (t, gnu_type);
-	      }
+	      SET_TYPE_UNCONSTRAINED_ARRAY (t, gnu_type);
 	  }
 	else
 	  {
+	    tem
+	      = create_field_decl (get_identifier ("P_ARRAY"),
+				   ptr_type_node, gnu_fat_type,
+				   NULL_TREE, NULL_TREE, 0, 0);
+	    DECL_CHAIN (tem)
+	      = create_field_decl (get_identifier ("P_BOUNDS"),
+				   gnu_ptr_template, gnu_fat_type,
+				   NULL_TREE, NULL_TREE, 0, 0);
 	    finish_fat_pointer_type (gnu_fat_type, tem);
 	    SET_TYPE_UNCONSTRAINED_ARRAY (gnu_fat_type, gnu_type);
 	  }
@@ -3389,20 +3407,6 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)
 	      break;
 	    }
 
-	  /* If this is a record subtype associated with a dispatch table,
-	     strip the suffix.  This is necessary to make sure 2 different
-	     subtypes associated with the imported and exported views of a
-	     dispatch table are properly merged in LTO mode.  */
-	  if (Is_Dispatch_Table_Entity (gnat_entity))
-	    {
-	      char *p;
-	      Get_Encoded_Name (gnat_entity);
-	      p = strchr (Name_Buffer, '_');
-	      gcc_assert (p);
-	      strcpy (p+2, "dtS");
-	      gnu_entity_name = get_identifier (Name_Buffer);
-	    }
-
 	  /* When the subtype has discriminants and these discriminants affect
 	     the initial shape it has inherited, factor them in.  But for an
 	     Unchecked_Union (it must be an Itype), just return the type.
@@ -4681,7 +4685,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)
       /* If this is not an unconstrained array type, set some flags.  */
       if (TREE_CODE (gnu_type) != UNCONSTRAINED_ARRAY_TYPE)
 	{
-	  /* Tell the middle-end that objects of tagged types are guaranteed to
+	  /* Record the property that objects of tagged types are guaranteed to
 	     be properly aligned.  This is necessary because conversions to the
 	     class-wide type are translated into conversions to the root type,
 	     which can be less aligned than some of its derived types.  */
@@ -5272,17 +5276,6 @@ gnat_to_gnu_component_type (Entity_Id gnat_array, bool definition,
 		     Is_Bit_Packed_Array (gnat_array) ? TYPE_DECL : VAR_DECL,
 		     true, Has_Component_Size_Clause (gnat_array));
 
-  /* If the array has aliased components and the component size can be zero,
-     force at least unit size to ensure that the components have distinct
-     addresses.  */
-  if (!gnu_comp_size
-      && Has_Aliased_Components (gnat_array)
-      && (integer_zerop (TYPE_SIZE (gnu_type))
-	  || (TREE_CODE (gnu_type) == ARRAY_TYPE
-	      && !TREE_CONSTANT (TYPE_SIZE (gnu_type)))))
-    gnu_comp_size
-      = size_binop (MAX_EXPR, TYPE_SIZE (gnu_type), bitsize_unit_node);
-
   /* If the component type is a RECORD_TYPE that has a self-referential size,
      then use the maximum size for the component size.  */
   if (!gnu_comp_size
@@ -5290,6 +5283,13 @@ gnat_to_gnu_component_type (Entity_Id gnat_array, bool definition,
       && CONTAINS_PLACEHOLDER_P (TYPE_SIZE (gnu_type)))
     gnu_comp_size = max_size (TYPE_SIZE (gnu_type), true);
 
+  /* If the array has aliased components and the component size is zero, force
+     the unit size to ensure that the components have distinct addresses.  */
+  if (!gnu_comp_size
+      && Has_Aliased_Components (gnat_array)
+      && integer_zerop (TYPE_SIZE (gnu_type)))
+    gnu_comp_size = bitsize_unit_node;
+
   /* Honor the component size.  This is not needed for bit-packed arrays.  */
   if (gnu_comp_size && !Is_Bit_Packed_Array (gnat_array))
     {
@@ -5312,6 +5312,30 @@ gnat_to_gnu_component_type (Entity_Id gnat_array, bool definition,
 			  gnat_array);
     }
 
+  /* This is a very special case where the array has aliased components and the
+     component size might be zero at run time.  As explained above, we force at
+     least the unit size but we don't want to build a distinct padding type for
+     each invocation (they are not canonicalized if they have variable size) so
+     we cache this special padding type as TYPE_PADDING_FOR_COMPONENT.  */
+  else if (Has_Aliased_Components (gnat_array)
+	   && TREE_CODE (gnu_type) == ARRAY_TYPE
+	   && !TREE_CONSTANT (TYPE_SIZE (gnu_type)))
+    {
+      if (TYPE_PADDING_FOR_COMPONENT (gnu_type))
+	gnu_type = TYPE_PADDING_FOR_COMPONENT (gnu_type);
+      else
+	{
+	  gnu_comp_size
+	    = size_binop (MAX_EXPR, TYPE_SIZE (gnu_type), bitsize_unit_node);
+	  TYPE_PADDING_FOR_COMPONENT (gnu_type)
+	    = maybe_pad_type (gnu_type, gnu_comp_size, 0, gnat_array,
+			      true, false, definition, true);
+	  gnu_type = TYPE_PADDING_FOR_COMPONENT (gnu_type);
+	  create_type_decl (TYPE_NAME (gnu_type), gnu_type, true, debug_info_p,
+			    gnat_array);
+	}
+    }
+
   /* If the component type is a padded type made for a non-bit-packed array
      of scalars with reverse storage order, we need to propagate the reverse
      storage order to the padding type since it is the innermost enclosing
@@ -6276,19 +6300,6 @@ gnu_ext_name_for_subprog (Entity_Id gnat_subprog, tree gnu_entity_name)
   return gnu_ext_name;
 }
 
-/* Like build_qualified_type, but TYPE_QUALS is added to the existing
-   qualifiers on TYPE.  */
-
-static tree
-change_qualified_type (tree type, int type_quals)
-{
-  /* Qualifiers must be put on the associated array type.  */
-  if (TREE_CODE (type) == UNCONSTRAINED_ARRAY_TYPE)
-    return type;
-
-  return build_qualified_type (type, TYPE_QUALS (type) | type_quals);
-}
-
 /* Set TYPE_NONALIASED_COMPONENT on an array type built by means of
    build_nonshared_array_type.  */
 
@@ -6330,12 +6341,6 @@ same_discriminant_p (Entity_Id discr1, Entity_Id discr2)
 static bool
 array_type_has_nonaliased_component (tree gnu_type, Entity_Id gnat_type)
 {
-  /* If the array type is not the innermost dimension of the GNAT type,
-     then it has a non-aliased component.  */
-  if (TREE_CODE (TREE_TYPE (gnu_type)) == ARRAY_TYPE
-      && TYPE_MULTI_ARRAY_P (TREE_TYPE (gnu_type)))
-    return true;
-
   /* If the array type has an aliased component in the front-end sense,
      then it also has an aliased component in the back-end sense.  */
   if (Has_Aliased_Components (gnat_type))
@@ -6346,15 +6351,17 @@ array_type_has_nonaliased_component (tree gnu_type, Entity_Id gnat_type)
   if (Is_Derived_Type (gnat_type))
     {
       tree gnu_parent_type = gnat_to_gnu_type (Etype (gnat_type));
-      int index;
       if (TREE_CODE (gnu_parent_type) == UNCONSTRAINED_ARRAY_TYPE)
 	gnu_parent_type
 	  = TREE_TYPE (TREE_TYPE (TYPE_FIELDS (TREE_TYPE (gnu_parent_type))));
-      for (index = Number_Dimensions (gnat_type) - 1; index > 0; index--)
-	gnu_parent_type = TREE_TYPE (gnu_parent_type);
       return TYPE_NONALIASED_COMPONENT (gnu_parent_type);
     }
 
+  /* For a multi-dimensional array type, find the component type.  */
+  while (TREE_CODE (TREE_TYPE (gnu_type)) == ARRAY_TYPE
+	 && TYPE_MULTI_ARRAY_P (TREE_TYPE (gnu_type)))
+    gnu_type = TREE_TYPE (gnu_type);
+
   /* Otherwise, rely exclusively on properties of the element type.  */
   return type_for_nonaliased_component_p (TREE_TYPE (gnu_type));
 }
@@ -6864,65 +6871,44 @@ elaborate_reference (tree ref, Entity_Id gnat_entity, bool definition,
    the value passed against the list of choices.  */
 
 static tree
-choices_to_gnu (tree operand, Node_Id choices)
+choices_to_gnu (tree gnu_operand, Node_Id gnat_choices)
 {
-  Node_Id choice;
-  Node_Id gnat_temp;
-  tree result = boolean_false_node;
-  tree this_test, low = 0, high = 0, single = 0;
+  tree gnu_result = boolean_false_node, gnu_type;
+
+  gnu_operand = maybe_character_value (gnu_operand);
+  gnu_type = TREE_TYPE (gnu_operand);
 
-  for (choice = First (choices); Present (choice); choice = Next (choice))
+  for (Node_Id gnat_choice = First (gnat_choices);
+       Present (gnat_choice);
+       gnat_choice = Next (gnat_choice))
     {
-      switch (Nkind (choice))
+      tree gnu_low = NULL_TREE, gnu_high = NULL_TREE;
+      tree gnu_test;
+
+      switch (Nkind (gnat_choice))
 	{
 	case N_Range:
-	  low = gnat_to_gnu (Low_Bound (choice));
-	  high = gnat_to_gnu (High_Bound (choice));
-
-	  this_test
-	    = build_binary_op (TRUTH_ANDIF_EXPR, boolean_type_node,
-			       build_binary_op (GE_EXPR, boolean_type_node,
-						operand, low, true),
-			       build_binary_op (LE_EXPR, boolean_type_node,
-						operand, high, true),
-			       true);
-
+	  gnu_low = gnat_to_gnu (Low_Bound (gnat_choice));
+	  gnu_high = gnat_to_gnu (High_Bound (gnat_choice));
 	  break;
 
 	case N_Subtype_Indication:
-	  gnat_temp = Range_Expression (Constraint (choice));
-	  low = gnat_to_gnu (Low_Bound (gnat_temp));
-	  high = gnat_to_gnu (High_Bound (gnat_temp));
-
-	  this_test
-	    = build_binary_op (TRUTH_ANDIF_EXPR, boolean_type_node,
-			       build_binary_op (GE_EXPR, boolean_type_node,
-						operand, low, true),
-			       build_binary_op (LE_EXPR, boolean_type_node,
-						operand, high, true),
-			       true);
+	  gnu_low = gnat_to_gnu (Low_Bound (Range_Expression
+					    (Constraint (gnat_choice))));
+	  gnu_high = gnat_to_gnu (High_Bound (Range_Expression
+					      (Constraint (gnat_choice))));
 	  break;
 
 	case N_Identifier:
 	case N_Expanded_Name:
-	  /* This represents either a subtype range, an enumeration
-	     literal, or a constant  Ekind says which.  If an enumeration
-	     literal or constant, fall through to the next case.  */
-	  if (Ekind (Entity (choice)) != E_Enumeration_Literal
-	      && Ekind (Entity (choice)) != E_Constant)
+	  /* This represents either a subtype range or a static value of
+	     some kind; Ekind says which.  */
+	  if (Is_Type (Entity (gnat_choice)))
 	    {
-	      tree type = gnat_to_gnu_type (Entity (choice));
-
-	      low = TYPE_MIN_VALUE (type);
-	      high = TYPE_MAX_VALUE (type);
-
-	      this_test
-		= build_binary_op (TRUTH_ANDIF_EXPR, boolean_type_node,
-				   build_binary_op (GE_EXPR, boolean_type_node,
-						    operand, low, true),
-				   build_binary_op (LE_EXPR, boolean_type_node,
-						    operand, high, true),
-				   true);
+	      tree gnu_type = get_unpadded_type (Entity (gnat_choice));
+
+	      gnu_low = TYPE_MIN_VALUE (gnu_type);
+	      gnu_high = TYPE_MAX_VALUE (gnu_type);
 	      break;
 	    }
 
@@ -6930,27 +6916,49 @@ choices_to_gnu (tree operand, Node_Id choices)
 
 	case N_Character_Literal:
 	case N_Integer_Literal:
-	  single = gnat_to_gnu (choice);
-	  this_test = build_binary_op (EQ_EXPR, boolean_type_node, operand,
-				       single, true);
+	  gnu_low = gnat_to_gnu (gnat_choice);
 	  break;
 
 	case N_Others_Choice:
-	  this_test = boolean_true_node;
 	  break;
 
 	default:
 	  gcc_unreachable ();
 	}
 
-      if (result == boolean_false_node)
-	result = this_test;
+      /* Everything should be folded into constants at this point.  */
+      gcc_assert (!gnu_low  || TREE_CODE (gnu_low)  == INTEGER_CST);
+      gcc_assert (!gnu_high || TREE_CODE (gnu_high) == INTEGER_CST);
+
+      if (gnu_low && TREE_TYPE (gnu_low) != gnu_type)
+	gnu_low = convert (gnu_type, gnu_low);
+      if (gnu_high && TREE_TYPE (gnu_high) != gnu_type)
+	gnu_high = convert (gnu_type, gnu_high);
+
+      if (gnu_low && gnu_high)
+	gnu_test
+	  = build_binary_op (TRUTH_ANDIF_EXPR, boolean_type_node,
+			     build_binary_op (GE_EXPR, boolean_type_node,
+					      gnu_operand, gnu_low, true),
+			     build_binary_op (LE_EXPR, boolean_type_node,
+					      gnu_operand, gnu_high, true),
+			     true);
+      else if (gnu_low)
+	gnu_test
+	  = build_binary_op (EQ_EXPR, boolean_type_node, gnu_operand, gnu_low,
+			     true);
+      else
+	gnu_test = boolean_true_node;
+
+      if (gnu_result == boolean_false_node)
+	gnu_result = gnu_test;
       else
-	result = build_binary_op (TRUTH_ORIF_EXPR, boolean_type_node, result,
-				  this_test, true);
+	gnu_result
+	  = build_binary_op (TRUTH_ORIF_EXPR, boolean_type_node, gnu_result,
+			     gnu_test, true);
     }
 
-  return result;
+  return gnu_result;
 }
 
 /* Adjust PACKED setting as passed to gnat_to_gnu_field for a field of
@@ -8040,9 +8048,8 @@ static Uint
 annotate_value (tree gnu_size)
 {
   TCode tcode;
-  Node_Ref_Or_Val ops[3], ret, pre_op1 = No_Uint;
+  Node_Ref_Or_Val ops[3] = { No_Uint, No_Uint, No_Uint };
   struct tree_int_map in;
-  int i;
 
   /* See if we've already saved the value for this node.  */
   if (EXPR_P (gnu_size))
@@ -8059,49 +8066,56 @@ annotate_value (tree gnu_size)
     in.base.from = NULL_TREE;
 
   /* If we do not return inside this switch, TCODE will be set to the
-     code to use for a Create_Node operand and LEN (set above) will be
-     the number of recursive calls for us to make.  */
-
+     code to be used in a call to Create_Node.  */
   switch (TREE_CODE (gnu_size))
     {
     case INTEGER_CST:
       /* For negative values, build NEGATE_EXPR of the opposite.  Such values
-	 can appear for discriminants in expressions for variants.  */
-      if (tree_int_cst_sgn (gnu_size) < 0)
+	 can appear for discriminants in expressions for variants.  Note that
+	 sizetype being unsigned, we don't directly use tree_int_cst_sgn.  */
+      if (tree_int_cst_sign_bit (gnu_size))
 	{
 	  tree t = wide_int_to_tree (sizetype, wi::neg (gnu_size));
-	  return annotate_value (build1 (NEGATE_EXPR, sizetype, t));
+	  tcode = Negate_Expr;
+	  ops[0] = UI_From_gnu (t);
 	}
-
-      return TREE_OVERFLOW (gnu_size) ? No_Uint : UI_From_gnu (gnu_size);
+      else
+	return TREE_OVERFLOW (gnu_size) ? No_Uint : UI_From_gnu (gnu_size);
+      break;
 
     case COMPONENT_REF:
       /* The only case we handle here is a simple discriminant reference.  */
       if (DECL_DISCRIMINANT_NUMBER (TREE_OPERAND (gnu_size, 1)))
 	{
-	  tree n = DECL_DISCRIMINANT_NUMBER (TREE_OPERAND (gnu_size, 1));
+	  tree ref = gnu_size;
+	  gnu_size = TREE_OPERAND (ref, 1);
 
 	  /* Climb up the chain of successive extensions, if any.  */
-	  while (TREE_CODE (TREE_OPERAND (gnu_size, 0)) == COMPONENT_REF
-		 && DECL_NAME (TREE_OPERAND (TREE_OPERAND (gnu_size, 0), 1))
+	  while (TREE_CODE (TREE_OPERAND (ref, 0)) == COMPONENT_REF
+		 && DECL_NAME (TREE_OPERAND (TREE_OPERAND (ref, 0), 1))
 		    == parent_name_id)
-	    gnu_size = TREE_OPERAND (gnu_size, 0);
+	    ref = TREE_OPERAND (ref, 0);
 
-	  if (TREE_CODE (TREE_OPERAND (gnu_size, 0)) == PLACEHOLDER_EXPR)
-	    return
-	      Create_Node (Discrim_Val, annotate_value (n), No_Uint, No_Uint);
+	  if (TREE_CODE (TREE_OPERAND (ref, 0)) == PLACEHOLDER_EXPR)
+	    {
+	      /* Fall through to common processing as a FIELD_DECL.  */
+	      tcode = Discrim_Val;
+	      ops[0] = UI_From_gnu (DECL_DISCRIMINANT_NUMBER (gnu_size));
+	    }
+	  else
+	    return No_Uint;
 	}
+      else
+	return No_Uint;
+      break;
 
-      return No_Uint;
-
-    CASE_CONVERT:   case NON_LVALUE_EXPR:
+    CASE_CONVERT:
+    case NON_LVALUE_EXPR:
       return annotate_value (TREE_OPERAND (gnu_size, 0));
 
       /* Now just list the operations we handle.  */
     case COND_EXPR:		tcode = Cond_Expr; break;
-    case PLUS_EXPR:		tcode = Plus_Expr; break;
     case MINUS_EXPR:		tcode = Minus_Expr; break;
-    case MULT_EXPR:		tcode = Mult_Expr; break;
     case TRUNC_DIV_EXPR:	tcode = Trunc_Div_Expr; break;
     case CEIL_DIV_EXPR:		tcode = Ceil_Div_Expr; break;
     case FLOOR_DIV_EXPR:	tcode = Floor_Div_Expr; break;
@@ -8126,20 +8140,56 @@ annotate_value (tree gnu_size)
     case EQ_EXPR:		tcode = Eq_Expr; break;
     case NE_EXPR:		tcode = Ne_Expr; break;
 
+    case PLUS_EXPR:
+      /* Turn addition of negative constant into subtraction.  */
+      if (TREE_CODE (TREE_OPERAND (gnu_size, 1)) == INTEGER_CST
+	  && tree_int_cst_sign_bit (TREE_OPERAND (gnu_size, 1)))
+	{
+	  tcode = Minus_Expr;
+	  ops[0] = annotate_value (TREE_OPERAND (gnu_size, 0));
+	  wide_int op1 = wi::neg (TREE_OPERAND (gnu_size, 1));
+	  ops[1] = annotate_value (wide_int_to_tree (sizetype, op1));
+	  break;
+	}
+
+      /* ... fall through ... */
+
+    case MULT_EXPR:
+      tcode = (TREE_CODE (gnu_size) == MULT_EXPR ? Mult_Expr : Plus_Expr);
+      /* Fold conversions from bytes to bits into inner operations.  */
+      if (TREE_CODE (TREE_OPERAND (gnu_size, 1)) == INTEGER_CST
+	  && CONVERT_EXPR_P (TREE_OPERAND (gnu_size, 0)))
+	{
+	  tree inner_op = TREE_OPERAND (TREE_OPERAND (gnu_size, 0), 0);
+	  if (TREE_CODE (inner_op) == TREE_CODE (gnu_size)
+	      && TREE_CODE (TREE_OPERAND (inner_op, 1)) == INTEGER_CST)
+	    {
+	      ops[0] = annotate_value (TREE_OPERAND (inner_op, 0));
+	      tree inner_op_op1 = TREE_OPERAND (inner_op, 1);
+	      tree gnu_size_op1 = TREE_OPERAND (gnu_size, 1);
+	      wide_int op1;
+	      if (TREE_CODE (gnu_size) == MULT_EXPR)
+		op1 = wi::mul (inner_op_op1, gnu_size_op1);
+	      else
+		{
+		  op1 = wi::add (inner_op_op1, gnu_size_op1);
+		  if (wi::zext (op1, TYPE_PRECISION (sizetype)) == 0)
+		    return ops[0];
+		}
+	      ops[1] = annotate_value (wide_int_to_tree (sizetype, op1));
+	    }
+	}
+      break;
+
     case BIT_AND_EXPR:
       tcode = Bit_And_Expr;
       /* For negative values in sizetype, build NEGATE_EXPR of the opposite.
-	 Such values appear in expressions with aligning patterns.  Note that,
-	 since sizetype is unsigned, we have to jump through some hoops.   */
+	 Such values can appear in expressions with aligning patterns.  */
       if (TREE_CODE (TREE_OPERAND (gnu_size, 1)) == INTEGER_CST)
 	{
-	  tree op1 = TREE_OPERAND (gnu_size, 1);
-	  wide_int signed_op1 = wi::sext (op1, TYPE_PRECISION (sizetype));
-	  if (wi::neg_p (signed_op1))
-	    {
-	      op1 = wide_int_to_tree (sizetype, wi::neg (signed_op1));
-	      pre_op1 = annotate_value (build1 (NEGATE_EXPR, sizetype, op1));
-	    }
+	  wide_int op1 = wi::sext (TREE_OPERAND (gnu_size, 1),
+				   TYPE_PRECISION (sizetype));
+	  ops[1] = annotate_value (wide_int_to_tree (sizetype, op1));
 	}
       break;
 
@@ -8150,34 +8200,26 @@ annotate_value (tree gnu_size)
       if (List_Representation_Info == 3 || type_annotate_only)
 	{
 	  tree t = maybe_inline_call_in_expr (gnu_size);
-	  if (t)
-	    return annotate_value (t);
+	  return t ? annotate_value (t) : No_Uint;
 	}
       else
 	return Uint_Minus_1;
 
-      /* Fall through... */
-
     default:
       return No_Uint;
     }
 
   /* Now get each of the operands that's relevant for this code.  If any
      cannot be expressed as a repinfo node, say we can't.  */
-  for (i = 0; i < 3; i++)
-    ops[i] = No_Uint;
-
-  for (i = 0; i < TREE_CODE_LENGTH (TREE_CODE (gnu_size)); i++)
-    {
-      if (i == 1 && pre_op1 != No_Uint)
-	ops[i] = pre_op1;
-      else
+  for (int i = 0; i < TREE_CODE_LENGTH (TREE_CODE (gnu_size)); i++)
+    if (ops[i] == No_Uint)
+      {
 	ops[i] = annotate_value (TREE_OPERAND (gnu_size, i));
-      if (ops[i] == No_Uint)
-	return No_Uint;
-    }
+	if (ops[i] == No_Uint)
+	  return No_Uint;
+      }
 
-  ret = Create_Node (tcode, ops[0], ops[1], ops[2]);
+  Node_Ref_Or_Val ret = Create_Node (tcode, ops[0], ops[1], ops[2]);
 
   /* Save the result in the cache.  */
   if (in.base.from)
@@ -8190,7 +8232,7 @@ annotate_value (tree gnu_size)
       h = annotate_value_cache->find_slot (&in, INSERT);
       gcc_assert (!*h);
       *h = ggc_alloc<tree_int_map> ();
-      (*h)->base.from = gnu_size;
+      (*h)->base.from = in.base.from;
       (*h)->to = ret;
     }
 
diff --git a/gcc/ada/gcc-interface/gigi.h b/gcc/ada/gcc-interface/gigi.h
index 1d87b5be44e..2b33c13302c 100644
--- a/gcc/ada/gcc-interface/gigi.h
+++ b/gcc/ada/gcc-interface/gigi.h
@@ -1074,7 +1074,7 @@ maybe_vector_array (tree exp)
 static inline unsigned HOST_WIDE_INT
 ceil_pow2 (unsigned HOST_WIDE_INT x)
 {
-  return (unsigned HOST_WIDE_INT) 1 << (floor_log2 (x - 1) + 1);
+  return (unsigned HOST_WIDE_INT) 1 << ceil_log2 (x);
 }
 
 /* Return true if EXP, a CALL_EXPR, is an atomic load.  */
@@ -1171,3 +1171,16 @@ maybe_debug_type (tree type)
 
   return type;
 }
+
+/* Like build_qualified_type, but TYPE_QUALS is added to the existing
+   qualifiers on TYPE.  */
+
+static inline tree
+change_qualified_type (tree type, int type_quals)
+{
+  /* Qualifiers must be put on the associated array type.  */
+  if (TREE_CODE (type) == UNCONSTRAINED_ARRAY_TYPE)
+    return type;
+
+  return build_qualified_type (type, TYPE_QUALS (type) | type_quals);
+}
diff --git a/gcc/ada/gcc-interface/misc.c b/gcc/ada/gcc-interface/misc.c
index 1b6b3eb265a..f23d7337e0a 100644
--- a/gcc/ada/gcc-interface/misc.c
+++ b/gcc/ada/gcc-interface/misc.c
@@ -262,6 +262,9 @@ gnat_post_options (const char **pfilename ATTRIBUTE_UNUSED)
   /* No psABI change warnings for Ada.  */
   warn_psabi = 0;
 
+  /* No string overflow warnings for Ada.  */
+  warn_stringop_overflow = 0;
+
   /* No caret by default for Ada.  */
   if (!global_options_set.x_flag_diagnostics_show_caret)
     global_dc->show_caret = false;
@@ -393,7 +396,7 @@ gnat_init_gcc_eh (void)
   using_eh_for_cleanups ();
 
   /* Turn on -fexceptions, -fnon-call-exceptions and -fdelete-dead-exceptions.
-     The first one triggers the generation of the necessary exception tables.
+     The first one activates the support for exceptions in the compiler.
      The second one is useful for two reasons: 1/ we map some asynchronous
      signals like SEGV to exceptions, so we need to ensure that the insns
      which can lead to such signals are correctly attached to the exception
@@ -403,10 +406,26 @@ gnat_init_gcc_eh (void)
      for such calls to actually raise in Ada.
      The third one is an optimization that makes it possible to delete dead
      instructions that may throw exceptions, most notably loads and stores,
-     as permitted in Ada.  */
+     as permitted in Ada.
+     Turn off -faggressive-loop-optimizations because it may optimize away
+     out-of-bound array accesses that we want to be able to catch.
+     If checks are disabled, we use the same settings as the C++ compiler,
+     except for the runtime on platforms where S'Machine_Overflow is true
+     because the runtime depends on FP (hardware) checks being properly
+     handled despite being compiled in -gnatp mode.  */
   flag_exceptions = 1;
-  flag_non_call_exceptions = 1;
   flag_delete_dead_exceptions = 1;
+  if (Suppress_Checks)
+    {
+      if (!global_options_set.x_flag_non_call_exceptions)
+	flag_non_call_exceptions = Machine_Overflows_On_Target && GNAT_Mode;
+    }
+  else
+    {
+      flag_non_call_exceptions = 1;
+      flag_aggressive_loop_optimizations = 0;
+      warn_aggressive_loop_optimizations = 0;
+    }
 
   init_eh ();
 }
diff --git a/gcc/ada/gcc-interface/trans.c b/gcc/ada/gcc-interface/trans.c
index bef7f8121f3..7430af10e83 100644
--- a/gcc/ada/gcc-interface/trans.c
+++ b/gcc/ada/gcc-interface/trans.c
@@ -197,9 +197,6 @@ struct GTY(()) loop_info_d {
   tree low_bound;
   tree high_bound;
   vec<range_check_info, va_gc> *checks;
-  bool artificial;
-  bool has_checks;
-  bool warned_aggressive_loop_optimizations;
 };
 
 typedef struct loop_info_d *loop_info;
@@ -658,10 +655,6 @@ gigi (Node_Id gnat_root,
   /* Now translate the compilation unit proper.  */
   Compilation_Unit_to_gnu (gnat_root);
 
-  /* Disable -Waggressive-loop-optimizations since we implement our own
-     version of the warning.  */
-  warn_aggressive_loop_optimizations = 0;
-
   /* Then process the N_Validate_Unchecked_Conversion nodes.  We do this at
      the very end to avoid having to second-guess the front-end when we run
      into dummy nodes during the regular processing.  */
@@ -1266,32 +1259,18 @@ Pragma_to_gnu (Node_Id gnat_node)
 	{
 	  Node_Id gnat_expr = Expression (gnat_temp);
 	  tree gnu_expr = gnat_to_gnu (gnat_expr);
-	  int use_address;
-	  machine_mode mode;
 	  tree asm_constraint = NULL_TREE;
 #ifdef ASM_COMMENT_START
 	  char *comment;
 #endif
-
-	  if (TREE_CODE (gnu_expr) == UNCONSTRAINED_ARRAY_REF)
-	    gnu_expr = TREE_OPERAND (gnu_expr, 0);
-
-	  /* Use the value only if it fits into a normal register,
-	     otherwise use the address.  */
-	  mode = TYPE_MODE (TREE_TYPE (gnu_expr));
-	  use_address = ((GET_MODE_CLASS (mode) != MODE_INT
-			  && GET_MODE_CLASS (mode) != MODE_PARTIAL_INT)
-			 || GET_MODE_SIZE (mode) > UNITS_PER_WORD);
-
-	  if (use_address)
-	    gnu_expr = build_unary_op (ADDR_EXPR, NULL_TREE, gnu_expr);
+	  gnu_expr = maybe_unconstrained_array (gnu_expr);
+	  gnat_mark_addressable (gnu_expr);
 
 #ifdef ASM_COMMENT_START
 	  comment = concat (ASM_COMMENT_START,
 			    " inspection point: ",
 			    Get_Name_String (Chars (gnat_expr)),
-			    use_address ? " address" : "",
-			    " is in %0",
+			    " is at %0",
 			    NULL);
 	  asm_constraint = build_string (strlen (comment), comment);
 	  free (comment);
@@ -1301,8 +1280,8 @@ Pragma_to_gnu (Node_Id gnat_node)
 			     NULL_TREE,
 			     tree_cons
 			     (build_tree_list (NULL_TREE,
-					       build_string (1, "g")),
-			      gnu_expr, NULL_TREE),
+					       build_string (1, "m")),
+					       gnu_expr, NULL_TREE),
 			     NULL_TREE, NULL_TREE);
 	  ASM_VOLATILE_P (gnu_expr) = 1;
 	  set_expr_location_from_node (gnu_expr, gnat_node);
@@ -2861,7 +2840,6 @@ Loop_Statement_to_gnu (Node_Id gnat_node)
 
   /* Save the statement for later reuse.  */
   gnu_loop_info->stmt = gnu_loop_stmt;
-  gnu_loop_info->artificial = !Comes_From_Source (gnat_node);
 
   /* Set the condition under which the loop must keep going.
      For the case "LOOP .... END LOOP;" the condition is always true.  */
@@ -3124,7 +3102,7 @@ Loop_Statement_to_gnu (Node_Id gnat_node)
 	 unswitching is enabled, do not require the loop bounds to be also
 	 invariant, as their evaluation will still be ahead of the loop.  */
       if (vec_safe_length (gnu_loop_info->checks) > 0
-	 && (make_invariant (&gnu_low, &gnu_high) || flag_unswitch_loops))
+	 && (make_invariant (&gnu_low, &gnu_high) || optimize >= 3))
 	{
 	  struct range_check_info_d *rci;
 	  unsigned int i, n_remaining_checks = 0;
@@ -3176,22 +3154,22 @@ Loop_Statement_to_gnu (Node_Id gnat_node)
 
 	  /* Note that loop unswitching can only be applied a small number of
 	     times to a given loop (PARAM_MAX_UNSWITCH_LEVEL default to 3).  */
-	  if (0 < n_remaining_checks && n_remaining_checks <= 3
-	      && optimize > 1 && !optimize_size)
+	  if (IN_RANGE (n_remaining_checks, 1, 3)
+	      && optimize >= 2
+	      && !optimize_size)
 	    FOR_EACH_VEC_ELT (*gnu_loop_info->checks, i, rci)
 	      if (rci->invariant_cond != boolean_false_node)
 		{
 		  TREE_OPERAND (rci->inserted_cond, 0) = rci->invariant_cond;
 
-		  if (flag_unswitch_loops)
+		  if (optimize >= 3)
 		    add_stmt_with_node_force (rci->inserted_cond, gnat_node);
 		}
 	}
 
       /* Second, if loop vectorization is enabled and the iterations of the
 	 loop can easily be proved as independent, mark the loop.  */
-      if (optimize
-	  && flag_tree_loop_vectorize
+      if (optimize >= 3
 	  && independent_iterations_p (LOOP_STMT_BODY (gnu_loop_stmt)))
 	LOOP_STMT_IVDEP (gnu_loop_stmt) = 1;
 
@@ -4059,6 +4037,8 @@ node_has_volatile_full_access (Node_Id gnat_node)
     case N_Identifier:
     case N_Expanded_Name:
       gnat_entity = Entity (gnat_node);
+      if (!Is_Object (gnat_entity))
+	break;
       return Is_Volatile_Full_Access (gnat_entity)
 	     || Is_Volatile_Full_Access (Etype (gnat_entity));
 
@@ -4324,12 +4304,15 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,
 	  because we need to preserve the return value before copying back the
 	  parameters.
 
-       2. There is no target and the call is made for neither an object nor a
+       2. There is no target and the call is made for neither an object, nor a
 	  renaming declaration, nor a return statement, nor an allocator, and
 	  the return type has variable size because in this case the gimplifier
-	  cannot create the temporary, or more generally is simply an aggregate
-	  type, because the gimplifier would then create the temporary in the
-	  outermost scope instead of locally.
+	  cannot create the temporary, or more generally is an aggregate type,
+	  because the gimplifier would create the temporary in the outermost
+	  scope instead of locally.  But there is an exception for an allocator
+	  of an unconstrained record type with default discriminant because we
+	  allocate the actual size in this case, unlike the other 3 cases, so
+	  we need a temporary to fetch the discriminant and we create it here.
 
        3. There is a target and it is a slice or an array with fixed size,
 	  and the return type has variable size, because the gimplifier
@@ -4348,8 +4331,9 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,
 	      && Nkind (Parent (gnat_node)) != N_Object_Declaration
 	      && Nkind (Parent (gnat_node)) != N_Object_Renaming_Declaration
 	      && Nkind (Parent (gnat_node)) != N_Simple_Return_Statement
-	      && !(Nkind (Parent (gnat_node)) == N_Qualified_Expression
-		   && Nkind (Parent (Parent (gnat_node))) == N_Allocator)
+	      && (!(Nkind (Parent (gnat_node)) == N_Qualified_Expression
+		    && Nkind (Parent (Parent (gnat_node))) == N_Allocator)
+		  || type_is_padding_self_referential (gnu_result_type))
 	      && AGGREGATE_TYPE_P (gnu_result_type)
 	      && !TYPE_IS_FAT_POINTER_P (gnu_result_type))
 	  || (gnu_target
@@ -5652,9 +5636,8 @@ Raise_Error_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)
 	      rci->inserted_cond
 		= build1 (SAVE_EXPR, boolean_type_node, boolean_true_node);
 	      vec_safe_push (loop->checks, rci);
-	      loop->has_checks = true;
 	      gnu_cond = build_noreturn_cond (gnat_to_gnu (gnat_cond));
-	      if (flag_unswitch_loops)
+	      if (optimize >= 3)
 		gnu_cond = build_binary_op (TRUTH_ANDIF_EXPR,
 					    boolean_type_node,
 					    rci->inserted_cond,
@@ -5665,14 +5648,6 @@ Raise_Error_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)
 					    gnu_cond,
 					    rci->inserted_cond);
 	    }
-
-	  /* Or else, if aggressive loop optimizations are enabled, we just
-	     record that there are checks applied to iteration variables.  */
-	  else if (optimize
-		   && flag_aggressive_loop_optimizations
-		   && inside_loop_p ()
-		   && (loop = find_loop_for (gnu_index)))
-	    loop->has_checks = true;
 	}
       break;
 
@@ -6288,45 +6263,9 @@ gnat_to_gnu (Node_Id gnat_node)
 	    gcc_assert (TREE_CODE (gnu_type) == ARRAY_TYPE);
 	    gnat_temp = gnat_expr_array[i];
 	    gnu_expr = maybe_character_value (gnat_to_gnu (gnat_temp));
-	    struct loop_info_d *loop;
 
 	    gnu_result
 	      = build_binary_op (ARRAY_REF, NULL_TREE, gnu_result, gnu_expr);
-
-	    /* Array accesses are bound-checked so they cannot trap, but this
-	       is valid only if they are not hoisted ahead of the check.  We
-	       need to mark them as no-trap to get decent loop optimizations
-	       in the presence of -fnon-call-exceptions, so we do it when we
-	       know that the original expression had no side-effects.  */
-	    if (TREE_CODE (gnu_result) == ARRAY_REF
-		&& !(Nkind (gnat_temp) == N_Identifier
-		     && Ekind (Entity (gnat_temp)) == E_Constant))
-	      TREE_THIS_NOTRAP (gnu_result) = 1;
-
-	    /* If aggressive loop optimizations are enabled, we warn for loops
-	       overrunning a simple array of size 1 not at the end of a record.
-	       This is aimed to catch misuses of the trailing array idiom.  */
-	    if (optimize
-		&& flag_aggressive_loop_optimizations
-		&& inside_loop_p ()
-		&& TREE_CODE (TREE_TYPE (gnu_type)) != ARRAY_TYPE
-		&& TREE_CODE (gnu_array_object) != ARRAY_REF
-		&& tree_int_cst_equal (TYPE_MIN_VALUE (TYPE_DOMAIN (gnu_type)),
-				       TYPE_MAX_VALUE (TYPE_DOMAIN (gnu_type)))
-		&& !array_at_struct_end_p (gnu_result)
-		&& (loop = find_loop_for (gnu_expr))
-		&& !loop->artificial
-		&& !loop->has_checks
-		&& tree_int_cst_equal (TYPE_MIN_VALUE (TYPE_DOMAIN (gnu_type)),
-				       loop->low_bound)
-		&& can_be_lower_p (loop->low_bound, loop->high_bound)
-		&& !loop->warned_aggressive_loop_optimizations
-		&& warning (OPT_Waggressive_loop_optimizations,
-			    "out-of-bounds access may be optimized away"))
-	      {
-		inform (EXPR_LOCATION (loop->stmt), "containing loop");
-		loop->warned_aggressive_loop_optimizations = true;
-	      }
 	  }
 
 	gnu_result_type = get_unpadded_type (Etype (gnat_node));
@@ -6965,21 +6904,29 @@ gnat_to_gnu (Node_Id gnat_node)
 	  /* Or else, use memset when the conditions are met.  */
 	  else if (use_memset_p)
 	    {
-	      tree value = fold_convert (integer_type_node, gnu_rhs);
-	      tree to = gnu_lhs;
-	      tree type = TREE_TYPE (to);
-	      tree size
-	        = SUBSTITUTE_PLACEHOLDER_IN_EXPR (TYPE_SIZE_UNIT (type), to);
-	      tree to_ptr = build_fold_addr_expr (to);
+	      tree value
+		= real_zerop (gnu_rhs)
+		  ? integer_zero_node
+		  : fold_convert (integer_type_node, gnu_rhs);
+	      tree dest = build_fold_addr_expr (gnu_lhs);
 	      tree t = builtin_decl_explicit (BUILT_IN_MEMSET);
-	      if (TREE_CODE (value) == INTEGER_CST)
+	      /* Be extra careful not to write too much data.  */
+	      tree size;
+	      if (TREE_CODE (gnu_lhs) == COMPONENT_REF)
+		size = DECL_SIZE_UNIT (TREE_OPERAND (gnu_lhs, 1));
+	      else if (DECL_P (gnu_lhs))
+		size = DECL_SIZE_UNIT (gnu_lhs);
+	      else
+		size = TYPE_SIZE_UNIT (TREE_TYPE (gnu_lhs));
+	      size = SUBSTITUTE_PLACEHOLDER_IN_EXPR (size, gnu_lhs);
+	      if (TREE_CODE (value) == INTEGER_CST && !integer_zerop (value))
 		{
 		  tree mask
 		    = build_int_cst (integer_type_node,
 				     ((HOST_WIDE_INT) 1 << BITS_PER_UNIT) - 1);
 		  value = int_const_binop (BIT_AND_EXPR, value, mask);
 		}
-	      gnu_result = build_call_expr (t, 3, to_ptr, value, size);
+	      gnu_result = build_call_expr (t, 3, dest, value, size);
 	    }
 
 	  /* Otherwise build a regular assignment.  */
@@ -9272,7 +9219,7 @@ convert_with_check (Entity_Id gnat_type, tree gnu_expr, bool overflowp,
 	  ? tree_int_cst_lt (gnu_out_ub, gnu_in_ub)
 	  : (FLOAT_TYPE_P (gnu_base_type)
 	     ? real_less (&TREE_REAL_CST (gnu_out_ub),
-			  &TREE_REAL_CST (gnu_in_lb))
+			  &TREE_REAL_CST (gnu_in_ub))
 	     : 1))
 	gnu_cond
 	  = build_binary_op (TRUTH_ORIF_EXPR, boolean_type_node, gnu_cond,
diff --git a/gcc/ada/gcc-interface/utils.c b/gcc/ada/gcc-interface/utils.c
index f362946e63a..01a182af737 100644
--- a/gcc/ada/gcc-interface/utils.c
+++ b/gcc/ada/gcc-interface/utils.c
@@ -1036,7 +1036,9 @@ make_packable_type (tree type, bool in_record, unsigned int max_align)
 
   finish_record_type (new_type, nreverse (new_field_list), 2, false);
   relate_alias_sets (new_type, type, ALIAS_SET_COPY);
-  if (TYPE_STUB_DECL (type))
+  if (gnat_encodings == DWARF_GNAT_ENCODINGS_MINIMAL)
+    SET_TYPE_DEBUG_TYPE (new_type, TYPE_DEBUG_TYPE (type));
+  else if (TYPE_STUB_DECL (type))
     SET_DECL_PARALLEL_TYPE (TYPE_STUB_DECL (new_type),
 			    DECL_PARALLEL_TYPE (TYPE_STUB_DECL (type)));
 
@@ -1367,7 +1369,7 @@ maybe_pad_type (tree type, tree size, unsigned int align,
   finish_record_type (record, field, 1, false);
 
   if (gnat_encodings == DWARF_GNAT_ENCODINGS_MINIMAL)
-    SET_TYPE_DEBUG_TYPE (record, type);
+    SET_TYPE_DEBUG_TYPE (record, maybe_debug_type (type));
 
   /* Set the RM size if requested.  */
   if (set_rm_size)
@@ -3255,8 +3257,11 @@ finish_subprog_decl (tree decl, tree asm_name, tree type)
   DECL_BY_REFERENCE (result_decl) = TREE_ADDRESSABLE (type);
   DECL_RESULT (decl) = result_decl;
 
+  /* Propagate the "const" property.  */
   TREE_READONLY (decl) = TYPE_READONLY (type);
-  TREE_SIDE_EFFECTS (decl) = TREE_THIS_VOLATILE (decl) = TYPE_VOLATILE (type);
+
+  /* Propagate the "noreturn" property.  */
+  TREE_THIS_VOLATILE (decl) = TYPE_VOLATILE (type);
 
   if (asm_name)
     {
@@ -4543,9 +4548,12 @@ convert (tree type, tree expr)
 					   etype)))
     return build1 (VIEW_CONVERT_EXPR, type, expr);
 
-  /* If we are converting between tagged types, try to upcast properly.  */
+  /* If we are converting between tagged types, try to upcast properly.
+     But don't do it if we are just annotating types since tagged types
+     aren't fully laid out in this mode.  */
   else if (ecode == RECORD_TYPE && code == RECORD_TYPE
-	   && TYPE_ALIGN_OK (etype) && TYPE_ALIGN_OK (type))
+	   && TYPE_ALIGN_OK (etype) && TYPE_ALIGN_OK (type)
+	   && !type_annotate_only)
     {
       tree child_etype = etype;
       do {
@@ -5022,8 +5030,16 @@ unchecked_convert (tree type, tree expr, bool notrunc_p)
   tree etype = TREE_TYPE (expr);
   enum tree_code ecode = TREE_CODE (etype);
   enum tree_code code = TREE_CODE (type);
+  const bool ebiased
+    = (ecode == INTEGER_TYPE && TYPE_BIASED_REPRESENTATION_P (etype));
+  const bool biased
+    = (code == INTEGER_TYPE && TYPE_BIASED_REPRESENTATION_P (type));
+  const bool ereverse
+    = (AGGREGATE_TYPE_P (etype) && TYPE_REVERSE_STORAGE_ORDER (etype));
+  const bool reverse
+    = (AGGREGATE_TYPE_P (type) && TYPE_REVERSE_STORAGE_ORDER (type));
   tree tem;
-  int c;
+  int c = 0;
 
   /* If the expression is already of the right type, we are done.  */
   if (etype == type)
@@ -5039,7 +5055,7 @@ unchecked_convert (tree type, tree expr, bool notrunc_p)
 	   || (ecode == RECORD_TYPE && TYPE_JUSTIFIED_MODULAR_P (etype))))
       || code == UNCONSTRAINED_ARRAY_TYPE)
     {
-      if (ecode == INTEGER_TYPE && TYPE_BIASED_REPRESENTATION_P (etype))
+      if (ebiased)
 	{
 	  tree ntype = copy_type (etype);
 	  TYPE_BIASED_REPRESENTATION_P (ntype) = 0;
@@ -5047,7 +5063,7 @@ unchecked_convert (tree type, tree expr, bool notrunc_p)
 	  expr = build1 (NOP_EXPR, ntype, expr);
 	}
 
-      if (code == INTEGER_TYPE && TYPE_BIASED_REPRESENTATION_P (type))
+      if (biased)
 	{
 	  tree rtype = copy_type (type);
 	  TYPE_BIASED_REPRESENTATION_P (rtype) = 0;
@@ -5076,30 +5092,35 @@ unchecked_convert (tree type, tree expr, bool notrunc_p)
      Finally, for the sake of consistency, we do the unchecked conversion
      to an integral type with reverse storage order as soon as the source
      type is an aggregate type with reverse storage order, even if there
-     are no considerations of precision or size involved.  */
-  else if (INTEGRAL_TYPE_P (type)
-	   && TYPE_RM_SIZE (type)
-	   && (tree_int_cst_compare (TYPE_RM_SIZE (type),
-				     TYPE_SIZE (type)) < 0
-	       || (AGGREGATE_TYPE_P (etype)
-		   && TYPE_REVERSE_STORAGE_ORDER (etype))))
+     are no considerations of precision or size involved.  Ultimately, we
+     further extend this processing to any scalar type.  */
+  else if ((INTEGRAL_TYPE_P (type)
+	    && TYPE_RM_SIZE (type)
+	    && ((c = tree_int_cst_compare (TYPE_RM_SIZE (type),
+					   TYPE_SIZE (type))) < 0
+		|| ereverse))
+	   || (SCALAR_FLOAT_TYPE_P (type) && ereverse))
     {
       tree rec_type = make_node (RECORD_TYPE);
-      unsigned HOST_WIDE_INT prec = TREE_INT_CST_LOW (TYPE_RM_SIZE (type));
       tree field_type, field;
 
-      if (AGGREGATE_TYPE_P (etype))
-	TYPE_REVERSE_STORAGE_ORDER (rec_type)
-	  = TYPE_REVERSE_STORAGE_ORDER (etype);
+      TYPE_REVERSE_STORAGE_ORDER (rec_type) = ereverse;
 
-      if (type_unsigned_for_rm (type))
-	field_type = make_unsigned_type (prec);
+      if (c < 0)
+	{
+	  const unsigned HOST_WIDE_INT prec
+	    = TREE_INT_CST_LOW (TYPE_RM_SIZE (type));
+	  if (type_unsigned_for_rm (type))
+	    field_type = make_unsigned_type (prec);
+	  else
+	    field_type = make_signed_type (prec);
+	  SET_TYPE_RM_SIZE (field_type, TYPE_RM_SIZE (type));
+	}
       else
-	field_type = make_signed_type (prec);
-      SET_TYPE_RM_SIZE (field_type, TYPE_RM_SIZE (type));
+	field_type = type;
 
       field = create_field_decl (get_identifier ("OBJ"), field_type, rec_type,
-				 NULL_TREE, bitsize_zero_node, 1, 0);
+				 NULL_TREE, bitsize_zero_node, c < 0, 0);
 
       finish_record_type (rec_type, field, 1, false);
 
@@ -5114,31 +5135,35 @@ unchecked_convert (tree type, tree expr, bool notrunc_p)
 
      The same considerations as above apply if the target type is an aggregate
      type with reverse storage order and we also proceed similarly.  */
-  else if (INTEGRAL_TYPE_P (etype)
-	   && TYPE_RM_SIZE (etype)
-	   && (tree_int_cst_compare (TYPE_RM_SIZE (etype),
-				     TYPE_SIZE (etype)) < 0
-	       || (AGGREGATE_TYPE_P (type)
-		   && TYPE_REVERSE_STORAGE_ORDER (type))))
+  else if ((INTEGRAL_TYPE_P (etype)
+	    && TYPE_RM_SIZE (etype)
+	    && ((c = tree_int_cst_compare (TYPE_RM_SIZE (etype),
+					   TYPE_SIZE (etype))) < 0
+		|| reverse))
+	   || (SCALAR_FLOAT_TYPE_P (etype) && reverse))
     {
       tree rec_type = make_node (RECORD_TYPE);
-      unsigned HOST_WIDE_INT prec = TREE_INT_CST_LOW (TYPE_RM_SIZE (etype));
       vec<constructor_elt, va_gc> *v;
       vec_alloc (v, 1);
       tree field_type, field;
 
-      if (AGGREGATE_TYPE_P (type))
-	TYPE_REVERSE_STORAGE_ORDER (rec_type)
-	  = TYPE_REVERSE_STORAGE_ORDER (type);
+      TYPE_REVERSE_STORAGE_ORDER (rec_type) = reverse;
 
-      if (type_unsigned_for_rm (etype))
-	field_type = make_unsigned_type (prec);
+      if (c < 0)
+	{
+	  const unsigned HOST_WIDE_INT prec
+	    = TREE_INT_CST_LOW (TYPE_RM_SIZE (etype));
+	  if (type_unsigned_for_rm (etype))
+	    field_type = make_unsigned_type (prec);
+	  else
+	    field_type = make_signed_type (prec);
+	  SET_TYPE_RM_SIZE (field_type, TYPE_RM_SIZE (etype));
+	}
       else
-	field_type = make_signed_type (prec);
-      SET_TYPE_RM_SIZE (field_type, TYPE_RM_SIZE (etype));
+	field_type = etype;
 
       field = create_field_decl (get_identifier ("OBJ"), field_type, rec_type,
-				 NULL_TREE, bitsize_zero_node, 1, 0);
+				 NULL_TREE, bitsize_zero_node, c < 0, 0);
 
       finish_record_type (rec_type, field, 1, false);
 
@@ -5237,8 +5262,8 @@ unchecked_convert (tree type, tree expr, bool notrunc_p)
      if the input is also an integral type and both are unsigned or both are
      signed and have the same precision.  */
   if (!notrunc_p
+      && !biased
       && INTEGRAL_TYPE_P (type)
-      && !(code == INTEGER_TYPE && TYPE_BIASED_REPRESENTATION_P (type))
       && TYPE_RM_SIZE (type)
       && tree_int_cst_compare (TYPE_RM_SIZE (type), TYPE_SIZE (type)) < 0
       && !(INTEGRAL_TYPE_P (etype)
@@ -6113,8 +6138,7 @@ handle_noreturn_attribute (tree *node, tree name, tree ARG_UNUSED (args),
 	   && TREE_CODE (TREE_TYPE (type)) == FUNCTION_TYPE)
     TREE_TYPE (*node)
       = build_pointer_type
-	(build_type_variant (TREE_TYPE (type),
-			     TYPE_READONLY (TREE_TYPE (type)), 1));
+	(change_qualified_type (TREE_TYPE (type), TYPE_QUAL_VOLATILE));
   else
     {
       warning (OPT_Wattributes, "%qs attribute ignored",
diff --git a/gcc/ada/osint.adb b/gcc/ada/osint.adb
index 8c6c22b9d14..1ede04ff564 100644
--- a/gcc/ada/osint.adb
+++ b/gcc/ada/osint.adb
@@ -250,8 +250,7 @@ package body Osint is
       Attr : aliased File_Attributes;
    end record;
 
-   No_File_Info_Cache : constant File_Info_Cache :=
-                          (No_File, Unknown_Attributes);
+   No_File_Info_Cache : constant File_Info_Cache := (No_File, (others => 0));
 
    package File_Name_Hash_Table is new GNAT.HTable.Simple_HTable (
      Header_Num => File_Hash_Num,
diff --git a/gcc/ada/osint.ads b/gcc/ada/osint.ads
index a96e83ea8e7..893ff7b0738 100644
--- a/gcc/ada/osint.ads
+++ b/gcc/ada/osint.ads
@@ -273,10 +273,26 @@ package Osint is
    --  from the disk and then cached in the File_Attributes parameter (possibly
    --  along with other values).
 
-   type File_Attributes is private;
-   Unknown_Attributes : constant File_Attributes;
+   File_Attributes_Size : constant Natural := 32;
+   --  This should be big enough to fit a "struct file_attributes" on any
+   --  system. It doesn't cause any malfunction if it is too big (which avoids
+   --  the need for either mapping the struct exactly or importing the sizeof
+   --  from C, which would result in dynamic code). However, it does waste
+   --  space (e.g. when a component of this type appears in a record, if it is
+   --  unnecessarily large). Note: for runtime units, use System.OS_Constants.
+   --  SIZEOF_struct_file_attributes instead, which has the exact value.
+
+   type File_Attributes is
+     array (1 .. File_Attributes_Size)
+       of System.Storage_Elements.Storage_Element;
+   for File_Attributes'Alignment use Standard'Maximum_Alignment;
+
+   Unknown_Attributes : File_Attributes;
    --  A cache for various attributes for a file (length, accessibility,...)
-   --  This must be initialized to Unknown_Attributes prior to the first call.
+   --  Will be initialized properly at elaboration (for efficiency later on,
+   --  avoid function calls every time we want to reset the attributes) prior
+   --  to the first usage. We cannot make it constant since the compiler may
+   --  put it in a read-only section.
 
    function Is_Directory
      (Name : C_File_Name;
@@ -769,22 +785,4 @@ private
    --  detected, the file being written is deleted, and a fatal error is
    --  signalled.
 
-   File_Attributes_Size : constant Natural := 32;
-   --  This should be big enough to fit a "struct file_attributes" on any
-   --  system. It doesn't cause any malfunction if it is too big (which avoids
-   --  the need for either mapping the struct exactly or importing the sizeof
-   --  from C, which would result in dynamic code). However, it does waste
-   --  space (e.g. when a component of this type appears in a record, if it is
-   --  unnecessarily large). Note: for runtime units, use System.OS_Constants.
-   --  SIZEOF_struct_file_attributes instead, which has the exact value.
-
-   type File_Attributes is
-     array (1 .. File_Attributes_Size)
-       of System.Storage_Elements.Storage_Element;
-   for File_Attributes'Alignment use Standard'Maximum_Alignment;
-
-   Unknown_Attributes : constant File_Attributes := (others => 0);
-   --  Will be initialized properly at elaboration (for efficiency later on,
-   --  avoid function calls every time we want to reset the attributes).
-
 end Osint;
diff --git a/gcc/ada/s-linux-sparc.ads b/gcc/ada/s-linux-sparc.ads
index 96c67145fe1..79be6c6bd06 100644
--- a/gcc/ada/s-linux-sparc.ads
+++ b/gcc/ada/s-linux-sparc.ads
@@ -70,7 +70,7 @@ package System.Linux is
    EINVAL    : constant := 22;
    ENOMEM    : constant := 12;
    EPERM     : constant := 1;
-   ETIMEDOUT : constant := 110;
+   ETIMEDOUT : constant := 60;
 
    -------------
    -- Signals --
diff --git a/gcc/ada/s-osinte-solaris.ads b/gcc/ada/s-osinte-solaris.ads
index b4baa6d4998..b1b197abd2c 100644
--- a/gcc/ada/s-osinte-solaris.ads
+++ b/gcc/ada/s-osinte-solaris.ads
@@ -536,17 +536,18 @@ private
    end record;
    pragma Convention (C, record_type_3);
 
+   type upad64_t is new Interfaces.Unsigned_64;
+
    type mutex_t is record
       flags : record_type_3;
-      lock  : String (1 .. 8);
-      data  : String (1 .. 8);
+      lock  : upad64_t;
+      data  : upad64_t;
    end record;
    pragma Convention (C, mutex_t);
 
    type cond_t is record
-      flag  : array_type_9;
-      Xtype : unsigned_long;
-      data  : String (1 .. 8);
+      flags : record_type_3;
+      data  : upad64_t;
    end record;
    pragma Convention (C, cond_t);
 
diff --git a/gcc/alias.c b/gcc/alias.c
index e16e3501522..e6d67b1200c 100644
--- a/gcc/alias.c
+++ b/gcc/alias.c
@@ -2997,7 +2997,8 @@ write_dependence_p (const_rtx mem,
   int ret;
 
   gcc_checking_assert (x_canonicalized
-		       ? (x_addr != NULL_RTX && x_mode != VOIDmode)
+		       ? (x_addr != NULL_RTX
+			  && (x_mode != VOIDmode || GET_MODE (x) == VOIDmode))
 		       : (x_addr == NULL_RTX && x_mode == VOIDmode));
 
   if (MEM_VOLATILE_P (x) && MEM_VOLATILE_P (mem))
diff --git a/gcc/brig/ChangeLog b/gcc/brig/ChangeLog
index 0e5761be302..06e3dd535db 100644
--- a/gcc/brig/ChangeLog
+++ b/gcc/brig/ChangeLog
@@ -1,3 +1,12 @@
+2018-12-06  Release Manager
+
+	* GCC 7.4.0 released.
+
+2018-07-04  Martin Jambor  <mjambor@suse.cz>
+
+	PR hsa/86371
+	* Make-lang.in (BRIGINCLUDES): Remove erroneous include path in $HOME.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
diff --git a/gcc/brig/Make-lang.in b/gcc/brig/Make-lang.in
index d7566bfe365..0572f61e299 100644
--- a/gcc/brig/Make-lang.in
+++ b/gcc/brig/Make-lang.in
@@ -235,8 +235,7 @@ brig.stagefeedback: stagefeedback-start
 CFLAGS-brig/brig-lang.o += -DDEFAULT_TARGET_VERSION=\"$(version)\" \
 	-DDEFAULT_TARGET_MACHINE=\"$(target_noncanonical)\"
 
-BRIGINCLUDES = -I $(srcdir)/brig -I ${HOME}/local/include \
-	-I $(srcdir)/brig/brigfrontend
+BRIGINCLUDES = -I $(srcdir)/brig -I $(srcdir)/brig/brigfrontend
 
 brig/brig-machine.o: brig/brigfrontend/brig-machine.c
 	$(COMPILE) $(BRIGINCLUDES) $<
diff --git a/gcc/builtins.c b/gcc/builtins.c
index d7d4f0f7483..767093f539f 100644
--- a/gcc/builtins.c
+++ b/gcc/builtins.c
@@ -7538,8 +7538,7 @@ builtin_mathfn_code (const_tree t)
   const_tree argtype, parmtype;
   const_call_expr_arg_iterator iter;
 
-  if (TREE_CODE (t) != CALL_EXPR
-      || TREE_CODE (CALL_EXPR_FN (t)) != ADDR_EXPR)
+  if (TREE_CODE (t) != CALL_EXPR)
     return END_BUILTINS;
 
   fndecl = get_callee_fndecl (t);
@@ -9271,7 +9270,7 @@ fold_builtin_strpbrk (location_t loc, tree s1, tree s2, tree type)
       if (p2[0] == '\0')
 	/* strpbrk(x, "") == NULL.
 	   Evaluate and ignore s1 in case it had side-effects.  */
-	return omit_one_operand_loc (loc, TREE_TYPE (s1), integer_zero_node, s1);
+	return omit_one_operand_loc (loc, type, integer_zero_node, s1);
 
       if (p2[1] != '\0')
 	return NULL_TREE;  /* Really call strpbrk.  */
diff --git a/gcc/c-family/ChangeLog b/gcc/c-family/ChangeLog
index 1a8dc119c31..7e77b0974de 100644
--- a/gcc/c-family/ChangeLog
+++ b/gcc/c-family/ChangeLog
@@ -1,3 +1,65 @@
+2019-04-09  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* c-ada-spec.c (print_destructor): Deal with deleting destructors.
+	(dump_ada_declaration) <FUNCTION_DECL>: Likewise.
+
+2018-12-06  Release Manager
+
+	* GCC 7.4.0 released.
+
+2018-06-22  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-06-20  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/86210
+	* c-common.c (check_nonnull_arg): Use fold_for_warn.  Adjust obsolete
+	comment.
+
+	2018-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/85696
+	* c-omp.c (c_omp_predetermined_sharing): Return
+	OMP_CLAUSE_DEFAULT_SHARED for artificial vars with integral type.
+
+	2018-05-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/85662
+	* c-common.h (fold_offsetof_1): Removed.
+	(fold_offsetof): Add TYPE argument defaulted to size_type_node and
+	CTX argument defaulted to ERROR_MARK.
+	* c-common.c (fold_offsetof_1): Renamed to ...
+	(fold_offsetof): ... this.  Remove wrapper function.  Add TYPE
+	argument, convert the pointer constant to TYPE and use size_binop
+	with PLUS_EXPR instead of fold_build_pointer_plus if type is not
+	a pointer type.  Adjust recursive calls.
+
+2018-04-26  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2018-03-16  Richard Biener  <rguenther@suse.de>
+
+	PR c/84873
+	* c-gimplify.c (c_gimplify_expr): Revert previous change.  Instead
+	unshare the possibly folded expression.
+
+	2018-03-15  Richard Biener  <rguenther@suse.de>
+
+	PR c/84873
+	* c-gimplify.c (c_gimplify_expr): Do not fold expressions.
+
+2018-03-03  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-01-27  Jakub Jelinek  <jakub@redhat.com>
+
+	* c-cppbuiltin.c (c_cpp_builtins): Use ggc_strdup for the fp_suffix
+	argument.
+	(LAZY_HEX_FP_VALUES_CNT): Define.
+	(lazy_hex_fp_values): Allow up to LAZY_HEX_FP_VALUES_CNT lazy hex fp
+	values rather than just 12.
+	(builtin_define_with_hex_fp_value): Likewise.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
diff --git a/gcc/c-family/c-ada-spec.c b/gcc/c-family/c-ada-spec.c
index 18c5ccf1054..6d7667e82b3 100644
--- a/gcc/c-family/c-ada-spec.c
+++ b/gcc/c-family/c-ada-spec.c
@@ -2663,6 +2663,8 @@ print_destructor (pretty_printer *buffer, tree t)
   tree decl_name = DECL_NAME (DECL_ORIGIN (t));
 
   pp_string (buffer, "Delete_");
+  if (strncmp (IDENTIFIER_POINTER (DECL_NAME (t)), "__del", 5) == 0)
+    pp_string (buffer, "And_Free_");
   pp_ada_tree_identifier (buffer, decl_name, t, false);
 }
 
@@ -2915,8 +2917,9 @@ print_ada_declaration (pretty_printer *buffer, tree t, tree type, int spc)
 	  if (DECL_ARTIFICIAL (t))
 	    return 0;
 
-	  /* Only consider constructors/destructors for complete objects.  */
-	  if (strncmp (IDENTIFIER_POINTER (decl_name), "__comp", 6) != 0)
+	  /* Only consider complete constructors and deleting destructors.  */
+	  if (strncmp (IDENTIFIER_POINTER (decl_name), "__comp", 6) != 0
+	      && strncmp (IDENTIFIER_POINTER (decl_name), "__del", 5) != 0)
 	    return 0;
 	}
 
diff --git a/gcc/c-family/c-common.c b/gcc/c-family/c-common.c
index e272488b39b..45be4bd1cbe 100644
--- a/gcc/c-family/c-common.c
+++ b/gcc/c-family/c-common.c
@@ -5434,10 +5434,8 @@ check_nonnull_arg (void *ctx, tree param, unsigned HOST_WIDE_INT param_num)
   if (TREE_CODE (TREE_TYPE (param)) != POINTER_TYPE)
     return;
 
-  /* When not optimizing diagnose the simple cases of null arguments.
-     When optimization is enabled defer the checking until expansion
-     when more cases can be detected.  */
-  if (integer_zerop (param))
+  /* Diagnose the simple cases of null arguments.  */
+  if (integer_zerop (fold_for_warn (param)))
     {
       warning_at (pctx->loc, OPT_Wnonnull, "null argument where non-null "
 		  "required (argument %lu)", (unsigned long) param_num);
@@ -6253,10 +6251,11 @@ c_common_to_target_charset (HOST_WIDE_INT c)
 
 /* Fold an offsetof-like expression.  EXPR is a nested sequence of component
    references with an INDIRECT_REF of a constant at the bottom; much like the
-   traditional rendering of offsetof as a macro.  Return the folded result.  */
+   traditional rendering of offsetof as a macro.  TYPE is the desired type of
+   the whole expression.  Return the folded result.  */
 
 tree
-fold_offsetof_1 (tree expr, enum tree_code ctx)
+fold_offsetof (tree expr, tree type, enum tree_code ctx)
 {
   tree base, off, t;
   tree_code code = TREE_CODE (expr);
@@ -6281,10 +6280,10 @@ fold_offsetof_1 (tree expr, enum tree_code ctx)
 	  error ("cannot apply %<offsetof%> to a non constant address");
 	  return error_mark_node;
 	}
-      return TREE_OPERAND (expr, 0);
+      return convert (type, TREE_OPERAND (expr, 0));
 
     case COMPONENT_REF:
-      base = fold_offsetof_1 (TREE_OPERAND (expr, 0), code);
+      base = fold_offsetof (TREE_OPERAND (expr, 0), type, code);
       if (base == error_mark_node)
 	return base;
 
@@ -6301,7 +6300,7 @@ fold_offsetof_1 (tree expr, enum tree_code ctx)
       break;
 
     case ARRAY_REF:
-      base = fold_offsetof_1 (TREE_OPERAND (expr, 0), code);
+      base = fold_offsetof (TREE_OPERAND (expr, 0), type, code);
       if (base == error_mark_node)
 	return base;
 
@@ -6358,23 +6357,16 @@ fold_offsetof_1 (tree expr, enum tree_code ctx)
       /* Handle static members of volatile structs.  */
       t = TREE_OPERAND (expr, 1);
       gcc_assert (VAR_P (t));
-      return fold_offsetof_1 (t);
+      return fold_offsetof (t, type);
 
     default:
       gcc_unreachable ();
     }
 
+  if (!POINTER_TYPE_P (type))
+    return size_binop (PLUS_EXPR, base, convert (type, off));
   return fold_build_pointer_plus (base, off);
 }
-
-/* Likewise, but convert it to the return type of offsetof.  */
-
-tree
-fold_offsetof (tree expr)
-{
-  return convert (size_type_node, fold_offsetof_1 (expr));
-}
-
 
 /* *PTYPE is an incomplete array.  Complete it with a domain based on
    INITIAL_VALUE.  If INITIAL_VALUE is not present, use 1 if DO_DEFAULT
diff --git a/gcc/c-family/c-common.h b/gcc/c-family/c-common.h
index b9333420434..0cff4414294 100644
--- a/gcc/c-family/c-common.h
+++ b/gcc/c-family/c-common.h
@@ -1053,8 +1053,8 @@ extern bool c_dump_tree (void *, tree);
 
 extern void verify_sequence_points (tree);
 
-extern tree fold_offsetof_1 (tree, tree_code ctx = ERROR_MARK);
-extern tree fold_offsetof (tree);
+extern tree fold_offsetof (tree, tree = size_type_node,
+			   tree_code ctx = ERROR_MARK);
 
 extern int complete_array_type (tree *, tree, bool);
 
diff --git a/gcc/c-family/c-cppbuiltin.c b/gcc/c-family/c-cppbuiltin.c
index c5fadaa6aa2..041cc64699f 100644
--- a/gcc/c-family/c-cppbuiltin.c
+++ b/gcc/c-family/c-cppbuiltin.c
@@ -1119,7 +1119,7 @@ c_cpp_builtins (cpp_reader *pfile)
 	       floatn_nx_types[i].extended ? "X" : "");
       sprintf (csuffix, "F%d%s", floatn_nx_types[i].n,
 	       floatn_nx_types[i].extended ? "x" : "");
-      builtin_define_float_constants (prefix, csuffix, "%s", NULL,
+      builtin_define_float_constants (prefix, ggc_strdup (csuffix), "%s", NULL,
 				      FLOATN_NX_TYPE_NODE (i));
     }
 
@@ -1566,7 +1566,14 @@ struct GTY(()) lazy_hex_fp_value_struct
   int digits;
   const char *fp_suffix;
 };
-static GTY(()) struct lazy_hex_fp_value_struct lazy_hex_fp_values[12];
+/* Number of the expensive to compute macros we should evaluate lazily.
+   Each builtin_define_float_constants invocation calls
+   builtin_define_with_hex_fp_value 4 times and builtin_define_float_constants
+   is called for FLT, DBL, LDBL and up to NUM_FLOATN_NX_TYPES times for
+   FLTNN*.  */ 
+#define LAZY_HEX_FP_VALUES_CNT (4 * (3 + NUM_FLOATN_NX_TYPES))
+static GTY(()) struct lazy_hex_fp_value_struct
+  lazy_hex_fp_values[LAZY_HEX_FP_VALUES_CNT];
 static GTY(()) int lazy_hex_fp_value_count;
 
 static bool
@@ -1611,7 +1618,7 @@ builtin_define_with_hex_fp_value (const char *macro,
   char dec_str[64], buf1[256], buf2[256];
 
   /* This is very expensive, so if possible expand them lazily.  */
-  if (lazy_hex_fp_value_count < 12
+  if (lazy_hex_fp_value_count < LAZY_HEX_FP_VALUES_CNT
       && flag_dump_macros == 0
       && !cpp_get_options (parse_in)->traditional)
     {
diff --git a/gcc/c-family/c-gimplify.c b/gcc/c-family/c-gimplify.c
index 57edb41af0f..deecb1a3e4a 100644
--- a/gcc/c-family/c-gimplify.c
+++ b/gcc/c-family/c-gimplify.c
@@ -244,7 +244,9 @@ c_gimplify_expr (tree *expr_p, gimple_seq *pre_p ATTRIBUTE_UNUSED,
 				    unsigned_type_node)
 	    && !types_compatible_p (TYPE_MAIN_VARIANT (TREE_TYPE (*op1_p)),
 				    integer_type_node))
-	  *op1_p = convert (unsigned_type_node, *op1_p);
+	  /* Make sure to unshare the result, tree sharing is invalid
+	     during gimplification.  */
+	  *op1_p = unshare_expr (convert (unsigned_type_node, *op1_p));
 	break;
       }
 
diff --git a/gcc/c-family/c-omp.c b/gcc/c-family/c-omp.c
index 977cb0ea153..eee718ddce1 100644
--- a/gcc/c-family/c-omp.c
+++ b/gcc/c-family/c-omp.c
@@ -1540,5 +1540,13 @@ c_omp_predetermined_sharing (tree decl)
   if (TREE_READONLY (decl))
     return OMP_CLAUSE_DEFAULT_SHARED;
 
+  /* Predetermine artificial variables holding integral values, those
+     are usually result of gimplify_one_sizepos or SAVE_EXPR
+     gimplification.  */
+  if (VAR_P (decl)
+      && DECL_ARTIFICIAL (decl)
+      && INTEGRAL_TYPE_P (TREE_TYPE (decl)))
+    return OMP_CLAUSE_DEFAULT_SHARED;
+
   return OMP_CLAUSE_DEFAULT_UNSPECIFIED;
 }
diff --git a/gcc/c/ChangeLog b/gcc/c/ChangeLog
index b48e7cb422e..ab2eae1ff37 100644
--- a/gcc/c/ChangeLog
+++ b/gcc/c/ChangeLog
@@ -1,3 +1,103 @@
+2019-01-16  Joseph Myers  <joseph@codesourcery.com>
+
+	Backport from mainline
+	2019-01-07  Joseph Myers  <joseph@codesourcery.com>
+
+	PR c/88720
+	PR c/88726
+	* c-decl.c (pop_scope): Use TREE_PUBLIC and b->nested to determine
+	whether a function is nested, not DECL_EXTERNAL.  Diagnose inline
+	functions declared but never defined only for external scope, not
+	for other scopes.
+
+2018-01-02  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	Backport from trunk
+	2018-12-06  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	PR inline-asm/55681
+	* c-parser.c (c_parser_asm_statement): Update grammar.  Allow any
+	combination of volatile and goto, in any order, without repetitions.
+
+	Backport from trunk
+	2018-12-06  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	* c-parser.c (c_parser_asm_statement): Detect the inline keyword
+	after asm.  Pass a flag for it to build_asm_expr.
+	* c-tree.h (build_asm_expr): Update declaration.
+	* c-typeck.c (build_asm_stmt): Add is_inline parameter.  Use it to
+	set ASM_INLINE_P.
+
+	Backport from trunk
+	2018-12-08  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	* c-parser (c_parser_asm_statement) [RID_INLINE]: Delete stray line
+	setting "quals".
+
+	Backport from trunk
+	2018-12-19  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	* c-parser.c (c_parser_asm_statement): Rewrite the loop to work without
+	"done" boolean variable.
+
+	Backport from trunk
+	2018-12-19  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	* c-parser.c (c_parser_asm_statement): Keep track of the location each
+	asm qualifier is first seen; use that to give nicer "duplicate asm
+	qualifier" messages.  Delete 'quals" variable, instead pass the
+	"is_volatile_ flag to build_asm_stmt directly.
+	* c-tree.h (build_asm_stmt): Make the first arg bool instead of tree.
+	* c-typeck.c (build_asm_stmt): Ditto; adjust.
+
+	Backport from trunk
+	2018-12-19  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	* c-parser.c (c_parser_asm_statement) <RID_CONST, RID_RESTRICT>: Give
+	a more specific error message (instead of just falling through).
+
+	And extra for the backport
+	2019-01-02  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	* c-parser.c (c_parser_asm_statement): Output a warning instead of an
+	error for const and restrict.
+
+2018-12-06  Release Manager
+
+	* GCC 7.4.0 released.
+
+2018-06-22  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/85696
+	* c-typeck.c (c_finish_omp_clauses): Don't use
+	c_omp_predetermined_sharing, instead just check TREE_READONLY.
+
+	2018-05-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/85662
+	* c-fold.c (c_fully_fold_internal): Use fold_offsetof rather than
+	fold_offsetof_1, pass TREE_TYPE (expr) as TYPE to it and drop the
+	fold_convert_loc.
+	* c-typeck.c (build_unary_op): Use fold_offsetof rather than
+	fold_offsetof_1, pass argtype as TYPE to it and drop the
+	fold_convert_loc.
+
+	2018-03-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/84999
+	* c-typeck.c (build_binary_op): If c_common_type_for_size fails when
+	building vector comparison, diagnose it and return error_mark_node.
+
+	2018-03-15  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/84853
+	* c-typeck.c (build_binary_op) <case RSHIFT_EXPR, case LSHIFT_EXPR>:
+	If code1 is INTEGER_TYPE, only allow code0 VECTOR_TYPE if it has
+	INTEGER_TYPE element type.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
diff --git a/gcc/c/c-decl.c b/gcc/c/c-decl.c
index ed609d29f96..14a3832f7bf 100644
--- a/gcc/c/c-decl.c
+++ b/gcc/c/c-decl.c
@@ -1235,8 +1235,9 @@ pop_scope (void)
 	      && DECL_ABSTRACT_ORIGIN (p) != 0
 	      && DECL_ABSTRACT_ORIGIN (p) != p)
 	    TREE_ADDRESSABLE (DECL_ABSTRACT_ORIGIN (p)) = 1;
-	  if (!DECL_EXTERNAL (p)
+	  if (!TREE_PUBLIC (p)
 	      && !DECL_INITIAL (p)
+	      && !b->nested
 	      && scope != file_scope
 	      && scope != external_scope)
 	    {
@@ -1252,7 +1253,7 @@ pop_scope (void)
 		 in the same translation unit."  */
 	      if (!flag_gnu89_inline
 		  && !lookup_attribute ("gnu_inline", DECL_ATTRIBUTES (p))
-		  && scope != external_scope)
+		  && scope == external_scope)
 		pedwarn (input_location, 0,
 			 "inline function %q+D declared but never defined", p);
 	      DECL_EXTERNAL (p) = 1;
diff --git a/gcc/c/c-fold.c b/gcc/c/c-fold.c
index b060d76da43..96c041e265d 100644
--- a/gcc/c/c-fold.c
+++ b/gcc/c/c-fold.c
@@ -403,7 +403,7 @@ c_fully_fold_internal (tree expr, bool in_init, bool *maybe_const_operands,
 	  && (op1 = get_base_address (op0)) != NULL_TREE
 	  && INDIRECT_REF_P (op1)
 	  && TREE_CONSTANT (TREE_OPERAND (op1, 0)))
-	ret = fold_convert_loc (loc, TREE_TYPE (expr), fold_offsetof_1 (op0));
+	ret = fold_offsetof (op0, TREE_TYPE (expr));
       else if (op0 != orig_op0 || in_init)
 	ret = in_init
 	  ? fold_build1_initializer_loc (loc, code, TREE_TYPE (expr), op0)
diff --git a/gcc/c/c-parser.c b/gcc/c/c-parser.c
index 101afb8e35f..86195c53249 100644
--- a/gcc/c/c-parser.c
+++ b/gcc/c/c-parser.c
@@ -6089,61 +6089,104 @@ c_parser_for_statement (c_parser *parser, bool ivdep, bool *if_p)
 }
 
 /* Parse an asm statement, a GNU extension.  This is a full-blown asm
-   statement with inputs, outputs, clobbers, and volatile tag
-   allowed.
+   statement with inputs, outputs, clobbers, and volatile, inline, and goto
+   tags allowed.
+
+   asm-qualifier:
+     volatile
+     inline
+     goto
+
+   asm-qualifier-list:
+     asm-qualifier-list asm-qualifier
+     asm-qualifier
 
    asm-statement:
-     asm type-qualifier[opt] ( asm-argument ) ;
-     asm type-qualifier[opt] goto ( asm-goto-argument ) ;
+     asm asm-qualifier-list[opt] ( asm-argument ) ;
 
    asm-argument:
      asm-string-literal
      asm-string-literal : asm-operands[opt]
      asm-string-literal : asm-operands[opt] : asm-operands[opt]
-     asm-string-literal : asm-operands[opt] : asm-operands[opt] : asm-clobbers[opt]
-
-   asm-goto-argument:
+     asm-string-literal : asm-operands[opt] : asm-operands[opt] \
+       : asm-clobbers[opt]
      asm-string-literal : : asm-operands[opt] : asm-clobbers[opt] \
        : asm-goto-operands
 
-   Qualifiers other than volatile are accepted in the syntax but
-   warned for.  */
+   The form with asm-goto-operands is valid if and only if the
+   asm-qualifier-list contains goto, and is the only allowed form in that case.
+   Duplicate asm-qualifiers are not allowed.  */
 
 static tree
 c_parser_asm_statement (c_parser *parser)
 {
-  tree quals, str, outputs, inputs, clobbers, labels, ret;
-  bool simple, is_goto;
+  tree str, outputs, inputs, clobbers, labels, ret;
+  bool simple;
   location_t asm_loc = c_parser_peek_token (parser)->location;
   int section, nsections;
 
   gcc_assert (c_parser_next_token_is_keyword (parser, RID_ASM));
   c_parser_consume_token (parser);
-  if (c_parser_next_token_is_keyword (parser, RID_VOLATILE))
-    {
-      quals = c_parser_peek_token (parser)->value;
-      c_parser_consume_token (parser);
-    }
-  else if (c_parser_next_token_is_keyword (parser, RID_CONST)
-	   || c_parser_next_token_is_keyword (parser, RID_RESTRICT))
-    {
-      warning_at (c_parser_peek_token (parser)->location,
-		  0,
-		  "%E qualifier ignored on asm",
-		  c_parser_peek_token (parser)->value);
-      quals = NULL_TREE;
-      c_parser_consume_token (parser);
-    }
-  else
-    quals = NULL_TREE;
 
-  is_goto = false;
-  if (c_parser_next_token_is_keyword (parser, RID_GOTO))
+  /* Handle the asm-qualifier-list.  */
+  location_t volatile_loc = UNKNOWN_LOCATION;
+  location_t inline_loc = UNKNOWN_LOCATION;
+  location_t goto_loc = UNKNOWN_LOCATION;
+  for (;;)
     {
-      c_parser_consume_token (parser);
-      is_goto = true;
+      c_token *token = c_parser_peek_token (parser);
+      location_t loc = token->location;
+      switch (token->keyword)
+	{
+	case RID_VOLATILE:
+	  if (volatile_loc)
+	    {
+	      error_at (loc, "duplicate asm qualifier %qE", token->value);
+	      inform (volatile_loc, "first seen here");
+	    }
+	  else
+	    volatile_loc = loc;
+	  c_parser_consume_token (parser);
+	  continue;
+
+	case RID_INLINE:
+	  if (inline_loc)
+	    {
+	      error_at (loc, "duplicate asm qualifier %qE", token->value);
+	      inform (inline_loc, "first seen here");
+	    }
+	  else
+	    inline_loc = loc;
+	  c_parser_consume_token (parser);
+	  continue;
+
+	case RID_GOTO:
+	  if (goto_loc)
+	    {
+	      error_at (loc, "duplicate asm qualifier %qE", token->value);
+	      inform (goto_loc, "first seen here");
+	    }
+	  else
+	    goto_loc = loc;
+	  c_parser_consume_token (parser);
+	  continue;
+
+	case RID_CONST:
+	case RID_RESTRICT:
+	  warning_at (loc, 0, "%qE is not an asm qualifier", token->value);
+	  c_parser_consume_token (parser);
+	  continue;
+
+	default:
+	  break;
+	}
+      break;
     }
 
+  bool is_volatile = (volatile_loc != UNKNOWN_LOCATION);
+  bool is_inline = (inline_loc != UNKNOWN_LOCATION);
+  bool is_goto = (goto_loc != UNKNOWN_LOCATION);
+
   /* ??? Follow the C++ parser rather than using the
      lex_untranslated_string kludge.  */
   parser->lex_untranslated_string = true;
@@ -6216,8 +6259,9 @@ c_parser_asm_statement (c_parser *parser)
   if (!c_parser_require (parser, CPP_SEMICOLON, "expected %<;%>"))
     c_parser_skip_to_end_of_block_or_statement (parser);
 
-  ret = build_asm_stmt (quals, build_asm_expr (asm_loc, str, outputs, inputs,
-					       clobbers, labels, simple));
+  ret = build_asm_stmt (is_volatile,
+			build_asm_expr (asm_loc, str, outputs, inputs,
+					clobbers, labels, simple, is_inline));
 
  error:
   parser->lex_untranslated_string = false;
diff --git a/gcc/c/c-tree.h b/gcc/c/c-tree.h
index 5fa32a48f29..eef26f89f02 100644
--- a/gcc/c/c-tree.h
+++ b/gcc/c/c-tree.h
@@ -659,8 +659,9 @@ extern tree build_compound_literal (location_t, tree, tree, bool);
 extern void check_compound_literal_type (location_t, struct c_type_name *);
 extern tree c_start_case (location_t, location_t, tree, bool);
 extern void c_finish_case (tree, tree);
-extern tree build_asm_expr (location_t, tree, tree, tree, tree, tree, bool);
-extern tree build_asm_stmt (tree, tree);
+extern tree build_asm_expr (location_t, tree, tree, tree, tree, tree, bool,
+			    bool);
+extern tree build_asm_stmt (bool, tree);
 extern int c_types_compatible_p (tree, tree);
 extern tree c_begin_compound_stmt (bool);
 extern tree c_end_compound_stmt (location_t, tree, bool);
diff --git a/gcc/c/c-typeck.c b/gcc/c/c-typeck.c
index ee365313c81..fd9fa2d5a19 100644
--- a/gcc/c/c-typeck.c
+++ b/gcc/c/c-typeck.c
@@ -4638,7 +4638,7 @@ build_unary_op (location_t location, enum tree_code code, tree xarg,
       if (val && INDIRECT_REF_P (val)
           && TREE_CONSTANT (TREE_OPERAND (val, 0)))
 	{
-	  ret = fold_convert_loc (location, argtype, fold_offsetof_1 (arg));
+	  ret = fold_offsetof (arg, argtype);
 	  goto return_build_unary_op;
 	}
 
@@ -9669,9 +9669,9 @@ process_init_element (location_t loc, struct c_expr value, bool implicit,
    (guaranteed to be 'volatile' or null) and ARGS (represented using
    an ASM_EXPR node).  */
 tree
-build_asm_stmt (tree cv_qualifier, tree args)
+build_asm_stmt (bool is_volatile, tree args)
 {
-  if (!ASM_VOLATILE_P (args) && cv_qualifier)
+  if (is_volatile)
     ASM_VOLATILE_P (args) = 1;
   return add_stmt (args);
 }
@@ -9680,10 +9680,12 @@ build_asm_stmt (tree cv_qualifier, tree args)
    some INPUTS, and some CLOBBERS.  The latter three may be NULL.
    SIMPLE indicates whether there was anything at all after the
    string in the asm expression -- asm("blah") and asm("blah" : )
-   are subtly different.  We use a ASM_EXPR node to represent this.  */
+   are subtly different.  We use a ASM_EXPR node to represent this.
+   LOC is the location of the asm, and IS_INLINE says whether this
+   is asm inline.  */
 tree
 build_asm_expr (location_t loc, tree string, tree outputs, tree inputs,
-		tree clobbers, tree labels, bool simple)
+		tree clobbers, tree labels, bool simple, bool is_inline)
 {
   tree tail;
   tree args;
@@ -9801,6 +9803,7 @@ build_asm_expr (location_t loc, tree string, tree outputs, tree inputs,
      as volatile.  */
   ASM_INPUT_P (args) = simple;
   ASM_VOLATILE_P (args) = (noutputs == 0);
+  ASM_INLINE_P (args) = is_inline;
 
   return args;
 }
@@ -11150,7 +11153,8 @@ build_binary_op (location_t location, enum tree_code code,
 	  converted = 1;
 	}
       else if ((code0 == INTEGER_TYPE || code0 == FIXED_POINT_TYPE
-		|| code0 == VECTOR_TYPE)
+		|| (code0 == VECTOR_TYPE
+		    && TREE_CODE (TREE_TYPE (type0)) == INTEGER_TYPE))
 	       && code1 == INTEGER_TYPE)
 	{
 	  doing_shift = true;
@@ -11207,7 +11211,8 @@ build_binary_op (location_t location, enum tree_code code,
 	  converted = 1;
 	}
       else if ((code0 == INTEGER_TYPE || code0 == FIXED_POINT_TYPE
-		|| code0 == VECTOR_TYPE)
+		|| (code0 == VECTOR_TYPE
+		    && TREE_CODE (TREE_TYPE (type0)) == INTEGER_TYPE))
 	       && code1 == INTEGER_TYPE)
 	{
 	  doing_shift = true;
@@ -11299,6 +11304,13 @@ build_binary_op (location_t location, enum tree_code code,
           /* Always construct signed integer vector type.  */
           intt = c_common_type_for_size (GET_MODE_BITSIZE
 					   (TYPE_MODE (TREE_TYPE (type0))), 0);
+	  if (!intt)
+	    {
+	      error_at (location, "could not find an integer type "
+				  "of the same size as %qT",
+			TREE_TYPE (type0));
+	      return error_mark_node;
+	    }
           result_type = build_opaque_vector_type (intt,
 						  TYPE_VECTOR_SUBPARTS (type0));
           converted = 1;
@@ -11458,6 +11470,13 @@ build_binary_op (location_t location, enum tree_code code,
           /* Always construct signed integer vector type.  */
           intt = c_common_type_for_size (GET_MODE_BITSIZE
 					   (TYPE_MODE (TREE_TYPE (type0))), 0);
+	  if (!intt)
+	    {
+	      error_at (location, "could not find an integer type "
+				  "of the same size as %qT",
+			TREE_TYPE (type0));
+	      return error_mark_node;
+	    }
           result_type = build_opaque_vector_type (intt,
 						  TYPE_VECTOR_SUBPARTS (type0));
           converted = 1;
@@ -13744,22 +13763,11 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)
 
 	      if (VAR_P (t) && DECL_THREAD_LOCAL_P (t))
 		share_name = "threadprivate";
-	      else switch (c_omp_predetermined_sharing (t))
+	      else if (TREE_READONLY (t))
 		{
-		case OMP_CLAUSE_DEFAULT_UNSPECIFIED:
-		  break;
-		case OMP_CLAUSE_DEFAULT_SHARED:
 		  /* const vars may be specified in firstprivate clause.  */
-		  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_FIRSTPRIVATE
-		      && TREE_READONLY (t))
-		    break;
-		  share_name = "shared";
-		  break;
-		case OMP_CLAUSE_DEFAULT_PRIVATE:
-		  share_name = "private";
-		  break;
-		default:
-		  gcc_unreachable ();
+		  if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_FIRSTPRIVATE)
+		    share_name = "shared";
 		}
 	      if (share_name)
 		{
diff --git a/gcc/calls.c b/gcc/calls.c
index b183be63dd4..8eec155cf7d 100644
--- a/gcc/calls.c
+++ b/gcc/calls.c
@@ -1196,65 +1196,79 @@ static GTY(()) tree alloc_object_size_limit;
 static tree
 alloc_max_size (void)
 {
-  if (!alloc_object_size_limit)
-    {
-      alloc_object_size_limit = TYPE_MAX_VALUE (ssizetype);
+  if (alloc_object_size_limit)
+    return alloc_object_size_limit;
 
-      if (warn_alloc_size_limit)
-	{
-	  char *end = NULL;
-	  errno = 0;
-	  unsigned HOST_WIDE_INT unit = 1;
-	  unsigned HOST_WIDE_INT limit
-	    = strtoull (warn_alloc_size_limit, &end, 10);
+  alloc_object_size_limit = TYPE_MAX_VALUE (ssizetype);
 
-	  if (!errno)
-	    {
-	      if (end && *end)
-		{
-		  /* Numeric option arguments are at most INT_MAX.  Make it
-		     possible to specify a larger value by accepting common
-		     suffixes.  */
-		  if (!strcmp (end, "kB"))
-		    unit = 1000;
-		  else if (!strcasecmp (end, "KiB") || strcmp (end, "KB"))
-		    unit = 1024;
-		  else if (!strcmp (end, "MB"))
-		    unit = HOST_WIDE_INT_UC (1000) * 1000;
-		  else if (!strcasecmp (end, "MiB"))
-		    unit = HOST_WIDE_INT_UC (1024) * 1024;
-		  else if (!strcasecmp (end, "GB"))
-		    unit = HOST_WIDE_INT_UC (1000) * 1000 * 1000;
-		  else if (!strcasecmp (end, "GiB"))
-		    unit = HOST_WIDE_INT_UC (1024) * 1024 * 1024;
-		  else if (!strcasecmp (end, "TB"))
-		    unit = HOST_WIDE_INT_UC (1000) * 1000 * 1000 * 1000;
-		  else if (!strcasecmp (end, "TiB"))
-		    unit = HOST_WIDE_INT_UC (1024) * 1024 * 1024 * 1024;
-		  else if (!strcasecmp (end, "PB"))
-		    unit = HOST_WIDE_INT_UC (1000) * 1000 * 1000 * 1000 * 1000;
-		  else if (!strcasecmp (end, "PiB"))
-		    unit = HOST_WIDE_INT_UC (1024) * 1024 * 1024 * 1024 * 1024;
-		  else if (!strcasecmp (end, "EB"))
-		    unit = HOST_WIDE_INT_UC (1000) * 1000 * 1000 * 1000 * 1000
-			   * 1000;
-		  else if (!strcasecmp (end, "EiB"))
-		    unit = HOST_WIDE_INT_UC (1024) * 1024 * 1024 * 1024 * 1024
-			   * 1024;
-		  else
-		    unit = 0;
-		}
+  if (!warn_alloc_size_limit)
+    return alloc_object_size_limit;
 
-	      if (unit)
-		{
-		  wide_int w = wi::uhwi (limit, HOST_BITS_PER_WIDE_INT + 64);
-		  w *= unit;
-		  if (wi::ltu_p (w, alloc_object_size_limit))
-		    alloc_object_size_limit = wide_int_to_tree (ssizetype, w);
-		}
-	    }
+  const char *optname = "-Walloc-size-larger-than=";
+
+  char *end = NULL;
+  errno = 0;
+  unsigned HOST_WIDE_INT unit = 1;
+  unsigned HOST_WIDE_INT limit
+    = strtoull (warn_alloc_size_limit, &end, 10);
+
+  /* If the value is too large to be represented use the maximum
+     representable value that strtoull sets limit to (setting
+     errno to ERANGE).  */
+
+  if (end && *end)
+    {
+      /* Numeric option arguments are at most INT_MAX.  Make it
+	 possible to specify a larger value by accepting common
+	 suffixes.  */
+      if (!strcmp (end, "kB"))
+	unit = 1000;
+      else if (!strcasecmp (end, "KiB") || !strcmp (end, "KB"))
+	unit = 1024;
+      else if (!strcmp (end, "MB"))
+	unit = HOST_WIDE_INT_UC (1000) * 1000;
+      else if (!strcasecmp (end, "MiB"))
+	unit = HOST_WIDE_INT_UC (1024) * 1024;
+      else if (!strcasecmp (end, "GB"))
+	unit = HOST_WIDE_INT_UC (1000) * 1000 * 1000;
+      else if (!strcasecmp (end, "GiB"))
+	unit = HOST_WIDE_INT_UC (1024) * 1024 * 1024;
+      else if (!strcasecmp (end, "TB"))
+	unit = HOST_WIDE_INT_UC (1000) * 1000 * 1000 * 1000;
+      else if (!strcasecmp (end, "TiB"))
+	unit = HOST_WIDE_INT_UC (1024) * 1024 * 1024 * 1024;
+      else if (!strcasecmp (end, "PB"))
+	unit = HOST_WIDE_INT_UC (1000) * 1000 * 1000 * 1000 * 1000;
+      else if (!strcasecmp (end, "PiB"))
+	unit = HOST_WIDE_INT_UC (1024) * 1024 * 1024 * 1024 * 1024;
+      else if (!strcasecmp (end, "EB"))
+	unit = HOST_WIDE_INT_UC (1000) * 1000 * 1000 * 1000 * 1000
+	  * 1000;
+      else if (!strcasecmp (end, "EiB"))
+	unit = HOST_WIDE_INT_UC (1024) * 1024 * 1024 * 1024 * 1024
+	  * 1024;
+      else
+	{
+	  /* This could mean an unknown suffix or a bad prefix, like
+	     "+-1".  */
+	  warning_at (UNKNOWN_LOCATION, 0,
+		      "invalid argument %qs to %qs",
+		      warn_alloc_size_limit, optname);
+	  /* Ignore the limit extracted by strtoull.  */
+	  unit = 0;
 	}
     }
+
+  if (unit)
+    {
+      widest_int w = wi::mul (limit, unit);
+      if (w < wi::to_widest (alloc_object_size_limit))
+	alloc_object_size_limit
+	  = wide_int_to_tree (ptrdiff_type_node, w);
+      else
+	alloc_object_size_limit = build_all_ones_cst (size_type_node);
+    }
+
   return alloc_object_size_limit;
 }
 
@@ -3133,9 +3147,14 @@ expand_call (tree exp, rtx target, int ignore)
 	if (CALL_EXPR_RETURN_SLOT_OPT (exp)
 	    && target
 	    && MEM_P (target)
-	    && !(MEM_ALIGN (target) < TYPE_ALIGN (rettype)
-		 && SLOW_UNALIGNED_ACCESS (TYPE_MODE (rettype),
-					   MEM_ALIGN (target))))
+	    /* If rettype is addressable, we may not create a temporary.
+	       If target is properly aligned at runtime and the compiler
+	       just doesn't know about it, it will work fine, otherwise it
+	       will be UB.  */
+	    && (TREE_ADDRESSABLE (rettype)
+		|| !(MEM_ALIGN (target) < TYPE_ALIGN (rettype)
+		     && SLOW_UNALIGNED_ACCESS (TYPE_MODE (rettype),
+					       MEM_ALIGN (target)))))
 	  structure_value_addr = XEXP (target, 0);
 	else
 	  {
diff --git a/gcc/cfgexpand.c b/gcc/cfgexpand.c
index 66af69973c6..7fd3916a3c7 100644
--- a/gcc/cfgexpand.c
+++ b/gcc/cfgexpand.c
@@ -1252,10 +1252,10 @@ set_parm_rtl (tree parm, rtx x)
 	 allocate it, which means that in-frame portion is just a
 	 pointer.  ??? We've got a pseudo for sure here, do we
 	 actually dynamically allocate its spilling area if needed?
-	 ??? Isn't it a problem when POINTER_SIZE also exceeds
-	 MAX_SUPPORTED_STACK_ALIGNMENT, as on cris and lm32?  */
+	 ??? Isn't it a problem when Pmode alignment also exceeds
+	 MAX_SUPPORTED_STACK_ALIGNMENT, as can happen on cris and lm32?  */
       if (align > MAX_SUPPORTED_STACK_ALIGNMENT)
-	align = POINTER_SIZE;
+	align = GET_MODE_ALIGNMENT (Pmode);
 
       record_alignment_for_reg_var (align);
     }
@@ -1375,7 +1375,7 @@ expand_one_ssa_partition (tree var)
   /* If the variable alignment is very large we'll dynamicaly allocate
      it, which means that in-frame portion is just a pointer.  */
   if (align > MAX_SUPPORTED_STACK_ALIGNMENT)
-    align = POINTER_SIZE;
+    align = GET_MODE_ALIGNMENT (Pmode);
 
   record_alignment_for_reg_var (align);
 
@@ -1592,7 +1592,7 @@ expand_one_var (tree var, bool toplevel, bool really_expand)
       /* If the variable alignment is very large we'll dynamicaly allocate
 	 it, which means that in-frame portion is just a pointer.  */
       if (align > MAX_SUPPORTED_STACK_ALIGNMENT)
-	align = POINTER_SIZE;
+	align = GET_MODE_ALIGNMENT (Pmode);
     }
 
   record_alignment_for_reg_var (align);
@@ -2997,14 +2997,14 @@ expand_asm_stmt (gasm *stmt)
 
       generating_concat_p = 0;
 
-      if ((TREE_CODE (val) == INDIRECT_REF
-	   && allows_mem)
+      if ((TREE_CODE (val) == INDIRECT_REF && allows_mem)
 	  || (DECL_P (val)
 	      && (allows_mem || REG_P (DECL_RTL (val)))
 	      && ! (REG_P (DECL_RTL (val))
 		    && GET_MODE (DECL_RTL (val)) != TYPE_MODE (type)))
 	  || ! allows_reg
-	  || is_inout)
+	  || is_inout
+	  || TREE_ADDRESSABLE (type))
 	{
 	  op = expand_expr (val, NULL_RTX, VOIDmode,
 			    !allows_reg ? EXPAND_MEMORY : EXPAND_WRITE);
@@ -3013,7 +3013,7 @@ expand_asm_stmt (gasm *stmt)
 
 	  if (! allows_reg && !MEM_P (op))
 	    error ("output number %d not directly addressable", i);
-	  if ((! allows_mem && MEM_P (op))
+	  if ((! allows_mem && MEM_P (op) && GET_MODE (op) != BLKmode)
 	      || GET_CODE (op) == CONCAT)
 	    {
 	      rtx old_op = op;
@@ -6466,6 +6466,14 @@ pass_expand::execute (function *fun)
   find_many_sub_basic_blocks (blocks);
   purge_all_dead_edges ();
 
+  /* After initial rtl generation, call back to finish generating
+     exception support code.  We need to do this before cleaning up
+     the CFG as the code does not expect dead landing pads.  */
+  if (fun->eh->region_tree != NULL)
+    finish_eh_generation ();
+
+  /* Call expand_stack_alignment after finishing all
+     updates to crtl->preferred_stack_boundary.  */
   expand_stack_alignment ();
 
   /* Fixup REG_EQUIV notes in the prologue if there are tailcalls in this
@@ -6473,12 +6481,6 @@ pass_expand::execute (function *fun)
   if (crtl->tail_call_emit)
     fixup_tail_calls ();
 
-  /* After initial rtl generation, call back to finish generating
-     exception support code.  We need to do this before cleaning up
-     the CFG as the code does not expect dead landing pads.  */
-  if (fun->eh->region_tree != NULL)
-    finish_eh_generation ();
-
   /* Remove unreachable blocks, otherwise we cannot compute dominators
      which are needed for loop state verification.  As a side-effect
      this also compacts blocks.
diff --git a/gcc/cgraph.h b/gcc/cgraph.h
index be4eaee71e2..ee053885442 100644
--- a/gcc/cgraph.h
+++ b/gcc/cgraph.h
@@ -321,6 +321,9 @@ public:
      or abstract function kept for debug info purposes only.  */
   bool real_symbol_p (void);
 
+  /* Return true when the symbol needs to be output to the LTO symbol table.  */
+  bool output_to_lto_symbol_table_p (void);
+
   /* Determine if symbol declaration is needed.  That is, visible to something
      either outside this translation unit, something magic in the system
      configury. This function is used just during symbol creation.  */
diff --git a/gcc/collect2.c b/gcc/collect2.c
index ddbd2be8bf8..319fcb31e3f 100644
--- a/gcc/collect2.c
+++ b/gcc/collect2.c
@@ -1,6 +1,6 @@
 /* Collect static initialization info into data structures that can be
    traversed by C++ initialization and finalization routines.
-   Copyright (C) 1992-2017 Free Software Foundation, Inc.
+   Copyright (C) 1992-2018 Free Software Foundation, Inc.
    Contributed by Chris Smith (csmith@convex.com).
    Heavily modified by Michael Meissner (meissner@cygnus.com),
    Per Bothner (bothner@cygnus.com), and John Gilmore (gnu@cygnus.com).
@@ -201,6 +201,7 @@ static enum lto_mode_d lto_mode = LTO_MODE_NONE;
 bool helpflag;			/* true if --help */
 
 static int shared_obj;			/* true if -shared */
+static int static_obj;			/* true if -static */
 
 static const char *c_file;		/* <xxx>.c for constructor/destructor list.  */
 static const char *o_file;		/* <xxx>.o for constructor/destructor list.  */
@@ -255,6 +256,7 @@ bool may_unlink_output_file = false;
 #ifdef COLLECT_EXPORT_LIST
 /* Lists to keep libraries to be scanned for global constructors/destructors.  */
 static struct head libs;                    /* list of libraries */
+static struct head static_libs;             /* list of statically linked libraries */
 static struct path_prefix cmdline_lib_dirs; /* directories specified with -L */
 static struct path_prefix libpath_lib_dirs; /* directories in LIBPATH */
 static struct path_prefix *libpaths[3] = {&cmdline_lib_dirs,
@@ -320,9 +322,7 @@ static void write_c_file_glob (FILE *, const char *);
 static void scan_libraries (const char *);
 #endif
 #ifdef COLLECT_EXPORT_LIST
-#if 0
 static int is_in_list (const char *, struct id *);
-#endif
 static void write_aix_file (FILE *, struct id *);
 static char *resolve_lib_name (const char *);
 #endif
@@ -911,6 +911,9 @@ main (int argc, char **argv)
   int first_file;
   int num_c_args;
   char **old_argv;
+#ifdef COLLECT_EXPORT_LIST
+  bool is_static = false;
+#endif
   int i;
 
   for (i = 0; i < USE_LD_MAX; i++)
@@ -1241,6 +1244,8 @@ main (int argc, char **argv)
 	*c_ptr++ = xstrdup (q);
       if (strcmp (q, "-shared") == 0)
 	shared_obj = 1;
+      if (strcmp (q, "-static") == 0)
+	static_obj = 1;
       if (*q == '-' && q[1] == 'B')
 	{
 	  *c_ptr++ = xstrdup (q);
@@ -1269,6 +1274,9 @@ main (int argc, char **argv)
   /* Parse arguments.  Remember output file spec, pass the rest to ld.  */
   /* After the first file, put in the c++ rt0.  */
 
+#ifdef COLLECT_EXPORT_LIST
+  is_static = static_obj;
+#endif
   first_file = 1;
   while ((arg = *++argv) != (char *) 0)
     {
@@ -1374,6 +1382,18 @@ main (int argc, char **argv)
 #endif
               break;
 
+#ifdef COLLECT_EXPORT_LIST
+	    case 'b':
+	      if (!strcmp (arg, "-bstatic"))
+		{
+		  is_static = true;
+		}
+	      else if (!strcmp (arg, "-bdynamic") || !strcmp (arg, "-bshared"))
+		{
+		  is_static = false;
+		}
+	      break;
+#endif
 	    case 'l':
 	      if (first_file)
 		{
@@ -1390,6 +1410,8 @@ main (int argc, char **argv)
 
 		/* Saving a full library name.  */
 		add_to_list (&libs, s);
+		if (is_static)
+		    add_to_list (&static_libs, s);
 	      }
 #endif
 	      break;
@@ -1490,6 +1512,8 @@ main (int argc, char **argv)
 	    {
 	      /* Saving a full library name.  */
 	      add_to_list (&libs, arg);
+	      if (is_static)
+		add_to_list (&static_libs, arg);
 	    }
 #endif
 	}
@@ -1501,6 +1525,8 @@ main (int argc, char **argv)
     {
       fprintf (stderr, "List of libraries:\n");
       dump_list (stderr, "\t", libs.first);
+      fprintf (stderr, "List of statically linked libraries:\n");
+      dump_list (stderr, "\t", static_libs.first);
     }
 
   /* The AIX linker will discard static constructors in object files if
@@ -1525,9 +1551,11 @@ main (int argc, char **argv)
       this_filter &= ~SCAN_DWEH;
 #endif
 
+    /* Scan object files.  */
     while (export_object_lst < object)
       scan_prog_file (*export_object_lst++, PASS_OBJ, this_filter);
 
+    /* Scan libraries.  */
     for (; list; list = list->next)
       scan_prog_file (list->name, PASS_FIRST, this_filter);
 
@@ -1975,7 +2003,6 @@ write_list (FILE *stream, const char *prefix, struct id *list)
 
 #ifdef COLLECT_EXPORT_LIST
 /* This function is really used only on AIX, but may be useful.  */
-#if 0
 static int
 is_in_list (const char *prefix, struct id *list)
 {
@@ -1986,7 +2013,6 @@ is_in_list (const char *prefix, struct id *list)
     }
     return 0;
 }
-#endif
 #endif /* COLLECT_EXPORT_LIST */
 
 /* Added for debugging purpose.  */
@@ -2815,7 +2841,12 @@ scan_prog_file (const char *prog_name, scanpass which_pass,
 			case SYM_AIXI:
 			  if (! (filter & SCAN_CTOR))
 			    break;
-			  if (is_shared && !aixlazy_flag)
+			  if (is_shared && !aixlazy_flag
+#ifdef COLLECT_EXPORT_LIST
+			      && ! static_obj
+			      && ! is_in_list (prog_name, static_libs.first)
+#endif
+			      )
 			    add_to_list (&constructors, name);
 			  break;
 
diff --git a/gcc/combine.c b/gcc/combine.c
index ff250aad6a1..56f7f491234 100644
--- a/gcc/combine.c
+++ b/gcc/combine.c
@@ -5482,11 +5482,15 @@ subst (rtx x, rtx from, rtx to, int in_dest, int in_cond, int unique_copy)
 		    x = gen_rtx_CLOBBER (mode, const0_rtx);
 		}
 	      else if (CONST_SCALAR_INT_P (new_rtx)
-		       && GET_CODE (x) == ZERO_EXTEND)
+		       && (GET_CODE (x) == ZERO_EXTEND
+			   || GET_CODE (x) == FLOAT
+			   || GET_CODE (x) == UNSIGNED_FLOAT))
 		{
-		  x = simplify_unary_operation (ZERO_EXTEND, GET_MODE (x),
-						new_rtx, GET_MODE (XEXP (x, 0)));
-		  gcc_assert (x);
+		  x = simplify_unary_operation (GET_CODE (x), GET_MODE (x),
+						new_rtx,
+						GET_MODE (XEXP (x, 0)));
+		  if (!x)
+		    return gen_rtx_CLOBBER (VOIDmode, const0_rtx);
 		}
 	      else
 		SUBST (XEXP (x, i), new_rtx);
@@ -5637,7 +5641,11 @@ combine_simplify_rtx (rtx x, machine_mode op0_mode, int in_dest,
 	  /* If everything is a comparison, what we have is highly unlikely
 	     to be simpler, so don't use it.  */
 	  && ! (COMPARISON_P (x)
-		&& (COMPARISON_P (true_rtx) || COMPARISON_P (false_rtx))))
+		&& (COMPARISON_P (true_rtx) || COMPARISON_P (false_rtx)))
+	  /* Similarly, if we end up with one of the expressions the same
+	     as the original, it is certainly not simpler.  */
+	  && ! rtx_equal_p (x, true_rtx)
+	  && ! rtx_equal_p (x, false_rtx))
 	{
 	  rtx cop1 = const0_rtx;
 	  enum rtx_code cond_code = simplify_comparison (NE, &cond, &cop1);
@@ -5799,8 +5807,9 @@ combine_simplify_rtx (rtx x, machine_mode op0_mode, int in_dest,
 	    && GET_MODE_PRECISION (mode) < GET_MODE_PRECISION (op0_mode)
 	    && subreg_lowpart_offset (mode, op0_mode) == SUBREG_BYTE (x)
 	    && HWI_COMPUTABLE_MODE_P (op0_mode)
-	    && (nonzero_bits (SUBREG_REG (x), op0_mode)
-		& GET_MODE_MASK (mode)) == 0)
+	    && ((nonzero_bits (SUBREG_REG (x), op0_mode)
+		 & GET_MODE_MASK (mode)) == 0)
+	    && !side_effects_p (SUBREG_REG (x)))
 	  return CONST0_RTX (mode);
       }
 
@@ -6325,7 +6334,7 @@ simplify_if_then_else (rtx x)
 			  pc_rtx, pc_rtx, 0, 0, 0);
       if (reg_mentioned_p (from, false_rtx))
 	false_rtx = subst (known_cond (copy_rtx (false_rtx), false_code,
-				   from, false_val),
+				       from, false_val),
 			   pc_rtx, pc_rtx, 0, 0, 0);
 
       SUBST (XEXP (x, 1), swapped ? false_rtx : true_rtx);
@@ -9179,6 +9188,7 @@ if_then_else_cond (rtx x, rtx *ptrue, rtx *pfalse)
 
 	  if (COMPARISON_P (cond0)
 	      && COMPARISON_P (cond1)
+	      && SCALAR_INT_MODE_P (mode)
 	      && ((GET_CODE (cond0) == reversed_comparison_code (cond1, NULL)
 		   && rtx_equal_p (XEXP (cond0, 0), XEXP (cond1, 0))
 		   && rtx_equal_p (XEXP (cond0, 1), XEXP (cond1, 1)))
@@ -9327,12 +9337,12 @@ known_cond (rtx x, enum rtx_code cond, rtx reg, rtx val)
 	  if (COMPARISON_P (x))
 	    {
 	      if (comparison_dominates_p (cond, code))
-		return const_true_rtx;
+		return VECTOR_MODE_P (GET_MODE (x)) ? x : const_true_rtx;
 
 	      code = reversed_comparison_code (x, NULL);
 	      if (code != UNKNOWN
 		  && comparison_dominates_p (cond, code))
-		return const0_rtx;
+		return CONST0_RTX (GET_MODE (x));
 	      else
 		return x;
 	    }
@@ -9375,7 +9385,7 @@ known_cond (rtx x, enum rtx_code cond, rtx reg, rtx val)
 	  /* We must simplify subreg here, before we lose track of the
 	     original inner_mode.  */
 	  new_rtx = simplify_subreg (GET_MODE (x), r,
-				 inner_mode, SUBREG_BYTE (x));
+				     inner_mode, SUBREG_BYTE (x));
 	  if (new_rtx)
 	    return new_rtx;
 	  else
@@ -9400,7 +9410,7 @@ known_cond (rtx x, enum rtx_code cond, rtx reg, rtx val)
 	  /* We must simplify the zero_extend here, before we lose
 	     track of the original inner_mode.  */
 	  new_rtx = simplify_unary_operation (ZERO_EXTEND, GET_MODE (x),
-					  r, inner_mode);
+					      r, inner_mode);
 	  if (new_rtx)
 	    return new_rtx;
 	  else
@@ -11322,8 +11332,15 @@ change_zero_ext (rtx pat)
 	    x = gen_rtx_LSHIFTRT (inner_mode, XEXP (x, 0), GEN_INT (start));
 	  else
 	    x = XEXP (x, 0);
+
 	  if (mode != inner_mode)
-	    x = gen_lowpart_SUBREG (mode, x);
+	    {
+	      if (REG_P (x) && HARD_REGISTER_P (x)
+		  && !can_change_dest_mode (x, 0, mode))
+		continue;
+
+	      x = gen_lowpart_SUBREG (mode, x);
+	    }
 	}
       else if (GET_CODE (x) == ZERO_EXTEND
 	       && SCALAR_INT_MODE_P (mode)
@@ -11335,7 +11352,13 @@ change_zero_ext (rtx pat)
 	  size = GET_MODE_PRECISION (GET_MODE (XEXP (x, 0)));
 	  x = SUBREG_REG (XEXP (x, 0));
 	  if (GET_MODE (x) != mode)
-	    x = gen_lowpart_SUBREG (mode, x);
+	    {
+	      if (REG_P (x) && HARD_REGISTER_P (x)
+		  && !can_change_dest_mode (x, 0, mode))
+		continue;
+
+	      x = gen_lowpart_SUBREG (mode, x);
+	    }
 	}
       else if (GET_CODE (x) == ZERO_EXTEND
 	       && SCALAR_INT_MODE_P (mode)
@@ -13081,8 +13104,11 @@ record_dead_and_set_regs_1 (rtx dest, const_rtx setter, void *data)
   if (REG_P (dest))
     {
       /* If we are setting the whole register, we know its value.  Otherwise
-	 show that we don't know the value.  We can handle SUBREG in
-	 some cases.  */
+	 show that we don't know the value.  We can handle a SUBREG if it's
+	 the low part, but we must be careful with paradoxical SUBREGs on
+	 RISC architectures because we cannot strip e.g. an extension around
+	 a load and record the naked load since the RTL middle-end considers
+	 that the upper bits are defined according to LOAD_EXTEND_OP.  */
       if (GET_CODE (setter) == SET && dest == SET_DEST (setter))
 	record_value_for_reg (dest, record_dead_insn, SET_SRC (setter));
       else if (GET_CODE (setter) == SET
@@ -13091,8 +13117,12 @@ record_dead_and_set_regs_1 (rtx dest, const_rtx setter, void *data)
 	       && GET_MODE_PRECISION (GET_MODE (dest)) <= BITS_PER_WORD
 	       && subreg_lowpart_p (SET_DEST (setter)))
 	record_value_for_reg (dest, record_dead_insn,
-			      gen_lowpart (GET_MODE (dest),
-						       SET_SRC (setter)));
+			      WORD_REGISTER_OPERATIONS
+			      && word_register_operation_p (SET_SRC (setter))
+			      && paradoxical_subreg_p (SET_DEST (setter))
+			      ? SET_SRC (setter)
+			      : gen_lowpart (GET_MODE (dest),
+					     SET_SRC (setter)));
       else
 	record_value_for_reg (dest, record_dead_insn, NULL_RTX);
     }
diff --git a/gcc/config.gcc b/gcc/config.gcc
index 6e75bd45fb9..3e41aa5b764 100644
--- a/gcc/config.gcc
+++ b/gcc/config.gcc
@@ -1461,7 +1461,7 @@ x86_64-*-elf*)
 	tm_file="${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h newlib-stdint.h i386/i386elf.h i386/x86-64.h"
 	;;
 x86_64-*-rtems*)
-	tm_file="${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h newlib-stdint.h i386/i386elf.h i386/x86-64.h i386/rtemself.h"
+	tm_file="${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h newlib-stdint.h i386/i386elf.h i386/x86-64.h i386/rtemself.h rtems.h"
 	;;
 i[34567]86-*-rdos*)
     tm_file="${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h newlib-stdint.h i386/i386elf.h i386/rdos.h"
@@ -2046,10 +2046,17 @@ riscv*-*-linux*)
 	;;
 riscv*-*-elf* | riscv*-*-rtems*)
 	tm_file="elfos.h newlib-stdint.h ${tm_file} riscv/elf.h"
-	case "x${enable_multilib}" in
-	xno) ;;
-	xyes) tmake_file="${tmake_file} riscv/t-elf-multilib" ;;
-	*) echo "Unknown value for enable_multilib"; exit 1
+	case ${target} in
+	*-*-rtems*)
+	  tm_file="${tm_file} rtems.h riscv/rtems.h"
+	  tmake_file="${tmake_file} riscv/t-rtems"
+	  ;;
+	*)
+	  case "x${enable_multilib}" in
+	  xno) ;;
+	  xyes) tmake_file="${tmake_file} riscv/t-elf-multilib" ;;
+	  *) echo "Unknown value for enable_multilib"; exit 1
+	  esac
 	esac
 	tmake_file="${tmake_file} riscv/t-riscv"
 	gnu_ld=yes
@@ -2057,11 +2064,6 @@ riscv*-*-elf* | riscv*-*-rtems*)
 	# Force .init_array support.  The configure script cannot always
 	# automatically detect that GAS supports it, yet we require it.
 	gcc_cv_initfini_array=yes
-	case ${target} in
-	riscv*-*-rtems*)
-	  tm_file="${tm_file} rtems.h riscv/rtems.h"
-	  ;;
-	esac
 	;;
 mips*-*-netbsd*)			# NetBSD/mips, either endian.
 	target_cpu_default="MASK_ABICALLS"
diff --git a/gcc/config/aarch64/aarch64-c.c b/gcc/config/aarch64/aarch64-c.c
index 177e638682f..9979e06daaf 100644
--- a/gcc/config/aarch64/aarch64-c.c
+++ b/gcc/config/aarch64/aarch64-c.c
@@ -134,6 +134,8 @@ aarch64_update_cpp_builtins (cpp_reader *pfile)
   aarch64_def_or_undef (TARGET_CRYPTO, "__ARM_FEATURE_CRYPTO", pfile);
   aarch64_def_or_undef (TARGET_SIMD_RDMA, "__ARM_FEATURE_QRDMX", pfile);
 
+  aarch64_def_or_undef (TARGET_LSE, "__ARM_FEATURE_ATOMICS", pfile);
+
   /* Not for ACLE, but required to keep "float.h" correct if we switch
      target between implementations that do or do not support ARMv8.2-A
      16-bit floating-point extensions.  */
diff --git a/gcc/config/aarch64/aarch64-simd.md b/gcc/config/aarch64/aarch64-simd.md
index c4621643452..9ddf43eda5e 100644
--- a/gcc/config/aarch64/aarch64-simd.md
+++ b/gcc/config/aarch64/aarch64-simd.md
@@ -2462,10 +2462,10 @@
 	  break;
 	}
       /* Fall through.  */
-    case UNGE:
+    case UNLT:
       std::swap (operands[2], operands[3]);
       /* Fall through.  */
-    case UNLE:
+    case UNGT:
     case GT:
       comparison = gen_aarch64_cmgt<mode>;
       break;
@@ -2476,10 +2476,10 @@
 	  break;
 	}
       /* Fall through.  */
-    case UNGT:
+    case UNLE:
       std::swap (operands[2], operands[3]);
       /* Fall through.  */
-    case UNLT:
+    case UNGE:
     case GE:
       comparison = gen_aarch64_cmge<mode>;
       break;
@@ -2490,6 +2490,7 @@
     case UNEQ:
     case ORDERED:
     case UNORDERED:
+    case LTGT:
       break;
     default:
       gcc_unreachable ();
@@ -2501,21 +2502,35 @@
     case UNGT:
     case UNLE:
     case UNLT:
-    case NE:
-      /* FCM returns false for lanes which are unordered, so if we use
-	 the inverse of the comparison we actually want to emit, then
-	 invert the result, we will end up with the correct result.
-	 Note that a NE NaN and NaN NE b are true for all a, b.
-
-	 Our transformations are:
-	 a UNGE b -> !(b GT a)
-	 a UNGT b -> !(b GE a)
-	 a UNLE b -> !(a GT b)
-	 a UNLT b -> !(a GE b)
-	 a   NE b -> !(a EQ b)  */
-      gcc_assert (comparison != NULL);
-      emit_insn (comparison (operands[0], operands[2], operands[3]));
-      emit_insn (gen_one_cmpl<v_cmp_result>2 (operands[0], operands[0]));
+      {
+	/* All of the above must not raise any FP exceptions.  Thus we first
+	   check each operand for NaNs and force any elements containing NaN to
+	   zero before using them in the compare.
+	   Example: UN<cc> (a, b) -> UNORDERED (a, b) |
+				     (cm<cc> (isnan (a) ? 0.0 : a,
+					      isnan (b) ? 0.0 : b))
+	   We use the following transformations for doing the comparisions:
+	   a UNGE b -> a GE b
+	   a UNGT b -> a GT b
+	   a UNLE b -> b GE a
+	   a UNLT b -> b GT a.  */
+
+	rtx tmp0 = gen_reg_rtx (<V_cmp_result>mode);
+	rtx tmp1 = gen_reg_rtx (<V_cmp_result>mode);
+	rtx tmp2 = gen_reg_rtx (<V_cmp_result>mode);
+	emit_insn (gen_aarch64_cmeq<mode> (tmp0, operands[2], operands[2]));
+	emit_insn (gen_aarch64_cmeq<mode> (tmp1, operands[3], operands[3]));
+	emit_insn (gen_and<v_cmp_result>3 (tmp2, tmp0, tmp1));
+	emit_insn (gen_and<v_cmp_result>3 (tmp0, tmp0,
+			lowpart_subreg (<V_cmp_result>mode, operands[2], <MODE>mode)));
+	emit_insn (gen_and<v_cmp_result>3 (tmp1, tmp1,
+			lowpart_subreg (<V_cmp_result>mode, operands[3], <MODE>mode)));
+	gcc_assert (comparison != NULL);
+	emit_insn (comparison (operands[0],
+			       lowpart_subreg (<MODE>mode, tmp0, <V_cmp_result>mode),
+			       lowpart_subreg (<MODE>mode, tmp1, <V_cmp_result>mode)));
+	emit_insn (gen_orn<v_cmp_result>3 (operands[0], tmp2, operands[0]));
+      }
       break;
 
     case LT:
@@ -2523,42 +2538,46 @@
     case GT:
     case GE:
     case EQ:
+    case NE:
       /* The easy case.  Here we emit one of FCMGE, FCMGT or FCMEQ.
 	 As a LT b <=> b GE a && a LE b <=> b GT a.  Our transformations are:
 	 a GE b -> a GE b
 	 a GT b -> a GT b
 	 a LE b -> b GE a
 	 a LT b -> b GT a
-	 a EQ b -> a EQ b  */
+	 a EQ b -> a EQ b
+	 a NE b -> ~(a EQ b)  */
       gcc_assert (comparison != NULL);
       emit_insn (comparison (operands[0], operands[2], operands[3]));
+      if (code == NE)
+	emit_insn (gen_one_cmpl<v_cmp_result>2 (operands[0], operands[0]));
       break;
 
-    case UNEQ:
-      /* We first check (a > b ||  b > a) which is !UNEQ, inverting
-	 this result will then give us (a == b || a UNORDERED b).  */
+    case LTGT:
+      /* LTGT is not guranteed to not generate a FP exception.  So let's
+	 go the faster way : ((a > b) || (b > a)).  */
       emit_insn (gen_aarch64_cmgt<mode> (operands[0],
 					 operands[2], operands[3]));
       emit_insn (gen_aarch64_cmgt<mode> (tmp, operands[3], operands[2]));
       emit_insn (gen_ior<v_cmp_result>3 (operands[0], operands[0], tmp));
-      emit_insn (gen_one_cmpl<v_cmp_result>2 (operands[0], operands[0]));
-      break;
-
-    case UNORDERED:
-      /* Operands are ORDERED iff (a > b || b >= a), so we can compute
-	 UNORDERED as !ORDERED.  */
-      emit_insn (gen_aarch64_cmgt<mode> (tmp, operands[2], operands[3]));
-      emit_insn (gen_aarch64_cmge<mode> (operands[0],
-					 operands[3], operands[2]));
-      emit_insn (gen_ior<v_cmp_result>3 (operands[0], operands[0], tmp));
-      emit_insn (gen_one_cmpl<v_cmp_result>2 (operands[0], operands[0]));
       break;
 
     case ORDERED:
-      emit_insn (gen_aarch64_cmgt<mode> (tmp, operands[2], operands[3]));
-      emit_insn (gen_aarch64_cmge<mode> (operands[0],
-					 operands[3], operands[2]));
-      emit_insn (gen_ior<v_cmp_result>3 (operands[0], operands[0], tmp));
+    case UNORDERED:
+    case UNEQ:
+      /* cmeq (a, a) & cmeq (b, b).  */
+      emit_insn (gen_aarch64_cmeq<mode> (operands[0],
+					 operands[2], operands[2]));
+      emit_insn (gen_aarch64_cmeq<mode> (tmp, operands[3], operands[3]));
+      emit_insn (gen_and<v_cmp_result>3 (operands[0], operands[0], tmp));
+
+      if (code == UNORDERED)
+	emit_insn (gen_one_cmpl<v_cmp_result>2 (operands[0], operands[0]));
+      else if (code == UNEQ)
+	{
+	  emit_insn (gen_aarch64_cmeq<mode> (tmp, operands[2], operands[3]));
+	  emit_insn (gen_orn<v_cmp_result>3 (operands[0], operands[0], tmp));
+	}
       break;
 
     default:
diff --git a/gcc/config/aarch64/aarch64.c b/gcc/config/aarch64/aarch64.c
index 436091af934..4e94be3b0b4 100644
--- a/gcc/config/aarch64/aarch64.c
+++ b/gcc/config/aarch64/aarch64.c
@@ -4664,13 +4664,13 @@ aarch64_select_cc_mode (RTX_CODE code, rtx x, rtx y)
 	case UNGT:
 	case UNGE:
 	case UNEQ:
-	case LTGT:
 	  return CCFPmode;
 
 	case LT:
 	case LE:
 	case GT:
 	case GE:
+	case LTGT:
 	  return CCFPEmode;
 
 	default:
@@ -5721,7 +5721,7 @@ aarch64_class_max_nregs (reg_class_t regclass, machine_mode mode)
 {
   switch (regclass)
     {
-    case CALLER_SAVE_REGS:
+    case TAILCALL_ADDR_REGS:
     case POINTER_REGS:
     case GENERAL_REGS:
     case ALL_REGS:
@@ -5804,7 +5804,7 @@ aarch64_elf_asm_constructor (rtx symbol, int priority)
          -Wformat-truncation false positive, use a larger size.  */
       char buf[23];
       snprintf (buf, sizeof (buf), ".init_array.%.5u", priority);
-      s = get_section (buf, SECTION_WRITE, NULL);
+      s = get_section (buf, SECTION_WRITE | SECTION_NOTYPE, NULL);
       switch_to_section (s);
       assemble_align (POINTER_SIZE);
       assemble_aligned_integer (POINTER_BYTES, symbol);
@@ -5824,7 +5824,7 @@ aarch64_elf_asm_destructor (rtx symbol, int priority)
          -Wformat-truncation false positive, use a larger size.  */
       char buf[23];
       snprintf (buf, sizeof (buf), ".fini_array.%.5u", priority);
-      s = get_section (buf, SECTION_WRITE, NULL);
+      s = get_section (buf, SECTION_WRITE | SECTION_NOTYPE, NULL);
       switch_to_section (s);
       assemble_align (POINTER_SIZE);
       assemble_aligned_integer (POINTER_BYTES, symbol);
@@ -6536,7 +6536,8 @@ aarch64_mask_and_shift_for_ubfiz_p (machine_mode mode, rtx mask, rtx shft_amnt)
   return CONST_INT_P (mask) && CONST_INT_P (shft_amnt)
 	 && INTVAL (shft_amnt) < GET_MODE_BITSIZE (mode)
 	 && exact_log2 ((INTVAL (mask) >> INTVAL (shft_amnt)) + 1) >= 0
-	 && (INTVAL (mask) & ((1 << INTVAL (shft_amnt)) - 1)) == 0;
+	 && (INTVAL (mask)
+	     & ((HOST_WIDE_INT_1U << INTVAL (shft_amnt)) - 1)) == 0;
 }
 
 /* Calculate the cost of calculating X, storing it in *COST.  Result
@@ -7799,10 +7800,10 @@ aarch64_register_move_cost (machine_mode mode,
     = aarch64_tune_params.regmove_cost;
 
   /* Caller save and pointer regs are equivalent to GENERAL_REGS.  */
-  if (to == CALLER_SAVE_REGS || to == POINTER_REGS)
+  if (to == TAILCALL_ADDR_REGS || to == POINTER_REGS)
     to = GENERAL_REGS;
 
-  if (from == CALLER_SAVE_REGS || from == POINTER_REGS)
+  if (from == TAILCALL_ADDR_REGS || from == POINTER_REGS)
     from = GENERAL_REGS;
 
   /* Moving between GPR and stack cost is the same as GP2GP.  */
@@ -8608,17 +8609,6 @@ aarch64_override_options_after_change_1 (struct gcc_options *opts)
   if (opts->x_pcrelative_literal_loads == 1)
     aarch64_pcrelative_literal_loads = true;
 
-  /* This is PR70113. When building the Linux kernel with
-     CONFIG_ARM64_ERRATUM_843419, support for relocations
-     R_AARCH64_ADR_PREL_PG_HI21 and R_AARCH64_ADR_PREL_PG_HI21_NC is
-     removed from the kernel to avoid loading objects with possibly
-     offending sequences.  Without -mpc-relative-literal-loads we would
-     generate such relocations, preventing the kernel build from
-     succeeding.  */
-  if (opts->x_pcrelative_literal_loads == 2
-      && TARGET_FIX_ERR_A53_843419)
-    aarch64_pcrelative_literal_loads = true;
-
   /* In the tiny memory model it makes no sense to disallow PC relative
      literal pool loads.  */
   if (aarch64_cmodel == AARCH64_CMODEL_TINY
diff --git a/gcc/config/aarch64/aarch64.h b/gcc/config/aarch64/aarch64.h
index 52d6414cbf4..ddf833ebfe8 100644
--- a/gcc/config/aarch64/aarch64.h
+++ b/gcc/config/aarch64/aarch64.h
@@ -439,7 +439,7 @@ extern unsigned aarch64_architecture_version;
 enum reg_class
 {
   NO_REGS,
-  CALLER_SAVE_REGS,
+  TAILCALL_ADDR_REGS,
   GENERAL_REGS,
   STACK_REG,
   POINTER_REGS,
@@ -454,7 +454,7 @@ enum reg_class
 #define REG_CLASS_NAMES				\
 {						\
   "NO_REGS",					\
-  "CALLER_SAVE_REGS",				\
+  "TAILCALL_ADDR_REGS",				\
   "GENERAL_REGS",				\
   "STACK_REG",					\
   "POINTER_REGS",				\
@@ -466,7 +466,7 @@ enum reg_class
 #define REG_CLASS_CONTENTS						\
 {									\
   { 0x00000000, 0x00000000, 0x00000000 },	/* NO_REGS */		\
-  { 0x0007ffff, 0x00000000, 0x00000000 },	/* CALLER_SAVE_REGS */	\
+  { 0x0004ffff, 0x00000000, 0x00000000 },	/* TAILCALL_ADDR_REGS */\
   { 0x7fffffff, 0x00000000, 0x00000003 },	/* GENERAL_REGS */	\
   { 0x80000000, 0x00000000, 0x00000000 },	/* STACK_REG */		\
   { 0xffffffff, 0x00000000, 0x00000003 },	/* POINTER_REGS */	\
diff --git a/gcc/config/aarch64/aarch64.md b/gcc/config/aarch64/aarch64.md
index 51368e29f2d..90f9ee658c5 100644
--- a/gcc/config/aarch64/aarch64.md
+++ b/gcc/config/aarch64/aarch64.md
@@ -140,6 +140,7 @@
     UNSPEC_RSQRTS
     UNSPEC_NZCV
     UNSPEC_XPACLRI
+    UNSPEC_COPYSIGN
 ])
 
 (define_c_enum "unspecv" [
@@ -3093,7 +3094,8 @@
 (define_insn_and_split "*compare_cstore<mode>_insn"
   [(set (match_operand:GPI 0 "register_operand" "=r")
 	 (EQL:GPI (match_operand:GPI 1 "register_operand" "r")
-		  (match_operand:GPI 2 "aarch64_imm24" "n")))]
+		  (match_operand:GPI 2 "aarch64_imm24" "n")))
+   (clobber (reg:CC CC_REGNUM))]
   "!aarch64_move_imm (INTVAL (operands[2]), <MODE>mode)
    && !aarch64_plus_operand (operands[2], <MODE>mode)
    && !reload_completed"
@@ -5002,45 +5004,45 @@
 ;;   LDR d2, #(1 << 63)
 ;;   BSL v2.8b, [y], [x]
 ;;
-;; or another, equivalent, sequence using one of BSL/BIT/BIF.
-;; aarch64_simd_bsldf will select the best suited of these instructions
-;; to generate based on register allocation, and knows how to partially
-;; constant fold based on the values of X and Y, so expand through that.
-
-(define_expand "copysigndf3"
-  [(match_operand:DF 0 "register_operand")
-   (match_operand:DF 1 "register_operand")
-   (match_operand:DF 2 "register_operand")]
+;; or another, equivalent, sequence using one of BSL/BIT/BIF.  Because
+;; we expect these operations to nearly always operate on
+;; floating-point values, we do not want the operation to be
+;; simplified into a bit-field insert operation that operates on the
+;; integer side, since typically that would involve three inter-bank
+;; register copies.  As we do not expect copysign to be followed by
+;; other logical operations on the result, it seems preferable to keep
+;; this as an unspec operation, rather than exposing the underlying
+;; logic to the compiler.
+
+(define_expand "copysign<GPF:mode>3"
+  [(match_operand:GPF 0 "register_operand")
+   (match_operand:GPF 1 "register_operand")
+   (match_operand:GPF 2 "register_operand")]
   "TARGET_FLOAT && TARGET_SIMD"
 {
-  rtx mask = gen_reg_rtx (DImode);
-  emit_move_insn (mask, GEN_INT (HOST_WIDE_INT_1U << 63));
-  emit_insn (gen_aarch64_simd_bsldf (operands[0], mask,
-				     operands[2], operands[1]));
+  rtx bitmask = gen_reg_rtx (<V_INT_EQUIV>mode);
+  emit_move_insn (bitmask, GEN_INT (HOST_WIDE_INT_M1U
+				<< (GET_MODE_BITSIZE (<MODE>mode) - 1)));
+  emit_insn (gen_copysign<mode>3_insn (operands[0], operands[1], operands[2],
+				       bitmask));
   DONE;
 }
 )
 
-;; As above, but we must first get to a 64-bit value if we wish to use
-;; aarch64_simd_bslv2sf.
-
-(define_expand "copysignsf3"
-  [(match_operand:SF 0 "register_operand")
-   (match_operand:SF 1 "register_operand")
-   (match_operand:SF 2 "register_operand")]
+(define_insn "copysign<GPF:mode>3_insn"
+  [(set (match_operand:GPF 0 "register_operand" "=w,w,w,r")
+	(unspec:GPF [(match_operand:GPF 1 "register_operand" "w,0,w,r")
+		     (match_operand:GPF 2 "register_operand" "w,w,0,0")
+		     (match_operand:<V_INT_EQUIV> 3 "register_operand"
+		     "0,w,w,X")]
+	 UNSPEC_COPYSIGN))]
   "TARGET_FLOAT && TARGET_SIMD"
-{
-  rtx mask = gen_reg_rtx (DImode);
-
-  /* Juggle modes to get us in to a vector mode for BSL.  */
-  rtx op1 = lowpart_subreg (V2SFmode, operands[1], SFmode);
-  rtx op2 = lowpart_subreg (V2SFmode, operands[2], SFmode);
-  rtx tmp = gen_reg_rtx (V2SFmode);
-  emit_move_insn (mask, GEN_INT (HOST_WIDE_INT_1U << 31));
-  emit_insn (gen_aarch64_simd_bslv2sf (tmp, mask, op2, op1));
-  emit_move_insn (operands[0], lowpart_subreg (SFmode, tmp, V2SFmode));
-  DONE;
-}
+  "@
+   bsl\\t%0.<Vbtype>, %2.<Vbtype>, %1.<Vbtype>
+   bit\\t%0.<Vbtype>, %2.<Vbtype>, %3.<Vbtype>
+   bif\\t%0.<Vbtype>, %1.<Vbtype>, %3.<Vbtype>
+   bfxil\\t%<w1>0, %<w1>1, #0, <sizem1>"
+  [(set_attr "type" "neon_bsl<q>,neon_bsl<q>,neon_bsl<q>,bfm")]
 )
 
 ;; -------------------------------------------------------------------
diff --git a/gcc/config/aarch64/constraints.md b/gcc/config/aarch64/constraints.md
index 5a252c07afa..9b3c7339c54 100644
--- a/gcc/config/aarch64/constraints.md
+++ b/gcc/config/aarch64/constraints.md
@@ -21,8 +21,8 @@
 (define_register_constraint "k" "STACK_REG"
   "@internal The stack register.")
 
-(define_register_constraint "Ucs" "CALLER_SAVE_REGS"
-  "@internal The caller save registers.")
+(define_register_constraint "Ucs" "TAILCALL_ADDR_REGS"
+  "@internal Registers suitable for an indirect tail call")
 
 (define_register_constraint "w" "FP_REGS"
   "Floating point and SIMD vector registers.")
diff --git a/gcc/config/aarch64/cortex-a57-fma-steering.c b/gcc/config/aarch64/cortex-a57-fma-steering.c
index 30fe85e41c7..c3063dcedb8 100644
--- a/gcc/config/aarch64/cortex-a57-fma-steering.c
+++ b/gcc/config/aarch64/cortex-a57-fma-steering.c
@@ -404,7 +404,7 @@ fma_forest::merge_forest (fma_forest *other_forest)
 
   /* Update root nodes' pointer to forest.  */
   for (other_root_iter = other_roots->begin ();
-       other_root_iter != other_roots->end (); other_root_iter++)
+       other_root_iter != other_roots->end (); ++other_root_iter)
     (*other_root_iter)->set_forest (this);
 
   /* Remove other_forest from the list of forests and move its tree roots in
@@ -845,14 +845,13 @@ func_fma_steering::dfs (void (*process_forest) (fma_forest *),
 			void (*process_node) (fma_forest *, fma_node *),
 			bool free)
 {
-  vec<fma_node *> to_process;
+  auto_vec<fma_node *> to_process;
+  auto_vec<fma_node *> to_free;
   std::list<fma_forest *>::iterator forest_iter;
 
-  to_process.create (0);
-
   /* For each forest.  */
   for (forest_iter = this->m_fma_forests.begin ();
-       forest_iter != this->m_fma_forests.end (); forest_iter++)
+       forest_iter != this->m_fma_forests.end (); ++forest_iter)
     {
       std::list<fma_root_node *>::iterator root_iter;
 
@@ -861,7 +860,7 @@ func_fma_steering::dfs (void (*process_forest) (fma_forest *),
 
       /* For each tree root in this forest.  */
       for (root_iter = (*forest_iter)->get_roots ()->begin ();
-	   root_iter != (*forest_iter)->get_roots ()->end (); root_iter++)
+	   root_iter != (*forest_iter)->get_roots ()->end (); ++root_iter)
 	{
 	  if (process_root)
 	    process_root (*forest_iter, *root_iter);
@@ -879,28 +878,30 @@ func_fma_steering::dfs (void (*process_forest) (fma_forest *),
 	  if (process_node)
 	    process_node (*forest_iter, node);
 
-	  /* Absence of children might indicate an alternate root of a *chain*.
-	     It's ok to skip it here as the chain will be renamed when
-	     processing the canonical root for that chain.  */
-	  if (node->get_children ()->empty ())
-	    continue;
-
 	  for (child_iter = node->get_children ()->begin ();
-	       child_iter != node->get_children ()->end (); child_iter++)
+	       child_iter != node->get_children ()->end (); ++child_iter)
 	    to_process.safe_push (*child_iter);
+
+	  /* Defer freeing so that the process_node callback can access the
+	     parent and children of the node being processed.  */
 	  if (free)
+	    to_free.safe_push (node);
+	}
+
+      if (free)
+	{
+	  delete *forest_iter;
+
+	  while (!to_free.is_empty ())
 	    {
+	      fma_node *node = to_free.pop ();
 	      if (node->root_p ())
 		delete static_cast<fma_root_node *> (node);
 	      else
 		delete node;
 	    }
 	}
-      if (free)
-	delete *forest_iter;
     }
-
-  to_process.release ();
 }
 
 /* Build the dependency trees of FMUL and FMADD/FMSUB instructions.  */
diff --git a/gcc/config/aarch64/iterators.md b/gcc/config/aarch64/iterators.md
index 43be7fd3611..4a39e30da13 100644
--- a/gcc/config/aarch64/iterators.md
+++ b/gcc/config/aarch64/iterators.md
@@ -438,7 +438,8 @@
 (define_mode_attr sizen [(QI "8") (HI "16") (SI "32") (DI "64")])
 
 ;; Give the ordinal of the MSB in the mode
-(define_mode_attr sizem1 [(QI "#7") (HI "#15") (SI "#31") (DI "#63")])
+(define_mode_attr sizem1 [(QI "#7") (HI "#15") (SI "#31") (DI "#63")
+			  (HF "#15") (SF "#31") (DF "#63")])
 
 ;; Attribute to describe constants acceptable in logical operations
 (define_mode_attr lconst [(SI "K") (DI "L")])
@@ -507,7 +508,7 @@
 			  (V8HF "16b") (V2SF  "8b")
 			  (V4SF "16b") (V2DF  "16b")
 			  (DI   "8b")  (DF    "8b")
-			  (SI   "8b")])
+			  (SI   "8b")  (SF    "8b")])
 
 ;; Define element mode for each vector mode.
 (define_mode_attr VEL [(V8QI "QI") (V16QI "QI")
@@ -648,6 +649,9 @@
 ;; Double vector types for ALLX.
 (define_mode_attr Vallxd [(QI "8b") (HI "4h") (SI "2s")])
 
+;; Mode with floating-point values replaced by like-sized integers.
+(define_mode_attr V_INT_EQUIV [(DF "DI") (SF "SI")])
+
 ;; Mode of result of comparison operations.
 (define_mode_attr V_cmp_result [(V8QI "V8QI") (V16QI "V16QI")
 				(V4HI "V4HI") (V8HI  "V8HI")
diff --git a/gcc/config/alpha/alpha.c b/gcc/config/alpha/alpha.c
index 15011aabcc7..8355031bff1 100644
--- a/gcc/config/alpha/alpha.c
+++ b/gcc/config/alpha/alpha.c
@@ -6357,8 +6357,40 @@ alpha_gimplify_va_arg (tree valist, tree type, gimple_seq *pre_p,
   offset = get_initialized_tmp_var (t, pre_p, NULL);
 
   indirect = pass_by_reference (NULL, TYPE_MODE (type), type, false);
+
   if (indirect)
-    type = build_pointer_type_for_mode (type, ptr_mode, true);
+    {
+      if (TREE_CODE (type) == COMPLEX_TYPE
+	  && targetm.calls.split_complex_arg (type))
+	{
+	  tree real_part, imag_part, real_temp;
+
+	  tree ptr_type = build_pointer_type_for_mode (TREE_TYPE (type),
+						       ptr_mode, true);
+
+	  real_part = alpha_gimplify_va_arg_1 (ptr_type, base,
+					       offset, pre_p);
+	  real_part = build_va_arg_indirect_ref (real_part);
+
+	  /* Copy the value into a new temporary, lest the formal temporary
+	     be reused out from under us.  */
+	  real_temp = get_initialized_tmp_var (real_part, pre_p, NULL);
+
+	  imag_part = alpha_gimplify_va_arg_1 (ptr_type, base,
+					       offset, pre_p);
+	  imag_part = build_va_arg_indirect_ref (imag_part);
+
+	  r = build2 (COMPLEX_EXPR, type, real_temp, imag_part);
+
+	  /* Stuff the offset temporary back into its field.  */
+	  gimplify_assign (unshare_expr (offset_field),
+			   fold_convert (TREE_TYPE (offset_field), offset),
+			   pre_p);
+	  return r;
+	}
+      else
+	type = build_pointer_type_for_mode (type, ptr_mode, true);
+    }
 
   /* Find the value.  Note that this will be a stable indirection, or
      a composite of stable indirections in the case of complex.  */
@@ -7750,13 +7782,13 @@ alpha_expand_prologue (void)
 	  int probed;
 
 	  for (probed = 4096; probed < probed_size; probed += 8192)
-	    emit_insn (gen_probe_stack (GEN_INT (-probed)));
+	    emit_insn (gen_stack_probe_internal (GEN_INT (-probed)));
 
 	  /* We only have to do this probe if we aren't saving registers or
 	     if we are probing beyond the frame because of -fstack-check.  */
 	  if ((sa_size == 0 && probed_size > probed - 4096)
 	      || flag_stack_check)
-	    emit_insn (gen_probe_stack (GEN_INT (-probed_size)));
+	    emit_insn (gen_stack_probe_internal (GEN_INT (-probed_size)));
 	}
 
       if (frame_size != 0)
diff --git a/gcc/config/alpha/alpha.md b/gcc/config/alpha/alpha.md
index 97838a5083a..14c18656d82 100644
--- a/gcc/config/alpha/alpha.md
+++ b/gcc/config/alpha/alpha.md
@@ -4915,7 +4915,7 @@
 
 
 ;; Subroutine of stack space allocation.  Perform a stack probe.
-(define_expand "probe_stack"
+(define_expand "stack_probe_internal"
   [(set (match_dup 1) (match_operand:DI 0 "const_int_operand"))]
   ""
 {
@@ -4950,12 +4950,14 @@
 
 	  int probed = 4096;
 
-	  emit_insn (gen_probe_stack (GEN_INT (- probed)));
+	  emit_insn (gen_stack_probe_internal (GEN_INT (- probed)));
 	  while (probed + 8192 < INTVAL (operands[1]))
-	    emit_insn (gen_probe_stack (GEN_INT (- (probed += 8192))));
+	    emit_insn (gen_stack_probe_internal
+		       (GEN_INT (- (probed += 8192))));
 
 	  if (probed + 4096 < INTVAL (operands[1]))
-	    emit_insn (gen_probe_stack (GEN_INT (- INTVAL(operands[1]))));
+	    emit_insn (gen_stack_probe_internal
+		       (GEN_INT (- INTVAL(operands[1]))));
 	}
 
       operands[1] = GEN_INT (- INTVAL (operands[1]));
diff --git a/gcc/config/arm/arm-builtins.c b/gcc/config/arm/arm-builtins.c
index 792b688f66c..d3b67184362 100644
--- a/gcc/config/arm/arm-builtins.c
+++ b/gcc/config/arm/arm-builtins.c
@@ -2576,7 +2576,7 @@ arm_expand_builtin (tree exp,
 	  icode = CODE_FOR_set_fpscr;
 	  arg0 = CALL_EXPR_ARG (exp, 0);
 	  op0 = expand_normal (arg0);
-	  pat = GEN_FCN (icode) (op0);
+	  pat = GEN_FCN (icode) (force_reg (SImode, op0));
 	}
       emit_insn (pat);
       return target;
@@ -2584,7 +2584,9 @@ arm_expand_builtin (tree exp,
     case ARM_BUILTIN_CMSE_NONSECURE_CALLER:
       target = gen_reg_rtx (SImode);
       op0 = arm_return_addr (0, NULL_RTX);
-      emit_insn (gen_addsi3 (target, op0, const1_rtx));
+      emit_insn (gen_andsi3 (target, op0, const1_rtx));
+      op1 = gen_rtx_EQ (SImode, target, const0_rtx);
+      emit_insn (gen_cstoresi4 (target, op1, target, const0_rtx));
       return target;
 
     case ARM_BUILTIN_TEXTRMSB:
diff --git a/gcc/config/arm/arm.c b/gcc/config/arm/arm.c
index 7b3f4c1011d..4cbc342e86f 100644
--- a/gcc/config/arm/arm.c
+++ b/gcc/config/arm/arm.c
@@ -3001,7 +3001,8 @@ arm_option_override_internal (struct gcc_options *opts,
 
   /* Thumb2 inline assembly code should always use unified syntax.
      This will apply to ARM and Thumb1 eventually.  */
-  opts->x_inline_asm_unified = TARGET_THUMB2_P (opts->x_target_flags);
+  if (TARGET_THUMB2_P (opts->x_target_flags))
+    opts->x_inline_asm_unified = true;
 
 #ifdef SUBTARGET_OVERRIDE_INTERNAL_OPTIONS
   SUBTARGET_OVERRIDE_INTERNAL_OPTIONS;
@@ -11695,8 +11696,7 @@ neon_valid_immediate (rtx op, machine_mode mode, int inverse,
   else
     {
       n_elts = 1;
-      if (mode == VOIDmode)
-	mode = DImode;
+      gcc_assert (mode != VOIDmode);
     }
 
   innersize = GET_MODE_UNIT_SIZE (mode);
@@ -17367,7 +17367,11 @@ arm_reorg (void)
 
   if (use_cmse)
     cmse_nonsecure_call_clear_caller_saved ();
-  if (TARGET_THUMB1)
+
+  /* We cannot run the Thumb passes for thunks because there is no CFG.  */
+  if (cfun->is_thunk)
+    ;
+  else if (TARGET_THUMB1)
     thumb1_reorg ();
   else if (TARGET_THUMB2)
     thumb2_reorg ();
@@ -18187,12 +18191,18 @@ output_move_double (rtx *operands, bool emit, int *count)
       gcc_assert ((REGNO (operands[1]) != IP_REGNUM)
                   || (TARGET_ARM && TARGET_LDRD));
 
+      /* For TARGET_ARM the first source register of an STRD
+	 must be even.  This is usually the case for double-word
+	 values but user assembly constraints can force an odd
+	 starting register.  */
+      bool allow_strd = TARGET_LDRD
+			 && !(TARGET_ARM && (REGNO (operands[1]) & 1) == 1);
       switch (GET_CODE (XEXP (operands[0], 0)))
         {
 	case REG:
 	  if (emit)
 	    {
-	      if (TARGET_LDRD)
+	      if (allow_strd)
 		output_asm_insn ("strd%?\t%1, [%m0]", operands);
 	      else
 		output_asm_insn ("stm%?\t%m0, %M1", operands);
@@ -18200,7 +18210,7 @@ output_move_double (rtx *operands, bool emit, int *count)
 	  break;
 
         case PRE_INC:
-	  gcc_assert (TARGET_LDRD);
+	  gcc_assert (allow_strd);
 	  if (emit)
 	    output_asm_insn ("strd%?\t%1, [%m0, #8]!", operands);
 	  break;
@@ -18208,7 +18218,7 @@ output_move_double (rtx *operands, bool emit, int *count)
         case PRE_DEC:
 	  if (emit)
 	    {
-	      if (TARGET_LDRD)
+	      if (allow_strd)
 		output_asm_insn ("strd%?\t%1, [%m0, #-8]!", operands);
 	      else
 		output_asm_insn ("stmdb%?\t%m0!, %M1", operands);
@@ -18218,7 +18228,7 @@ output_move_double (rtx *operands, bool emit, int *count)
         case POST_INC:
 	  if (emit)
 	    {
-	      if (TARGET_LDRD)
+	      if (allow_strd)
 		output_asm_insn ("strd%?\t%1, [%m0], #8", operands);
 	      else
 		output_asm_insn ("stm%?\t%m0!, %M1", operands);
@@ -18226,7 +18236,7 @@ output_move_double (rtx *operands, bool emit, int *count)
 	  break;
 
         case POST_DEC:
-	  gcc_assert (TARGET_LDRD);
+	  gcc_assert (allow_strd);
 	  if (emit)
 	    output_asm_insn ("strd%?\t%1, [%m0], #-8", operands);
 	  break;
@@ -18237,8 +18247,8 @@ output_move_double (rtx *operands, bool emit, int *count)
 	  otherops[1] = XEXP (XEXP (XEXP (operands[0], 0), 1), 0);
 	  otherops[2] = XEXP (XEXP (XEXP (operands[0], 0), 1), 1);
 
-	  /* IWMMXT allows offsets larger than ldrd can handle,
-	     fix these up with a pair of ldr.  */
+	  /* IWMMXT allows offsets larger than strd can handle,
+	     fix these up with a pair of str.  */
 	  if (!TARGET_THUMB2
 	      && CONST_INT_P (otherops[2])
 	      && (INTVAL(otherops[2]) <= -256
@@ -18303,7 +18313,7 @@ output_move_double (rtx *operands, bool emit, int *count)
 		  return "";
 		}
 	    }
-	  if (TARGET_LDRD
+	  if (allow_strd
 	      && (REG_P (otherops[2])
 		  || TARGET_THUMB2
 		  || (CONST_INT_P (otherops[2])
@@ -19097,6 +19107,11 @@ arm_r3_live_at_start_p (void)
 static int
 arm_compute_static_chain_stack_bytes (void)
 {
+  /* Once the value is updated from the init value of -1, do not
+     re-compute.  */
+  if (cfun->machine->static_chain_stack_bytes != -1)
+    return cfun->machine->static_chain_stack_bytes;
+
   /* See the defining assertion in arm_expand_prologue.  */
   if (IS_NESTED (arm_current_func_type ())
       && ((TARGET_APCS_FRAME && frame_pointer_needed && TARGET_ARM)
@@ -21395,6 +21410,11 @@ arm_expand_prologue (void)
       emit_insn (gen_movsi (stack_pointer_rtx, r1));
     }
 
+  /* Let's compute the static_chain_stack_bytes required and store it.  Right
+     now the value must the -1 as stored by arm_init_machine_status ().  */
+  cfun->machine->static_chain_stack_bytes
+    = arm_compute_static_chain_stack_bytes ();
+
   /* The static chain register is the same as the IP register.  If it is
      clobbered when creating the frame, we need to save and restore it.  */
   clobber_ip = IS_NESTED (func_type)
@@ -24542,6 +24562,7 @@ arm_init_machine_status (void)
 #if ARM_FT_UNKNOWN != 0
   machine->func_type = ARM_FT_UNKNOWN;
 #endif
+  machine->static_chain_stack_bytes = -1;
   return machine;
 }
 
@@ -26412,6 +26433,8 @@ static void
 arm32_output_mi_thunk (FILE *file, tree, HOST_WIDE_INT delta,
 		       HOST_WIDE_INT vcall_offset, tree function)
 {
+  const bool long_call_p = arm_is_long_call_p (function);
+
   /* On ARM, this_regno is R0 or R1 depending on
      whether the function returns an aggregate or not.
   */
@@ -26449,9 +26472,22 @@ arm32_output_mi_thunk (FILE *file, tree, HOST_WIDE_INT delta,
       TREE_USED (function) = 1;
     }
   rtx funexp = XEXP (DECL_RTL (function), 0);
+  if (long_call_p)
+    {
+      emit_move_insn (temp, funexp);
+      funexp = temp;
+    }
   funexp = gen_rtx_MEM (FUNCTION_MODE, funexp);
-  rtx_insn * insn = emit_call_insn (gen_sibcall (funexp, const0_rtx, NULL_RTX));
+  rtx_insn *insn = emit_call_insn (gen_sibcall (funexp, const0_rtx, NULL_RTX));
   SIBLING_CALL_P (insn) = 1;
+  emit_barrier ();
+
+  /* Indirect calls require a bit of fixup in PIC mode.  */
+  if (long_call_p)
+    {
+      split_all_insns_noflow ();
+      arm_reorg ();
+    }
 
   insn = get_insns ();
   shorten_branches (insn);
@@ -26853,7 +26889,10 @@ static bool
 arm_array_mode_supported_p (machine_mode mode,
 			    unsigned HOST_WIDE_INT nelems)
 {
-  if (TARGET_NEON
+  /* We don't want to enable interleaved loads and stores for BYTES_BIG_ENDIAN
+     for now, as the lane-swapping logic needs to be extended in the expanders.
+     See PR target/82518.  */
+  if (TARGET_NEON && !BYTES_BIG_ENDIAN
       && (VALID_NEON_DREG_MODE (mode) || VALID_NEON_QREG_MODE (mode))
       && (nelems >= 2 && nelems <= 4))
     return true;
diff --git a/gcc/config/arm/arm.h b/gcc/config/arm/arm.h
index 25953f53bd6..d89b6d345f4 100644
--- a/gcc/config/arm/arm.h
+++ b/gcc/config/arm/arm.h
@@ -186,7 +186,7 @@ extern tree arm_fp16_type_node;
 /* FPU supports converting between HFmode and DFmode in a single hardware
    step.  */
 #define TARGET_FP16_TO_DOUBLE						\
-  (TARGET_HARD_FLOAT && (TARGET_FP16 && TARGET_VFP5))
+  (TARGET_HARD_FLOAT && TARGET_FP16 && TARGET_VFP5 && TARGET_VFP_DOUBLE)
 
 /* FPU supports fused-multiply-add operations.  */
 #define TARGET_FMA (bitmap_bit_p (arm_active_target.isa, isa_bit_VFPv4))
@@ -1420,6 +1420,9 @@ typedef struct GTY(()) machine_function
   machine_mode thumb1_cc_mode;
   /* Set to 1 after arm_reorg has started.  */
   int after_arm_reorg;
+  /* The number of bytes used to store the static chain register on the
+     stack, above the stack frame.  */
+  int static_chain_stack_bytes;
 }
 machine_function;
 #endif
diff --git a/gcc/config/arm/arm.md b/gcc/config/arm/arm.md
index f9365cde504..ad5f3874bc7 100644
--- a/gcc/config/arm/arm.md
+++ b/gcc/config/arm/arm.md
@@ -4498,16 +4498,13 @@
    (set_attr "type" "load1")])
 
 (define_insn "unaligned_loadhis"
-  [(set (match_operand:SI 0 "s_register_operand" "=l,r")
+  [(set (match_operand:SI 0 "s_register_operand" "=r")
 	(sign_extend:SI
-	  (unspec:HI [(match_operand:HI 1 "memory_operand" "Uw,Uh")]
+	  (unspec:HI [(match_operand:HI 1 "memory_operand" "Uh")]
 		     UNSPEC_UNALIGNED_LOAD)))]
   "unaligned_access"
   "ldrsh%?\t%0, %1\t@ unaligned"
-  [(set_attr "arch" "t2,any")
-   (set_attr "length" "2,4")
-   (set_attr "predicable" "yes")
-   (set_attr "predicable_short_it" "yes,no")
+  [(set_attr "predicable" "yes")
    (set_attr "type" "load_byte")])
 
 (define_insn "unaligned_loadhiu"
diff --git a/gcc/config/arm/arm_cmse.h b/gcc/config/arm/arm_cmse.h
index 8fde2736a2a..427647fb981 100644
--- a/gcc/config/arm/arm_cmse.h
+++ b/gcc/config/arm/arm_cmse.h
@@ -35,7 +35,6 @@ extern "C" {
 #if __ARM_FEATURE_CMSE & 1
 
 #include <stddef.h>
-#include <stdint.h>
 
 #ifdef __ARM_BIG_ENDIAN
 
@@ -174,9 +173,9 @@ cmse_nonsecure_caller (void)
 #define CMSE_MPU_NONSECURE	16
 #define CMSE_NONSECURE		18
 
-#define cmse_nsfptr_create(p) ((typeof ((p))) ((intptr_t) (p) & ~1))
+#define cmse_nsfptr_create(p) ((__typeof__ ((p))) ((__INTPTR_TYPE__) (p) & ~1))
 
-#define cmse_is_nsfptr(p) (!((intptr_t) (p) & 1))
+#define cmse_is_nsfptr(p) (!((__INTPTR_TYPE__) (p) & 1))
 
 #endif /* __ARM_FEATURE_CMSE & 2 */
 
@@ -188,7 +187,7 @@ __extension__ void *
 cmse_check_address_range (void *, size_t, int);
 
 #define cmse_check_pointed_object(p, f) \
-  ((typeof ((p))) cmse_check_address_range ((p), sizeof (*(p)), (f)))
+  ((__typeof__ ((p))) cmse_check_address_range ((p), sizeof (*(p)), (f)))
 
 #endif /* __ARM_FEATURE_CMSE & 1 */
 
diff --git a/gcc/config/arm/constraints.md b/gcc/config/arm/constraints.md
index 0bd87dd32af..9b5ec891b13 100644
--- a/gcc/config/arm/constraints.md
+++ b/gcc/config/arm/constraints.md
@@ -31,7 +31,8 @@
 ;; 'H' was previously used for FPA.
 
 ;; The following multi-letter normal constraints have been used:
-;; in ARM/Thumb-2 state: Da, Db, Dc, Dd, Dn, Dl, DL, Do, Dv, Dy, Di, Dt, Dp, Dz
+;; in ARM/Thumb-2 state: Da, Db, Dc, Dd, Dn, DN, Dm, Dl, DL, Do, Dv, Dy, Di,
+;;			 Dt, Dp, Dz
 ;; in Thumb-1 state: Pa, Pb, Pc, Pd, Pe
 ;; in Thumb-2 state: Pj, PJ, Ps, Pt, Pu, Pv, Pw, Px, Py
 ;; in all states: Pf
@@ -294,14 +295,28 @@
  (and (match_code "const_double,const_int")
       (match_test "TARGET_32BIT && arm_const_double_by_immediates (op)")))
 
-(define_constraint "Dn"
+(define_constraint "Dm"
  "@internal
-  In ARM/Thumb-2 state a const_vector or const_int which can be loaded with a
-  Neon vmov immediate instruction."
- (and (match_code "const_vector,const_int")
+  In ARM/Thumb-2 state a const_vector which can be loaded with a Neon vmov
+  immediate instruction."
+ (and (match_code "const_vector")
       (match_test "TARGET_32BIT
 		   && imm_for_neon_mov_operand (op, GET_MODE (op))")))
 
+(define_constraint "Dn"
+ "@internal
+  In ARM/Thumb-2 state a DImode const_int which can be loaded with a Neon vmov
+  immediate instruction."
+ (and (match_code "const_int")
+      (match_test "TARGET_32BIT && imm_for_neon_mov_operand (op, DImode)")))
+
+(define_constraint "DN"
+ "@internal
+  In ARM/Thumb-2 state a TImode const_int which can be loaded with a Neon vmov
+  immediate instruction."
+ (and (match_code "const_int")
+      (match_test "TARGET_32BIT && imm_for_neon_mov_operand (op, TImode)")))
+
 (define_constraint "Dl"
  "@internal
   In ARM/Thumb-2 state a const_vector which can be used with a Neon vorr or
diff --git a/gcc/config/arm/neon.md b/gcc/config/arm/neon.md
index cacc1f9198a..c1a28f903f9 100644
--- a/gcc/config/arm/neon.md
+++ b/gcc/config/arm/neon.md
@@ -25,14 +25,14 @@
 
 (define_insn "*neon_mov<mode>"
   [(set (match_operand:VDX 0 "nonimmediate_operand"
-	  "=w,Un,w, w,  ?r,?w,?r,?r, ?Us")
+	  "=w,Un,w, w, w,  ?r,?w,?r,?r, ?Us")
 	(match_operand:VDX 1 "general_operand"
-	  " w,w, Dn,Uni, w, r, r, Usi,r"))]
+	  " w,w, Dm,Dn,Uni, w, r, r, Usi,r"))]
   "TARGET_NEON
    && (register_operand (operands[0], <MODE>mode)
        || register_operand (operands[1], <MODE>mode))"
 {
-  if (which_alternative == 2)
+  if (which_alternative == 2 || which_alternative == 3)
     {
       int width, is_valid;
       static char templ[40];
@@ -53,31 +53,32 @@
   switch (which_alternative)
     {
     case 0: return "vmov\t%P0, %P1  @ <mode>";
-    case 1: case 3: return output_move_neon (operands);
-    case 2: gcc_unreachable ();
-    case 4: return "vmov\t%Q0, %R0, %P1  @ <mode>";
-    case 5: return "vmov\t%P0, %Q1, %R1  @ <mode>";
+    case 1: case 4: return output_move_neon (operands);
+    case 2: case 3: gcc_unreachable ();
+    case 5: return "vmov\t%Q0, %R0, %P1  @ <mode>";
+    case 6: return "vmov\t%P0, %Q1, %R1  @ <mode>";
     default: return output_move_double (operands, true, NULL);
     }
 }
  [(set_attr "type" "neon_move<q>,neon_store1_1reg,neon_move<q>,\
-                    neon_load1_1reg, neon_to_gp<q>,neon_from_gp<q>,mov_reg,\
-                    neon_load1_2reg, neon_store1_2reg")
-  (set_attr "length" "4,4,4,4,4,4,8,8,8")
-  (set_attr "arm_pool_range"     "*,*,*,1020,*,*,*,1020,*")
-  (set_attr "thumb2_pool_range"     "*,*,*,1018,*,*,*,1018,*")
-  (set_attr "neg_pool_range" "*,*,*,1004,*,*,*,1004,*")])
+                    neon_move<q>,neon_load1_1reg, neon_to_gp<q>,\
+		    neon_from_gp<q>,mov_reg,neon_load1_2reg,\
+		    neon_store1_2reg")
+  (set_attr "length" "4,4,4,4,4,4,4,8,8,8")
+  (set_attr "arm_pool_range"     "*,*,*,*,1020,*,*,*,1020,*")
+  (set_attr "thumb2_pool_range"     "*,*,*,*,1018,*,*,*,1018,*")
+  (set_attr "neg_pool_range" "*,*,*,*,1004,*,*,*,1004,*")])
 
 (define_insn "*neon_mov<mode>"
   [(set (match_operand:VQXMOV 0 "nonimmediate_operand"
-  	  "=w,Un,w, w,  ?r,?w,?r,?r,  ?Us")
+	  "=w,Un,w, w, w,  ?r,?w,?r,?r,  ?Us")
 	(match_operand:VQXMOV 1 "general_operand"
-	  " w,w, Dn,Uni, w, r, r, Usi, r"))]
+	  " w,w, Dm,DN,Uni, w, r, r, Usi, r"))]
   "TARGET_NEON
    && (register_operand (operands[0], <MODE>mode)
        || register_operand (operands[1], <MODE>mode))"
 {
-  if (which_alternative == 2)
+  if (which_alternative == 2 || which_alternative == 3)
     {
       int width, is_valid;
       static char templ[40];
@@ -98,20 +99,20 @@
   switch (which_alternative)
     {
     case 0: return "vmov\t%q0, %q1  @ <mode>";
-    case 1: case 3: return output_move_neon (operands);
-    case 2: gcc_unreachable ();
-    case 4: return "vmov\t%Q0, %R0, %e1  @ <mode>\;vmov\t%J0, %K0, %f1";
-    case 5: return "vmov\t%e0, %Q1, %R1  @ <mode>\;vmov\t%f0, %J1, %K1";
+    case 1: case 4: return output_move_neon (operands);
+    case 2: case 3: gcc_unreachable ();
+    case 5: return "vmov\t%Q0, %R0, %e1  @ <mode>\;vmov\t%J0, %K0, %f1";
+    case 6: return "vmov\t%e0, %Q1, %R1  @ <mode>\;vmov\t%f0, %J1, %K1";
     default: return output_move_quad (operands);
     }
 }
   [(set_attr "type" "neon_move_q,neon_store2_2reg_q,neon_move_q,\
-                     neon_load2_2reg_q,neon_to_gp_q,neon_from_gp_q,\
-                     mov_reg,neon_load1_4reg,neon_store1_4reg")
-   (set_attr "length" "4,8,4,8,8,8,16,8,16")
-   (set_attr "arm_pool_range" "*,*,*,1020,*,*,*,1020,*")
-   (set_attr "thumb2_pool_range" "*,*,*,1018,*,*,*,1018,*")
-   (set_attr "neg_pool_range" "*,*,*,996,*,*,*,996,*")])
+                     neon_move_q,neon_load2_2reg_q,neon_to_gp_q,\
+                     neon_from_gp_q,mov_reg,neon_load1_4reg,neon_store1_4reg")
+   (set_attr "length" "4,8,4,4,8,8,8,16,8,16")
+   (set_attr "arm_pool_range" "*,*,*,*,1020,*,*,*,1020,*")
+   (set_attr "thumb2_pool_range" "*,*,*,*,1018,*,*,*,1018,*")
+   (set_attr "neg_pool_range" "*,*,*,*,996,*,*,*,996,*")])
 
 (define_expand "movti"
   [(set (match_operand:TI 0 "nonimmediate_operand" "")
@@ -1007,7 +1008,7 @@
 (define_insn "vashl<mode>3"
   [(set (match_operand:VDQIW 0 "s_register_operand" "=w,w")
 	(ashift:VDQIW (match_operand:VDQIW 1 "s_register_operand" "w,w")
-		      (match_operand:VDQIW 2 "imm_lshift_or_reg_neon" "w,Dn")))]
+		      (match_operand:VDQIW 2 "imm_lshift_or_reg_neon" "w,Dm")))]
   "TARGET_NEON"
   {
     switch (which_alternative)
@@ -1026,7 +1027,7 @@
 (define_insn "vashr<mode>3_imm"
   [(set (match_operand:VDQIW 0 "s_register_operand" "=w")
 	(ashiftrt:VDQIW (match_operand:VDQIW 1 "s_register_operand" "w")
-			(match_operand:VDQIW 2 "imm_for_neon_rshift_operand" "Dn")))]
+			(match_operand:VDQIW 2 "imm_for_neon_rshift_operand" "Dm")))]
   "TARGET_NEON"
   {
     return neon_output_shift_immediate ("vshr", 's', &operands[2],
@@ -1039,7 +1040,7 @@
 (define_insn "vlshr<mode>3_imm"
   [(set (match_operand:VDQIW 0 "s_register_operand" "=w")
 	(lshiftrt:VDQIW (match_operand:VDQIW 1 "s_register_operand" "w")
-			(match_operand:VDQIW 2 "imm_for_neon_rshift_operand" "Dn")))]
+			(match_operand:VDQIW 2 "imm_for_neon_rshift_operand" "Dm")))]
   "TARGET_NEON"
   {
     return neon_output_shift_immediate ("vshr", 'u', &operands[2],
@@ -1143,12 +1144,12 @@
 )
 
 (define_insn_and_split "ashldi3_neon"
-  [(set (match_operand:DI 0 "s_register_operand"	    "= w, w,?&r,?r,?&r, ?w,w")
-	(ashift:DI (match_operand:DI 1 "s_register_operand" " 0w, w, 0r, 0,  r, 0w,w")
-		   (match_operand:SI 2 "general_operand"    "rUm, i,  r, i,  i,rUm,i")))
-   (clobber (match_scratch:SI 3				    "= X, X,?&r, X,  X,  X,X"))
-   (clobber (match_scratch:SI 4				    "= X, X,?&r, X,  X,  X,X"))
-   (clobber (match_scratch:DI 5				    "=&w, X,  X, X,  X, &w,X"))
+  [(set (match_operand:DI 0 "s_register_operand"	    "= w, w, &r, r, &r, ?w,?w")
+	(ashift:DI (match_operand:DI 1 "s_register_operand" " 0w, w, 0r, 0,  r, 0w, w")
+		   (match_operand:SI 2 "general_operand"    "rUm, i,  r, i,  i,rUm, i")))
+   (clobber (match_scratch:SI 3				    "= X, X, &r, X,  X,  X, X"))
+   (clobber (match_scratch:SI 4				    "= X, X, &r, X,  X,  X, X"))
+   (clobber (match_scratch:DI 5				    "=&w, X,  X, X,  X, &w, X"))
    (clobber (reg:CC_C CC_REGNUM))]
   "TARGET_NEON"
   "#"
@@ -1243,7 +1244,7 @@
 ;; ashrdi3_neon
 ;; lshrdi3_neon
 (define_insn_and_split "<shift>di3_neon"
-  [(set (match_operand:DI 0 "s_register_operand"	     "= w, w,?&r,?r,?&r,?w,?w")
+  [(set (match_operand:DI 0 "s_register_operand"	     "= w, w, &r, r, &r,?w,?w")
 	(RSHIFTS:DI (match_operand:DI 1 "s_register_operand" " 0w, w, 0r, 0,  r,0w, w")
 		    (match_operand:SI 2 "reg_or_int_operand" "  r, i,  r, i,  i, r, i")))
    (clobber (match_scratch:SI 3				     "=2r, X, &r, X,  X,2r, X"))
diff --git a/gcc/config/arm/t-rtems b/gcc/config/arm/t-rtems
index 026a5895662..e276b4f3e57 100644
--- a/gcc/config/arm/t-rtems
+++ b/gcc/config/arm/t-rtems
@@ -1,7 +1,7 @@
 # Custom RTEMS multilibs for ARM
 
-MULTILIB_OPTIONS  = mbig-endian mthumb march=armv6-m/march=armv7-a/march=armv7-r/march=armv7-m/mcpu=cortex-m7 mfpu=neon/mfpu=vfp/mfpu=vfpv3-d16/mfpu=fpv4-sp-d16/mfpu=fpv5-d16 mfloat-abi=hard
-MULTILIB_DIRNAMES = eb thumb armv6-m armv7-a armv7-r armv7-m cortex-m7 neon vfp vfpv3-d16 fpv4-sp-d16 fpv5-d16 hard
+MULTILIB_OPTIONS  = mbig-endian mthumb march=armv6-m/march=armv7-a/march=armv7-r/mcpu=cortex-m3/mcpu=cortex-m4/mcpu=cortex-m7 mfpu=neon/mfpu=vfp/mfpu=vfpv3-d16/mfpu=fpv4-sp-d16/mfpu=fpv5-d16 mfloat-abi=hard
+MULTILIB_DIRNAMES = eb thumb armv6-m armv7-a armv7-r cortex-m3 cortex-m4 cortex-m7 neon vfp vfpv3-d16 fpv4-sp-d16 fpv5-d16 hard
 
 # Enumeration of multilibs
 
@@ -16,7 +16,8 @@ MULTILIB_REQUIRED += mthumb/march=armv7-a/mfpu=neon/mfloat-abi=hard
 MULTILIB_REQUIRED += mthumb/march=armv7-a
 MULTILIB_REQUIRED += mthumb/march=armv7-r/mfpu=vfpv3-d16/mfloat-abi=hard
 MULTILIB_REQUIRED += mthumb/march=armv7-r
-MULTILIB_REQUIRED += mthumb/march=armv7-m/mfpu=fpv4-sp-d16/mfloat-abi=hard
+MULTILIB_REQUIRED += mthumb/mcpu=cortex-m3
+MULTILIB_REQUIRED += mthumb/mcpu=cortex-m4
+MULTILIB_REQUIRED += mthumb/mcpu=cortex-m4/mfpu=fpv4-sp-d16/mfloat-abi=hard
 MULTILIB_REQUIRED += mthumb/mcpu=cortex-m7/mfpu=fpv5-d16/mfloat-abi=hard
-MULTILIB_REQUIRED += mthumb/march=armv7-m
 MULTILIB_REQUIRED += mthumb
diff --git a/gcc/config/avr/avr.h b/gcc/config/avr/avr.h
index 3dfa8c3b00b..c7705ca3c21 100644
--- a/gcc/config/avr/avr.h
+++ b/gcc/config/avr/avr.h
@@ -153,6 +153,9 @@ FIXME: DRIVER_SELF_SPECS has changed.
 
 #define FIRST_PSEUDO_REGISTER 36
 
+#define GENERAL_REGNO_P(N)	IN_RANGE (N, 2, 31)
+#define GENERAL_REG_P(X)	(REG_P (X) && GENERAL_REGNO_P (REGNO (X)))
+
 #define FIXED_REGISTERS {\
   1,1,/* r0 r1 */\
   0,0,/* r2 r3 */\
diff --git a/gcc/config/avr/avr.md b/gcc/config/avr/avr.md
index 3a6dec2b0c0..ee5a1c420c7 100644
--- a/gcc/config/avr/avr.md
+++ b/gcc/config/avr/avr.md
@@ -3362,6 +3362,8 @@
         (match_operand:HI 1 "reg_or_0_operand"))]
   "optimize
    && reload_completed
+   && GENERAL_REG_P (operands[0])
+   && (operands[1] == const0_rtx || GENERAL_REG_P (operands[1]))
    && (!AVR_HAVE_MOVW
        || const0_rtx == operands[1])"
   [(set (match_dup 2) (match_dup 3))
diff --git a/gcc/config/darwin.c b/gcc/config/darwin.c
index 8e6e25ab7f5..bafb1c541cd 100644
--- a/gcc/config/darwin.c
+++ b/gcc/config/darwin.c
@@ -3674,21 +3674,4 @@ default_function_sections:
 		    : text_section;
 }
 
-/* When a function is partitioned between sections, we need to insert a label
-   at the start of each new chunk - so that it may become a valid 'atom' for
-   eh and debug purposes.  Without this the linker will emit warnings if one 
-   tries to add line location information (since the switched fragment will 
-   be anonymous).  */
-
-void
-darwin_function_switched_text_sections (FILE *fp, tree decl, bool new_is_cold)
-{
-  char buf[128];
-  snprintf (buf, 128, "%s%s",new_is_cold?"__cold_sect_of_":"__hot_sect_of_",
-	    IDENTIFIER_POINTER (DECL_NAME (decl)));
-  /* Make sure we pick up all the relevant quotes etc.  */
-  assemble_name_raw (fp, (const char *) buf);
-  fputs (":\n", fp);
-}
-
 #include "gt-darwin.h"
diff --git a/gcc/config/darwin.h b/gcc/config/darwin.h
index a8397cd2331..8bb79a445d7 100644
--- a/gcc/config/darwin.h
+++ b/gcc/config/darwin.h
@@ -434,20 +434,29 @@ extern GTY(()) int darwin_ms_struct;
 
 #define DWARF2_DEBUGGING_INFO 1
 
-#define DEBUG_FRAME_SECTION	"__DWARF,__debug_frame,regular,debug"
-#define DEBUG_INFO_SECTION	"__DWARF,__debug_info,regular,debug"
-#define DEBUG_ABBREV_SECTION	"__DWARF,__debug_abbrev,regular,debug"
-#define DEBUG_ARANGES_SECTION	"__DWARF,__debug_aranges,regular,debug"
-#define DEBUG_MACINFO_SECTION	"__DWARF,__debug_macinfo,regular,debug"
-#define DEBUG_LINE_SECTION	"__DWARF,__debug_line,regular,debug"
-#define DEBUG_LOC_SECTION	"__DWARF,__debug_loc,regular,debug"
-#define DEBUG_PUBNAMES_SECTION	"__DWARF,__debug_pubnames,regular,debug"
-#define DEBUG_PUBTYPES_SECTION	"__DWARF,__debug_pubtypes,regular,debug"
-#define DEBUG_STR_SECTION	"__DWARF,__debug_str,regular,debug"
-#define DEBUG_RANGES_SECTION	"__DWARF,__debug_ranges,regular,debug"
-#define DEBUG_MACRO_SECTION    "__DWARF,__debug_macro,regular,debug"
+#define DEBUG_FRAME_SECTION	  "__DWARF,__debug_frame,regular,debug"
+#define DEBUG_INFO_SECTION	  "__DWARF,__debug_info,regular,debug"
+#define DEBUG_ABBREV_SECTION	  "__DWARF,__debug_abbrev,regular,debug"
+#define DEBUG_ARANGES_SECTION	  "__DWARF,__debug_aranges,regular,debug"
+#define DEBUG_MACINFO_SECTION	  "__DWARF,__debug_macinfo,regular,debug"
+#define DEBUG_LINE_SECTION	  "__DWARF,__debug_line,regular,debug"
+#define DEBUG_LOC_SECTION	  "__DWARF,__debug_loc,regular,debug"
+#define DEBUG_LOCLISTS_SECTION    "__DWARF,__debug_loclists,regular,debug"
+
+#define DEBUG_STR_SECTION	  "__DWARF,__debug_str,regular,debug"
+#define DEBUG_STR_OFFSETS_SECTION "__DWARF,__debug_str_offs,regular,debug"
+#define DEBUG_RANGES_SECTION	  "__DWARF,__debug_ranges,regular,debug"
+#define DEBUG_RNGLISTS_SECTION    "__DWARF,__debug_rnglists,regular,debug"
+#define DEBUG_MACRO_SECTION       "__DWARF,__debug_macro,regular,debug"
 
 #define TARGET_WANT_DEBUG_PUB_SECTIONS true
+#define DEBUG_PUBNAMES_SECTION   ((debug_generate_pub_sections == 2) \
+                               ? "__DWARF,__debug_gnu_pubn,regular,debug" \
+                               : "__DWARF,__debug_pubnames,regular,debug")
+
+#define DEBUG_PUBTYPES_SECTION   ((debug_generate_pub_sections == 2) \
+                               ? "__DWARF,__debug_gnu_pubt,regular,debug" \
+                               : "__DWARF,__debug_pubtypes,regular,debug")
 
 /* When generating stabs debugging, use N_BINCL entries.  */
 
@@ -495,11 +504,6 @@ extern GTY(()) int darwin_ms_struct;
    links to, so there's no need for weak-ness for that.  */
 #define GTHREAD_USE_WEAK 0
 
-/* The Darwin linker doesn't want coalesced symbols to appear in
-   a static archive's table of contents. */
-#undef TARGET_WEAK_NOT_IN_ARCHIVE_TOC
-#define TARGET_WEAK_NOT_IN_ARCHIVE_TOC 1
-
 /* On Darwin, we don't (at the time of writing) have linkonce sections
    with names, so it's safe to make the class data not comdat.  */
 #define TARGET_CXX_CLASS_DATA_ALWAYS_COMDAT hook_bool_void_false
@@ -705,10 +709,6 @@ extern GTY(()) section * darwin_sections[NUM_DARWIN_SECTIONS];
 #undef	TARGET_ASM_FUNCTION_SECTION
 #define TARGET_ASM_FUNCTION_SECTION darwin_function_section
 
-#undef	TARGET_ASM_FUNCTION_SWITCHED_TEXT_SECTIONS
-#define TARGET_ASM_FUNCTION_SWITCHED_TEXT_SECTIONS \
-	darwin_function_switched_text_sections
-
 #undef	TARGET_ASM_SELECT_RTX_SECTION
 #define TARGET_ASM_SELECT_RTX_SECTION machopic_select_rtx_section
 #undef  TARGET_ASM_UNIQUE_SECTION
diff --git a/gcc/config/gnu-user.h b/gcc/config/gnu-user.h
index de605b0c466..9b4bded8f69 100644
--- a/gcc/config/gnu-user.h
+++ b/gcc/config/gnu-user.h
@@ -122,7 +122,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 
 #define GNU_USER_TARGET_NO_PTHREADS_LIB_SPEC \
   "%{shared:-lc} \
-   %{!shared:%{mieee-fp:-lieee} %{profile:-lc_p}%{!profile:-lc}}"
+   %{!shared:%{profile:-lc_p}%{!profile:-lc}}"
 
 #define GNU_USER_TARGET_LIB_SPEC \
   "%{pthread:-lpthread} " \
diff --git a/gcc/config/i386/avx512fintrin.h b/gcc/config/i386/avx512fintrin.h
index afc80d62d62..a8e2e763cb2 100644
--- a/gcc/config/i386/avx512fintrin.h
+++ b/gcc/config/i386/avx512fintrin.h
@@ -3333,7 +3333,7 @@ _mm512_maskz_fnmsub_round_ps (__mmask16 __U, __m512 __A, __m512 __B,
     (__m512d)__builtin_ia32_vfmaddsubpd512_mask(A, B, C, -1, R)
 
 #define _mm512_mask_fmaddsub_round_pd(A, U, B, C, R)    \
-    (__m512d)__builtin_ia32_vfmaddpd512_mask(A, B, C, U, R)
+    (__m512d)__builtin_ia32_vfmaddsubpd512_mask(A, B, C, U, R)
 
 #define _mm512_mask3_fmaddsub_round_pd(A, B, C, U, R)   \
     (__m512d)__builtin_ia32_vfmaddsubpd512_mask3(A, B, C, U, R)
@@ -7298,7 +7298,7 @@ _mm512_mask_abs_ps (__m512 __W, __mmask16 __U, __m512 __A)
 
 extern __inline __m512d
 __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
-_mm512_abs_pd (__m512 __A)
+_mm512_abs_pd (__m512d __A)
 {
   return (__m512d) _mm512_and_epi64 ((__m512i) __A,
 				     _mm512_set1_epi64 (0x7fffffffffffffffLL));
@@ -7306,7 +7306,7 @@ _mm512_abs_pd (__m512 __A)
 
 extern __inline __m512d
 __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
-_mm512_mask_abs_pd (__m512d __W, __mmask8 __U, __m512 __A)
+_mm512_mask_abs_pd (__m512d __W, __mmask8 __U, __m512d __A)
 {
   return (__m512d)
 	 _mm512_mask_and_epi64 ((__m512i) __W, __U, (__m512i) __A,
diff --git a/gcc/config/i386/avx512vlintrin.h b/gcc/config/i386/avx512vlintrin.h
index f62f641188e..301713ba907 100644
--- a/gcc/config/i386/avx512vlintrin.h
+++ b/gcc/config/i386/avx512vlintrin.h
@@ -9097,6 +9097,17 @@ _mm_maskz_mul_epi32 (__mmask8 __M, __m128i __X, __m128i __Y)
 						  __M);
 }
 
+extern __inline __m256i
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+_mm256_permutexvar_epi64 (__m256i __X, __m256i __Y)
+{
+  return (__m256i) __builtin_ia32_permvardi256_mask ((__v4di) __Y,
+						     (__v4di) __X,
+						     (__v4di)
+						     _mm256_setzero_si256 (),
+						     (__mmask8) -1);
+}
+
 extern __inline __m256i
 __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
 _mm256_mask_permutexvar_epi64 (__m256i __W, __mmask8 __M, __m256i __X,
@@ -9161,6 +9172,17 @@ _mm_maskz_mul_epu32 (__mmask8 __M, __m128i __X, __m128i __Y)
 						   __M);
 }
 
+extern __inline __m256i
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+_mm256_permutexvar_epi32 (__m256i __X, __m256i __Y)
+{
+  return (__m256i) __builtin_ia32_permvarsi256_mask ((__v8si) __Y,
+						     (__v8si) __X,
+						     (__v8si)
+						     _mm256_setzero_si256 (),
+						     (__mmask8) -1);
+}
+
 extern __inline __m256i
 __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
 _mm256_mask_permutexvar_epi32 (__m256i __W, __mmask8 __M, __m256i __X,
@@ -9749,6 +9771,17 @@ _mm_cmple_epi64_mask (__m128i __X, __m128i __Y)
 }
 
 #ifdef __OPTIMIZE__
+extern __inline __m256i
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+_mm256_permutex_epi64 (__m256i __X, const int __I)
+{
+  return (__m256i) __builtin_ia32_permdi256_mask ((__v4di) __X,
+					      __I,
+					      (__v4di)
+					      _mm256_setzero_si256 (),
+					      (__mmask8) -1);
+}
+
 extern __inline __m256i
 __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
 _mm256_mask_permutex_epi64 (__m256i __W, __mmask8 __M,
@@ -12367,6 +12400,13 @@ _mm256_permutex_pd (__m256d __X, const int __M)
 					    _mm256_undefined_pd (),		\
 					    (__mmask8)-1))
 
+#define _mm256_permutex_epi64(X, I)				\
+  ((__m256i) __builtin_ia32_permdi256_mask ((__v4di)(__m256i)(X), \
+					    (int)(I),		\
+					    (__v4di)(__m256i)	\
+					    (_mm256_setzero_si256 ()),\
+					    (__mmask8) -1))
+
 #define _mm256_maskz_permutex_epi64(M, X, I)                    \
   ((__m256i) __builtin_ia32_permdi256_mask ((__v4di)(__m256i)(X),    \
 					    (int)(I),                \
diff --git a/gcc/config/i386/constraints.md b/gcc/config/i386/constraints.md
index a0a632aef8a..0cca766d3a0 100644
--- a/gcc/config/i386/constraints.md
+++ b/gcc/config/i386/constraints.md
@@ -198,7 +198,7 @@
 
 (define_constraint "Bs"
   "@internal Sibcall memory operand."
-  (ior (and (not (match_test "ix86_indirect_branch_register"))
+  (ior (and (not (match_test "TARGET_INDIRECT_BRANCH_REGISTER"))
 	    (not (match_test "TARGET_X32"))
 	    (match_operand 0 "sibcall_memory_operand"))
        (and (match_test "TARGET_X32 && Pmode == DImode")
@@ -206,7 +206,7 @@
 
 (define_constraint "Bw"
   "@internal Call memory operand."
-  (ior (and (not (match_test "ix86_indirect_branch_register"))
+  (ior (and (not (match_test "TARGET_INDIRECT_BRANCH_REGISTER"))
 	    (not (match_test "TARGET_X32"))
 	    (match_operand 0 "memory_operand"))
        (and (match_test "TARGET_X32 && Pmode == DImode")
diff --git a/gcc/config/i386/cygming.h b/gcc/config/i386/cygming.h
index a731e2f6c6a..8cca8615114 100644
--- a/gcc/config/i386/cygming.h
+++ b/gcc/config/i386/cygming.h
@@ -269,9 +269,6 @@ do {						\
    bytes in one go.  */
 #define CHECK_STACK_LIMIT 4000
 
-#undef STACK_BOUNDARY
-#define STACK_BOUNDARY	(TARGET_64BIT && ix86_abi == MS_ABI ? 128 : BITS_PER_WORD)
-
 /* By default, target has a 80387, uses IEEE compatible arithmetic,
    returns float values in the 387 and needs stack probes.
    We also align doubles to 64-bits for MSVC default compatibility.  */
diff --git a/gcc/config/i386/darwin.h b/gcc/config/i386/darwin.h
index fccaf7eb94b..ebaa15a2199 100644
--- a/gcc/config/i386/darwin.h
+++ b/gcc/config/i386/darwin.h
@@ -85,10 +85,6 @@ extern int darwin_emit_branch_islands;
 /* On Darwin, the stack is 128-bit aligned at the point of every call.
    Failure to ensure this will lead to a crash in the system libraries
    or dynamic loader.  */
-#undef STACK_BOUNDARY
-#define STACK_BOUNDARY \
- ((profile_flag || (TARGET_64BIT && ix86_abi == MS_ABI)) \
-  ? 128 : BITS_PER_WORD)
 
 #undef MAIN_STACK_BOUNDARY
 #define MAIN_STACK_BOUNDARY 128
diff --git a/gcc/config/i386/emmintrin.h b/gcc/config/i386/emmintrin.h
index 828f4a07a9b..c35a20f7107 100644
--- a/gcc/config/i386/emmintrin.h
+++ b/gcc/config/i386/emmintrin.h
@@ -45,6 +45,7 @@ typedef unsigned int __v4su __attribute__ ((__vector_size__ (16)));
 typedef short __v8hi __attribute__ ((__vector_size__ (16)));
 typedef unsigned short __v8hu __attribute__ ((__vector_size__ (16)));
 typedef char __v16qi __attribute__ ((__vector_size__ (16)));
+typedef signed char __v16qs __attribute__ ((__vector_size__ (16)));
 typedef unsigned char __v16qu __attribute__ ((__vector_size__ (16)));
 
 /* The Intel API is flexible enough that we must allow aliasing with other
@@ -1295,7 +1296,7 @@ _mm_xor_si128 (__m128i __A, __m128i __B)
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cmpeq_epi8 (__m128i __A, __m128i __B)
 {
-  return (__m128i) ((__v16qi)__A == (__v16qi)__B);
+  return (__m128i) ((__v16qs)__A == (__v16qs)__B);
 }
 
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -1313,7 +1314,7 @@ _mm_cmpeq_epi32 (__m128i __A, __m128i __B)
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cmplt_epi8 (__m128i __A, __m128i __B)
 {
-  return (__m128i) ((__v16qi)__A < (__v16qi)__B);
+  return (__m128i) ((__v16qs)__A < (__v16qs)__B);
 }
 
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -1331,7 +1332,7 @@ _mm_cmplt_epi32 (__m128i __A, __m128i __B)
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cmpgt_epi8 (__m128i __A, __m128i __B)
 {
-  return (__m128i) ((__v16qi)__A > (__v16qi)__B);
+  return (__m128i) ((__v16qs)__A > (__v16qs)__B);
 }
 
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
diff --git a/gcc/config/i386/gnu-user.h b/gcc/config/i386/gnu-user.h
index a4c88f1a848..0e49f0512a4 100644
--- a/gcc/config/i386/gnu-user.h
+++ b/gcc/config/i386/gnu-user.h
@@ -67,7 +67,7 @@ along with GCC; see the file COPYING3.  If not see
 
 #undef  ASM_SPEC
 #define ASM_SPEC \
-  "--32 %{!mno-sse2avx:%{mavx:-msse2avx}} %{msse2avx:%{!mavx:-msse2avx}}"
+  "--32 %{msse2avx:%{!mavx:-msse2avx}}"
 
 #undef  SUBTARGET_EXTRA_SPECS
 #define SUBTARGET_EXTRA_SPECS \
diff --git a/gcc/config/i386/gnu-user64.h b/gcc/config/i386/gnu-user64.h
index 39f5ef6a68b..911fbd4651c 100644
--- a/gcc/config/i386/gnu-user64.h
+++ b/gcc/config/i386/gnu-user64.h
@@ -50,7 +50,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 #define ASM_SPEC "%{" SPEC_32 ":--32} \
  %{" SPEC_64 ":--64} \
  %{" SPEC_X32 ":--x32} \
- %{!mno-sse2avx:%{mavx:-msse2avx}} %{msse2avx:%{!mavx:-msse2avx}}"
+ %{msse2avx:%{!mavx:-msse2avx}}"
 
 #define GNU_USER_TARGET_LINK_SPEC				   \
                   "%{" SPEC_64 ":-m " GNU_USER_LINK_EMULATION64 "} \
diff --git a/gcc/config/i386/i386-builtin.def b/gcc/config/i386/i386-builtin.def
index 43b5b620e47..eec6a27242e 100644
--- a/gcc/config/i386/i386-builtin.def
+++ b/gcc/config/i386/i386-builtin.def
@@ -90,6 +90,7 @@ BDESC_END (PCMPISTR, SPECIAL_ARGS)
 BDESC_FIRST (special_args, SPECIAL_ARGS,
        0, CODE_FOR_nothing, "__builtin_ia32_rdtsc", IX86_BUILTIN_RDTSC, UNKNOWN, (int) UINT64_FTYPE_VOID)
 BDESC (0, CODE_FOR_nothing, "__builtin_ia32_rdtscp", IX86_BUILTIN_RDTSCP, UNKNOWN, (int) UINT64_FTYPE_PUNSIGNED)
+BDESC (0, CODE_FOR_nothing, "__builtin_ia32_rdpmc", IX86_BUILTIN_RDPMC, UNKNOWN, (int) UINT64_FTYPE_INT)
 BDESC (0, CODE_FOR_pause, "__builtin_ia32_pause", IX86_BUILTIN_PAUSE, UNKNOWN, (int) VOID_FTYPE_VOID)
 
 /* 80387 (for use internally for atomic compound assignment).  */
@@ -387,7 +388,6 @@ BDESC_END (SPECIAL_ARGS, ARGS)
 BDESC_FIRST (args, ARGS,
        0, CODE_FOR_bsr, "__builtin_ia32_bsrsi", IX86_BUILTIN_BSRSI, UNKNOWN, (int) INT_FTYPE_INT)
 BDESC (OPTION_MASK_ISA_64BIT, CODE_FOR_bsr_rex64, "__builtin_ia32_bsrdi", IX86_BUILTIN_BSRDI, UNKNOWN, (int) INT64_FTYPE_INT64)
-BDESC (0, CODE_FOR_nothing, "__builtin_ia32_rdpmc", IX86_BUILTIN_RDPMC, UNKNOWN, (int) UINT64_FTYPE_INT)
 BDESC (0, CODE_FOR_rotlqi3, "__builtin_ia32_rolqi", IX86_BUILTIN_ROLQI, UNKNOWN, (int) UINT8_FTYPE_UINT8_INT)
 BDESC (0, CODE_FOR_rotlhi3, "__builtin_ia32_rolhi", IX86_BUILTIN_ROLHI, UNKNOWN, (int) UINT16_FTYPE_UINT16_INT)
 BDESC (0, CODE_FOR_rotrqi3, "__builtin_ia32_rorqi", IX86_BUILTIN_RORQI, UNKNOWN, (int) UINT8_FTYPE_UINT8_INT)
diff --git a/gcc/config/i386/i386-protos.h b/gcc/config/i386/i386-protos.h
index 42eece35766..9434e8463c1 100644
--- a/gcc/config/i386/i386-protos.h
+++ b/gcc/config/i386/i386-protos.h
@@ -313,8 +313,10 @@ extern enum attr_cpu ix86_schedule;
 #endif
 
 extern const char * ix86_output_call_insn (rtx_insn *insn, rtx call_op);
-extern const char * ix86_output_indirect_jmp (rtx call_op, bool ret_p);
+extern const char * ix86_output_indirect_jmp (rtx call_op);
 extern const char * ix86_output_function_return (bool long_p);
+extern const char * ix86_output_indirect_function_return (rtx ret_op);
+extern void ix86_split_simple_return_pop_internal (rtx);
 extern bool ix86_operands_ok_for_move_multiple (rtx *operands, bool load,
 						enum machine_mode mode);
 
diff --git a/gcc/config/i386/i386.c b/gcc/config/i386/i386.c
index ba2abc53ed1..96bdb3a78ba 100644
--- a/gcc/config/i386/i386.c
+++ b/gcc/config/i386/i386.c
@@ -6282,6 +6282,12 @@ ix86_option_override_internal (bool main_args_p,
     target_option_default_node = target_option_current_node
       = build_target_option_node (opts);
 
+  /* PR86952: jump table usage with retpolines is slow.
+     The PR provides some numbers about the slowness.  */
+  if (ix86_indirect_branch != indirect_branch_keep
+      && !opts_set->x_flag_jump_tables)
+    opts->x_flag_jump_tables = 0;
+
   return true;
 }
 
@@ -9442,7 +9448,7 @@ construct_container (machine_mode mode, machine_mode orig_mode,
       case X86_64_SSEDF_CLASS:
 	if (mode != BLKmode)
 	  return gen_reg_or_parallel (mode, orig_mode,
-				      SSE_REGNO (sse_regno));
+				      GET_SSE_REGNO (sse_regno));
 	break;
       case X86_64_X87_CLASS:
       case X86_64_COMPLEX_X87_CLASS:
@@ -9458,7 +9464,7 @@ construct_container (machine_mode mode, machine_mode orig_mode,
       && regclass[1] == X86_64_SSEUP_CLASS
       && mode != BLKmode)
     return gen_reg_or_parallel (mode, orig_mode,
-				SSE_REGNO (sse_regno));
+				GET_SSE_REGNO (sse_regno));
   if (n == 4
       && regclass[0] == X86_64_SSE_CLASS
       && regclass[1] == X86_64_SSEUP_CLASS
@@ -9466,7 +9472,7 @@ construct_container (machine_mode mode, machine_mode orig_mode,
       && regclass[3] == X86_64_SSEUP_CLASS
       && mode != BLKmode)
     return gen_reg_or_parallel (mode, orig_mode,
-				SSE_REGNO (sse_regno));
+				GET_SSE_REGNO (sse_regno));
   if (n == 8
       && regclass[0] == X86_64_SSE_CLASS
       && regclass[1] == X86_64_SSEUP_CLASS
@@ -9478,7 +9484,7 @@ construct_container (machine_mode mode, machine_mode orig_mode,
       && regclass[7] == X86_64_SSEUP_CLASS
       && mode != BLKmode)
     return gen_reg_or_parallel (mode, orig_mode,
-				SSE_REGNO (sse_regno));
+				GET_SSE_REGNO (sse_regno));
   if (n == 2
       && regclass[0] == X86_64_X87_CLASS
       && regclass[1] == X86_64_X87UP_CLASS)
@@ -9487,9 +9493,22 @@ construct_container (machine_mode mode, machine_mode orig_mode,
   if (n == 2
       && regclass[0] == X86_64_INTEGER_CLASS
       && regclass[1] == X86_64_INTEGER_CLASS
-      && (mode == CDImode || mode == TImode)
+      && (mode == CDImode || mode == TImode || mode == BLKmode)
       && intreg[0] + 1 == intreg[1])
-    return gen_rtx_REG (mode, intreg[0]);
+    {
+      if (mode == BLKmode)
+	{
+	  /* Use TImode for BLKmode values in 2 integer registers.  */
+	  exp[0] = gen_rtx_EXPR_LIST (VOIDmode,
+				      gen_rtx_REG (TImode, intreg[0]),
+				      GEN_INT (0));
+	  ret = gen_rtx_PARALLEL (mode, rtvec_alloc (1));
+	  XVECEXP (ret, 0, 0) = exp[0];
+	  return ret;
+	}
+      else
+	return gen_rtx_REG (mode, intreg[0]);
+    }
 
   /* Otherwise figure out the entries of the PARALLEL.  */
   for (i = 0; i < n; i++)
@@ -9524,7 +9543,7 @@ construct_container (machine_mode mode, machine_mode orig_mode,
 	    exp [nexps++]
 	      = gen_rtx_EXPR_LIST (VOIDmode,
 				   gen_rtx_REG (SFmode,
-						SSE_REGNO (sse_regno)),
+						GET_SSE_REGNO (sse_regno)),
 				   GEN_INT (i*8));
 	    sse_regno++;
 	    break;
@@ -9532,7 +9551,7 @@ construct_container (machine_mode mode, machine_mode orig_mode,
 	    exp [nexps++]
 	      = gen_rtx_EXPR_LIST (VOIDmode,
 				   gen_rtx_REG (DFmode,
-						SSE_REGNO (sse_regno)),
+						GET_SSE_REGNO (sse_regno)),
 				   GEN_INT (i*8));
 	    sse_regno++;
 	    break;
@@ -9578,7 +9597,7 @@ construct_container (machine_mode mode, machine_mode orig_mode,
 	    exp [nexps++]
 	      = gen_rtx_EXPR_LIST (VOIDmode,
 				   gen_rtx_REG (tmpmode,
-						SSE_REGNO (sse_regno)),
+						GET_SSE_REGNO (sse_regno)),
 				   GEN_INT (pos*8));
 	    sse_regno++;
 	    break;
@@ -11013,7 +11032,7 @@ setup_incoming_varargs_64 (CUMULATIVE_ARGS *cum)
 	  set_mem_alias_set (mem, set);
 	  set_mem_align (mem, GET_MODE_ALIGNMENT (smode));
 
-	  emit_move_insn (mem, gen_rtx_REG (smode, SSE_REGNO (i)));
+	  emit_move_insn (mem, gen_rtx_REG (smode, GET_SSE_REGNO (i)));
 	}
 
       emit_label (label);
@@ -12031,19 +12050,29 @@ ix86_setup_frame_addresses (void)
    labels in call and return thunks.  */
 static int indirectlabelno;
 
-/* True if call and return thunk functions are needed.  */
+/* True if call thunk function is needed.  */
 static bool indirect_thunk_needed = false;
-/* True if call and return thunk functions with the BND prefix are
-   needed.  */
+/* True if call thunk function with the BND prefix is needed.  */
 static bool indirect_thunk_bnd_needed = false;
 
 /* Bit masks of integer registers, which contain branch target, used
-   by call and return thunks functions.  */
+   by call thunk functions.  */
 static int indirect_thunks_used;
 /* Bit masks of integer registers, which contain branch target, used
-   by call and return thunks functions with the BND prefix.  */
+   by call thunk functions with the BND prefix.  */
 static int indirect_thunks_bnd_used;
 
+/* True if return thunk function is needed.  */
+static bool indirect_return_needed = false;
+/* True if return thunk function with the BND prefix is needed.  */
+static bool indirect_return_bnd_needed = false;
+
+/* True if return thunk function via CX is needed.  */
+static bool indirect_return_via_cx;
+/* True if return thunk function via CX with the BND prefix is
+   needed.  */
+static bool indirect_return_via_cx_bnd;
+
 #ifndef INDIRECT_LABEL
 # define INDIRECT_LABEL "LIND"
 #endif
@@ -12051,34 +12080,32 @@ static int indirect_thunks_bnd_used;
 /* Fills in the label name that should be used for the indirect thunk.  */
 
 static void
-indirect_thunk_name (char name[32], int regno, bool need_bnd_p,
-		     bool ret_p)
+indirect_thunk_name (char name[32], unsigned int regno,
+		     bool need_bnd_p, bool ret_p)
 {
-  if (regno >= 0 && ret_p)
+  if (regno != INVALID_REGNUM && regno != CX_REG && ret_p)
     gcc_unreachable ();
 
   if (USE_HIDDEN_LINKONCE)
     {
       const char *bnd = need_bnd_p ? "_bnd" : "";
-      if (regno >= 0)
+      const char *ret = ret_p ? "return" : "indirect";
+      if (regno != INVALID_REGNUM)
 	{
 	  const char *reg_prefix;
 	  if (LEGACY_INT_REGNO_P (regno))
 	    reg_prefix = TARGET_64BIT ? "r" : "e";
 	  else
 	    reg_prefix = "";
-	  sprintf (name, "__x86_indirect_thunk%s_%s%s",
-		   bnd, reg_prefix, reg_names[regno]);
+	  sprintf (name, "__x86_%s_thunk%s_%s%s",
+		   ret, bnd, reg_prefix, reg_names[regno]);
 	}
       else
-	{
-	  const char *ret = ret_p ? "return" : "indirect";
-	  sprintf (name, "__x86_%s_thunk%s", ret, bnd);
-	}
+	sprintf (name, "__x86_%s_thunk%s", ret, bnd);
     }
   else
     {
-      if (regno >= 0)
+      if (regno != INVALID_REGNUM)
 	{
 	  if (need_bnd_p)
 	    ASM_GENERATE_INTERNAL_LABEL (name, "LITBR", regno);
@@ -12130,7 +12157,7 @@ indirect_thunk_name (char name[32], int regno, bool need_bnd_p,
  */
 
 static void
-output_indirect_thunk (bool need_bnd_p, int regno)
+output_indirect_thunk (bool need_bnd_p, unsigned int regno)
 {
   char indirectlabel1[32];
   char indirectlabel2[32];
@@ -12160,7 +12187,7 @@ output_indirect_thunk (bool need_bnd_p, int regno)
 
   ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, indirectlabel2);
 
-  if (regno >= 0)
+  if (regno != INVALID_REGNUM)
     {
       /* MOV.  */
       rtx xops[2];
@@ -12184,18 +12211,20 @@ output_indirect_thunk (bool need_bnd_p, int regno)
 }
 
 /* Output a funtion with a call and return thunk for indirect branch.
-   If BND_P is true, the BND prefix is needed.   If REGNO != -1,  the
-   function address is in REGNO.  Otherwise, the function address is
-   on the top of stack.  */
+   If BND_P is true, the BND prefix is needed.  If REGNO != INVALID_REGNUM,
+   the function address is in REGNO.  Otherwise, the function address is
+   on the top of stack.  Thunk is used for function return if RET_P is
+   true.  */
 
 static void
-output_indirect_thunk_function (bool need_bnd_p, int regno)
+output_indirect_thunk_function (bool need_bnd_p, unsigned int regno,
+				bool ret_p)
 {
   char name[32];
   tree decl;
 
   /* Create __x86_indirect_thunk/__x86_indirect_thunk_bnd.  */
-  indirect_thunk_name (name, regno, need_bnd_p, false);
+  indirect_thunk_name (name, regno, need_bnd_p, ret_p);
   decl = build_decl (BUILTINS_LOCATION, FUNCTION_DECL,
 		     get_identifier (name),
 		     build_function_type_list (void_type_node, NULL_TREE));
@@ -12238,36 +12267,6 @@ output_indirect_thunk_function (bool need_bnd_p, int regno)
 	ASM_OUTPUT_LABEL (asm_out_file, name);
       }
 
-  if (regno < 0)
-    {
-      /* Create alias for __x86.return_thunk/__x86.return_thunk_bnd.  */
-      char alias[32];
-
-      indirect_thunk_name (alias, regno, need_bnd_p, true);
-#if TARGET_MACHO
-      if (TARGET_MACHO)
-	{
-	  fputs ("\t.weak_definition\t", asm_out_file);
-	  assemble_name (asm_out_file, alias);
-	  fputs ("\n\t.private_extern\t", asm_out_file);
-	  assemble_name (asm_out_file, alias);
-	  putc ('\n', asm_out_file);
-	  ASM_OUTPUT_LABEL (asm_out_file, alias);
-	}
-#else
-      ASM_OUTPUT_DEF (asm_out_file, alias, name);
-      if (USE_HIDDEN_LINKONCE)
-	{
-	  fputs ("\t.globl\t", asm_out_file);
-	  assemble_name (asm_out_file, alias);
-	  putc ('\n', asm_out_file);
-	  fputs ("\t.hidden\t", asm_out_file);
-	  assemble_name (asm_out_file, alias);
-	  putc ('\n', asm_out_file);
-	}
-#endif
-    }
-
   DECL_INITIAL (decl) = make_node (BLOCK);
   current_function_decl = decl;
   allocate_struct_function (decl, false);
@@ -12312,21 +12311,31 @@ static void
 ix86_code_end (void)
 {
   rtx xops[2];
-  int regno;
+  unsigned int regno;
+
+  if (indirect_return_needed)
+    output_indirect_thunk_function (false, INVALID_REGNUM, true);
+  if (indirect_return_bnd_needed)
+    output_indirect_thunk_function (true, INVALID_REGNUM, true);
+
+  if (indirect_return_via_cx)
+    output_indirect_thunk_function (false, CX_REG, true);
+  if (indirect_return_via_cx_bnd)
+    output_indirect_thunk_function (true, CX_REG, true);
 
   if (indirect_thunk_needed)
-    output_indirect_thunk_function (false, -1);
+    output_indirect_thunk_function (false, INVALID_REGNUM, false);
   if (indirect_thunk_bnd_needed)
-    output_indirect_thunk_function (true, -1);
+    output_indirect_thunk_function (true, INVALID_REGNUM, false);
 
   for (regno = FIRST_REX_INT_REG; regno <= LAST_REX_INT_REG; regno++)
     {
-      int i = regno - FIRST_REX_INT_REG + LAST_INT_REG + 1;
+      unsigned int i = regno - FIRST_REX_INT_REG + LAST_INT_REG + 1;
       if ((indirect_thunks_used & (1 << i)))
-	output_indirect_thunk_function (false, regno);
+	output_indirect_thunk_function (false, regno, false);
 
       if ((indirect_thunks_bnd_used & (1 << i)))
-	output_indirect_thunk_function (true, regno);
+	output_indirect_thunk_function (true, regno, false);
     }
 
   for (regno = AX_REG; regno <= SP_REG; regno++)
@@ -12335,10 +12344,10 @@ ix86_code_end (void)
       tree decl;
 
       if ((indirect_thunks_used & (1 << regno)))
-	output_indirect_thunk_function (false, regno);
+	output_indirect_thunk_function (false, regno, false);
 
       if ((indirect_thunks_bnd_used & (1 << regno)))
-	output_indirect_thunk_function (true, regno);
+	output_indirect_thunk_function (true, regno, false);
 
       if (!(pic_labels_used & (1 << regno)))
 	continue;
@@ -12785,10 +12794,16 @@ ix86_compute_frame_layout (void)
   /* 64-bit MS ABI seem to require stack alignment to be always 16,
      except for function prologues, leaf functions and when the defult
      incoming stack boundary is overriden at command line or via
-     force_align_arg_pointer attribute.  */
-  if ((TARGET_64BIT_MS_ABI && crtl->preferred_stack_boundary < 128)
+     force_align_arg_pointer attribute.
+
+     Darwin's ABI specifies 128b alignment for both 32 and  64 bit variants
+     at call sites, including profile function calls.
+ */
+  if (((TARGET_64BIT_MS_ABI || TARGET_MACHO)
+        && crtl->preferred_stack_boundary < 128)
       && (!crtl->is_leaf || cfun->calls_alloca != 0
 	  || ix86_current_function_calls_tls_descriptor
+	  || (TARGET_MACHO && crtl->profile)
 	  || ix86_incoming_stack_boundary < 128))
     {
       crtl->preferred_stack_boundary = 128;
@@ -14061,7 +14076,6 @@ ix86_expand_prologue (void)
 {
   struct machine_function *m = cfun->machine;
   rtx insn, t;
-  struct ix86_frame frame;
   HOST_WIDE_INT allocate;
   bool int_registers_saved;
   bool sse_registers_saved;
@@ -14085,7 +14099,7 @@ ix86_expand_prologue (void)
   m->fs.sp_valid = true;
 
   ix86_compute_frame_layout ();
-  frame = m->frame;
+  const struct ix86_frame &frame = cfun->machine->frame;
 
   if (!TARGET_64BIT && ix86_function_ms_hook_prologue (current_function_decl))
     {
@@ -14491,8 +14505,9 @@ ix86_expand_prologue (void)
 	}
       m->fs.sp_offset += allocate;
 
-      /* Use stack_pointer_rtx for relative addressing so that code
-	 works for realigned stack, too.  */
+      /* Use stack_pointer_rtx for relative addressing so that code works for
+	 realigned stack.  But this means that we need a blockage to prevent
+	 stores based on the frame pointer from being scheduled before.  */
       if (r10_live && eax_live)
         {
 	  t = gen_rtx_PLUS (Pmode, stack_pointer_rtx, eax);
@@ -14501,6 +14516,7 @@ ix86_expand_prologue (void)
 	  t = plus_constant (Pmode, t, UNITS_PER_WORD);
 	  emit_move_insn (gen_rtx_REG (word_mode, AX_REG),
 			  gen_frame_mem (word_mode, t));
+	  emit_insn (gen_memory_blockage ());
 	}
       else if (eax_live || r10_live)
 	{
@@ -14508,6 +14524,7 @@ ix86_expand_prologue (void)
 	  emit_move_insn (gen_rtx_REG (word_mode,
 				       (eax_live ? AX_REG : R10_REG)),
 			  gen_frame_mem (word_mode, t));
+	  emit_insn (gen_memory_blockage ());
 	}
     }
   gcc_assert (m->fs.sp_offset == frame.stack_pointer_offset);
@@ -14748,13 +14765,12 @@ ix86_expand_epilogue (int style)
 {
   struct machine_function *m = cfun->machine;
   struct machine_frame_state frame_state_save = m->fs;
-  struct ix86_frame frame;
   bool restore_regs_via_mov;
   bool using_drap;
 
   ix86_finalize_stack_realign_flags ();
   ix86_compute_frame_layout ();
-  frame = m->frame;
+  const struct ix86_frame &frame = cfun->machine->frame;
 
   m->fs.sp_valid = (!frame_pointer_needed
 		    || (crtl->sp_is_unchanging
@@ -14796,11 +14812,13 @@ ix86_expand_epilogue (int style)
 				  + UNITS_PER_WORD);
     }
 
+  HOST_WIDE_INT reg_save_offset = frame.reg_save_offset;
+
   /* Special care must be taken for the normal return case of a function
      using eh_return: the eax and edx registers are marked as saved, but
      not restored along this path.  Adjust the save location to match.  */
   if (crtl->calls_eh_return && style != 2)
-    frame.reg_save_offset -= 2 * UNITS_PER_WORD;
+    reg_save_offset -= 2 * UNITS_PER_WORD;
 
   /* EH_RETURN requires the use of moves to function properly.  */
   if (crtl->calls_eh_return)
@@ -14816,11 +14834,11 @@ ix86_expand_epilogue (int style)
   else if (TARGET_EPILOGUE_USING_MOVE
 	   && cfun->machine->use_fast_prologue_epilogue
 	   && (frame.nregs > 1
-	       || m->fs.sp_offset != frame.reg_save_offset))
+	       || m->fs.sp_offset != reg_save_offset))
     restore_regs_via_mov = true;
   else if (frame_pointer_needed
 	   && !frame.nregs
-	   && m->fs.sp_offset != frame.reg_save_offset)
+	   && m->fs.sp_offset != reg_save_offset)
     restore_regs_via_mov = true;
   else if (frame_pointer_needed
 	   && TARGET_USE_LEAVE
@@ -14858,7 +14876,7 @@ ix86_expand_epilogue (int style)
       rtx t;
 
       if (frame.nregs)
-	ix86_emit_restore_regs_using_mov (frame.reg_save_offset, style == 2);
+	ix86_emit_restore_regs_using_mov (reg_save_offset, style == 2);
 
       /* eh_return epilogues need %ecx added to the stack pointer.  */
       if (style == 2)
@@ -14948,19 +14966,19 @@ ix86_expand_epilogue (int style)
 	 epilogues.  */
       if (!m->fs.sp_valid
  	  || (TARGET_SEH
-	      && (m->fs.sp_offset - frame.reg_save_offset
+	      && (m->fs.sp_offset - reg_save_offset
 		  >= SEH_MAX_FRAME_SIZE)))
 	{
 	  pro_epilogue_adjust_stack (stack_pointer_rtx, hard_frame_pointer_rtx,
 				     GEN_INT (m->fs.fp_offset
-					      - frame.reg_save_offset),
+					      - reg_save_offset),
 				     style, false);
 	}
-      else if (m->fs.sp_offset != frame.reg_save_offset)
+      else if (m->fs.sp_offset != reg_save_offset)
 	{
 	  pro_epilogue_adjust_stack (stack_pointer_rtx, stack_pointer_rtx,
 				     GEN_INT (m->fs.sp_offset
-					      - frame.reg_save_offset),
+					      - reg_save_offset),
 				     style,
 				     m->fs.cfa_reg == stack_pointer_rtx);
 	}
@@ -18161,6 +18179,7 @@ print_reg (rtx x, int code, FILE *file)
    ~ -- print "i" if TARGET_AVX2, "f" otherwise.
    @ -- print a segment register of thread base pointer load
    ^ -- print addr32 prefix if TARGET_64BIT and Pmode != word_mode
+   M -- print addr32 prefix for TARGET_X32 with VSIB address.
    ! -- print MPX prefix for jxx/call/ret instructions if required.
  */
 
@@ -18720,6 +18739,26 @@ ix86_print_operand (FILE *file, rtx x, int code)
 	  putc (TARGET_AVX2 ? 'i' : 'f', file);
 	  return;
 
+	case 'M':
+	  if (TARGET_X32)
+	    {
+	      /* NB: 32-bit indices in VSIB address are sign-extended
+		 to 64 bits. In x32, if 32-bit address 0xf7fa3010 is
+		 sign-extended to 0xfffffffff7fa3010 which is invalid
+		 address.  Add addr32 prefix if there is no base
+		 register nor symbol.  */
+	      bool ok;
+	      struct ix86_address parts;
+	      ok = ix86_decompose_address (x, &parts);
+	      gcc_assert (ok && parts.index == NULL_RTX);
+	      if (parts.base == NULL_RTX
+		  && (parts.disp == NULL_RTX
+		      || !symbolic_operand (parts.disp,
+					    GET_MODE (parts.disp))))
+		fputs ("addr32 ", file);
+	    }
+	  return;
+
 	case '^':
 	  if (TARGET_64BIT && Pmode != word_mode)
 	    fputs ("addr32 ", file);
@@ -18842,7 +18881,8 @@ ix86_print_operand (FILE *file, rtx x, int code)
 	 since we can in fact encode that into an immediate.  */
       if (GET_CODE (x) == CONST_VECTOR)
 	{
-	  gcc_assert (x == CONST0_RTX (GET_MODE (x)));
+	  if (x != CONST0_RTX (GET_MODE (x)))
+	    output_operand_lossage ("invalid vector immediate");
 	  x = const0_rtx;
 	}
 
@@ -19807,72 +19847,36 @@ emit_i387_cw_initialization (int mode)
   emit_insn (gen_x86_fnstcw_1 (stored_mode));
   emit_move_insn (reg, copy_rtx (stored_mode));
 
-  if (TARGET_64BIT || TARGET_PARTIAL_REG_STALL
-      || optimize_insn_for_size_p ())
-    {
-      switch (mode)
-	{
-	case I387_CW_TRUNC:
-	  /* round toward zero (truncate) */
-	  emit_insn (gen_iorhi3 (reg, reg, GEN_INT (0x0c00)));
-	  slot = SLOT_CW_TRUNC;
-	  break;
-
-	case I387_CW_FLOOR:
-	  /* round down toward -oo */
-	  emit_insn (gen_andhi3 (reg, reg, GEN_INT (~0x0c00)));
-	  emit_insn (gen_iorhi3 (reg, reg, GEN_INT (0x0400)));
-	  slot = SLOT_CW_FLOOR;
-	  break;
-
-	case I387_CW_CEIL:
-	  /* round up toward +oo */
-	  emit_insn (gen_andhi3 (reg, reg, GEN_INT (~0x0c00)));
-	  emit_insn (gen_iorhi3 (reg, reg, GEN_INT (0x0800)));
-	  slot = SLOT_CW_CEIL;
-	  break;
-
-	case I387_CW_MASK_PM:
-	  /* mask precision exception for nearbyint() */
-	  emit_insn (gen_iorhi3 (reg, reg, GEN_INT (0x0020)));
-	  slot = SLOT_CW_MASK_PM;
-	  break;
-
-	default:
-	  gcc_unreachable ();
-	}
-    }
-  else
+  switch (mode)
     {
-      switch (mode)
-	{
-	case I387_CW_TRUNC:
-	  /* round toward zero (truncate) */
-	  emit_insn (gen_insvsi_1 (reg, GEN_INT (0xc)));
-	  slot = SLOT_CW_TRUNC;
-	  break;
+    case I387_CW_TRUNC:
+      /* round toward zero (truncate) */
+      emit_insn (gen_iorhi3 (reg, reg, GEN_INT (0x0c00)));
+      slot = SLOT_CW_TRUNC;
+      break;
 
-	case I387_CW_FLOOR:
-	  /* round down toward -oo */
-	  emit_insn (gen_insvsi_1 (reg, GEN_INT (0x4)));
-	  slot = SLOT_CW_FLOOR;
-	  break;
+    case I387_CW_FLOOR:
+      /* round down toward -oo */
+      emit_insn (gen_andhi3 (reg, reg, GEN_INT (~0x0c00)));
+      emit_insn (gen_iorhi3 (reg, reg, GEN_INT (0x0400)));
+      slot = SLOT_CW_FLOOR;
+      break;
 
-	case I387_CW_CEIL:
-	  /* round up toward +oo */
-	  emit_insn (gen_insvsi_1 (reg, GEN_INT (0x8)));
-	  slot = SLOT_CW_CEIL;
-	  break;
+    case I387_CW_CEIL:
+      /* round up toward +oo */
+      emit_insn (gen_andhi3 (reg, reg, GEN_INT (~0x0c00)));
+      emit_insn (gen_iorhi3 (reg, reg, GEN_INT (0x0800)));
+      slot = SLOT_CW_CEIL;
+      break;
 
-	case I387_CW_MASK_PM:
-	  /* mask precision exception for nearbyint() */
-	  emit_insn (gen_iorhi3 (reg, reg, GEN_INT (0x0020)));
-	  slot = SLOT_CW_MASK_PM;
-	  break;
+    case I387_CW_MASK_PM:
+      /* mask precision exception for nearbyint() */
+      emit_insn (gen_iorhi3 (reg, reg, GEN_INT (0x0020)));
+      slot = SLOT_CW_MASK_PM;
+      break;
 
-	default:
-	  gcc_unreachable ();
-	}
+    default:
+      gcc_unreachable ();
     }
 
   gcc_assert (slot < MAX_386_STACK_LOCALS);
@@ -24150,7 +24154,7 @@ ix86_expand_sse_fp_minmax (rtx dest, enum rtx_code code, rtx cmp_op0,
   return true;
 }
 
-/* Expand an sse vector comparison.  Return the register with the result.  */
+/* Expand an SSE comparison.  Return the register with the result.  */
 
 static rtx
 ix86_expand_sse_cmp (rtx dest, enum rtx_code code, rtx cmp_op0, rtx cmp_op1,
@@ -24176,9 +24180,12 @@ ix86_expand_sse_cmp (rtx dest, enum rtx_code code, rtx cmp_op0, rtx cmp_op1,
   else
     cmp_mode = cmp_ops_mode;
 
-
   cmp_op0 = force_reg (cmp_ops_mode, cmp_op0);
-  if (!nonimmediate_operand (cmp_op1, cmp_ops_mode))
+
+  int (*op1_predicate)(rtx, machine_mode)
+    = VECTOR_MODE_P (cmp_ops_mode) ? vector_operand : nonimmediate_operand;
+
+  if (!op1_predicate (cmp_op1, cmp_ops_mode))
     cmp_op1 = force_reg (cmp_ops_mode, cmp_op1);
 
   if (optimize
@@ -24298,7 +24305,7 @@ ix86_expand_sse_movcc (rtx dest, rtx cmp, rtx op_true, rtx op_false)
       rtx (*gen) (rtx, rtx, rtx, rtx) = NULL;
       rtx d = dest;
 
-      if (!nonimmediate_operand (op_true, mode))
+      if (!vector_operand (op_true, mode))
 	op_true = force_reg (mode, op_true);
 
       op_false = force_reg (mode, op_false);
@@ -29109,18 +29116,17 @@ ix86_output_indirect_branch (rtx call_op, const char *xasm,
   else
     ix86_output_indirect_branch_via_push (call_op, xasm, sibcall_p);
 }
-/* Output indirect jump.  CALL_OP is the jump target.  Jump is a
-   function return if RET_P is true.  */
+
+/* Output indirect jump.  CALL_OP is the jump target.  */
 
 const char *
-ix86_output_indirect_jmp (rtx call_op, bool ret_p)
+ix86_output_indirect_jmp (rtx call_op)
 {
   if (cfun->machine->indirect_branch_type != indirect_branch_keep)
     {
-      /* We can't have red-zone if this isn't a function return since
-	 "call" in the indirect thunk pushes the return address onto
-	 stack, destroying red-zone.  */
-      if (!ret_p && ix86_red_zone_size != 0)
+      /* We can't have red-zone since "call" in the indirect thunk
+         pushes the return address onto stack, destroying red-zone.  */
+      if (ix86_red_zone_size != 0)
 	gcc_unreachable ();
 
       ix86_output_indirect_branch (call_op, "%0", true);
@@ -29146,20 +29152,21 @@ ix86_output_function_return (bool long_p)
 	{
 	  bool need_thunk = (cfun->machine->function_return_type
 			     == indirect_branch_thunk);
-	  indirect_thunk_name (thunk_name, -1, need_bnd_p, true);
+	  indirect_thunk_name (thunk_name, INVALID_REGNUM, need_bnd_p,
+			       true);
 	  if (need_bnd_p)
 	    {
-	      indirect_thunk_bnd_needed |= need_thunk;
+	      indirect_return_bnd_needed |= need_thunk;
 	      fprintf (asm_out_file, "\tbnd jmp\t%s\n", thunk_name);
 	    }
 	  else
 	    {
-	      indirect_thunk_needed |= need_thunk;
+	      indirect_return_needed |= need_thunk;
 	      fprintf (asm_out_file, "\tjmp\t%s\n", thunk_name);
 	    }
 	}
       else
-	output_indirect_thunk (need_bnd_p, -1);
+	output_indirect_thunk (need_bnd_p, INVALID_REGNUM);
 
       return "";
     }
@@ -29170,6 +29177,86 @@ ix86_output_function_return (bool long_p)
   return "rep%; ret";
 }
 
+/* Output indirect function return.  RET_OP is the function return
+   target.  */
+
+const char *
+ix86_output_indirect_function_return (rtx ret_op)
+{
+  if (cfun->machine->function_return_type != indirect_branch_keep)
+    {
+      char thunk_name[32];
+      bool need_bnd_p = ix86_bnd_prefixed_insn_p (current_output_insn);
+      unsigned int regno = REGNO (ret_op);
+      gcc_assert (regno == CX_REG);
+
+      if (cfun->machine->function_return_type
+	  != indirect_branch_thunk_inline)
+	{
+	  bool need_thunk = (cfun->machine->function_return_type
+			     == indirect_branch_thunk);
+	  indirect_thunk_name (thunk_name, regno, need_bnd_p, true);
+	  if (need_bnd_p)
+	    {
+	      if (need_thunk)
+		{
+		  indirect_return_via_cx_bnd = true;
+		  indirect_thunks_bnd_used |= 1 << CX_REG;
+		}
+	      fprintf (asm_out_file, "\tbnd jmp\t%s\n", thunk_name);
+	    }
+	  else
+	    {
+	      if (need_thunk)
+		{
+		  indirect_return_via_cx = true;
+		  indirect_thunks_used |= 1 << CX_REG;
+		}
+	      fprintf (asm_out_file, "\tjmp\t%s\n", thunk_name);
+	    }
+	}
+      else
+	output_indirect_thunk (need_bnd_p, regno);
+
+      return "";
+    }
+  else
+    return "%!jmp\t%A0";
+}
+
+/* Split simple return with popping POPC bytes from stack to indirect
+   branch with stack adjustment .  */
+
+void
+ix86_split_simple_return_pop_internal (rtx popc)
+{
+  struct machine_function *m = cfun->machine;
+  rtx ecx = gen_rtx_REG (SImode, CX_REG);
+  rtx_insn *insn;
+
+  /* There is no "pascal" calling convention in any 64bit ABI.  */
+  gcc_assert (!TARGET_64BIT);
+
+  insn = emit_insn (gen_pop (ecx));
+  m->fs.cfa_offset -= UNITS_PER_WORD;
+  m->fs.sp_offset -= UNITS_PER_WORD;
+
+  rtx x = plus_constant (Pmode, stack_pointer_rtx, UNITS_PER_WORD);
+  x = gen_rtx_SET (stack_pointer_rtx, x);
+  add_reg_note (insn, REG_CFA_ADJUST_CFA, x);
+  add_reg_note (insn, REG_CFA_REGISTER, gen_rtx_SET (ecx, pc_rtx));
+  RTX_FRAME_RELATED_P (insn) = 1;
+
+  x = gen_rtx_PLUS (Pmode, stack_pointer_rtx, popc);
+  x = gen_rtx_SET (stack_pointer_rtx, x);
+  insn = emit_insn (x);
+  add_reg_note (insn, REG_CFA_ADJUST_CFA, x);
+  RTX_FRAME_RELATED_P (insn) = 1;
+
+  /* Now return address is in ECX.  */
+  emit_jump_insn (gen_simple_return_indirect_internal (ecx));
+}
+
 /* Output the assembly for a call instruction.  */
 
 const char *
@@ -38340,6 +38427,16 @@ ix86_expand_builtin (tree exp, rtx target, rtx subtarget,
           unsigned char lsb_index = INTVAL (op1) & 0xFF;
           op1 = GEN_INT (length);
           op2 = GEN_INT (lsb_index);
+
+	  mode1 = insn_data[icode].operand[1].mode;
+	  if (!insn_data[icode].operand[1].predicate (op0, mode1))
+	    op0 = copy_to_mode_reg (mode1, op0);
+
+	  mode0 = insn_data[icode].operand[0].mode;
+	  if (target == 0
+	      || !register_operand (target, mode0))
+	    target = gen_reg_rtx (mode0);
+
           pat = GEN_FCN (icode) (target, op0, op1, op2);
           if (pat)
             emit_insn (pat);
@@ -40430,7 +40527,7 @@ ix86_vectorize_builtin_scatter (const_tree vectype,
 static bool
 use_rsqrt_p ()
 {
-  return (TARGET_SSE_MATH
+  return (TARGET_SSE && TARGET_SSE_MATH
 	  && flag_finite_math_only
 	  && !flag_trapping_math
 	  && flag_unsafe_math_optimizations);
@@ -51885,7 +51982,7 @@ ix86_float_exceptions_rounding_supported_p (void)
      there is no adddf3 pattern (since x87 floating point only has
      XFmode operations) so the default hook implementation gets this
      wrong.  */
-  return TARGET_80387 || TARGET_SSE_MATH;
+  return TARGET_80387 || (TARGET_SSE && TARGET_SSE_MATH);
 }
 
 /* Implement TARGET_ATOMIC_ASSIGN_EXPAND_FENV.  */
@@ -51893,7 +51990,7 @@ ix86_float_exceptions_rounding_supported_p (void)
 static void
 ix86_atomic_assign_expand_fenv (tree *hold, tree *clear, tree *update)
 {
-  if (!TARGET_80387 && !TARGET_SSE_MATH)
+  if (!TARGET_80387 && !(TARGET_SSE && TARGET_SSE_MATH))
     return;
   tree exceptions_var = create_tmp_var_raw (integer_type_node);
   if (TARGET_80387)
@@ -51928,7 +52025,7 @@ ix86_atomic_assign_expand_fenv (tree *hold, tree *clear, tree *update)
       tree update_fldenv = build_call_expr (fldenv, 1, fenv_addr);
       *update = build2 (COMPOUND_EXPR, void_type_node, *update, update_fldenv);
     }
-  if (TARGET_SSE_MATH)
+  if (TARGET_SSE && TARGET_SSE_MATH)
     {
       tree mxcsr_orig_var = create_tmp_var_raw (unsigned_type_node);
       tree mxcsr_mod_var = create_tmp_var_raw (unsigned_type_node);
@@ -52287,7 +52384,7 @@ ix86_excess_precision (enum excess_precision_type type)
 	  return FLT_EVAL_METHOD_PROMOTE_TO_FLOAT;
 	else if (!TARGET_MIX_SSE_I387)
 	  {
-	    if (!TARGET_SSE_MATH)
+	    if (!(TARGET_SSE && TARGET_SSE_MATH))
 	      return FLT_EVAL_METHOD_PROMOTE_TO_LONG_DOUBLE;
 	    else if (TARGET_SSE2)
 	      return FLT_EVAL_METHOD_PROMOTE_TO_FLOAT;
diff --git a/gcc/config/i386/i386.h b/gcc/config/i386/i386.h
index e7da790f1b1..0fe4c8b2caa 100644
--- a/gcc/config/i386/i386.h
+++ b/gcc/config/i386/i386.h
@@ -759,8 +759,7 @@ extern const char *host_detect_local_cpu (int argc, const char **argv);
 #define PARM_BOUNDARY BITS_PER_WORD
 
 /* Boundary (in *bits*) on which stack pointer should be aligned.  */
-#define STACK_BOUNDARY \
- (TARGET_64BIT && ix86_abi == MS_ABI ? 128 : BITS_PER_WORD)
+#define STACK_BOUNDARY (TARGET_64BIT_MS_ABI ? 128 : BITS_PER_WORD)
 
 /* Stack boundary of the main function guaranteed by OS.  */
 #define MAIN_STACK_BOUNDARY (TARGET_64BIT ? 128 : 32)
@@ -1557,10 +1556,10 @@ enum reg_class
 #define FIRST_FLOAT_REG FIRST_STACK_REG
 #define STACK_TOP_P(X) (REG_P (X) && REGNO (X) == FIRST_FLOAT_REG)
 
-#define SSE_REGNO(N) \
-  ((N) < 8 ? FIRST_SSE_REG + (N) \
-         : (N) <= LAST_REX_SSE_REG ? (FIRST_REX_SSE_REG + (N) - 8) \
-                                   : (FIRST_EXT_REX_SSE_REG + (N) - 16))
+#define GET_SSE_REGNO(N)			\
+  ((N) < 8 ? FIRST_SSE_REG + (N)		\
+   : (N) < 16 ? FIRST_REX_SSE_REG + (N) - 8	\
+   : FIRST_EXT_REX_SSE_REG + (N) - 16)
 
 /* The class value for index registers, and the one for base regs.  */
 
@@ -2719,6 +2718,11 @@ extern void debug_dispatch_window (int);
 #define TARGET_RECIP_VEC_DIV	((recip_mask & RECIP_MASK_VEC_DIV) != 0)
 #define TARGET_RECIP_VEC_SQRT	((recip_mask & RECIP_MASK_VEC_SQRT) != 0)
 
+
+#define TARGET_INDIRECT_BRANCH_REGISTER \
+  (ix86_indirect_branch_register \
+   || cfun->machine->indirect_branch_type != indirect_branch_keep)
+
 #define IX86_HLE_ACQUIRE (1 << 16)
 #define IX86_HLE_RELEASE (1 << 17)
 
diff --git a/gcc/config/i386/i386.md b/gcc/config/i386/i386.md
index d074c2fb53a..b665dc5834a 100644
--- a/gcc/config/i386/i386.md
+++ b/gcc/config/i386/i386.md
@@ -739,7 +739,7 @@
 	   (if_then_else (match_operand 1 "constant_call_address_operand")
 	     (const_string "none")
 	     (const_string "load"))
-	 (and (eq_attr "type" "alu1,negnot,ishift1,sselog1,sseshuf1")
+	 (and (eq_attr "type" "alu1,negnot,ishift1,rotate1,sselog1,sseshuf1")
 	      (match_operand 1 "memory_operand"))
 	   (const_string "both")
 	 (and (match_operand 0 "memory_operand")
@@ -750,7 +750,7 @@
 	 (match_operand 1 "memory_operand")
 	   (const_string "load")
 	 (and (eq_attr "type"
-		 "!alu1,negnot,ishift1,
+		 "!alu1,negnot,ishift1,rotate1,
 		   imov,imovx,icmp,test,bitmanip,
 		   fmov,fcmp,fsgn,
 		   sse,ssemov,ssecmp,ssecomi,ssecvt,ssecvt1,sseicvt,
@@ -6685,6 +6685,20 @@
    (set_attr "pent_pair" "pu")
    (set_attr "mode" "<MODE>")])
 
+(define_insn "*add<mode>3_carry_0"
+  [(set (match_operand:SWI 0 "nonimmediate_operand" "=<r>m")
+	(plus:SWI
+	  (match_operator:SWI 3 "ix86_carry_flag_operator"
+	    [(match_operand 2 "flags_reg_operand") (const_int 0)])
+	  (match_operand:SWI 1 "nonimmediate_operand" "0")))
+   (clobber (reg:CC FLAGS_REG))]
+  "ix86_unary_operator_ok (PLUS, <MODE>mode, operands)"
+  "adc{<imodesuffix>}\t{$0, %0|%0, 0}"
+  [(set_attr "type" "alu")
+   (set_attr "use_carry" "1")
+   (set_attr "pent_pair" "pu")
+   (set_attr "mode" "<MODE>")])
+
 (define_insn "*addsi3_carry_zext"
   [(set (match_operand:DI 0 "register_operand" "=r")
 	(zero_extend:DI
@@ -6701,6 +6715,20 @@
    (set_attr "pent_pair" "pu")
    (set_attr "mode" "SI")])
 
+(define_insn "*addsi3_carry_zext_0"
+  [(set (match_operand:DI 0 "register_operand" "=r")
+	(zero_extend:DI
+	  (plus:SI (match_operator:SI 2 "ix86_carry_flag_operator"
+		    [(reg FLAGS_REG) (const_int 0)])
+		   (match_operand:SI 1 "register_operand" "0"))))
+   (clobber (reg:CC FLAGS_REG))]
+  "TARGET_64BIT"
+  "adc{l}\t{$0, %k0|%k0, 0}"
+  [(set_attr "type" "alu")
+   (set_attr "use_carry" "1")
+   (set_attr "pent_pair" "pu")
+   (set_attr "mode" "SI")])
+
 ;; There is no point to generate ADCX instruction. ADC is shorter and faster.
 
 (define_insn "addcarry<mode>"
@@ -6741,6 +6769,20 @@
    (set_attr "pent_pair" "pu")
    (set_attr "mode" "<MODE>")])
 
+(define_insn "*sub<mode>3_carry_0"
+  [(set (match_operand:SWI 0 "nonimmediate_operand" "=<r>m")
+	(minus:SWI
+	  (match_operand:SWI 1 "nonimmediate_operand" "0")
+	  (match_operator:SWI 3 "ix86_carry_flag_operator"
+	    [(match_operand 2 "flags_reg_operand") (const_int 0)])))
+   (clobber (reg:CC FLAGS_REG))]
+  "ix86_unary_operator_ok (MINUS, <MODE>mode, operands)"
+  "sbb{<imodesuffix>}\t{$0, %0|%0, 0}"
+  [(set_attr "type" "alu")
+   (set_attr "use_carry" "1")
+   (set_attr "pent_pair" "pu")
+   (set_attr "mode" "<MODE>")])
+
 (define_insn "*subsi3_carry_zext"
   [(set (match_operand:DI 0 "register_operand" "=r")
 	(zero_extend:DI
@@ -6758,6 +6800,21 @@
    (set_attr "pent_pair" "pu")
    (set_attr "mode" "SI")])
 
+(define_insn "*subsi3_carry_zext_0"
+  [(set (match_operand:DI 0 "register_operand" "=r")
+	(zero_extend:DI
+	  (minus:SI
+	    (match_operand:SI 1 "register_operand" "0")
+	    (match_operator:SI 2 "ix86_carry_flag_operator"
+	      [(reg FLAGS_REG) (const_int 0)]))))
+   (clobber (reg:CC FLAGS_REG))]
+  "TARGET_64BIT"
+  "sbb{l}\t{$0, %k0|%k0, 0}"
+  [(set_attr "type" "alu")
+   (set_attr "use_carry" "1")
+   (set_attr "pent_pair" "pu")
+   (set_attr "mode" "SI")])
+
 (define_insn "subborrow<mode>"
   [(set (reg:CCC FLAGS_REG)
 	(compare:CCC
@@ -8211,7 +8268,16 @@
   [(parallel [(set (match_dup 0)
 		   (zero_extend:DI (and:SI (match_dup 1) (match_dup 2))))
 	      (clobber (reg:CC FLAGS_REG))])]
-  "operands[2] = gen_lowpart (SImode, operands[2]);")
+{
+  if (GET_CODE (operands[2]) == SYMBOL_REF
+      || GET_CODE (operands[2]) == LABEL_REF)
+    {
+      operands[2] = shallow_copy_rtx (operands[2]);
+      PUT_MODE (operands[2], SImode);
+    }
+  else
+    operands[2] = gen_lowpart (SImode, operands[2]);
+})
 
 ;; See comment for addsi_1_zext why we do use nonimmediate_operand
 (define_insn "*andsi_1_zext"
@@ -8584,14 +8650,14 @@
 })
 
 (define_insn "*andndi3_doubleword"
-  [(set (match_operand:DI 0 "register_operand" "=r,&r")
+  [(set (match_operand:DI 0 "register_operand" "=&r,r,r,&r")
 	(and:DI
-	  (not:DI (match_operand:DI 1 "register_operand" "r,0"))
-	  (match_operand:DI 2 "nonimmediate_operand" "rm,rm")))
+	  (not:DI (match_operand:DI 1 "register_operand" "r,0,r,0"))
+	  (match_operand:DI 2 "nonimmediate_operand" "rm,rm,0,rm")))
    (clobber (reg:CC FLAGS_REG))]
   "!TARGET_64BIT && TARGET_STV && TARGET_SSE2"
   "#"
-  [(set_attr "isa" "bmi,*")])
+  [(set_attr "isa" "bmi,bmi,bmi,*")])
 
 (define_split
   [(set (match_operand:DI 0 "register_operand")
@@ -9916,7 +9982,7 @@
 {
   switch (get_attr_type (insn))
     {
-    case TYPE_ALU:
+    case TYPE_ALU1:
       gcc_assert (operands[1] == const1_rtx);
       return "add{b}\t%0, %0";
 
@@ -9932,12 +9998,12 @@
      (cond [(and (and (match_test "TARGET_DOUBLE_WITH_ADD")
 		      (match_operand 0 "register_operand"))
 		 (match_operand 1 "const1_operand"))
-	      (const_string "alu")
+	      (const_string "alu1")
 	   ]
 	   (const_string "ishift1")))
    (set (attr "length_immediate")
      (if_then_else
-       (ior (eq_attr "type" "alu")
+       (ior (eq_attr "type" "alu1")
 	    (and (eq_attr "type" "ishift1")
 		 (and (match_operand 1 "const1_operand")
 		      (ior (match_test "TARGET_SHIFT1")
@@ -11625,7 +11691,7 @@
   [(set (pc) (match_operand 0 "indirect_branch_operand"))]
   ""
 {
-  if (TARGET_X32 || ix86_indirect_branch_register)
+  if (TARGET_X32 || TARGET_INDIRECT_BRANCH_REGISTER)
     operands[0] = convert_memory_address (word_mode, operands[0]);
   cfun->machine->has_local_indirect_jump = true;
 })
@@ -11633,7 +11699,7 @@
 (define_insn "*indirect_jump"
   [(set (pc) (match_operand:W 0 "indirect_branch_operand" "rBw"))]
   ""
-  "* return ix86_output_indirect_jmp (operands[0], false);"
+  "* return ix86_output_indirect_jmp (operands[0]);"
   [(set (attr "type")
      (if_then_else (match_test "(cfun->machine->indirect_branch_type
 				 != indirect_branch_keep)")
@@ -11679,7 +11745,7 @@
 					 OPTAB_DIRECT);
     }
 
-  if (TARGET_X32 || ix86_indirect_branch_register)
+  if (TARGET_X32 || TARGET_INDIRECT_BRANCH_REGISTER)
     operands[0] = convert_memory_address (word_mode, operands[0]);
   cfun->machine->has_local_indirect_jump = true;
 })
@@ -11688,7 +11754,7 @@
   [(set (pc) (match_operand:W 0 "indirect_branch_operand" "rBw"))
    (use (label_ref (match_operand 1)))]
   ""
-  "* return ix86_output_indirect_jmp (operands[0], false);"
+  "* return ix86_output_indirect_jmp (operands[0]);"
   [(set (attr "type")
      (if_then_else (match_test "(cfun->machine->indirect_branch_type
 				 != indirect_branch_keep)")
@@ -11730,6 +11796,7 @@
   "(peep2_reg_dead_p (3, operands[1])
     || operands_match_p (operands[1], operands[3]))
    && ! reg_overlap_mentioned_p (operands[3], operands[0])
+   && ! reg_overlap_mentioned_p (operands[3], operands[4])
    && ! reg_set_p (operands[3], operands[4])
    && peep2_regno_dead_p (0, FLAGS_REG)"
   [(parallel [(set (match_dup 5) (match_dup 0))
@@ -11776,6 +11843,7 @@
   "(peep2_reg_dead_p (3, operands[1])
     || operands_match_p (operands[1], operands[3]))
    && ! reg_overlap_mentioned_p (operands[3], operands[0])
+   && ! reg_overlap_mentioned_p (operands[3], operands[4])
    && ! reg_set_p (operands[3], operands[4])
    && peep2_regno_dead_p (0, FLAGS_REG)"
   [(parallel [(set (match_dup 5) (match_dup 0))
@@ -11852,7 +11920,10 @@
 		     (match_operand:SI 0 "register_no_elim_operand" "U")
 		     (match_operand:SI 1 "GOT32_symbol_operand"))))
 	 (match_operand 2))]
-  "!TARGET_MACHO && !TARGET_64BIT && SIBLING_CALL_P (insn)"
+  "!TARGET_MACHO
+  && !TARGET_64BIT
+  && !TARGET_INDIRECT_BRANCH_REGISTER
+  && SIBLING_CALL_P (insn)"
 {
   rtx fnaddr = gen_rtx_PLUS (SImode, operands[0], operands[1]);
   fnaddr = gen_const_mem (SImode, fnaddr);
@@ -11871,7 +11942,7 @@
   [(call (mem:QI (match_operand:W 0 "memory_operand" "m"))
 	 (match_operand 1))
    (unspec [(const_int 0)] UNSPEC_PEEPSIB)]
-  "!TARGET_X32 && !ix86_indirect_branch_register"
+  "!TARGET_X32 && !TARGET_INDIRECT_BRANCH_REGISTER"
   "* return ix86_output_call_insn (insn, operands[0]);"
   [(set_attr "type" "call")])
 
@@ -11881,7 +11952,7 @@
    (call (mem:QI (match_dup 0))
 	 (match_operand 3))]
   "!TARGET_X32
-   && !ix86_indirect_branch_register
+   && !TARGET_INDIRECT_BRANCH_REGISTER
    && SIBLING_CALL_P (peep2_next_insn (1))
    && !reg_mentioned_p (operands[0],
 			CALL_INSN_FUNCTION_USAGE (peep2_next_insn (1)))"
@@ -11896,7 +11967,7 @@
    (call (mem:QI (match_dup 0))
 	 (match_operand 3))]
   "!TARGET_X32
-   && !ix86_indirect_branch_register
+   && !TARGET_INDIRECT_BRANCH_REGISTER
    && SIBLING_CALL_P (peep2_next_insn (2))
    && !reg_mentioned_p (operands[0],
 			CALL_INSN_FUNCTION_USAGE (peep2_next_insn (2)))"
@@ -11994,7 +12065,7 @@
         (match_operand:W 1 "memory_operand"))
    (set (pc) (match_dup 0))]
   "!TARGET_X32
-   && !ix86_indirect_branch_register
+   && !TARGET_INDIRECT_BRANCH_REGISTER
    && peep2_reg_dead_p (2, operands[0])"
   [(set (pc) (match_dup 1))])
 
@@ -12055,7 +12126,10 @@
 			  (match_operand:SI 1 "register_no_elim_operand" "U")
 			  (match_operand:SI 2 "GOT32_symbol_operand"))))
 	 (match_operand 3)))]
-  "!TARGET_MACHO && !TARGET_64BIT && SIBLING_CALL_P (insn)"
+  "!TARGET_MACHO
+   && !TARGET_64BIT
+   && !TARGET_INDIRECT_BRANCH_REGISTER
+   && SIBLING_CALL_P (insn)"
 {
   rtx fnaddr = gen_rtx_PLUS (SImode, operands[1], operands[2]);
   fnaddr = gen_const_mem (SImode, fnaddr);
@@ -12076,7 +12150,7 @@
  	(call (mem:QI (match_operand:W 1 "memory_operand" "m"))
 	      (match_operand 2)))
    (unspec [(const_int 0)] UNSPEC_PEEPSIB)]
-  "!TARGET_X32 && !ix86_indirect_branch_register"
+  "!TARGET_X32 && !TARGET_INDIRECT_BRANCH_REGISTER"
   "* return ix86_output_call_insn (insn, operands[1]);"
   [(set_attr "type" "callv")])
 
@@ -12087,7 +12161,7 @@
    (call (mem:QI (match_dup 0))
 		 (match_operand 3)))]
   "!TARGET_X32
-   && !ix86_indirect_branch_register
+   && !TARGET_INDIRECT_BRANCH_REGISTER
    && SIBLING_CALL_P (peep2_next_insn (1))
    && !reg_mentioned_p (operands[0],
 			CALL_INSN_FUNCTION_USAGE (peep2_next_insn (1)))"
@@ -12104,7 +12178,7 @@
 	(call (mem:QI (match_dup 0))
 	      (match_operand 3)))]
   "!TARGET_X32
-   && !ix86_indirect_branch_register
+   && !TARGET_INDIRECT_BRANCH_REGISTER
    && SIBLING_CALL_P (peep2_next_insn (2))
    && !reg_mentioned_p (operands[0],
 			CALL_INSN_FUNCTION_USAGE (peep2_next_insn (2)))"
@@ -12354,11 +12428,14 @@
    (set_attr "prefix_rep" "1")
    (set_attr "modrm" "0")])
 
-(define_insn "simple_return_pop_internal"
+(define_insn_and_split "simple_return_pop_internal"
   [(simple_return)
    (use (match_operand:SI 0 "const_int_operand"))]
   "reload_completed"
   "%!ret\t%0"
+  "&& cfun->machine->function_return_type != indirect_branch_keep"
+  [(const_int 0)]
+  "ix86_split_simple_return_pop_internal (operands[0]); DONE;"
   [(set_attr "length" "3")
    (set_attr "atom_unit" "jeu")
    (set_attr "length_immediate" "2")
@@ -12369,7 +12446,7 @@
   [(simple_return)
    (use (match_operand:SI 0 "register_operand" "r"))]
   "reload_completed"
-  "* return ix86_output_indirect_jmp (operands[0], true);"
+  "* return ix86_output_indirect_function_return (operands[0]);"
   [(set (attr "type")
      (if_then_else (match_test "(cfun->machine->indirect_branch_type
 				 != indirect_branch_keep)")
@@ -12524,7 +12601,10 @@
      stack address we wish to restore.  */
   tmp = gen_rtx_PLUS (Pmode, arg_pointer_rtx, sa);
   tmp = plus_constant (Pmode, tmp, -UNITS_PER_WORD);
-  tmp = gen_rtx_MEM (Pmode, tmp);
+  /* Return address is always in word_mode.  */
+  tmp = gen_rtx_MEM (word_mode, tmp);
+  if (GET_MODE (ra) != word_mode)
+    ra = convert_to_mode (word_mode, ra, 1);
   emit_move_insn (tmp, ra);
 
   emit_jump_insn (gen_eh_return_internal ());
@@ -15527,7 +15607,8 @@
   "(TARGET_USE_FANCY_MATH_387
     && (!(SSE_FLOAT_MODE_P (<MODE>mode) && TARGET_SSE_MATH)
 	|| TARGET_MIX_SSE_I387)
-    && flag_unsafe_math_optimizations)
+    && flag_unsafe_math_optimizations
+    && (flag_fp_int_builtin_inexact || !flag_trapping_math))
    || (SSE_FLOAT_MODE_P (<MODE>mode) && TARGET_SSE_MATH
        && !flag_trapping_math && !flag_rounding_math)"
 {
diff --git a/gcc/config/i386/predicates.md b/gcc/config/i386/predicates.md
index e4da3092260..7d9e601fc62 100644
--- a/gcc/config/i386/predicates.md
+++ b/gcc/config/i386/predicates.md
@@ -635,7 +635,7 @@
 ;; Test for a valid operand for indirect branch.
 (define_predicate "indirect_branch_operand"
   (ior (match_operand 0 "register_operand")
-       (and (not (match_test "ix86_indirect_branch_register"))
+       (and (not (match_test "TARGET_INDIRECT_BRANCH_REGISTER"))
 	    (not (match_test "TARGET_X32"))
 	    (match_operand 0 "memory_operand"))))
 
@@ -679,7 +679,7 @@
   (ior (match_test "constant_call_address_operand
 		     (op, mode == VOIDmode ? mode : Pmode)")
        (match_operand 0 "call_register_no_elim_operand")
-       (and (not (match_test "ix86_indirect_branch_register"))
+       (and (not (match_test "TARGET_INDIRECT_BRANCH_REGISTER"))
 	    (ior (and (not (match_test "TARGET_X32"))
 		      (match_operand 0 "memory_operand"))
 		 (and (match_test "TARGET_X32 && Pmode == DImode")
@@ -690,7 +690,7 @@
   (ior (match_test "constant_call_address_operand
 		     (op, mode == VOIDmode ? mode : Pmode)")
        (match_operand 0 "register_no_elim_operand")
-       (and (not (match_test "ix86_indirect_branch_register"))
+       (and (not (match_test "TARGET_INDIRECT_BRANCH_REGISTER"))
 	    (ior (and (not (match_test "TARGET_X32"))
 		      (match_operand 0 "sibcall_memory_operand"))
 		 (and (match_test "TARGET_X32 && Pmode == DImode")
@@ -1499,7 +1499,7 @@
       if (GET_CODE (elt) != SET
 	  || GET_CODE (SET_DEST (elt)) != REG
 	  || GET_MODE (SET_DEST (elt)) != V8SImode
-	  || REGNO (SET_DEST (elt)) != SSE_REGNO (i)
+	  || REGNO (SET_DEST (elt)) != GET_SSE_REGNO (i)
 	  || SET_SRC (elt) != CONST0_RTX (V8SImode))
 	return false;
     }
diff --git a/gcc/config/i386/sse.md b/gcc/config/i386/sse.md
index 80cda39bacf..87ae894b235 100644
--- a/gcc/config/i386/sse.md
+++ b/gcc/config/i386/sse.md
@@ -21,6 +21,9 @@
   ;; SSE
   UNSPEC_MOVNT
 
+  ;; SSE2
+  UNSPEC_MOVDI_TO_SSE
+
   ;; SSE3
   UNSPEC_LDDQU
 
@@ -1113,10 +1116,10 @@
 ;; from there.
 
 (define_insn_and_split "movdi_to_sse"
-  [(parallel
-    [(set (match_operand:V4SI 0 "register_operand" "=?x,x")
-	  (subreg:V4SI (match_operand:DI 1 "nonimmediate_operand" "r,m") 0))
-     (clobber (match_scratch:V4SI 2 "=&x,X"))])]
+  [(set (match_operand:V4SI 0 "register_operand" "=?x,x")
+	(unspec:V4SI [(match_operand:DI 1 "nonimmediate_operand" "r,m")]
+		     UNSPEC_MOVDI_TO_SSE))
+     (clobber (match_scratch:V4SI 2 "=&x,X"))]
   "!TARGET_64BIT && TARGET_SSE2 && TARGET_INTER_UNIT_MOVES_TO_VEC"
   "#"
   "&& reload_completed"
@@ -1134,11 +1137,8 @@
 					     operands[2]));
    }
  else if (memory_operand (operands[1], DImode))
-   {
-     rtx tmp = gen_reg_rtx (V2DImode);
-     emit_insn (gen_vec_concatv2di (tmp, operands[1], const0_rtx));
-     emit_move_insn (operands[0], gen_lowpart (V4SImode, tmp));
-   }
+   emit_insn (gen_vec_concatv2di (gen_lowpart (V2DImode, operands[0]),
+				  operands[1], const0_rtx));
  else
    gcc_unreachable ();
  DONE;
@@ -1777,7 +1777,7 @@
   [(set (match_operand:VF1_128_256 0 "register_operand")
 	(unspec:VF1_128_256
 	  [(match_operand:VF1_128_256 1 "vector_operand")] UNSPEC_RSQRT))]
-  "TARGET_SSE_MATH"
+  "TARGET_SSE && TARGET_SSE_MATH"
 {
   ix86_emit_swsqrtsf (operands[0], operands[1], <MODE>mode, true);
   DONE;
@@ -4398,7 +4398,7 @@
 	  (match_operand:VF_128 1 "register_operand" "v")
 	  (const_int 1)))]
   "TARGET_AVX512F && TARGET_64BIT"
-  "vcvtusi2<ssescalarmodesuffix>\t{%2, <round_op3>%1, %0|%0, %1<round_op3>, %2}"
+  "vcvtusi2<ssescalarmodesuffix>{q}\t{%2, <round_op3>%1, %0|%0, %1<round_op3>, %2}"
   [(set_attr "type" "sseicvt")
    (set_attr "prefix" "evex")
    (set_attr "mode" "<ssescalarmode>")])
@@ -4601,37 +4601,49 @@
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 
 (define_insn "sse2_cvtpi2pd"
-  [(set (match_operand:V2DF 0 "register_operand" "=x,x")
-	(float:V2DF (match_operand:V2SI 1 "nonimmediate_operand" "y,m")))]
+  [(set (match_operand:V2DF 0 "register_operand" "=v,x")
+	(float:V2DF (match_operand:V2SI 1 "nonimmediate_operand" "vBm,?!y")))]
   "TARGET_SSE2"
-  "cvtpi2pd\t{%1, %0|%0, %1}"
+  "@
+   %vcvtdq2pd\t{%1, %0|%0, %1}
+   cvtpi2pd\t{%1, %0|%0, %1}"
   [(set_attr "type" "ssecvt")
-   (set_attr "unit" "mmx,*")
-   (set_attr "prefix_data16" "1,*")
+   (set_attr "unit" "*,mmx")
+   (set_attr "prefix_data16" "*,1")
+   (set_attr "prefix" "maybe_vex,*")
    (set_attr "mode" "V2DF")])
 
 (define_insn "sse2_cvtpd2pi"
-  [(set (match_operand:V2SI 0 "register_operand" "=y")
-	(unspec:V2SI [(match_operand:V2DF 1 "nonimmediate_operand" "xm")]
+  [(set (match_operand:V2SI 0 "register_operand" "=v,?!y")
+	(unspec:V2SI [(match_operand:V2DF 1 "nonimmediate_operand" "vBm,xm")]
 		     UNSPEC_FIX_NOTRUNC))]
   "TARGET_SSE2"
-  "cvtpd2pi\t{%1, %0|%0, %1}"
+  "@
+   * return TARGET_AVX ? \"vcvtpd2dq{x}\t{%1, %0|%0, %1}\" : \"cvtpd2dq\t{%1, %0|%0, %1}\";
+   cvtpd2pi\t{%1, %0|%0, %1}"
   [(set_attr "type" "ssecvt")
-   (set_attr "unit" "mmx")
+   (set_attr "unit" "*,mmx")
+   (set_attr "amdfam10_decode" "double")
+   (set_attr "athlon_decode" "vector")
    (set_attr "bdver1_decode" "double")
-   (set_attr "btver2_decode" "direct")
-   (set_attr "prefix_data16" "1")
-   (set_attr "mode" "DI")])
+   (set_attr "prefix_data16" "*,1")
+   (set_attr "prefix" "maybe_vex,*")
+   (set_attr "mode" "TI")])
 
 (define_insn "sse2_cvttpd2pi"
-  [(set (match_operand:V2SI 0 "register_operand" "=y")
-	(fix:V2SI (match_operand:V2DF 1 "nonimmediate_operand" "xm")))]
+  [(set (match_operand:V2SI 0 "register_operand" "=v,?!y")
+	(fix:V2SI (match_operand:V2DF 1 "nonimmediate_operand" "vBm,xm")))]
   "TARGET_SSE2"
-  "cvttpd2pi\t{%1, %0|%0, %1}"
+  "@
+   * return TARGET_AVX ? \"vcvttpd2dq{x}\t{%1, %0|%0, %1}\" : \"cvttpd2dq\t{%1, %0|%0, %1}\";
+   cvttpd2pi\t{%1, %0|%0, %1}"
   [(set_attr "type" "ssecvt")
-   (set_attr "unit" "mmx")
+   (set_attr "unit" "*,mmx")
+   (set_attr "amdfam10_decode" "double")
+   (set_attr "athlon_decode" "vector")
    (set_attr "bdver1_decode" "double")
-   (set_attr "prefix_data16" "1")
+   (set_attr "prefix_data16" "*,1")
+   (set_attr "prefix" "maybe_vex,*")
    (set_attr "mode" "TI")])
 
 (define_insn "sse2_cvtsi2sd"
@@ -8883,14 +8895,14 @@
 ;; see comment above inline_secondary_memory_needed function in i386.c
 (define_insn "sse2_loadhpd"
   [(set (match_operand:V2DF 0 "nonimmediate_operand"
-	  "=x,v,x,v,o,o ,o")
+	  "=x,v,x,v ,o,o ,o")
 	(vec_concat:V2DF
 	  (vec_select:DF
 	    (match_operand:V2DF 1 "nonimmediate_operand"
-	  " 0,v,0,v,0,0 ,0")
+	  " 0,v,0,v ,0,0 ,0")
 	    (parallel [(const_int 0)]))
 	  (match_operand:DF 2 "nonimmediate_operand"
-	  " m,m,x,v,x,*f,r")))]
+	  " m,m,x,Yv,x,*f,r")))]
   "TARGET_SSE2 && !(MEM_P (operands[1]) && MEM_P (operands[2]))"
   "@
    movhpd\t{%2, %0|%0, %2}
@@ -9938,11 +9950,11 @@
    && ix86_binary_operator_ok (<CODE>, <MODE>mode, operands)"
   "@
    p<plusminus_mnemonic><ssemodesuffix>\t{%2, %0|%0, %2}
-   vp<plusminus_mnemonic><ssemodesuffix>\t{%2, %1, %0<mask_operand3>|%0<mask_operand3>, %1, %2}"
+   vp<plusminus_mnemonic><ssemodesuffix>\t{%2, %1, %0|%0, %1, %2}"
   [(set_attr "isa" "noavx,avx")
    (set_attr "type" "sseiadd")
    (set_attr "prefix_data16" "1,*")
-   (set_attr "prefix" "<mask_prefix3>")
+   (set_attr "prefix" "orig,vex")
    (set_attr "mode" "<sseinsnmode>")])
 
 (define_insn "*<plusminus_insn><mode>3_mask"
@@ -10683,11 +10695,14 @@
        (const_string "0")))
    (set_attr "mode" "<sseinsnmode>")])
 
+(define_mode_attr vshift_count
+  [(V32HI "v") (V16HI "Yv") (V8HI "Yv")])
+
 (define_insn "<shift_insn><mode>3<mask_name>"
   [(set (match_operand:VI2_AVX2_AVX512BW 0 "register_operand" "=x,v")
 	(any_lshift:VI2_AVX2_AVX512BW
 	  (match_operand:VI2_AVX2_AVX512BW 1 "register_operand" "0,v")
-	  (match_operand:DI 2 "nonmemory_operand" "xN,vN")))]
+	  (match_operand:DI 2 "nonmemory_operand" "xN,<vshift_count>N")))]
   "TARGET_SSE2 && <mask_mode512bit_condition> && <mask_avx512bw_condition>"
   "@
    p<vshift><ssemodesuffix>\t{%2, %0|%0, %2}
@@ -10706,7 +10721,7 @@
   [(set (match_operand:VI48_AVX2 0 "register_operand" "=x,x,v")
 	(any_lshift:VI48_AVX2
 	  (match_operand:VI48_AVX2 1 "register_operand" "0,x,v")
-	  (match_operand:DI 2 "nonmemory_operand" "xN,xN,vN")))]
+	  (match_operand:DI 2 "nonmemory_operand" "xN,xN,YvN")))]
   "TARGET_SSE2 && <mask_mode512bit_condition>"
   "@
    p<vshift><ssemodesuffix>\t{%2, %0|%0, %2}
@@ -11822,7 +11837,7 @@
 	    (eq_attr "mode" "TI"))
        (const_string "1")
        (const_string "*")))
-   (set_attr "prefix" "<mask_prefix3>")
+   (set_attr "prefix" "orig,vex")
    (set (attr "mode")
 	(cond [(and (match_test "<MODE_SIZE> == 16")
 		    (match_test "TARGET_SSE_PACKED_SINGLE_INSN_OPTIMAL"))
@@ -16012,9 +16027,9 @@
   switch (INTVAL (operands[4]))
     {
     case 3:
-      return "vgatherpf0<ssemodesuffix>ps\t{%5%{%0%}|%5%{%0%}}";
+      return "%M2vgatherpf0<ssemodesuffix>ps\t{%5%{%0%}|%5%{%0%}}";
     case 2:
-      return "vgatherpf1<ssemodesuffix>ps\t{%5%{%0%}|%5%{%0%}}";
+      return "%M2vgatherpf1<ssemodesuffix>ps\t{%5%{%0%}|%5%{%0%}}";
     default:
       gcc_unreachable ();
     }
@@ -16057,9 +16072,9 @@
   switch (INTVAL (operands[4]))
     {
     case 3:
-      return "vgatherpf0<ssemodesuffix>pd\t{%5%{%0%}|%5%{%0%}}";
+      return "%M2vgatherpf0<ssemodesuffix>pd\t{%5%{%0%}|%5%{%0%}}";
     case 2:
-      return "vgatherpf1<ssemodesuffix>pd\t{%5%{%0%}|%5%{%0%}}";
+      return "%M2vgatherpf1<ssemodesuffix>pd\t{%5%{%0%}|%5%{%0%}}";
     default:
       gcc_unreachable ();
     }
@@ -16103,10 +16118,10 @@
     {
     case 3:
     case 7:
-      return "vscatterpf0<ssemodesuffix>ps\t{%5%{%0%}|%5%{%0%}}";
+      return "%M2vscatterpf0<ssemodesuffix>ps\t{%5%{%0%}|%5%{%0%}}";
     case 2:
     case 6:
-      return "vscatterpf1<ssemodesuffix>ps\t{%5%{%0%}|%5%{%0%}}";
+      return "%M2vscatterpf1<ssemodesuffix>ps\t{%5%{%0%}|%5%{%0%}}";
     default:
       gcc_unreachable ();
     }
@@ -16150,10 +16165,10 @@
     {
     case 3:
     case 7:
-      return "vscatterpf0<ssemodesuffix>pd\t{%5%{%0%}|%5%{%0%}}";
+      return "%M2vscatterpf0<ssemodesuffix>pd\t{%5%{%0%}|%5%{%0%}}";
     case 2:
     case 6:
-      return "vscatterpf1<ssemodesuffix>pd\t{%5%{%0%}|%5%{%0%}}";
+      return "%M2vscatterpf1<ssemodesuffix>pd\t{%5%{%0%}|%5%{%0%}}";
     default:
       gcc_unreachable ();
     }
@@ -17245,7 +17260,7 @@
 
   for (regno = 0; regno < nregs; regno++)
     XVECEXP (operands[0], 0, regno + 1)
-      = gen_rtx_SET (gen_rtx_REG (V8SImode, SSE_REGNO (regno)),
+      = gen_rtx_SET (gen_rtx_REG (V8SImode, GET_SSE_REGNO (regno)),
 		     CONST0_RTX (V8SImode));
 })
 
@@ -19017,7 +19032,7 @@
 	  UNSPEC_GATHER))
    (clobber (match_scratch:VEC_GATHER_MODE 1 "=&x"))]
   "TARGET_AVX2"
-  "v<sseintprefix>gatherd<ssemodesuffix>\t{%1, %7, %0|%0, %7, %1}"
+  "%M3v<sseintprefix>gatherd<ssemodesuffix>\t{%1, %7, %0|%0, %7, %1}"
   [(set_attr "type" "ssemov")
    (set_attr "prefix" "vex")
    (set_attr "mode" "<sseinsnmode>")])
@@ -19037,7 +19052,7 @@
 	  UNSPEC_GATHER))
    (clobber (match_scratch:VEC_GATHER_MODE 1 "=&x"))]
   "TARGET_AVX2"
-  "v<sseintprefix>gatherd<ssemodesuffix>\t{%1, %6, %0|%0, %6, %1}"
+  "%M2v<sseintprefix>gatherd<ssemodesuffix>\t{%1, %6, %0|%0, %6, %1}"
   [(set_attr "type" "ssemov")
    (set_attr "prefix" "vex")
    (set_attr "mode" "<sseinsnmode>")])
@@ -19078,7 +19093,7 @@
 	  UNSPEC_GATHER))
    (clobber (match_scratch:VEC_GATHER_MODE 1 "=&x"))]
   "TARGET_AVX2"
-  "v<sseintprefix>gatherq<ssemodesuffix>\t{%5, %7, %2|%2, %7, %5}"
+  "%M3v<sseintprefix>gatherq<ssemodesuffix>\t{%5, %7, %2|%2, %7, %5}"
   [(set_attr "type" "ssemov")
    (set_attr "prefix" "vex")
    (set_attr "mode" "<sseinsnmode>")])
@@ -19100,8 +19115,8 @@
   "TARGET_AVX2"
 {
   if (<MODE>mode != <VEC_GATHER_SRCDI>mode)
-    return "v<sseintprefix>gatherq<ssemodesuffix>\t{%4, %6, %x0|%x0, %6, %4}";
-  return "v<sseintprefix>gatherq<ssemodesuffix>\t{%4, %6, %0|%0, %6, %4}";
+    return "%M2v<sseintprefix>gatherq<ssemodesuffix>\t{%4, %6, %x0|%x0, %6, %4}";
+  return "%M2v<sseintprefix>gatherq<ssemodesuffix>\t{%4, %6, %0|%0, %6, %4}";
 }
   [(set_attr "type" "ssemov")
    (set_attr "prefix" "vex")
@@ -19125,7 +19140,7 @@
 		     (const_int 2) (const_int 3)])))
    (clobber (match_scratch:VI4F_256 1 "=&x"))]
   "TARGET_AVX2"
-  "v<sseintprefix>gatherq<ssemodesuffix>\t{%5, %7, %0|%0, %7, %5}"
+  "%M3v<sseintprefix>gatherq<ssemodesuffix>\t{%5, %7, %0|%0, %7, %5}"
   [(set_attr "type" "ssemov")
    (set_attr "prefix" "vex")
    (set_attr "mode" "<sseinsnmode>")])
@@ -19148,7 +19163,7 @@
 		     (const_int 2) (const_int 3)])))
    (clobber (match_scratch:VI4F_256 1 "=&x"))]
   "TARGET_AVX2"
-  "v<sseintprefix>gatherq<ssemodesuffix>\t{%4, %6, %0|%0, %6, %4}"
+  "%M2v<sseintprefix>gatherq<ssemodesuffix>\t{%4, %6, %0|%0, %6, %4}"
   [(set_attr "type" "ssemov")
    (set_attr "prefix" "vex")
    (set_attr "mode" "<sseinsnmode>")])
@@ -19192,7 +19207,7 @@
 	  UNSPEC_GATHER))
    (clobber (match_scratch:<avx512fmaskmode> 2 "=&Yk"))]
   "TARGET_AVX512F"
-  "v<sseintprefix>gatherd<ssemodesuffix>\t{%6, %0%{%2%}|%0%{%2%}, %<xtg_mode>6}"
+  "%M4v<sseintprefix>gatherd<ssemodesuffix>\t{%6, %0%{%2%}|%0%{%2%}, %<xtg_mode>6}"
   [(set_attr "type" "ssemov")
    (set_attr "prefix" "evex")
    (set_attr "mode" "<sseinsnmode>")])
@@ -19211,7 +19226,7 @@
 	  UNSPEC_GATHER))
    (clobber (match_scratch:<avx512fmaskmode> 1 "=&Yk"))]
   "TARGET_AVX512F"
-  "v<sseintprefix>gatherd<ssemodesuffix>\t{%5, %0%{%1%}|%0%{%1%}, %<xtg_mode>5}"
+  "%M3v<sseintprefix>gatherd<ssemodesuffix>\t{%5, %0%{%1%}|%0%{%1%}, %<xtg_mode>5}"
   [(set_attr "type" "ssemov")
    (set_attr "prefix" "evex")
    (set_attr "mode" "<sseinsnmode>")])
@@ -19251,7 +19266,7 @@
    (clobber (match_scratch:QI 2 "=&Yk"))]
   "TARGET_AVX512F"
 {
-  return "v<sseintprefix>gatherq<ssemodesuffix>\t{%6, %1%{%2%}|%1%{%2%}, %<gatherq_mode>6}";
+  return "%M4v<sseintprefix>gatherq<ssemodesuffix>\t{%6, %1%{%2%}|%1%{%2%}, %<gatherq_mode>6}";
 }
   [(set_attr "type" "ssemov")
    (set_attr "prefix" "evex")
@@ -19275,11 +19290,11 @@
   if (<MODE>mode != <VEC_GATHER_SRCDI>mode)
     {
       if (<MODE_SIZE> != 64)
-	return "v<sseintprefix>gatherq<ssemodesuffix>\t{%5, %x0%{%1%}|%x0%{%1%}, %<gatherq_mode>5}";
+	return "%M3v<sseintprefix>gatherq<ssemodesuffix>\t{%5, %x0%{%1%}|%x0%{%1%}, %<gatherq_mode>5}";
       else
-	return "v<sseintprefix>gatherq<ssemodesuffix>\t{%5, %t0%{%1%}|%t0%{%1%}, %t5}";
+	return "%M3v<sseintprefix>gatherq<ssemodesuffix>\t{%5, %t0%{%1%}|%t0%{%1%}, %t5}";
     }
-  return "v<sseintprefix>gatherq<ssemodesuffix>\t{%5, %0%{%1%}|%0%{%1%}, %<gatherq_mode>5}";
+  return "%M3v<sseintprefix>gatherq<ssemodesuffix>\t{%5, %0%{%1%}|%0%{%1%}, %<gatherq_mode>5}";
 }
   [(set_attr "type" "ssemov")
    (set_attr "prefix" "evex")
@@ -19316,7 +19331,7 @@
 	  UNSPEC_SCATTER))
    (clobber (match_scratch:<avx512fmaskmode> 1 "=&Yk"))]
   "TARGET_AVX512F"
-  "v<sseintprefix>scatterd<ssemodesuffix>\t{%3, %5%{%1%}|%5%{%1%}, %3}"
+  "%M0v<sseintprefix>scatterd<ssemodesuffix>\t{%3, %5%{%1%}|%5%{%1%}, %3}"
   [(set_attr "type" "ssemov")
    (set_attr "prefix" "evex")
    (set_attr "mode" "<sseinsnmode>")])
@@ -19354,8 +19369,8 @@
   "TARGET_AVX512F"
 {
   if (GET_MODE_SIZE (GET_MODE_INNER (<MODE>mode)) == 8)
-    return "v<sseintprefix>scatterq<ssemodesuffix>\t{%3, %5%{%1%}|%5%{%1%}, %3}";
-  return "v<sseintprefix>scatterq<ssemodesuffix>\t{%3, %5%{%1%}|%t5%{%1%}, %3}";
+    return "%M0v<sseintprefix>scatterq<ssemodesuffix>\t{%3, %5%{%1%}|%5%{%1%}, %3}";
+  return "%M0v<sseintprefix>scatterq<ssemodesuffix>\t{%3, %5%{%1%}|%t5%{%1%}, %3}";
 }
   [(set_attr "type" "ssemov")
    (set_attr "prefix" "evex")
diff --git a/gcc/config/m68k/m68k.c b/gcc/config/m68k/m68k.c
index c14ce86d810..68504b84abb 100644
--- a/gcc/config/m68k/m68k.c
+++ b/gcc/config/m68k/m68k.c
@@ -185,6 +185,8 @@ static bool m68k_output_addr_const_extra (FILE *, rtx);
 static void m68k_init_sync_libfuncs (void) ATTRIBUTE_UNUSED;
 static enum flt_eval_method
 m68k_excess_precision (enum excess_precision_type);
+static machine_mode m68k_promote_function_mode (const_tree, machine_mode,
+						int *, const_tree, int);
 
 /* Initialize the GCC target structure.  */
 
@@ -332,6 +334,9 @@ m68k_excess_precision (enum excess_precision_type);
 #undef TARGET_ATOMIC_TEST_AND_SET_TRUEVAL
 #define TARGET_ATOMIC_TEST_AND_SET_TRUEVAL 128
 
+#undef TARGET_PROMOTE_FUNCTION_MODE
+#define TARGET_PROMOTE_FUNCTION_MODE m68k_promote_function_mode
+
 static const struct attribute_spec m68k_attribute_table[] =
 {
   /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler,
@@ -6571,4 +6576,20 @@ m68k_excess_precision (enum excess_precision_type type)
   return FLT_EVAL_METHOD_UNPREDICTABLE;
 }
 
+/* Implement TARGET_PROMOTE_FUNCTION_MODE.  */
+
+static machine_mode
+m68k_promote_function_mode (const_tree type, machine_mode mode,
+                            int *punsignedp ATTRIBUTE_UNUSED,
+                            const_tree fntype ATTRIBUTE_UNUSED,
+                            int for_return)
+{
+  /* Promote libcall arguments narrower than int to match the normal C
+     ABI (for which promotions are handled via
+     TARGET_PROMOTE_PROTOTYPES).  */
+  if (type == NULL_TREE && !for_return && (mode == QImode || mode == HImode))
+    return SImode;
+  return mode;
+}
+
 #include "gt-m68k.h"
diff --git a/gcc/config/msp430/msp430.c b/gcc/config/msp430/msp430.c
index 710a97b2958..c1f0d5b0026 100644
--- a/gcc/config/msp430/msp430.c
+++ b/gcc/config/msp430/msp430.c
@@ -905,6 +905,8 @@ msp430_hard_regno_nregs (int regno ATTRIBUTE_UNUSED,
 {
   if (mode == PSImode && msp430x)
     return 1;
+  if (mode == CPSImode && msp430x)
+    return 2;
   return ((GET_MODE_SIZE (mode) + UNITS_PER_WORD - 1)
 	  / UNITS_PER_WORD);
 }
@@ -927,6 +929,8 @@ msp430_hard_regno_nregs_with_padding (int regno ATTRIBUTE_UNUSED,
 {
   if (mode == PSImode)
     return 2;
+  if (mode == CPSImode)
+    return 4;
   return msp430_hard_regno_nregs (regno, mode);
 }
 
diff --git a/gcc/config/nvptx/nvptx.c b/gcc/config/nvptx/nvptx.c
index e89b314f6ce..af2c4a23dfe 100644
--- a/gcc/config/nvptx/nvptx.c
+++ b/gcc/config/nvptx/nvptx.c
@@ -1875,9 +1875,15 @@ output_init_frag (rtx sym)
   
   if (sym)
     {
-      fprintf (asm_out_file, "generic(");
+      bool function = (SYMBOL_REF_DECL (sym)
+		       && (TREE_CODE (SYMBOL_REF_DECL (sym)) == FUNCTION_DECL));
+      if (!function)
+	fprintf (asm_out_file, "generic(");
       output_address (VOIDmode, sym);
-      fprintf (asm_out_file, val ? ") + " : ")");
+      if (!function)
+	fprintf (asm_out_file, ")");
+      if (val)
+	fprintf (asm_out_file, " + ");
     }
 
   if (!sym || val)
@@ -2002,6 +2008,9 @@ static void
 nvptx_assemble_decl_begin (FILE *file, const char *name, const char *section,
 			   const_tree type, HOST_WIDE_INT size, unsigned align)
 {
+  bool atype = (TREE_CODE (type) == ARRAY_TYPE)
+    && (TYPE_DOMAIN (type) == NULL_TREE);
+
   while (TREE_CODE (type) == ARRAY_TYPE)
     type = TREE_TYPE (type);
 
@@ -2041,6 +2050,8 @@ nvptx_assemble_decl_begin (FILE *file, const char *name, const char *section,
     /* We make everything an array, to simplify any initialization
        emission.  */
     fprintf (file, "[" HOST_WIDE_INT_PRINT_DEC "]", init_frag.remaining);
+  else if (atype)
+    fprintf (file, "[]");
 }
 
 /* Called when the initializer for a decl has been completely output through
diff --git a/gcc/config/pa/pa.c b/gcc/config/pa/pa.c
index 27dcdeab3d2..6d260baf55d 100644
--- a/gcc/config/pa/pa.c
+++ b/gcc/config/pa/pa.c
@@ -1725,9 +1725,7 @@ pa_emit_move_sequence (rtx *operands, machine_mode mode, rtx scratch_reg)
 		}
 	      else
 		emit_move_insn (scratch_reg, XEXP (op1, 0));
-	      emit_insn (gen_rtx_SET (operand0,
-				  replace_equiv_address (op1, scratch_reg)));
-	      return 1;
+	      op1 = replace_equiv_address (op1, scratch_reg);
 	    }
 	}
       else if ((!INT14_OK_STRICT && symbolic_memory_operand (op1, VOIDmode))
@@ -1737,10 +1735,10 @@ pa_emit_move_sequence (rtx *operands, machine_mode mode, rtx scratch_reg)
 	  /* Load memory address into SCRATCH_REG.  */
 	  scratch_reg = force_mode (word_mode, scratch_reg);
 	  emit_move_insn (scratch_reg, XEXP (op1, 0));
-	  emit_insn (gen_rtx_SET (operand0,
-				  replace_equiv_address (op1, scratch_reg)));
-	  return 1;
+	  op1 = replace_equiv_address (op1, scratch_reg);
 	}
+      emit_insn (gen_rtx_SET (operand0, op1));
+      return 1;
     }
   else if (scratch_reg
 	   && FP_REG_P (operand1)
@@ -1778,9 +1776,7 @@ pa_emit_move_sequence (rtx *operands, machine_mode mode, rtx scratch_reg)
 		}
 	      else
 		emit_move_insn (scratch_reg, XEXP (op0, 0));
-	      emit_insn (gen_rtx_SET (replace_equiv_address (op0, scratch_reg),
-				      operand1));
-	      return 1;
+	      op0 = replace_equiv_address (op0, scratch_reg);
 	    }
 	}
       else if ((!INT14_OK_STRICT && symbolic_memory_operand (op0, VOIDmode))
@@ -1790,10 +1786,10 @@ pa_emit_move_sequence (rtx *operands, machine_mode mode, rtx scratch_reg)
 	  /* Load memory address into SCRATCH_REG.  */
 	  scratch_reg = force_mode (word_mode, scratch_reg);
 	  emit_move_insn (scratch_reg, XEXP (op0, 0));
-	  emit_insn (gen_rtx_SET (replace_equiv_address (op0, scratch_reg),
-				  operand1));
-	  return 1;
+	  op0 = replace_equiv_address (op0, scratch_reg);
 	}
+      emit_insn (gen_rtx_SET (op0, operand1));
+      return 1;
     }
   /* Handle secondary reloads for loads of FP registers from constant
      expressions by forcing the constant into memory.  For the most part,
@@ -4562,13 +4558,17 @@ hppa_profile_hook (int label_no)
      lcla2 and load_offset_label_address insn patterns.  */
   rtx reg = gen_reg_rtx (SImode);
   rtx_code_label *label_rtx = gen_label_rtx ();
-  rtx mcount = gen_rtx_MEM (Pmode, gen_rtx_SYMBOL_REF (Pmode, "_mcount"));
   int reg_parm_stack_space = REG_PARM_STACK_SPACE (NULL_TREE);
-  rtx arg_bytes, begin_label_rtx;
+  rtx arg_bytes, begin_label_rtx, mcount, sym;
   rtx_insn *call_insn;
   char begin_label_name[16];
   bool use_mcount_pcrel_call;
 
+  /* Set up call destination.  */
+  sym = gen_rtx_SYMBOL_REF (Pmode, "_mcount");
+  pa_encode_label (sym);
+  mcount = gen_rtx_MEM (Pmode, sym);
+
   /* If we can reach _mcount with a pc-relative call, we can optimize
      loading the address of the current function.  This requires linker
      long branch stub support.  */
@@ -10645,6 +10645,8 @@ pa_output_addr_vec (rtx lab, rtx body)
 {
   int idx, vlen = XVECLEN (body, 0);
 
+  if (!TARGET_SOM)
+    fputs ("\t.align 4\n", asm_out_file);
   targetm.asm_out.internal_label (asm_out_file, "L", CODE_LABEL_NUMBER (lab));
   if (TARGET_GAS)
     fputs ("\t.begin_brtab\n", asm_out_file);
diff --git a/gcc/config/pa/pa.h b/gcc/config/pa/pa.h
index 65df53e54b0..a220d61c55f 100644
--- a/gcc/config/pa/pa.h
+++ b/gcc/config/pa/pa.h
@@ -1153,8 +1153,18 @@ do {									     \
    PREFIX is the class of label and NUM is the number within the class.
    This is suitable for output with `assemble_name'.  */
 
-#define ASM_GENERATE_INTERNAL_LABEL(LABEL,PREFIX,NUM)	\
-  sprintf (LABEL, "*%c$%s%04ld", (PREFIX)[0], (PREFIX) + 1, (long)(NUM))
+#define ASM_GENERATE_INTERNAL_LABEL(LABEL, PREFIX, NUM)		\
+  do								\
+    {								\
+      char *__p;						\
+      (LABEL)[0] = '*';						\
+      (LABEL)[1] = (PREFIX)[0];					\
+      (LABEL)[2] = '$';						\
+      __p = stpcpy (&(LABEL)[3], &(PREFIX)[1]);			\
+      sprint_ul (__p, (unsigned long) (NUM));			\
+    }								\
+  while (0)
+
 
 /* Output the definition of a compiler-generated label named NAME.  */
 
@@ -1172,35 +1182,37 @@ do {									     \
 #define ASM_OUTPUT_ASCII(FILE, P, SIZE)  \
   pa_output_ascii ((FILE), (P), (SIZE))
 
-/* Jump tables are always placed in the text section.  Technically, it
-   is possible to put them in the readonly data section.  This has the
-   benefit of getting the table out of .text and reducing branch lengths
-   as a result.
+/* Jump tables are always placed in the text section.  We have to do
+   this for the HP-UX SOM target as we can't switch sections in the
+   middle of a function.
+
+   On ELF targets, it is possible to put them in the readonly-data section.
+   This would get the table out of .text and reduce branch lengths.
 
-   The downside is that an additional insn (addil) is needed to access
+   A downside is that an additional insn (addil) is needed to access
    the table when generating PIC code.  The address difference table
-   also has to use 32-bit pc-relative relocations.  Currently, GAS does
-   not support these relocations, although it is easily modified to do
-   this operation.
+   also has to use 32-bit pc-relative relocations.
 
    The table entries need to look like "$L1+(.+8-$L0)-$PIC_pcrel$0"
    when using ELF GAS.  A simple difference can be used when using
-   SOM GAS or the HP assembler.  The final downside is GDB complains
-   about the nesting of the label for the table when debugging.  */
+   the HP assembler.
+
+   The final downside is GDB complains about the nesting of the label
+   for the table.  */
 
 #define JUMP_TABLES_IN_TEXT_SECTION 1
 
 /* This is how to output an element of a case-vector that is absolute.  */
 
 #define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \
-  fprintf (FILE, "\t.word L$%04d\n", VALUE)
+  fprintf (FILE, "\t.word L$%d\n", VALUE)
 
 /* This is how to output an element of a case-vector that is relative. 
    Since we always place jump tables in the text section, the difference
    is absolute and requires no relocation.  */
 
 #define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL)  \
-  fprintf (FILE, "\t.word L$%04d-L$%04d\n", VALUE, REL)
+  fprintf (FILE, "\t.word L$%d-L$%d\n", VALUE, REL)
 
 /* This is how to output an absolute case-vector.  */
 
diff --git a/gcc/config/pa/pa.md b/gcc/config/pa/pa.md
index e786d104b1f..d975ddb0f70 100644
--- a/gcc/config/pa/pa.md
+++ b/gcc/config/pa/pa.md
@@ -84,6 +84,7 @@
    UNSPEC_TLSGD_PIC
    UNSPEC_TLSLDM_PIC
    UNSPEC_TLSIE_PIC
+   UNSPEC_MEMORY_BARRIER
   ])
 
 ;; UNSPEC_VOLATILE:
@@ -2536,24 +2537,40 @@
 
   xoperands[0] = operands[0];
   xoperands[1] = operands[1];
-  xoperands[2] = gen_label_rtx ();
 
-  (*targetm.asm_out.internal_label) (asm_out_file, \"L\",
-				     CODE_LABEL_NUMBER (xoperands[2]));
-  output_asm_insn (\"mfia %0\", xoperands);
-
-  /* If we're trying to load the address of a label that happens to be
-     close, then we can use a shorter sequence.  */
   if (GET_CODE (operands[1]) == LABEL_REF
-      && !LABEL_REF_NONLOCAL_P (operands[1])
-      && INSN_ADDRESSES_SET_P ()
-      && abs (INSN_ADDRESSES (INSN_UID (XEXP (operands[1], 0)))
-	        - INSN_ADDRESSES (INSN_UID (insn))) < 8100)
-    output_asm_insn (\"ldo %1-%2(%0),%0\", xoperands);
+      && !LABEL_REF_NONLOCAL_P (operands[1]))
+    {
+      xoperands[2] = gen_label_rtx ();
+      (*targetm.asm_out.internal_label) (asm_out_file, \"L\",
+					 CODE_LABEL_NUMBER (xoperands[2]));
+      output_asm_insn (\"mfia %0\", xoperands);
+
+      /* If we're trying to load the address of a label that happens to be
+	 close, then we can use a shorter sequence.  */
+      if (INSN_ADDRESSES_SET_P ()
+	  && abs (INSN_ADDRESSES (INSN_UID (XEXP (operands[1], 0)))
+		  - INSN_ADDRESSES (INSN_UID (insn))) < 8100)
+	output_asm_insn (\"ldo %1-%2(%0),%0\", xoperands);
+      else
+	{
+	  output_asm_insn (\"addil L%%%1-%2,%0\", xoperands);
+	  output_asm_insn (\"ldo R%%%1-%2(%0),%0\", xoperands);
+	}
+    }
   else
     {
-      output_asm_insn (\"addil L%%%1-%2,%0\", xoperands);
-      output_asm_insn (\"ldo R%%%1-%2(%0),%0\", xoperands);
+      /* Load using linkage table.  */
+      if (TARGET_64BIT)
+	{
+	  output_asm_insn (\"addil LT%%%1,%%r27\", xoperands);
+	  output_asm_insn (\"ldd RT%%%1(%0),%0\", xoperands);
+	}
+      else
+	{
+	  output_asm_insn (\"addil LT%%%1,%%r19\", xoperands);
+	  output_asm_insn (\"ldw RT%%%1(%0),%0\", xoperands);
+	}
     }
   return \"\";
 }"
@@ -2570,25 +2587,33 @@
 
   xoperands[0] = operands[0];
   xoperands[1] = operands[1];
-  xoperands[2] = gen_label_rtx ();
 
-  output_asm_insn (\"bl .+8,%0\", xoperands);
-  output_asm_insn (\"depi 0,31,2,%0\", xoperands);
-  (*targetm.asm_out.internal_label) (asm_out_file, \"L\",
-				     CODE_LABEL_NUMBER (xoperands[2]));
-
-  /* If we're trying to load the address of a label that happens to be
-     close, then we can use a shorter sequence.  */
   if (GET_CODE (operands[1]) == LABEL_REF
-      && !LABEL_REF_NONLOCAL_P (operands[1])
-      && INSN_ADDRESSES_SET_P ()
-      && abs (INSN_ADDRESSES (INSN_UID (XEXP (operands[1], 0)))
-	        - INSN_ADDRESSES (INSN_UID (insn))) < 8100)
-    output_asm_insn (\"ldo %1-%2(%0),%0\", xoperands);
+      && !LABEL_REF_NONLOCAL_P (operands[1]))
+    {
+      xoperands[2] = gen_label_rtx ();
+      output_asm_insn (\"bl .+8,%0\", xoperands);
+      output_asm_insn (\"depi 0,31,2,%0\", xoperands);
+      (*targetm.asm_out.internal_label) (asm_out_file, \"L\",
+					 CODE_LABEL_NUMBER (xoperands[2]));
+
+      /* If we're trying to load the address of a label that happens to be
+	 close, then we can use a shorter sequence.  */
+      if (INSN_ADDRESSES_SET_P ()
+	  && abs (INSN_ADDRESSES (INSN_UID (XEXP (operands[1], 0)))
+		  - INSN_ADDRESSES (INSN_UID (insn))) < 8100)
+	output_asm_insn (\"ldo %1-%2(%0),%0\", xoperands);
+      else
+	{
+	  output_asm_insn (\"addil L%%%1-%2,%0\", xoperands);
+	  output_asm_insn (\"ldo R%%%1-%2(%0),%0\", xoperands);
+	}
+    }
   else
     {
-      output_asm_insn (\"addil L%%%1-%2,%0\", xoperands);
-      output_asm_insn (\"ldo R%%%1-%2(%0),%0\", xoperands);
+      /* Load using linkage table.  */
+      output_asm_insn (\"addil LT%%%1,%%r19\", xoperands);
+      output_asm_insn (\"ldw RT%%%1(%0),%0\", xoperands);
     }
   return \"\";
 }"
@@ -9931,14 +9956,8 @@ add,l %2,%3,%3\;bv,n %%r0(%3)"
 ;; doubleword loads and stores are not guaranteed to be atomic
 ;; when referencing the I/O address space.
 
-;; The kernel cmpxchg operation on linux is not atomic with respect to
-;; memory stores on SMP machines, so we must do stores using a cmpxchg
-;; operation.
-
 ;; These patterns are at the bottom so the non atomic versions are preferred.
 
-;; Implement atomic QImode store using exchange.
-
 (define_expand "atomic_storeqi"
   [(match_operand:QI 0 "memory_operand")                ;; memory
    (match_operand:QI 1 "register_operand")              ;; val out
@@ -9991,25 +10010,7 @@ add,l %2,%3,%3\;bv,n %%r0(%3)"
   FAIL;
 })
 
-;; Implement atomic SFmode store using exchange.
-
-(define_expand "atomic_storesf"
-  [(match_operand:SF 0 "memory_operand")                ;; memory
-   (match_operand:SF 1 "register_operand")              ;; val out
-   (match_operand:SI 2 "const_int_operand")]            ;; model
-  ""
-{
-  if (TARGET_SYNC_LIBCALL)
-    {
-      rtx mem = operands[0];
-      rtx val = operands[1];
-      if (pa_maybe_emit_compare_and_swap_exchange_loop (NULL_RTX, mem, val))
-	DONE;
-    }
-  FAIL;
-})
-
-;; Implement atomic DImode load using 64-bit floating point load.
+;; Implement atomic DImode load.
 
 (define_expand "atomic_loaddi"
   [(match_operand:DI 0 "register_operand")              ;; val out
@@ -10024,29 +10025,27 @@ add,l %2,%3,%3\;bv,n %%r0(%3)"
 
   model = memmodel_from_int (INTVAL (operands[2]));
   operands[1] = force_reg (SImode, XEXP (operands[1], 0));
-  expand_mem_thread_fence (model);
-  emit_insn (gen_atomic_loaddi_1 (operands[0], operands[1]));
   if (is_mm_seq_cst (model))
     expand_mem_thread_fence (model);
+  emit_insn (gen_atomic_loaddi_1 (operands[0], operands[1]));
+  expand_mem_thread_fence (model);
   DONE;
 })
 
 (define_insn "atomic_loaddi_1"
-  [(set (match_operand:DI 0 "register_operand" "=f,r")
-        (mem:DI (match_operand:SI 1 "register_operand" "r,r")))
-   (clobber (match_scratch:DI 2 "=X,f"))]
+  [(set (match_operand:DI 0 "register_operand" "=r")
+        (mem:DI (match_operand:SI 1 "register_operand" "r")))
+   (clobber (match_scratch:DI 2 "=f"))]
   "!TARGET_64BIT && !TARGET_DISABLE_FPREGS && !TARGET_SOFT_FLOAT"
-  "@
-   {fldds|fldd} 0(%1),%0
-   {fldds|fldd} 0(%1),%2\n\t{fstds|fstd} %2,-16(%%sp)\n\t{ldws|ldw} -16(%%sp),%0\n\t{ldws|ldw} -12(%%sp),%R0"
-  [(set_attr "type" "move,move")
-   (set_attr "length" "4,16")])
+  "{fldds|fldd} 0(%1),%2\n\t{fstds|fstd} %2,-16(%%sp)\n\t{ldws|ldw} -16(%%sp),%0\n\t{ldws|ldw} -12(%%sp),%R0"
+  [(set_attr "type" "move")
+   (set_attr "length" "16")])
 
 ;; Implement atomic DImode store.
 
 (define_expand "atomic_storedi"
   [(match_operand:DI 0 "memory_operand")                ;; memory
-   (match_operand:DI 1 "register_operand")              ;; val out
+   (match_operand:DI 1 "reg_or_cint_move_operand")      ;; val out
    (match_operand:SI 2 "const_int_operand")]            ;; model
   ""
 {
@@ -10065,6 +10064,8 @@ add,l %2,%3,%3\;bv,n %%r0(%3)"
 
   model = memmodel_from_int (INTVAL (operands[2]));
   operands[0] = force_reg (SImode, XEXP (operands[0], 0));
+  if (operands[1] != CONST0_RTX (DImode))
+    operands[1] = force_reg (DImode, operands[1]);
   expand_mem_thread_fence (model);
   emit_insn (gen_atomic_storedi_1 (operands[0], operands[1]));
   if (is_mm_seq_cst (model))
@@ -10074,87 +10075,33 @@ add,l %2,%3,%3\;bv,n %%r0(%3)"
 
 (define_insn "atomic_storedi_1"
   [(set (mem:DI (match_operand:SI 0 "register_operand" "r,r"))
-        (match_operand:DI 1 "register_operand" "f,r"))
+        (match_operand:DI 1 "reg_or_0_operand" "M,r"))
    (clobber (match_scratch:DI 2 "=X,f"))]
-  "!TARGET_64BIT && !TARGET_DISABLE_FPREGS
-   && !TARGET_SOFT_FLOAT && !TARGET_SYNC_LIBCALL"
+  "!TARGET_64BIT && !TARGET_DISABLE_FPREGS && !TARGET_SOFT_FLOAT"
   "@
-   {fstds|fstd} %1,0(%0)
+   {fstds|fstd} %%fr0,0(%0)
    {stws|stw} %1,-16(%%sp)\n\t{stws|stw} %R1,-12(%%sp)\n\t{fldds|fldd} -16(%%sp),%2\n\t{fstds|fstd} %2,0(%0)"
   [(set_attr "type" "move,move")
    (set_attr "length" "4,16")])
 
-;; Implement atomic DFmode load using 64-bit floating point load.
+;; PA 2.0 hardware supports out-of-order execution of loads and stores, so
+;; we need a memory barrier to enforce program order for memory references.
+;; Since we want PA 1.x code to be PA 2.0 compatible, we also need the
+;; barrier when generating PA 1.x code.
 
-(define_expand "atomic_loaddf"
-  [(match_operand:DF 0 "register_operand")              ;; val out
-   (match_operand:DF 1 "memory_operand")                ;; memory
-   (match_operand:SI 2 "const_int_operand")]            ;; model
+(define_expand "memory_barrier"
+  [(set (match_dup 0)
+        (unspec:BLK [(match_dup 0)] UNSPEC_MEMORY_BARRIER))]
   ""
 {
-  enum memmodel model;
-
-  if (TARGET_64BIT || TARGET_DISABLE_FPREGS || TARGET_SOFT_FLOAT)
-    FAIL;
-
-  model = memmodel_from_int (INTVAL (operands[2]));
-  operands[1] = force_reg (SImode, XEXP (operands[1], 0));
-  expand_mem_thread_fence (model);
-  emit_insn (gen_atomic_loaddf_1 (operands[0], operands[1]));
-  if (is_mm_seq_cst (model))
-    expand_mem_thread_fence (model);
-  DONE;
+  operands[0] = gen_rtx_MEM (BLKmode, gen_rtx_SCRATCH (Pmode));
+  MEM_VOLATILE_P (operands[0]) = 1;
 })
 
-(define_insn "atomic_loaddf_1"
-  [(set (match_operand:DF 0 "register_operand" "=f,r")
-        (mem:DF (match_operand:SI 1 "register_operand" "r,r")))
-   (clobber (match_scratch:DF 2 "=X,f"))]
-  "!TARGET_64BIT && !TARGET_DISABLE_FPREGS && !TARGET_SOFT_FLOAT"
-  "@
-   {fldds|fldd} 0(%1),%0
-   {fldds|fldd} 0(%1),%2\n\t{fstds|fstd} %2,-16(%%sp)\n\t{ldws|ldw} -16(%%sp),%0\n\t{ldws|ldw} -12(%%sp),%R0"
-  [(set_attr "type" "move,move")
-   (set_attr "length" "4,16")])
-
-;; Implement atomic DFmode store using 64-bit floating point store.
-
-(define_expand "atomic_storedf"
-  [(match_operand:DF 0 "memory_operand")                ;; memory
-   (match_operand:DF 1 "register_operand")              ;; val out
-   (match_operand:SI 2 "const_int_operand")]            ;; model
+(define_insn "*memory_barrier"
+  [(set (match_operand:BLK 0 "" "")
+        (unspec:BLK [(match_dup 0)] UNSPEC_MEMORY_BARRIER))]
   ""
-{
-  enum memmodel model;
-
-  if (TARGET_SYNC_LIBCALL)
-    {
-      rtx mem = operands[0];
-      rtx val = operands[1];
-      if (pa_maybe_emit_compare_and_swap_exchange_loop (NULL_RTX, mem, val))
-	DONE;
-    }
-
-  if (TARGET_64BIT || TARGET_DISABLE_FPREGS || TARGET_SOFT_FLOAT)
-    FAIL;
-
-  model = memmodel_from_int (INTVAL (operands[2]));
-  operands[0] = force_reg (SImode, XEXP (operands[0], 0));
-  expand_mem_thread_fence (model);
-  emit_insn (gen_atomic_storedf_1 (operands[0], operands[1]));
-  if (is_mm_seq_cst (model))
-    expand_mem_thread_fence (model);
-  DONE;
-})
-
-(define_insn "atomic_storedf_1"
-  [(set (mem:DF (match_operand:SI 0 "register_operand" "r,r"))
-        (match_operand:DF 1 "register_operand" "f,r"))
-   (clobber (match_scratch:DF 2 "=X,f"))]
-  "!TARGET_64BIT && !TARGET_DISABLE_FPREGS
-   && !TARGET_SOFT_FLOAT && !TARGET_SYNC_LIBCALL"
-  "@
-   {fstds|fstd} %1,0(%0)
-   {stws|stw} %1,-16(%%sp)\n\t{stws|stw} %R1,-12(%%sp)\n\t{fldds|fldd} -16(%%sp),%2\n\t{fstds|fstd} %2,0(%0)"
-  [(set_attr "type" "move,move")
-   (set_attr "length" "4,16")])
+  "sync"
+  [(set_attr "type" "binary")
+   (set_attr "length" "4")])
diff --git a/gcc/config/pa/pa32-linux.h b/gcc/config/pa/pa32-linux.h
index 131f26cfbed..01c82b13ecc 100644
--- a/gcc/config/pa/pa32-linux.h
+++ b/gcc/config/pa/pa32-linux.h
@@ -62,3 +62,12 @@ call_ ## FUNC (void)					\
 
 #undef  WCHAR_TYPE_SIZE
 #define WCHAR_TYPE_SIZE BITS_PER_WORD
+
+/* Place jump tables in the text section except when generating non-PIC
+   code.  When generating non-PIC code, the relocations needed to load the
+   address of the jump table result in a text label in the final executable
+   if the jump table is placed in the text section.  This breaks the unwind
+   data for the function.  Thus, the jump table needs to be placed in
+   rodata when generating non-PIC code.  */
+#undef JUMP_TABLES_IN_TEXT_SECTION
+#define JUMP_TABLES_IN_TEXT_SECTION (flag_pic)
diff --git a/gcc/config/pa/pa64-hpux.h b/gcc/config/pa/pa64-hpux.h
index 8b7a42be3b5..5b21482602d 100644
--- a/gcc/config/pa/pa64-hpux.h
+++ b/gcc/config/pa/pa64-hpux.h
@@ -245,8 +245,18 @@ do {								\
 
 /* We need to use the HP style for internal labels.  */
 #undef ASM_GENERATE_INTERNAL_LABEL
-#define ASM_GENERATE_INTERNAL_LABEL(LABEL, PREFIX, NUM)	\
-  sprintf (LABEL, "*%c$%s%04ld", (PREFIX)[0], (PREFIX) + 1, (long)(NUM))
+#define ASM_GENERATE_INTERNAL_LABEL(LABEL, PREFIX, NUM)		\
+  do								\
+    {								\
+      char *__p;						\
+      (LABEL)[0] = '*';						\
+      (LABEL)[1] = (PREFIX)[0];					\
+      (LABEL)[2] = '$';						\
+      __p = stpcpy (&(LABEL)[3], &(PREFIX)[1]);			\
+      sprint_ul (__p, (unsigned long) (NUM));			\
+    }								\
+  while (0)
+
 
 #else /* USING_ELFOS_H */
 
diff --git a/gcc/config/pa/predicates.md b/gcc/config/pa/predicates.md
index 75187eeb406..8f1be3e0fd6 100644
--- a/gcc/config/pa/predicates.md
+++ b/gcc/config/pa/predicates.md
@@ -277,6 +277,9 @@
     case HImode:
       return true;
 
+    case VOIDmode:
+      return false;
+
     default:
       return (INTVAL (op) % GET_MODE_SIZE (mode)) == 0;
     }
diff --git a/gcc/config/riscv/t-rtems b/gcc/config/riscv/t-rtems
new file mode 100644
index 00000000000..41f5927fc87
--- /dev/null
+++ b/gcc/config/riscv/t-rtems
@@ -0,0 +1,25 @@
+MULTILIB_OPTIONS	=
+MULTILIB_DIRNAMES	=
+
+MULTILIB_OPTIONS	+= march=rv32i/march=rv32im/march=rv32imafd/march=rv32iac/march=rv32imac/march=rv32imafc/march=rv64imafd/march=rv64imac/march=rv64imafdc
+MULTILIB_DIRNAMES	+= rv32i       rv32im       rv32imafd       rv32iac       rv32imac       rv32imafc       rv64imafd       rv64imac       rv64imafdc
+
+MULTILIB_OPTIONS	+= mabi=ilp32/mabi=ilp32f/mabi=ilp32d/mabi=lp64/mabi=lp64d
+MULTILIB_DIRNAMES	+= ilp32      ilp32f      ilp32d      lp64      lp64d
+
+MULTILIB_OPTIONS	+= mcmodel=medany
+MULTILIB_DIRNAMES	+= medany
+
+MULTILIB_REQUIRED	=
+MULTILIB_REQUIRED	+= march=rv32i/mabi=ilp32
+MULTILIB_REQUIRED	+= march=rv32im/mabi=ilp32
+MULTILIB_REQUIRED	+= march=rv32imafd/mabi=ilp32d
+MULTILIB_REQUIRED	+= march=rv32iac/mabi=ilp32
+MULTILIB_REQUIRED	+= march=rv32imac/mabi=ilp32
+MULTILIB_REQUIRED	+= march=rv32imafc/mabi=ilp32f
+MULTILIB_REQUIRED	+= march=rv64imafd/mabi=lp64d
+MULTILIB_REQUIRED	+= march=rv64imafd/mabi=lp64d/mcmodel=medany
+MULTILIB_REQUIRED	+= march=rv64imac/mabi=lp64
+MULTILIB_REQUIRED	+= march=rv64imac/mabi=lp64/mcmodel=medany
+MULTILIB_REQUIRED	+= march=rv64imafdc/mabi=lp64d
+MULTILIB_REQUIRED	+= march=rv64imafdc/mabi=lp64d/mcmodel=medany
diff --git a/gcc/config/rs6000/altivec.h b/gcc/config/rs6000/altivec.h
index b9de05a72f0..757be5b2de2 100644
--- a/gcc/config/rs6000/altivec.h
+++ b/gcc/config/rs6000/altivec.h
@@ -388,6 +388,11 @@
 #define vec_vsubuqm __builtin_vec_vsubuqm
 #define vec_vupkhsw __builtin_vec_vupkhsw
 #define vec_vupklsw __builtin_vec_vupklsw
+#define vec_sbox_be __builtin_crypto_vsbox_be
+#define vec_cipher_be __builtin_crypto_vcipher_be
+#define vec_cipherlast_be __builtin_crypto_vcipherlast_be
+#define vec_ncipher_be __builtin_crypto_vncipher_be
+#define vec_ncipherlast_be __builtin_crypto_vncipherlast_be
 #endif
 
 #ifdef __POWER9_VECTOR__
@@ -398,8 +403,8 @@
 #define vec_vctzd __builtin_vec_vctzd
 #define vec_vctzh __builtin_vec_vctzh
 #define vec_vctzw __builtin_vec_vctzw
-#define vec_vextract4b __builtin_vec_vextract4b
-#define vec_vinsert4b __builtin_vec_vinsert4b
+#define vec_extract4b __builtin_vec_extract4b
+#define vec_insert4b __builtin_vec_insert4b
 #define vec_vprtyb __builtin_vec_vprtyb
 #define vec_vprtybd __builtin_vec_vprtybd
 #define vec_vprtybw __builtin_vec_vprtybw
@@ -421,6 +426,11 @@
 #define vec_insert_exp __builtin_vec_insert_exp
 #define vec_test_data_class __builtin_vec_test_data_class
 
+#define vec_extract_fp_from_shorth __builtin_vec_vextract_fp_from_shorth
+#define vec_extract_fp_from_shortl __builtin_vec_vextract_fp_from_shortl
+#define vec_extract_fp32_from_shorth __builtin_vec_vextract_fp_from_shorth
+#define vec_extract_fp32_from_shortl __builtin_vec_vextract_fp_from_shortl
+
 #define scalar_extract_exp __builtin_vec_scalar_extract_exp
 #define scalar_extract_sig __builtin_vec_scalar_extract_sig
 #define scalar_insert_exp __builtin_vec_scalar_insert_exp
diff --git a/gcc/config/rs6000/altivec.md b/gcc/config/rs6000/altivec.md
index 06c7582c5a5..32dfa8f999a 100644
--- a/gcc/config/rs6000/altivec.md
+++ b/gcc/config/rs6000/altivec.md
@@ -414,7 +414,6 @@
 (define_insn "*restore_world"
  [(match_parallel 0 "restore_world_operation"
                   [(return)
-		   (use (reg:SI LR_REGNO))
                    (use (match_operand:SI 1 "call_operand" "s"))
                    (clobber (match_operand:SI 2 "gpc_reg_operand" "=r"))])]
  "TARGET_MACHO && (DEFAULT_ABI == ABI_DARWIN) && TARGET_32BIT"
@@ -2616,39 +2615,49 @@
   "lvx %0,%y1"
   [(set_attr "type" "vecload")])
 
-; The next two patterns embody what lvx should usually look like.
-(define_insn "altivec_lvx_<mode>_2op"
-  [(set (match_operand:VM2 0 "register_operand" "=v")
-        (mem:VM2 (and:DI (plus:DI (match_operand:DI 1 "register_operand" "b")
-                                  (match_operand:DI 2 "register_operand" "r"))
-		         (const_int -16))))]
-  "TARGET_ALTIVEC && TARGET_64BIT"
-  "lvx %0,%1,%2"
-  [(set_attr "type" "vecload")])
-
-(define_insn "altivec_lvx_<mode>_1op"
-  [(set (match_operand:VM2 0 "register_operand" "=v")
-        (mem:VM2 (and:DI (match_operand:DI 1 "register_operand" "r")
-			 (const_int -16))))]
-  "TARGET_ALTIVEC && TARGET_64BIT"
-  "lvx %0,0,%1"
-  [(set_attr "type" "vecload")])
+; The following patterns embody what lvx should usually look like.
+(define_expand "altivec_lvx_<VM2:mode>"
+  [(set (match_operand:VM2 0 "register_operand")
+	(match_operand:VM2 1 "altivec_indexed_or_indirect_operand"))]
+  "TARGET_ALTIVEC"
+{
+  rtx addr = XEXP (operand1, 0);
+  if (GET_CODE (addr) == PLUS
+      && REG_P (XEXP (addr, 0))
+      && REG_P (XEXP (addr, 1)))
+    {
+      rtx op1 = XEXP (addr, 0);
+      rtx op2 = XEXP (addr, 1);
+      if (TARGET_64BIT)
+	emit_insn (gen_altivec_lvx_<VM2:mode>_2op_di (operand0, op1, op2));
+      else
+	emit_insn (gen_altivec_lvx_<VM2:mode>_2op_si (operand0, op1, op2));
+    }
+  else
+    {
+      if (TARGET_64BIT)
+	emit_insn (gen_altivec_lvx_<VM2:mode>_1op_di (operand0, addr));
+      else
+	emit_insn (gen_altivec_lvx_<VM2:mode>_1op_si (operand0, addr));
+    }
+  DONE;
+})
 
-; 32-bit versions of the above.
-(define_insn "altivec_lvx_<mode>_2op_si"
+; The next two patterns embody what lvx should usually look like.
+(define_insn "altivec_lvx_<VM2:mode>_2op_<P:mptrsize>"
   [(set (match_operand:VM2 0 "register_operand" "=v")
-        (mem:VM2 (and:SI (plus:SI (match_operand:SI 1 "register_operand" "b")
-                                  (match_operand:SI 2 "register_operand" "r"))
-		         (const_int -16))))]
-  "TARGET_ALTIVEC && TARGET_32BIT"
+	(mem:VM2 (and:P (plus:P (match_operand:P 1 "register_operand" "b")
+				(match_operand:P 2 "register_operand" "r"))
+			(const_int -16))))]
+  "TARGET_ALTIVEC"
   "lvx %0,%1,%2"
   [(set_attr "type" "vecload")])
 
-(define_insn "altivec_lvx_<mode>_1op_si"
+(define_insn "altivec_lvx_<VM2:mode>_1op_<P:mptrsize>"
   [(set (match_operand:VM2 0 "register_operand" "=v")
-        (mem:VM2 (and:SI (match_operand:SI 1 "register_operand" "r")
-			 (const_int -16))))]
-  "TARGET_ALTIVEC && TARGET_32BIT"
+	(mem:VM2 (and:P (match_operand:P 1 "register_operand" "r")
+			(const_int -16))))]
+  "TARGET_ALTIVEC"
   "lvx %0,0,%1"
   [(set_attr "type" "vecload")])
 
@@ -2664,39 +2673,49 @@
   "stvx %1,%y0"
   [(set_attr "type" "vecstore")])
 
-; The next two patterns embody what stvx should usually look like.
-(define_insn "altivec_stvx_<mode>_2op"
-  [(set (mem:VM2 (and:DI (plus:DI (match_operand:DI 1 "register_operand" "b")
-  	                          (match_operand:DI 2 "register_operand" "r"))
-	                 (const_int -16)))
-        (match_operand:VM2 0 "register_operand" "v"))]
-  "TARGET_ALTIVEC && TARGET_64BIT"
-  "stvx %0,%1,%2"
-  [(set_attr "type" "vecstore")])
-
-(define_insn "altivec_stvx_<mode>_1op"
-  [(set (mem:VM2 (and:DI (match_operand:DI 1 "register_operand" "r")
-	                 (const_int -16)))
-        (match_operand:VM2 0 "register_operand" "v"))]
-  "TARGET_ALTIVEC && TARGET_64BIT"
-  "stvx %0,0,%1"
-  [(set_attr "type" "vecstore")])
+; The following patterns embody what stvx should usually look like.
+(define_expand "altivec_stvx_<VM2:mode>"
+  [(set (match_operand:VM2 1 "altivec_indexed_or_indirect_operand")
+	(match_operand:VM2 0 "register_operand"))]
+  "TARGET_ALTIVEC"
+{
+  rtx addr = XEXP (operand1, 0);
+  if (GET_CODE (addr) == PLUS
+      && REG_P (XEXP (addr, 0))
+      && REG_P (XEXP (addr, 1)))
+    {
+      rtx op1 = XEXP (addr, 0);
+      rtx op2 = XEXP (addr, 1);
+      if (TARGET_64BIT)
+	emit_insn (gen_altivec_stvx_<VM2:mode>_2op_di (operand0, op1, op2));
+      else
+	emit_insn (gen_altivec_stvx_<VM2:mode>_2op_si (operand0, op1, op2));
+    }
+  else
+    {
+      if (TARGET_64BIT)
+	emit_insn (gen_altivec_stvx_<VM2:mode>_1op_di (operand0, addr));
+      else
+	emit_insn (gen_altivec_stvx_<VM2:mode>_1op_si (operand0, addr));
+    }
+  DONE;
+})
 
-; 32-bit versions of the above.
-(define_insn "altivec_stvx_<mode>_2op_si"
-  [(set (mem:VM2 (and:SI (plus:SI (match_operand:SI 1 "register_operand" "b")
-  	                          (match_operand:SI 2 "register_operand" "r"))
-	                 (const_int -16)))
-        (match_operand:VM2 0 "register_operand" "v"))]
-  "TARGET_ALTIVEC && TARGET_32BIT"
+; The next two patterns embody what stvx should usually look like.
+(define_insn "altivec_stvx_<VM2:mode>_2op_<P:mptrsize>"
+  [(set (mem:VM2 (and:P (plus:P (match_operand:P 1 "register_operand" "b")
+				(match_operand:P 2 "register_operand" "r"))
+			(const_int -16)))
+	(match_operand:VM2 0 "register_operand" "v"))]
+  "TARGET_ALTIVEC"
   "stvx %0,%1,%2"
   [(set_attr "type" "vecstore")])
 
-(define_insn "altivec_stvx_<mode>_1op_si"
-  [(set (mem:VM2 (and:SI (match_operand:SI 1 "register_operand" "r")
-	                 (const_int -16)))
-        (match_operand:VM2 0 "register_operand" "v"))]
-  "TARGET_ALTIVEC && TARGET_32BIT"
+(define_insn "altivec_stvx_<VM2:mode>_1op_<P:mptrsize>"
+  [(set (mem:VM2 (and:P (match_operand:P 1 "register_operand" "r")
+			(const_int -16)))
+	(match_operand:VM2 0 "register_operand" "v"))]
+  "TARGET_ALTIVEC"
   "stvx %0,0,%1"
   [(set_attr "type" "vecstore")])
 
diff --git a/gcc/config/rs6000/crypto.md b/gcc/config/rs6000/crypto.md
index 5892f8918f2..316f5aa440a 100644
--- a/gcc/config/rs6000/crypto.md
+++ b/gcc/config/rs6000/crypto.md
@@ -48,6 +48,9 @@
 ;; Iterator for VSHASIGMAD/VSHASIGMAW
 (define_mode_iterator CR_hash [V4SI V2DI])
 
+;; Iterator for VSBOX/VCIPHER/VNCIPHER/VCIPHERLAST/VNCIPHERLAST
+(define_mode_iterator CR_vqdi [V16QI V2DI])
+
 ;; Iterator for the other crypto functions
 (define_int_iterator CR_code   [UNSPEC_VCIPHER
 				UNSPEC_VNCIPHER
@@ -60,10 +63,10 @@
 			  (UNSPEC_VNCIPHERLAST "vncipherlast")])
 
 ;; 2 operand crypto instructions
-(define_insn "crypto_<CR_insn>"
-  [(set (match_operand:V2DI 0 "register_operand" "=v")
-	(unspec:V2DI [(match_operand:V2DI 1 "register_operand" "v")
-		      (match_operand:V2DI 2 "register_operand" "v")]
+(define_insn "crypto_<CR_insn>_<mode>"
+  [(set (match_operand:CR_vqdi 0 "register_operand" "=v")
+	(unspec:CR_vqdi [(match_operand:CR_vqdi 1 "register_operand" "v")
+		      (match_operand:CR_vqdi 2 "register_operand" "v")]
 		     CR_code))]
   "TARGET_CRYPTO"
   "<CR_insn> %0,%1,%2"
@@ -90,9 +93,9 @@
   [(set_attr "type" "vecperm")])
 
 ;; 1 operand crypto instruction
-(define_insn "crypto_vsbox"
-  [(set (match_operand:V2DI 0 "register_operand" "=v")
-	(unspec:V2DI [(match_operand:V2DI 1 "register_operand" "v")]
+(define_insn "crypto_vsbox_<mode>"
+  [(set (match_operand:CR_vqdi 0 "register_operand" "=v")
+	(unspec:CR_vqdi [(match_operand:CR_vqdi 1 "register_operand" "v")]
 		     UNSPEC_VSBOX))]
   "TARGET_CRYPTO"
   "vsbox %0,%1"
diff --git a/gcc/config/rs6000/darwin7.h b/gcc/config/rs6000/darwin7.h
index f5e9f893030..5146707c6aa 100644
--- a/gcc/config/rs6000/darwin7.h
+++ b/gcc/config/rs6000/darwin7.h
@@ -28,5 +28,10 @@ along with GCC; see the file COPYING3.  If not see
   %:version-compare(!< 10.3 mmacosx-version-min= -lmx)\
   -lSystem}"
 
+/* This generation of tools (specifically the archive tool) did not
+   export weak symbols from the TOC. */
+#undef TARGET_WEAK_NOT_IN_ARCHIVE_TOC
+#define TARGET_WEAK_NOT_IN_ARCHIVE_TOC 1
+
 #undef DEF_MIN_OSX_VERSION
 #define DEF_MIN_OSX_VERSION "10.3.9"
diff --git a/gcc/config/rs6000/driver-rs6000.c b/gcc/config/rs6000/driver-rs6000.c
index 8215abbd625..04936bd9b9b 100644
--- a/gcc/config/rs6000/driver-rs6000.c
+++ b/gcc/config/rs6000/driver-rs6000.c
@@ -21,6 +21,8 @@ along with GCC; see the file COPYING3.  If not see
 #include "system.h"
 #include "coretypes.h"
 #include "tm.h"
+#include "diagnostic.h"
+#include "opts.h"
 #include <stdlib.h>
 
 #ifdef _AIX
@@ -36,6 +38,44 @@ along with GCC; see the file COPYING3.  If not see
 # include <sys/sysctl.h>
 #endif
 
+#ifdef __linux__
+/* Canonical GCC cpu name table.  */
+static const char *rs6000_supported_cpu_names[] =
+{
+#define RS6000_CPU(NAME, CPU, FLAGS) NAME,
+#include "rs6000-cpus.def"
+#undef RS6000_CPU
+};
+
+/* This table holds a list of cpus where their Linux AT_PLATFORM name differs
+   from their GCC canonical name.  The first column in a row contains the GCC
+   canonical cpu name and the other columns in that row contain AT_PLATFORM
+   names that should be mapped to the canonical name.  */
+
+static const char *linux_cpu_translation_table[][4] = {
+  { "403", "ppc403", NULL },
+  { "405", "ppc405", NULL },
+  { "440", "ppc440", "ppc440gp", NULL },
+  { "476", "ppc470", NULL },
+  { "601", "ppc601", NULL },
+  { "603", "ppc603", NULL },
+  { "604", "ppc604", NULL },
+  { "7400", "ppc7400", NULL },
+  { "7450", "ppc7450", NULL },
+  { "750", "ppc750", NULL },
+  { "823", "ppc823", NULL },
+  { "8540", "ppc8540", NULL },
+  { "8548", "ppc8548", NULL },
+  { "970", "ppc970", NULL },
+  { "cell", "ppc-cell-be", NULL },
+  { "e500mc", "ppce500mc", NULL },
+  { "e5500", "ppce5500", NULL },
+  { "e6500", "ppce6500", NULL },
+  { "power7", "power7+", NULL },
+  { NULL } /* End of table sentinel.  */
+};
+#endif
+
 const char *host_detect_local_cpu (int argc, const char **argv);
 
 #if GCC_VERSION >= 0
@@ -156,14 +196,19 @@ detect_processor_freebsd (void)
 
 #ifdef __linux__
 
-/* Returns AT_PLATFORM if present, otherwise generic PowerPC.  */
+/* Returns the canonical AT_PLATFORM if present, otherwise NULL.  */
 
 static const char *
 elf_platform (void)
 {
-  int fd;
+  /* Used to cache the result we determine below.  */
+  static const char *cpu = NULL;
 
-  fd = open ("/proc/self/auxv", O_RDONLY);
+  /* Use the cached AT_PLATFORM cpu name if we've already determined it.  */
+  if (cpu != NULL)
+    return cpu;
+
+  int fd = open ("/proc/self/auxv", O_RDONLY);
 
   if (fd != -1)
     {
@@ -177,15 +222,51 @@ elf_platform (void)
       if (n > 0)
 	{
 	  for (av = (ElfW(auxv_t) *) buf; av->a_type != AT_NULL; ++av)
-	    switch (av->a_type)
+	    if (av->a_type == AT_PLATFORM)
 	      {
-	      case AT_PLATFORM:
-		return (const char *) av->a_un.a_val;
-
-	      default:
+		/* Cache the result.  */
+		cpu = (const char *) av->a_un.a_val;
 		break;
 	      }
 	}
+
+      /* Verify that CPU is either a valid -mcpu=<cpu> option name, or is a
+	 valid alternative name.  If it is a valid alternative name, then use
+	 the canonical name.  */
+      if (cpu != NULL)
+	{
+	  size_t i, j;
+	  char *s;
+
+	  /* Check if AT_PLATFORM is a GCC canonical cpu name.  */
+	  for (i = 0; i < ARRAY_SIZE (rs6000_supported_cpu_names); i++)
+	    if (!strcmp (cpu, rs6000_supported_cpu_names[i]))
+	      return cpu;
+
+	  /* Check if AT_PLATFORM can be translated to a canonical cpu name.  */
+	  for (i = 0; linux_cpu_translation_table[i][0] != NULL; i++)
+	    {
+	      const char *canonical = linux_cpu_translation_table[i][0];
+	      for (j = 1; linux_cpu_translation_table[i][j] != NULL; j++)
+		if (!strcmp (cpu, linux_cpu_translation_table[i][j]))
+		  {
+		    /* Cache the result.  */
+		    cpu = canonical;
+		    return cpu;
+		  }
+	    }
+
+	  /* The kernel returned an AT_PLATFORM name we do not support.  */
+	  auto_vec <const char *> candidates;
+	  for (i = 0; i < ARRAY_SIZE (rs6000_supported_cpu_names); i++)
+	    candidates.safe_push (rs6000_supported_cpu_names[i]);
+	  candidates_list_and_hint (cpu, s, candidates);
+	  fatal_error (
+	    input_location,
+	    "Unsupported cpu name returned from kernel for -mcpu=native: %s\n"
+	    "Please use an explicit cpu name.  Valid cpu names are: %s",
+	    cpu, s);
+	}
     }
   return NULL;
 }
diff --git a/gcc/config/rs6000/predicates.md b/gcc/config/rs6000/predicates.md
index 0d816e5e6d9..a9e4ef56580 100644
--- a/gcc/config/rs6000/predicates.md
+++ b/gcc/config/rs6000/predicates.md
@@ -1468,12 +1468,11 @@
   rtx elt;
   int count = XVECLEN (op, 0);
 
-  if (count != 59)
+  if (count != 58)
     return 0;
 
   index = 0;
   if (GET_CODE (XVECEXP (op, 0, index++)) != RETURN
-      || GET_CODE (XVECEXP (op, 0, index++)) != USE
       || GET_CODE (XVECEXP (op, 0, index++)) != USE
       || GET_CODE (XVECEXP (op, 0, index++)) != CLOBBER)
     return 0;
diff --git a/gcc/config/rs6000/rs6000-builtin.def b/gcc/config/rs6000/rs6000-builtin.def
index a39f9363515..f91ef704a45 100644
--- a/gcc/config/rs6000/rs6000-builtin.def
+++ b/gcc/config/rs6000/rs6000-builtin.def
@@ -1,5 +1,5 @@
 /* Builtin functions for rs6000/powerpc.
-   Copyright (C) 2009-2017 Free Software Foundation, Inc.
+   Copyright (C) 2009-2018 Free Software Foundation, Inc.
    Contributed by Michael Meissner (meissner@linux.vnet.ibm.com)
 
    This file is part of GCC.
@@ -659,6 +659,14 @@
 		     | RS6000_BTC_BINARY),				\
 		    CODE_FOR_ ## ICODE)			/* ICODE */
 
+#define BU_P7_POWERPC64_MISC_2(ENUM, NAME, ATTR, ICODE)			\
+  RS6000_BUILTIN_2 (MISC_BUILTIN_ ## ENUM,		/* ENUM */      \
+		    "__builtin_" NAME,			/* NAME */      \
+		    RS6000_BTM_POPCNTD			/* MASK */	\
+		    | RS6000_BTM_POWERPC64,				\
+		    (RS6000_BTC_ ## ATTR		/* ATTR */      \
+		    | RS6000_BTC_BINARY),				\
+		    CODE_FOR_ ## ICODE)			/* ICODE */
 
 /* Miscellaneous builtins for instructions added in ISA 2.07.  These
    instructions do require the ISA 2.07 vector support, but they aren't vector
@@ -992,6 +1000,7 @@ BU_ALTIVEC_3 (VSEL_1TI_UNS,   "vsel_1ti_uns",   CONST, 	vector_select_v1ti_uns)
 BU_ALTIVEC_3 (VSLDOI_16QI,    "vsldoi_16qi",    CONST, 	altivec_vsldoi_v16qi)
 BU_ALTIVEC_3 (VSLDOI_8HI,     "vsldoi_8hi",     CONST, 	altivec_vsldoi_v8hi)
 BU_ALTIVEC_3 (VSLDOI_4SI,     "vsldoi_4si",     CONST, 	altivec_vsldoi_v4si)
+BU_ALTIVEC_3 (VSLDOI_2DI,     "vsldoi_2di",     CONST, 	altivec_vsldoi_v2di)
 BU_ALTIVEC_3 (VSLDOI_4SF,     "vsldoi_4sf",     CONST, 	altivec_vsldoi_v4sf)
 BU_ALTIVEC_3 (VSLDOI_2DF,     "vsldoi_2df",     CONST, 	altivec_vsldoi_v2df)
 
@@ -1980,6 +1989,9 @@ BU_P9V_OVERLOAD_1 (VSTDCNSP,	"scalar_test_neg_sp")
 
 BU_P9V_OVERLOAD_1 (REVB,	"revb")
 
+BU_P9V_OVERLOAD_1 (VEXTRACT_FP_FROM_SHORTH, "vextract_fp_from_shorth")
+BU_P9V_OVERLOAD_1 (VEXTRACT_FP_FROM_SHORTL, "vextract_fp_from_shortl")
+
 /* ISA 3.0 vector scalar overloaded 2 argument functions.  */
 BU_P9V_OVERLOAD_2 (VSIEDP,	"scalar_insert_exp")
 
@@ -1997,6 +2009,8 @@ BU_P9V_VSX_1 (VEEDP, "extract_exp_dp", CONST, xvxexpdp)
 BU_P9V_VSX_1 (VEESP, "extract_exp_sp", CONST, xvxexpsp)
 BU_P9V_VSX_1 (VESDP, "extract_sig_dp", CONST, xvxsigdp)
 BU_P9V_VSX_1 (VESSP, "extract_sig_sp", CONST, xvxsigsp)
+BU_P9V_VSX_1 (VEXTRACT_FP_FROM_SHORTH, "vextract_fp_from_shorth", CONST, vextract_fp_from_shorth)
+BU_P9V_VSX_1 (VEXTRACT_FP_FROM_SHORTL, "vextract_fp_from_shortl", CONST, vextract_fp_from_shortl)
 
 /* 2 argument vsx vector functions added in ISA 3.0 (power9).  */
 BU_P9V_VSX_2 (VIEDP, "insert_exp_dp", CONST, xviexpdp)
@@ -2034,8 +2048,8 @@ BU_P9V_AV_2 (VEXTUWRX, "vextuwrx",		CONST,	vextuwrx)
 
 /* Insert/extract 4 byte word into a vector.  */
 BU_P9V_VSX_2 (VEXTRACT4B,   "vextract4b",	CONST,	vextract4b)
-BU_P9V_VSX_3 (VINSERT4B,    "vinsert4b",	CONST,	vinsert4b)
-BU_P9V_VSX_3 (VINSERT4B_DI, "vinsert4b_di",	CONST,	vinsert4b_di)
+BU_P9V_VSX_3 (INSERT4B,    "insert4b",		CONST,  insert4b)
+BU_P9V_VSX_2 (EXTRACT4B,   "extract4b", 	CONST,  extract4b)
 
 /* 3 argument vector functions returning void, treated as SPECIAL,
    added in ISA 3.0 (power9).  */
@@ -2084,10 +2098,11 @@ BU_P9V_OVERLOAD_2 (LXVL,	"lxvl")
 BU_P9V_OVERLOAD_2 (VEXTULX,	"vextulx")
 BU_P9V_OVERLOAD_2 (VEXTURX,	"vexturx")
 BU_P9V_OVERLOAD_2 (VEXTRACT4B,	"vextract4b")
+BU_P9V_OVERLOAD_2 (EXTRACT4B,  "extract4b")
 
 /* ISA 3.0 Vector scalar overloaded 3 argument functions */
 BU_P9V_OVERLOAD_3 (STXVL,	"stxvl")
-BU_P9V_OVERLOAD_3 (VINSERT4B,	"vinsert4b")
+BU_P9V_OVERLOAD_3 (INSERT4B,    "insert4b")
 
 /* Overloaded CMPNE support was implemented prior to Power 9,
    so is not mentioned here.  */
@@ -2103,13 +2118,9 @@ BU_P9V_OVERLOAD_1 (VCTZLSBB,	"vctzlsbb")
 
 /* 2 argument extended divide functions added in ISA 2.06.  */
 BU_P7_MISC_2 (DIVWE,		"divwe",	CONST,	dive_si)
-BU_P7_MISC_2 (DIVWEO,		"divweo",	CONST,	diveo_si)
 BU_P7_MISC_2 (DIVWEU,		"divweu",	CONST,	diveu_si)
-BU_P7_MISC_2 (DIVWEUO,		"divweuo",	CONST,	diveuo_si)
-BU_P7_MISC_2 (DIVDE,		"divde",	CONST,	dive_di)
-BU_P7_MISC_2 (DIVDEO,		"divdeo",	CONST,	diveo_di)
-BU_P7_MISC_2 (DIVDEU,		"divdeu",	CONST,	diveu_di)
-BU_P7_MISC_2 (DIVDEUO,		"divdeuo",	CONST,	diveuo_di)
+BU_P7_POWERPC64_MISC_2 (DIVDE,	"divde",	CONST,	dive_di)
+BU_P7_POWERPC64_MISC_2 (DIVDEU,	"divdeu",	CONST,	diveu_di)
 
 /* 1 argument DFP (decimal floating point) functions added in ISA 2.05.  */
 BU_DFP_MISC_1 (DXEX,		"dxex",		CONST,	dfp_dxex_dd)
@@ -2228,13 +2239,22 @@ BU_FLOAT128_1 (FABSQ,		"fabsq",       CONST, abskf2)
 BU_FLOAT128_2 (COPYSIGNQ,	"copysignq",   CONST, copysignkf3)
 
 /* 1 argument crypto functions.  */
-BU_CRYPTO_1 (VSBOX,		"vsbox",	  CONST, crypto_vsbox)
+BU_CRYPTO_1 (VSBOX,		"vsbox",	  CONST, crypto_vsbox_v2di)
+BU_CRYPTO_1 (VSBOX_BE,		"vsbox_be",	  CONST, crypto_vsbox_v16qi)
 
 /* 2 argument crypto functions.  */
-BU_CRYPTO_2 (VCIPHER,		"vcipher",	  CONST, crypto_vcipher)
-BU_CRYPTO_2 (VCIPHERLAST,	"vcipherlast",	  CONST, crypto_vcipherlast)
-BU_CRYPTO_2 (VNCIPHER,		"vncipher",	  CONST, crypto_vncipher)
-BU_CRYPTO_2 (VNCIPHERLAST,	"vncipherlast",	  CONST, crypto_vncipherlast)
+BU_CRYPTO_2 (VCIPHER,		"vcipher",	  CONST, crypto_vcipher_v2di)
+BU_CRYPTO_2 (VCIPHER_BE,	"vcipher_be",	  CONST, crypto_vcipher_v16qi)
+BU_CRYPTO_2 (VCIPHERLAST,	"vcipherlast",
+	     CONST, crypto_vcipherlast_v2di)
+BU_CRYPTO_2 (VCIPHERLAST_BE,	"vcipherlast_be",
+	     CONST, crypto_vcipherlast_v16qi)
+BU_CRYPTO_2 (VNCIPHER,		"vncipher",	  CONST, crypto_vncipher_v2di)
+BU_CRYPTO_2 (VNCIPHER_BE,	"vncipher_be",	  CONST, crypto_vncipher_v16qi)
+BU_CRYPTO_2 (VNCIPHERLAST,	"vncipherlast",
+	     CONST, crypto_vncipherlast_v2di)
+BU_CRYPTO_2 (VNCIPHERLAST_BE,	"vncipherlast_be",
+	     CONST, crypto_vncipherlast_v16qi)
 BU_CRYPTO_2A (VPMSUMB,		"vpmsumb",	  CONST, crypto_vpmsumb)
 BU_CRYPTO_2A (VPMSUMH,		"vpmsumh",	  CONST, crypto_vpmsumh)
 BU_CRYPTO_2A (VPMSUMW,		"vpmsumw",	  CONST, crypto_vpmsumw)
diff --git a/gcc/config/rs6000/rs6000-c.c b/gcc/config/rs6000/rs6000-c.c
index d9905f7b2f6..43e2d3c7668 100644
--- a/gcc/config/rs6000/rs6000-c.c
+++ b/gcc/config/rs6000/rs6000-c.c
@@ -910,6 +910,8 @@ const struct altivec_builtin_types altivec_overloaded_builtins[] = {
     RS6000_BTI_bool_V2DI, RS6000_BTI_bool_V4SI, 0, 0 },
   { ALTIVEC_BUILTIN_VEC_UNPACKH, ALTIVEC_BUILTIN_VUPKHPX,
     RS6000_BTI_unsigned_V4SI, RS6000_BTI_pixel_V8HI, 0, 0 },
+  { ALTIVEC_BUILTIN_VEC_UNPACKH, ALTIVEC_BUILTIN_VUPKHPX,
+    RS6000_BTI_V2DF, RS6000_BTI_V4SF, 0, 0 },
   { ALTIVEC_BUILTIN_VEC_VUPKHSH, ALTIVEC_BUILTIN_VUPKHSH,
     RS6000_BTI_V4SI, RS6000_BTI_V8HI, 0, 0 },
   { ALTIVEC_BUILTIN_VEC_VUPKHSH, ALTIVEC_BUILTIN_VUPKHSH,
@@ -940,6 +942,8 @@ const struct altivec_builtin_types altivec_overloaded_builtins[] = {
     RS6000_BTI_V2DI, RS6000_BTI_V4SI, 0, 0 },
   { ALTIVEC_BUILTIN_VEC_UNPACKL, P8V_BUILTIN_VUPKLSW,
     RS6000_BTI_bool_V2DI, RS6000_BTI_bool_V4SI, 0, 0 },
+  { ALTIVEC_BUILTIN_VEC_UNPACKL, ALTIVEC_BUILTIN_VUPKLPX,
+    RS6000_BTI_V2DF, RS6000_BTI_V4SF, 0, 0 },
   { ALTIVEC_BUILTIN_VEC_VUPKLPX, ALTIVEC_BUILTIN_VUPKLPX,
     RS6000_BTI_unsigned_V4SI, RS6000_BTI_unsigned_V8HI, 0, 0 },
   { ALTIVEC_BUILTIN_VEC_VUPKLPX, ALTIVEC_BUILTIN_VUPKLPX,
@@ -1184,6 +1188,8 @@ const struct altivec_builtin_types altivec_overloaded_builtins[] = {
     RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_bool_V2DI, 0 },
   { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND,
     RS6000_BTI_unsigned_V2DI, RS6000_BTI_bool_V2DI, RS6000_BTI_unsigned_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND,
+    RS6000_BTI_bool_V2DI, RS6000_BTI_bool_V2DI, RS6000_BTI_bool_V2DI, 0 },
   { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND,
     RS6000_BTI_bool_V4SI, RS6000_BTI_bool_V4SI, RS6000_BTI_bool_V4SI, 0 },
   { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND,
@@ -1518,11 +1524,18 @@ const struct altivec_builtin_types altivec_overloaded_builtins[] = {
     RS6000_BTI_V2DF, RS6000_BTI_unsigned_V2DI, 0, 0 },
   { ALTIVEC_BUILTIN_VEC_LD, ALTIVEC_BUILTIN_LVX_V2DF,
     RS6000_BTI_V2DF, RS6000_BTI_INTSI, ~RS6000_BTI_V2DF, 0 },
+  { ALTIVEC_BUILTIN_VEC_LD, ALTIVEC_BUILTIN_LVX_V2DF,
+    RS6000_BTI_V2DF, RS6000_BTI_INTSI, ~RS6000_BTI_double, 0 },
   { ALTIVEC_BUILTIN_VEC_LD, ALTIVEC_BUILTIN_LVX_V2DI,
     RS6000_BTI_V2DI, RS6000_BTI_INTSI, ~RS6000_BTI_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LD, ALTIVEC_BUILTIN_LVX_V2DI,
+    RS6000_BTI_V2DI, RS6000_BTI_INTSI, ~RS6000_BTI_long_long, 0 },
   { ALTIVEC_BUILTIN_VEC_LD, ALTIVEC_BUILTIN_LVX_V2DI,
     RS6000_BTI_unsigned_V2DI, RS6000_BTI_INTSI,
     ~RS6000_BTI_unsigned_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_LD, ALTIVEC_BUILTIN_LVX_V2DI,
+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_INTSI,
+    ~RS6000_BTI_unsigned_long_long, 0 },
   { ALTIVEC_BUILTIN_VEC_LD, ALTIVEC_BUILTIN_LVX_V2DI,
     RS6000_BTI_bool_V2DI, RS6000_BTI_INTSI, ~RS6000_BTI_bool_V2DI, 0 },
   { ALTIVEC_BUILTIN_VEC_LD, ALTIVEC_BUILTIN_LVX_V4SF,
@@ -2393,7 +2406,7 @@ const struct altivec_builtin_types altivec_overloaded_builtins[] = {
     RS6000_BTI_unsigned_V8HI, RS6000_BTI_V4SI, RS6000_BTI_V4SI, 0 },
   { ALTIVEC_BUILTIN_VEC_PACKSU, P8V_BUILTIN_VPKSDUS,
     RS6000_BTI_unsigned_V4SI, RS6000_BTI_V2DI, RS6000_BTI_V2DI, 0 },
-  { ALTIVEC_BUILTIN_VEC_PACKSU, P8V_BUILTIN_VPKSDUS,
+  { ALTIVEC_BUILTIN_VEC_PACKSU, P8V_BUILTIN_VPKUDUS,
     RS6000_BTI_unsigned_V4SI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, 0 },
   { ALTIVEC_BUILTIN_VEC_VPKSWUS, ALTIVEC_BUILTIN_VPKSWUS,
     RS6000_BTI_unsigned_V8HI, RS6000_BTI_V4SI, RS6000_BTI_V4SI, 0 },
@@ -2535,6 +2548,18 @@ const struct altivec_builtin_types altivec_overloaded_builtins[] = {
     RS6000_BTI_bool_V16QI, RS6000_BTI_bool_V16QI, RS6000_BTI_unsigned_V8HI, 0 },
   { ALTIVEC_BUILTIN_VEC_SLL, ALTIVEC_BUILTIN_VSL,
     RS6000_BTI_bool_V16QI, RS6000_BTI_bool_V16QI, RS6000_BTI_unsigned_V16QI, 0 },
+
+  { ALTIVEC_BUILTIN_VEC_SLL, ALTIVEC_BUILTIN_VSL,
+    RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_unsigned_V16QI, 0 },
+  { ALTIVEC_BUILTIN_VEC_SLL, ALTIVEC_BUILTIN_VSL,
+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V16QI, 0 },
+  { ALTIVEC_BUILTIN_VEC_SLL, ALTIVEC_BUILTIN_VSL,
+    RS6000_BTI_bool_V2DI, RS6000_BTI_bool_V2DI, RS6000_BTI_unsigned_V16QI, 0 },
+  { ALTIVEC_BUILTIN_VEC_SLL, ALTIVEC_BUILTIN_VSL,
+    RS6000_BTI_bool_V2DI, RS6000_BTI_bool_V2DI, RS6000_BTI_unsigned_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_SLL, ALTIVEC_BUILTIN_VSL,
+    RS6000_BTI_bool_V2DI, RS6000_BTI_bool_V2DI, RS6000_BTI_unsigned_V8HI, 0 },
+
   { ALTIVEC_BUILTIN_VEC_SLO, ALTIVEC_BUILTIN_VSLO,
     RS6000_BTI_V4SF, RS6000_BTI_V4SF, RS6000_BTI_V16QI, 0 },
   { ALTIVEC_BUILTIN_VEC_SLO, ALTIVEC_BUILTIN_VSLO,
@@ -2735,6 +2760,10 @@ const struct altivec_builtin_types altivec_overloaded_builtins[] = {
     RS6000_BTI_bool_V16QI, RS6000_BTI_bool_V16QI, RS6000_BTI_unsigned_V8HI, 0 },
   { ALTIVEC_BUILTIN_VEC_SRL, ALTIVEC_BUILTIN_VSR,
     RS6000_BTI_bool_V16QI, RS6000_BTI_bool_V16QI, RS6000_BTI_unsigned_V16QI, 0 },
+  { ALTIVEC_BUILTIN_VEC_SRL, ALTIVEC_BUILTIN_VSR,
+    RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_unsigned_V16QI, 0 },
+  { ALTIVEC_BUILTIN_VEC_SRL, ALTIVEC_BUILTIN_VSR,
+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V16QI, 0 },
   { ALTIVEC_BUILTIN_VEC_SRO, ALTIVEC_BUILTIN_VSRO,
     RS6000_BTI_V4SF, RS6000_BTI_V4SF, RS6000_BTI_V16QI, 0 },
   { ALTIVEC_BUILTIN_VEC_SRO, ALTIVEC_BUILTIN_VSRO,
@@ -2767,6 +2796,15 @@ const struct altivec_builtin_types altivec_overloaded_builtins[] = {
     RS6000_BTI_unsigned_V16QI, RS6000_BTI_unsigned_V16QI, RS6000_BTI_V16QI, 0 },
   { ALTIVEC_BUILTIN_VEC_SRO, ALTIVEC_BUILTIN_VSRO,
     RS6000_BTI_unsigned_V16QI, RS6000_BTI_unsigned_V16QI, RS6000_BTI_unsigned_V16QI, 0 },
+  { ALTIVEC_BUILTIN_VEC_SRO, ALTIVEC_BUILTIN_VSRO,
+    RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_V16QI, 0 },
+  { ALTIVEC_BUILTIN_VEC_SRO, ALTIVEC_BUILTIN_VSRO,
+    RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_unsigned_V16QI, 0 },
+  { ALTIVEC_BUILTIN_VEC_SRO, ALTIVEC_BUILTIN_VSRO,
+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_V16QI, 0 },
+  { ALTIVEC_BUILTIN_VEC_SRO, ALTIVEC_BUILTIN_VSRO,
+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V16QI, 0 },
+
   { ALTIVEC_BUILTIN_VEC_SUB, ALTIVEC_BUILTIN_VSUBUBM,
     RS6000_BTI_V16QI, RS6000_BTI_bool_V16QI, RS6000_BTI_V16QI, 0 },
   { ALTIVEC_BUILTIN_VEC_SUB, ALTIVEC_BUILTIN_VSUBUBM,
@@ -3438,16 +3476,36 @@ const struct altivec_builtin_types altivec_overloaded_builtins[] = {
     RS6000_BTI_bool_V16QI, RS6000_BTI_bool_V16QI, RS6000_BTI_bool_V16QI, RS6000_BTI_NOT_OPAQUE },
   { ALTIVEC_BUILTIN_VEC_SLD, ALTIVEC_BUILTIN_VSLDOI_2DF,
     RS6000_BTI_V2DF, RS6000_BTI_V2DF, RS6000_BTI_V2DF, RS6000_BTI_NOT_OPAQUE },
+  { ALTIVEC_BUILTIN_VEC_SLD, ALTIVEC_BUILTIN_VSLDOI_2DI,
+    RS6000_BTI_bool_V2DI, RS6000_BTI_bool_V2DI, RS6000_BTI_bool_V2DI, RS6000_BTI_NOT_OPAQUE },
+  { ALTIVEC_BUILTIN_VEC_SLD, ALTIVEC_BUILTIN_VSLDOI_2DI,
+    RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_NOT_OPAQUE },
+  { ALTIVEC_BUILTIN_VEC_SLD, ALTIVEC_BUILTIN_VSLDOI_2DI,
+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_NOT_OPAQUE },
+
   { ALTIVEC_BUILTIN_VEC_ST, ALTIVEC_BUILTIN_STVX_V2DF,
     RS6000_BTI_void, RS6000_BTI_V2DF, RS6000_BTI_INTSI, ~RS6000_BTI_V2DF },
+  { ALTIVEC_BUILTIN_VEC_ST, ALTIVEC_BUILTIN_STVX_V2DF,
+    RS6000_BTI_void, RS6000_BTI_V2DF, RS6000_BTI_INTSI, ~RS6000_BTI_double },
   { ALTIVEC_BUILTIN_VEC_ST, ALTIVEC_BUILTIN_STVX_V2DI,
     RS6000_BTI_void, RS6000_BTI_V2DI, RS6000_BTI_INTSI, ~RS6000_BTI_V2DI },
+  { ALTIVEC_BUILTIN_VEC_ST, ALTIVEC_BUILTIN_STVX_V2DI,
+    RS6000_BTI_void, RS6000_BTI_V2DI, RS6000_BTI_INTSI, ~RS6000_BTI_long_long },
   { ALTIVEC_BUILTIN_VEC_ST, ALTIVEC_BUILTIN_STVX_V2DI,
     RS6000_BTI_void, RS6000_BTI_unsigned_V2DI, RS6000_BTI_INTSI,
     ~RS6000_BTI_unsigned_V2DI },
+  { ALTIVEC_BUILTIN_VEC_ST, ALTIVEC_BUILTIN_STVX_V2DI,
+    RS6000_BTI_void, RS6000_BTI_unsigned_V2DI, RS6000_BTI_INTSI,
+    ~RS6000_BTI_unsigned_long_long },
   { ALTIVEC_BUILTIN_VEC_ST, ALTIVEC_BUILTIN_STVX_V2DI,
     RS6000_BTI_void, RS6000_BTI_bool_V2DI, RS6000_BTI_INTSI,
     ~RS6000_BTI_bool_V2DI },
+  { ALTIVEC_BUILTIN_VEC_ST, ALTIVEC_BUILTIN_STVX_V2DI,
+    RS6000_BTI_void, RS6000_BTI_bool_V2DI, RS6000_BTI_INTSI,
+    ~RS6000_BTI_long_long },
+  { ALTIVEC_BUILTIN_VEC_ST, ALTIVEC_BUILTIN_STVX_V2DI,
+    RS6000_BTI_void, RS6000_BTI_bool_V2DI, RS6000_BTI_INTSI,
+    ~RS6000_BTI_unsigned_long_long },
   { ALTIVEC_BUILTIN_VEC_ST, ALTIVEC_BUILTIN_STVX_V4SF,
     RS6000_BTI_void, RS6000_BTI_V4SF, RS6000_BTI_INTSI, ~RS6000_BTI_V4SF },
   { ALTIVEC_BUILTIN_VEC_ST, ALTIVEC_BUILTIN_STVX_V4SF,
@@ -5047,6 +5105,13 @@ const struct altivec_builtin_types altivec_overloaded_builtins[] = {
     RS6000_BTI_INTDI, RS6000_BTI_V16QI, RS6000_BTI_UINTSI, 0 },
   { P9V_BUILTIN_VEC_VEXTRACT4B, P9V_BUILTIN_VEXTRACT4B,
     RS6000_BTI_INTDI, RS6000_BTI_unsigned_V16QI, RS6000_BTI_UINTSI, 0 },
+  { P9V_BUILTIN_VEC_EXTRACT4B, P9V_BUILTIN_EXTRACT4B,
+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V16QI, RS6000_BTI_INTSI, 0 },
+
+  { P9V_BUILTIN_VEC_VEXTRACT_FP_FROM_SHORTH, P9V_BUILTIN_VEXTRACT_FP_FROM_SHORTH,
+    RS6000_BTI_V4SF, RS6000_BTI_unsigned_V8HI, 0, 0 },
+  { P9V_BUILTIN_VEC_VEXTRACT_FP_FROM_SHORTL, P9V_BUILTIN_VEXTRACT_FP_FROM_SHORTL,
+    RS6000_BTI_V4SF, RS6000_BTI_unsigned_V8HI, 0, 0 },
 
   { P9V_BUILTIN_VEC_VEXTULX, P9V_BUILTIN_VEXTUBLX,
     RS6000_BTI_INTQI, RS6000_BTI_UINTSI,
@@ -5101,27 +5166,12 @@ const struct altivec_builtin_types altivec_overloaded_builtins[] = {
   { P8V_BUILTIN_VEC_VGBBD, P8V_BUILTIN_VGBBD,
     RS6000_BTI_unsigned_V16QI, RS6000_BTI_unsigned_V16QI, 0, 0 },
 
-  { P9V_BUILTIN_VEC_VINSERT4B, P9V_BUILTIN_VINSERT4B,
-    RS6000_BTI_V16QI, RS6000_BTI_V4SI,
-    RS6000_BTI_V16QI, RS6000_BTI_UINTSI },
-  { P9V_BUILTIN_VEC_VINSERT4B, P9V_BUILTIN_VINSERT4B,
-    RS6000_BTI_V16QI, RS6000_BTI_unsigned_V4SI,
-    RS6000_BTI_V16QI, RS6000_BTI_UINTSI },
-  { P9V_BUILTIN_VEC_VINSERT4B, P9V_BUILTIN_VINSERT4B,
+  { P9V_BUILTIN_VEC_INSERT4B, P9V_BUILTIN_INSERT4B,
+    RS6000_BTI_unsigned_V16QI, RS6000_BTI_V4SI,
+    RS6000_BTI_unsigned_V16QI, RS6000_BTI_INTSI },
+  { P9V_BUILTIN_VEC_INSERT4B, P9V_BUILTIN_INSERT4B,
     RS6000_BTI_unsigned_V16QI, RS6000_BTI_unsigned_V4SI,
-    RS6000_BTI_unsigned_V16QI, RS6000_BTI_UINTSI },
-  { P9V_BUILTIN_VEC_VINSERT4B, P9V_BUILTIN_VINSERT4B_DI,
-    RS6000_BTI_V16QI, RS6000_BTI_INTDI,
-    RS6000_BTI_V16QI, RS6000_BTI_UINTDI },
-  { P9V_BUILTIN_VEC_VINSERT4B, P9V_BUILTIN_VINSERT4B_DI,
-    RS6000_BTI_V16QI, RS6000_BTI_UINTDI,
-    RS6000_BTI_V16QI, RS6000_BTI_UINTDI },
-  { P9V_BUILTIN_VEC_VINSERT4B, P9V_BUILTIN_VINSERT4B_DI,
-    RS6000_BTI_unsigned_V16QI, RS6000_BTI_INTDI,
-    RS6000_BTI_unsigned_V16QI, RS6000_BTI_UINTDI },
-  { P9V_BUILTIN_VEC_VINSERT4B, P9V_BUILTIN_VINSERT4B_DI,
-    RS6000_BTI_unsigned_V16QI, RS6000_BTI_UINTDI,
-    RS6000_BTI_unsigned_V16QI, RS6000_BTI_UINTDI },
+    RS6000_BTI_unsigned_V16QI, RS6000_BTI_INTSI },
 
   { P8V_BUILTIN_VEC_VADDECUQ, P8V_BUILTIN_VADDECUQ,
     RS6000_BTI_V1TI, RS6000_BTI_V1TI, RS6000_BTI_V1TI, RS6000_BTI_V1TI },
@@ -5971,11 +6021,15 @@ altivec_resolve_overloaded_builtin (location_t loc, tree fndecl,
 	  tree call = NULL_TREE;
 	  int nunits = GET_MODE_NUNITS (mode);
 
-	  /* If the second argument is an integer constant, if the value is in
-	     the expected range, generate the built-in code if we can.  We need
-	     64-bit and direct move to extract the small integer vectors.  */
-	  if (TREE_CODE (arg2) == INTEGER_CST && wi::ltu_p (arg2, nunits))
+	  /* If the second argument is an integer constant, generate
+	     the built-in code if we can.  We need 64-bit and direct
+	     move to extract the small integer vectors.  */
+	  if (TREE_CODE (arg2) == INTEGER_CST)
 	    {
+	      wide_int selector
+		= wi::to_wide (arg2, TYPE_PRECISION (TREE_TYPE (arg2)));
+	      selector = wi::umod_trunc (selector, nunits);
+	      arg2 = wide_int_to_tree (TREE_TYPE (arg2), selector);
 	      switch (mode)
 		{
 		default:
@@ -6050,7 +6104,13 @@ altivec_resolve_overloaded_builtin (location_t loc, tree fndecl,
 	    }
 
 	  if (call)
-	    return build_call_expr (call, 2, arg1, arg2);
+	    {
+	      tree result = build_call_expr (call, 2, arg1, arg2);
+	      /* Coerce the result to vector element type.  May be no-op.  */
+	      arg1_inner_type = TREE_TYPE (arg1_type);
+	      result = fold_convert (arg1_inner_type, result);
+	      return result;
+	    }
 	}
 
       /* Build *(((arg1_inner_type*)&(vector type){arg1})+arg2). */
@@ -6088,6 +6148,15 @@ altivec_resolve_overloaded_builtin (location_t loc, tree fndecl,
       stmt = build_binary_op (loc, PLUS_EXPR, stmt, arg2, 1);
       stmt = build_indirect_ref (loc, stmt, RO_NULL);
 
+      /* PR83660: We mark this as having side effects so that
+	 downstream in fold_build_cleanup_point_expr () it will get a
+	 CLEANUP_POINT_EXPR.  If it does not we can run into an ICE
+	 later in gimplify_cleanup_point_expr ().  Potentially this
+	 causes missed optimization because the actually is no side
+	 effect.  */
+      if (c_dialect_cxx ())
+	TREE_SIDE_EFFECTS (stmt) = 1;
+
       return stmt;
     }
 
diff --git a/gcc/config/rs6000/rs6000-protos.h b/gcc/config/rs6000/rs6000-protos.h
index 0692510b98e..8962f5e8c2f 100644
--- a/gcc/config/rs6000/rs6000-protos.h
+++ b/gcc/config/rs6000/rs6000-protos.h
@@ -139,7 +139,6 @@ extern bool rs6000_emit_set_const (rtx, rtx);
 extern int rs6000_emit_cmove (rtx, rtx, rtx, rtx);
 extern int rs6000_emit_vector_cond_expr (rtx, rtx, rtx, rtx, rtx, rtx);
 extern void rs6000_emit_minmax (rtx, enum rtx_code, rtx, rtx);
-extern void rs6000_split_signbit (rtx, rtx);
 extern void rs6000_expand_atomic_compare_and_swap (rtx op[]);
 extern void rs6000_expand_atomic_exchange (rtx op[]);
 extern void rs6000_expand_atomic_op (enum rtx_code, rtx, rtx, rtx, rtx, rtx);
diff --git a/gcc/config/rs6000/rs6000.c b/gcc/config/rs6000/rs6000.c
index 6c5679a1282..ddf412137bb 100644
--- a/gcc/config/rs6000/rs6000.c
+++ b/gcc/config/rs6000/rs6000.c
@@ -1,5 +1,5 @@
 /* Subroutines used for code generation on IBM RS/6000.
-   Copyright (C) 1991-2017 Free Software Foundation, Inc.
+   Copyright (C) 1991-2018 Free Software Foundation, Inc.
    Contributed by Richard Kenner (kenner@vlsi1.ultra.nyu.edu)
 
    This file is part of GCC.
@@ -1372,6 +1372,7 @@ static rtx rs6000_debug_legitimize_reload_address (rtx, machine_mode, int,
 						   int, int, int *);
 static bool rs6000_mode_dependent_address (const_rtx);
 static bool rs6000_debug_mode_dependent_address (const_rtx);
+static bool rs6000_offsettable_memref_p (rtx, machine_mode, bool);
 static enum reg_class rs6000_secondary_reload_class (enum reg_class,
 						     machine_mode, rtx);
 static enum reg_class rs6000_debug_secondary_reload_class (enum reg_class,
@@ -3890,6 +3891,7 @@ rs6000_builtin_mask_calculate (void)
 	  | ((TARGET_P9_MISC)		    ? RS6000_BTM_P9_MISC   : 0)
 	  | ((TARGET_MODULO)		    ? RS6000_BTM_MODULO    : 0)
 	  | ((TARGET_64BIT)		    ? RS6000_BTM_64BIT     : 0)
+	  | ((TARGET_POWERPC64)		    ? RS6000_BTM_POWERPC64 : 0)
 	  | ((TARGET_CRYPTO)		    ? RS6000_BTM_CRYPTO	   : 0)
 	  | ((TARGET_HTM)		    ? RS6000_BTM_HTM	   : 0)
 	  | ((TARGET_DFP)		    ? RS6000_BTM_DFP	   : 0)
@@ -4827,6 +4829,13 @@ rs6000_option_override_internal (bool global_init_p)
       else
 	rs6000_long_double_type_size = RS6000_DEFAULT_LONG_DOUBLE_SIZE;
     }
+  else if (global_options_set.x_rs6000_ieeequad)
+    {
+      if (global_options.x_rs6000_ieeequad)
+	error ("%qs requires %qs", "-mabi=ieeelongdouble", "-mlong-double-128");
+      else
+	error ("%qs requires %qs", "-mabi=ibmlongdouble", "-mlong-double-128");
+    }
 
   /* Set -mabi=ieeelongdouble on some old targets.  Note, AIX and Darwin
      explicitly redefine TARGET_IEEEQUAD to 0, so those systems will not
@@ -4836,6 +4845,11 @@ rs6000_option_override_internal (bool global_init_p)
     rs6000_ieeequad = 1;
 #endif
 
+  if (global_options_set.x_rs6000_ieeequad
+      && global_options.x_rs6000_ieeequad
+      && (!TARGET_POPCNTD || !TARGET_VSX))
+    error ("%qs requires full ISA 2.06 support", "-mabi=ieeelongdouble");
+
   /* Enable the default support for IEEE 128-bit floating point on Linux VSX
      sytems, but don't enable the __float128 keyword.  */
   if (TARGET_VSX && TARGET_LONG_DOUBLE_128
@@ -5563,6 +5577,11 @@ rs6000_option_override_internal (bool global_init_p)
   if (TARGET_LINK_STACK == -1)
     SET_TARGET_LINK_STACK (rs6000_cpu == PROCESSOR_PPC476 && flag_pic);
 
+  /* Deprecate use of -mno-speculate-indirect-jumps.  */
+  if (!rs6000_speculate_indirect_jumps)
+    warning (0, "%qs is deprecated and not recommended in any circumstances",
+	     "-mno-speculate-indirect-jumps");
+
   return ret;
 }
 
@@ -7636,7 +7655,6 @@ rs6000_expand_vector_extract (rtx target, rtx vec, rtx elt)
 	default:
 	  break;
 	case V1TImode:
-	  gcc_assert (INTVAL (elt) == 0 && inner_mode == TImode);
 	  emit_move_insn (target, gen_lowpart (TImode, vec));
 	  break;
 	case V2DFmode:
@@ -7687,6 +7705,10 @@ rs6000_expand_vector_extract (rtx target, rtx vec, rtx elt)
 
       switch (mode)
 	{
+	case V1TImode:
+	  emit_move_insn (target, gen_lowpart (TImode, vec));
+	  return;
+
 	case V2DFmode:
 	  emit_insn (gen_vsx_extract_v2df_var (target, vec, elt));
 	  return;
@@ -7716,18 +7738,32 @@ rs6000_expand_vector_extract (rtx target, rtx vec, rtx elt)
 	}
     }
 
-  gcc_assert (CONST_INT_P (elt));
-
   /* Allocate mode-sized buffer.  */
   mem = assign_stack_temp (mode, GET_MODE_SIZE (mode));
 
   emit_move_insn (mem, vec);
+  if (CONST_INT_P (elt))
+    {
+      int modulo_elt = INTVAL (elt) % GET_MODE_NUNITS (mode);
 
-  /* Add offset to field within buffer matching vector element.  */
-  mem = adjust_address_nv (mem, inner_mode,
-			   INTVAL (elt) * GET_MODE_SIZE (inner_mode));
+      /* Add offset to field within buffer matching vector element.  */
+      mem = adjust_address_nv (mem, inner_mode,
+			       modulo_elt * GET_MODE_SIZE (inner_mode));
+      emit_move_insn (target, adjust_address_nv (mem, inner_mode, 0));
+    }
+  else
+    {
+      unsigned int ele_size = GET_MODE_SIZE (inner_mode);
+      rtx num_ele_m1 = GEN_INT (GET_MODE_NUNITS (mode) - 1);
+      rtx new_addr = gen_reg_rtx (Pmode);
 
-  emit_move_insn (target, adjust_address_nv (mem, inner_mode, 0));
+      elt = gen_rtx_AND (Pmode, elt, num_ele_m1);
+      if (ele_size > 1)
+	elt = gen_rtx_MULT (Pmode, elt, GEN_INT (ele_size));
+      new_addr = gen_rtx_PLUS (Pmode, XEXP (mem, 0), elt);
+      new_addr = change_address (mem, inner_mode, new_addr);
+      emit_move_insn (target, new_addr);
+    }
 }
 
 /* Helper function to return the register number of a RTX.  */
@@ -7908,7 +7944,7 @@ rs6000_split_vec_extract_var (rtx dest, rtx src, rtx element, rtx tmp_gpr,
 			      rtx tmp_altivec)
 {
   machine_mode mode = GET_MODE (src);
-  machine_mode scalar_mode = GET_MODE (dest);
+  machine_mode scalar_mode = GET_MODE_INNER (GET_MODE (src));
   unsigned scalar_size = GET_MODE_SIZE (scalar_mode);
   int byte_shift = exact_log2 (scalar_size);
 
@@ -7919,6 +7955,10 @@ rs6000_split_vec_extract_var (rtx dest, rtx src, rtx element, rtx tmp_gpr,
      systems.  */
   if (MEM_P (src))
     {
+      int num_elements = GET_MODE_NUNITS (mode);
+      rtx num_ele_m1 = GEN_INT (num_elements - 1);
+
+      emit_insn (gen_anddi3 (element, element, num_ele_m1));
       gcc_assert (REG_P (tmp_gpr));
       emit_move_insn (dest, rs6000_adjust_vec_address (dest, src, element,
 						       tmp_gpr, scalar_mode));
@@ -7927,7 +7967,9 @@ rs6000_split_vec_extract_var (rtx dest, rtx src, rtx element, rtx tmp_gpr,
 
   else if (REG_P (src) || SUBREG_P (src))
     {
-      int bit_shift = byte_shift + 3;
+      int num_elements = GET_MODE_NUNITS (mode);
+      int bits_in_element = GET_MODE_BITSIZE (GET_MODE_INNER (mode));
+      int bit_shift = 7 - exact_log2 (num_elements);
       rtx element2;
       int dest_regno = regno_or_subregno (dest);
       int src_regno = regno_or_subregno (src);
@@ -8003,7 +8045,7 @@ rs6000_split_vec_extract_var (rtx dest, rtx src, rtx element, rtx tmp_gpr,
 	{
 	  if (!VECTOR_ELT_ORDER_BIG)
 	    {
-	      rtx num_ele_m1 = GEN_INT (GET_MODE_NUNITS (mode) - 1);
+	      rtx num_ele_m1 = GEN_INT (num_elements - 1);
 
 	      emit_insn (gen_anddi3 (tmp_gpr, element, num_ele_m1));
 	      emit_insn (gen_subdi3 (tmp_gpr, num_ele_m1, tmp_gpr));
@@ -8061,8 +8103,8 @@ rs6000_split_vec_extract_var (rtx dest, rtx src, rtx element, rtx tmp_gpr,
 	    emit_insn (gen_vsx_vslo_v2di (tmp_altivec_di, src_v2di,
 					  tmp_altivec));
 	    emit_move_insn (tmp_gpr_di, tmp_altivec_di);
-	    emit_insn (gen_ashrdi3 (tmp_gpr_di, tmp_gpr_di,
-				    GEN_INT (64 - (8 * scalar_size))));
+	    emit_insn (gen_lshrdi3 (tmp_gpr_di, tmp_gpr_di,
+				    GEN_INT (64 - bits_in_element)));
 	    return;
 	  }
 
@@ -8558,6 +8600,17 @@ mem_operand_gpr (rtx op, machine_mode mode)
   int extra;
   rtx addr = XEXP (op, 0);
 
+  /* PR85755: Allow PRE_INC and PRE_DEC addresses.  */
+  if (TARGET_UPDATE
+      && (GET_CODE (addr) == PRE_INC || GET_CODE (addr) == PRE_DEC)
+      && mode_supports_pre_incdec_p (mode)
+      && legitimate_indirect_address_p (XEXP (addr, 0), false))
+    return true;
+
+  /* Don't allow non-offsettable addresses.  See PRs 83969 and 84279.  */
+  if (!rs6000_offsettable_memref_p (op, mode, false))
+    return false;
+
   op = address_offset (addr);
   if (op == NULL_RTX)
     return true;
@@ -8822,7 +8875,9 @@ toc_relative_expr_p (const_rtx op, bool strict)
     }
 
   return (GET_CODE (tocrel_base) == UNSPEC
-	  && XINT (tocrel_base, 1) == UNSPEC_TOCREL);
+	  && XINT (tocrel_base, 1) == UNSPEC_TOCREL
+	  && REG_P (XVECEXP (tocrel_base, 0, 1))
+	  && REGNO (XVECEXP (tocrel_base, 0, 1)) == TOC_REGISTER);
 }
 
 /* Return true if X is a constant pool address, and also for cmodel=medium
@@ -10328,7 +10383,7 @@ rs6000_find_base_term (rtx op)
    in 32-bit mode, that the recog predicate rejects.  */
 
 static bool
-rs6000_offsettable_memref_p (rtx op, machine_mode reg_mode)
+rs6000_offsettable_memref_p (rtx op, machine_mode reg_mode, bool strict)
 {
   bool worst_case;
 
@@ -10336,7 +10391,7 @@ rs6000_offsettable_memref_p (rtx op, machine_mode reg_mode)
     return false;
 
   /* First mimic offsettable_memref_p.  */
-  if (offsettable_address_p (true, GET_MODE (op), XEXP (op, 0)))
+  if (offsettable_address_p (strict, GET_MODE (op), XEXP (op, 0)))
     return true;
 
   /* offsettable_address_p invokes rs6000_mode_dependent_address, but
@@ -10350,7 +10405,7 @@ rs6000_offsettable_memref_p (rtx op, machine_mode reg_mode)
   worst_case = ((TARGET_POWERPC64 && GET_MODE_CLASS (reg_mode) == MODE_INT)
 		|| GET_MODE_SIZE (reg_mode) == 4);
   return rs6000_legitimate_offset_address_p (GET_MODE (op), XEXP (op, 0),
-					     true, worst_case);
+					     strict, worst_case);
 }
 
 /* Determine the reassociation width to be used in reassociate_bb.
@@ -11574,12 +11629,12 @@ rs6000_discover_homogeneous_aggregate (machine_mode mode, const_tree type,
 
       if (field_count > 0)
 	{
-	  int n_regs = (SCALAR_FLOAT_MODE_P (field_mode) ?
-			(GET_MODE_SIZE (field_mode) + 7) >> 3 : 1);
+	  int reg_size = ALTIVEC_OR_VSX_VECTOR_MODE (field_mode) ? 16 : 8;
+	  int field_size = ROUND_UP (GET_MODE_SIZE (field_mode), reg_size);
 
 	  /* The ELFv2 ABI allows homogeneous aggregates to occupy
 	     up to AGGR_ARG_NUM_REG registers.  */
-	  if (field_count * n_regs <= AGGR_ARG_NUM_REG)
+	  if (field_count * field_size <= AGGR_ARG_NUM_REG * reg_size)
 	    {
 	      if (elt_mode)
 		*elt_mode = field_mode;
@@ -13089,7 +13144,9 @@ rs6000_function_arg (cumulative_args_t cum_v, machine_mode mode,
       if (elt_mode == TDmode && (cum->fregno % 2) == 1)
 	cum->fregno++;
 
-      if (USE_FP_FOR_ARG_P (cum, elt_mode))
+      if (USE_FP_FOR_ARG_P (cum, elt_mode)
+	  && !(TARGET_AIX && !TARGET_ELF
+	       && type != NULL && AGGREGATE_TYPE_P (type)))
 	{
 	  rtx rvec[GP_ARG_NUM_REG + AGGR_ARG_NUM_REG + 1];
 	  rtx r, off;
@@ -13225,7 +13282,9 @@ rs6000_arg_partial_bytes (cumulative_args_t cum_v, machine_mode mode,
 
   align_words = rs6000_parm_start (mode, type, cum->words);
 
-  if (USE_FP_FOR_ARG_P (cum, elt_mode))
+  if (USE_FP_FOR_ARG_P (cum, elt_mode)
+      && !(TARGET_AIX && !TARGET_ELF
+	   && type != NULL && AGGREGATE_TYPE_P (type)))
     {
       unsigned long n_fpreg = (GET_MODE_SIZE (elt_mode) + 7) >> 3;
 
@@ -14106,6 +14165,7 @@ rs6000_gimplify_va_arg (tree valist, tree type, gimple_seq *pre_p,
 
       tree copy = build_call_expr (builtin_decl_implicit (BUILT_IN_MEMCPY),
 				   3, dest_addr, addr, size_int (rsize * 4));
+      TREE_ADDRESSABLE (tmp) = 1;
 
       gimplify_and_add (copy, pre_p);
       addr = dest_addr;
@@ -15087,12 +15147,12 @@ altivec_expand_lv_builtin (enum insn_code icode, tree exp, rtx target, bool blk)
   /* For LVX, express the RTL accurately by ANDing the address with -16.
      LVXL and LVE*X expand to use UNSPECs to hide their special behavior,
      so the raw address is fine.  */
-  if (icode == CODE_FOR_altivec_lvx_v2df_2op
-      || icode == CODE_FOR_altivec_lvx_v2di_2op
-      || icode == CODE_FOR_altivec_lvx_v4sf_2op
-      || icode == CODE_FOR_altivec_lvx_v4si_2op
-      || icode == CODE_FOR_altivec_lvx_v8hi_2op
-      || icode == CODE_FOR_altivec_lvx_v16qi_2op)
+  if (icode == CODE_FOR_altivec_lvx_v2df
+      || icode == CODE_FOR_altivec_lvx_v2di
+      || icode == CODE_FOR_altivec_lvx_v4sf
+      || icode == CODE_FOR_altivec_lvx_v4si
+      || icode == CODE_FOR_altivec_lvx_v8hi
+      || icode == CODE_FOR_altivec_lvx_v16qi)
     {
       rtx rawaddr;
       if (op0 == const0_rtx)
@@ -15278,12 +15338,12 @@ altivec_expand_stv_builtin (enum insn_code icode, tree exp)
   /* For STVX, express the RTL accurately by ANDing the address with -16.
      STVXL and STVE*X expand to use UNSPECs to hide their special behavior,
      so the raw address is fine.  */
-  if (icode == CODE_FOR_altivec_stvx_v2df_2op
-      || icode == CODE_FOR_altivec_stvx_v2di_2op
-      || icode == CODE_FOR_altivec_stvx_v4sf_2op
-      || icode == CODE_FOR_altivec_stvx_v4si_2op
-      || icode == CODE_FOR_altivec_stvx_v8hi_2op
-      || icode == CODE_FOR_altivec_stvx_v16qi_2op)
+  if (icode == CODE_FOR_altivec_stvx_v2df
+      || icode == CODE_FOR_altivec_stvx_v2di
+      || icode == CODE_FOR_altivec_stvx_v4sf
+      || icode == CODE_FOR_altivec_stvx_v4si
+      || icode == CODE_FOR_altivec_stvx_v8hi
+      || icode == CODE_FOR_altivec_stvx_v16qi)
     {
       if (op1 == const0_rtx)
 	rawaddr = op2;
@@ -16125,9 +16185,17 @@ altivec_expand_vec_ext_builtin (tree exp, rtx target)
   op0 = expand_normal (arg0);
   op1 = expand_normal (arg1);
 
-  /* Call get_element_number to validate arg1 if it is a constant.  */
   if (TREE_CODE (arg1) == INTEGER_CST)
-    (void) get_element_number (TREE_TYPE (arg0), arg1);
+    {
+      unsigned HOST_WIDE_INT elt;
+      unsigned HOST_WIDE_INT size = TYPE_VECTOR_SUBPARTS (TREE_TYPE (arg0));
+      unsigned int truncated_selector;
+      /* Even if !tree_fits_uhwi_p (arg1)), TREE_INT_CST_LOW (arg0)
+	 returns low-order bits of INTEGER_CST for modulo indexing.  */
+      elt = TREE_INT_CST_LOW (arg1);
+      truncated_selector = elt % size;
+      op1 = GEN_INT (truncated_selector);
+    }
 
   tmode = TYPE_MODE (TREE_TYPE (TREE_TYPE (arg0)));
   mode0 = TYPE_MODE (TREE_TYPE (arg0));
@@ -16184,18 +16252,18 @@ altivec_expand_builtin (tree exp, rtx target, bool *expandedp)
   switch (fcode)
     {
     case ALTIVEC_BUILTIN_STVX_V2DF:
-      return altivec_expand_stv_builtin (CODE_FOR_altivec_stvx_v2df_2op, exp);
+      return altivec_expand_stv_builtin (CODE_FOR_altivec_stvx_v2df, exp);
     case ALTIVEC_BUILTIN_STVX_V2DI:
-      return altivec_expand_stv_builtin (CODE_FOR_altivec_stvx_v2di_2op, exp);
+      return altivec_expand_stv_builtin (CODE_FOR_altivec_stvx_v2di, exp);
     case ALTIVEC_BUILTIN_STVX_V4SF:
-      return altivec_expand_stv_builtin (CODE_FOR_altivec_stvx_v4sf_2op, exp);
+      return altivec_expand_stv_builtin (CODE_FOR_altivec_stvx_v4sf, exp);
     case ALTIVEC_BUILTIN_STVX:
     case ALTIVEC_BUILTIN_STVX_V4SI:
-      return altivec_expand_stv_builtin (CODE_FOR_altivec_stvx_v4si_2op, exp);
+      return altivec_expand_stv_builtin (CODE_FOR_altivec_stvx_v4si, exp);
     case ALTIVEC_BUILTIN_STVX_V8HI:
-      return altivec_expand_stv_builtin (CODE_FOR_altivec_stvx_v8hi_2op, exp);
+      return altivec_expand_stv_builtin (CODE_FOR_altivec_stvx_v8hi, exp);
     case ALTIVEC_BUILTIN_STVX_V16QI:
-      return altivec_expand_stv_builtin (CODE_FOR_altivec_stvx_v16qi_2op, exp);
+      return altivec_expand_stv_builtin (CODE_FOR_altivec_stvx_v16qi, exp);
     case ALTIVEC_BUILTIN_STVEBX:
       return altivec_expand_stv_builtin (CODE_FOR_altivec_stvebx, exp);
     case ALTIVEC_BUILTIN_STVEHX:
@@ -16374,6 +16442,7 @@ altivec_expand_builtin (tree exp, rtx target, bool *expandedp)
 
     case P9V_BUILTIN_VEXTRACT4B:
     case P9V_BUILTIN_VEC_VEXTRACT4B:
+    case P9V_BUILTIN_VEC_EXTRACT4B:
       arg1 = CALL_EXPR_ARG (exp, 1);
       STRIP_NOPS (arg1);
 
@@ -16388,9 +16457,7 @@ altivec_expand_builtin (tree exp, rtx target, bool *expandedp)
 	}
       break;
 
-    case P9V_BUILTIN_VINSERT4B:
-    case P9V_BUILTIN_VINSERT4B_DI:
-    case P9V_BUILTIN_VEC_VINSERT4B:
+    case P9V_BUILTIN_VEC_INSERT4B:
       arg2 = CALL_EXPR_ARG (exp, 2);
       STRIP_NOPS (arg2);
 
@@ -16400,7 +16467,7 @@ altivec_expand_builtin (tree exp, rtx target, bool *expandedp)
 
       if (TREE_CODE (arg2) != INTEGER_CST || TREE_INT_CST_LOW (arg2) > 12)
 	{
-	  error ("third argument to vec_vinsert4b must be 0..12");
+	  error ("third argument to vec_insert4b must be 0..12");
 	  return expand_call (exp, target, false);
 	}
       break;
@@ -16460,23 +16527,23 @@ altivec_expand_builtin (tree exp, rtx target, bool *expandedp)
       return altivec_expand_lv_builtin (CODE_FOR_altivec_lvxl_v16qi,
 					exp, target, false);
     case ALTIVEC_BUILTIN_LVX_V2DF:
-      return altivec_expand_lv_builtin (CODE_FOR_altivec_lvx_v2df_2op,
+      return altivec_expand_lv_builtin (CODE_FOR_altivec_lvx_v2df,
 					exp, target, false);
     case ALTIVEC_BUILTIN_LVX_V2DI:
-      return altivec_expand_lv_builtin (CODE_FOR_altivec_lvx_v2di_2op,
+      return altivec_expand_lv_builtin (CODE_FOR_altivec_lvx_v2di,
 					exp, target, false);
     case ALTIVEC_BUILTIN_LVX_V4SF:
-      return altivec_expand_lv_builtin (CODE_FOR_altivec_lvx_v4sf_2op,
+      return altivec_expand_lv_builtin (CODE_FOR_altivec_lvx_v4sf,
 					exp, target, false);
     case ALTIVEC_BUILTIN_LVX:
     case ALTIVEC_BUILTIN_LVX_V4SI:
-      return altivec_expand_lv_builtin (CODE_FOR_altivec_lvx_v4si_2op,
+      return altivec_expand_lv_builtin (CODE_FOR_altivec_lvx_v4si,
 					exp, target, false);
     case ALTIVEC_BUILTIN_LVX_V8HI:
-      return altivec_expand_lv_builtin (CODE_FOR_altivec_lvx_v8hi_2op,
+      return altivec_expand_lv_builtin (CODE_FOR_altivec_lvx_v8hi,
 					exp, target, false);
     case ALTIVEC_BUILTIN_LVX_V16QI:
-      return altivec_expand_lv_builtin (CODE_FOR_altivec_lvx_v16qi_2op,
+      return altivec_expand_lv_builtin (CODE_FOR_altivec_lvx_v16qi,
 					exp, target, false);
     case ALTIVEC_BUILTIN_LVLX:
       return altivec_expand_lv_builtin (CODE_FOR_altivec_lvlx,
@@ -17040,6 +17107,11 @@ rs6000_invalid_builtin (enum rs6000_builtins fncode)
     error ("Builtin function %s requires the -mhard-float option", name);
   else if ((fnmask & RS6000_BTM_FLOAT128) != 0)
     error ("Builtin function %s requires the -mfloat128 option", name);
+  else if ((fnmask & (RS6000_BTM_POPCNTD | RS6000_BTM_POWERPC64))
+	   == (RS6000_BTM_POPCNTD | RS6000_BTM_POWERPC64))
+    error ("builtin function %qs requires the %qs (or newer), and "
+	   "%qs or %qs options",
+	   name, "-mcpu=power7", "-m64", "-mpowerpc64");
   else
     error ("Builtin function %s is not supported with the current options",
 	   name);
@@ -18781,6 +18853,7 @@ builtin_function_type (machine_mode mode_ret, machine_mode mode_arg0,
     {
       /* unsigned 1 argument functions.  */
     case CRYPTO_BUILTIN_VSBOX:
+    case CRYPTO_BUILTIN_VSBOX_BE:
     case P8V_BUILTIN_VGBBD:
     case MISC_BUILTIN_CDTBCD:
     case MISC_BUILTIN_CBCDTD:
@@ -18794,9 +18867,13 @@ builtin_function_type (machine_mode mode_ret, machine_mode mode_arg0,
     case ALTIVEC_BUILTIN_VMULOUB:
     case ALTIVEC_BUILTIN_VMULOUH:
     case CRYPTO_BUILTIN_VCIPHER:
+    case CRYPTO_BUILTIN_VCIPHER_BE:
     case CRYPTO_BUILTIN_VCIPHERLAST:
+    case CRYPTO_BUILTIN_VCIPHERLAST_BE:
     case CRYPTO_BUILTIN_VNCIPHER:
+    case CRYPTO_BUILTIN_VNCIPHER_BE:
     case CRYPTO_BUILTIN_VNCIPHERLAST:
+    case CRYPTO_BUILTIN_VNCIPHERLAST_BE:
     case CRYPTO_BUILTIN_VPMSUMB:
     case CRYPTO_BUILTIN_VPMSUMH:
     case CRYPTO_BUILTIN_VPMSUMW:
@@ -18804,9 +18881,7 @@ builtin_function_type (machine_mode mode_ret, machine_mode mode_arg0,
     case CRYPTO_BUILTIN_VPMSUM:
     case MISC_BUILTIN_ADDG6S:
     case MISC_BUILTIN_DIVWEU:
-    case MISC_BUILTIN_DIVWEUO:
     case MISC_BUILTIN_DIVDEU:
-    case MISC_BUILTIN_DIVDEUO:
       h.uns_p[0] = 1;
       h.uns_p[1] = 1;
       h.uns_p[2] = 1;
@@ -23267,7 +23342,7 @@ rs6000_output_move_128bit (rtx operands[])
 	}
 
       else if (TARGET_ALTIVEC && src_vmx_p
-	       && altivec_indexed_or_indirect_operand (src, mode))
+	       && altivec_indexed_or_indirect_operand (dest, mode))
 	return "stvx %1,%y0";
 
       else if (TARGET_VSX && src_vsx_p)
@@ -23980,7 +24055,7 @@ print_operand (FILE *file, rtx x, int code)
 
 	    /* Fall through.  Must be [reg+reg].  */
 	  }
-	if (VECTOR_MEM_ALTIVEC_P (GET_MODE (x))
+	if (VECTOR_MEM_ALTIVEC_OR_VSX_P (GET_MODE (x))
 	    && GET_CODE (tmp) == AND
 	    && GET_CODE (XEXP (tmp, 1)) == CONST_INT
 	    && INTVAL (XEXP (tmp, 1)) == -16)
@@ -25907,49 +25982,6 @@ rs6000_emit_minmax (rtx dest, enum rtx_code code, rtx op0, rtx op1)
     emit_move_insn (dest, target);
 }
 
-/* Split a signbit operation on 64-bit machines with direct move.  Also allow
-   for the value to come from memory or if it is already loaded into a GPR.  */
-
-void
-rs6000_split_signbit (rtx dest, rtx src)
-{
-  machine_mode d_mode = GET_MODE (dest);
-  machine_mode s_mode = GET_MODE (src);
-  rtx dest_di = (d_mode == DImode) ? dest : gen_lowpart (DImode, dest);
-  rtx shift_reg = dest_di;
-
-  gcc_assert (FLOAT128_IEEE_P (s_mode) && TARGET_POWERPC64);
-
-  if (MEM_P (src))
-    {
-      rtx mem = (WORDS_BIG_ENDIAN
-		 ? adjust_address (src, DImode, 0)
-		 : adjust_address (src, DImode, 8));
-      emit_insn (gen_rtx_SET (dest_di, mem));
-    }
-
-  else
-    {
-      unsigned int r = reg_or_subregno (src);
-
-      if (INT_REGNO_P (r))
-	shift_reg = gen_rtx_REG (DImode, r + (BYTES_BIG_ENDIAN == 0));
-
-      else
-	{
-	  /* Generate the special mfvsrd instruction to get it in a GPR.  */
-	  gcc_assert (VSX_REGNO_P (r));
-	  if (s_mode == KFmode)
-	    emit_insn (gen_signbitkf2_dm2 (dest_di, src));
-	  else
-	    emit_insn (gen_signbittf2_dm2 (dest_di, src));
-	}
-    }
-
-  emit_insn (gen_lshrdi3 (dest_di, shift_reg, GEN_INT (63)));
-  return;
-}
-
 /* A subroutine of the atomic operation splitters.  Jump to LABEL if
    COND is true.  Mark the jump as unlikely to be taken.  */
 
@@ -26588,7 +26620,7 @@ rs6000_split_multireg_move (rtx dst, rtx src)
 	      emit_insn (gen_add3_insn (breg, breg, delta_rtx));
 	      src = replace_equiv_address (src, breg);
 	    }
-	  else if (! rs6000_offsettable_memref_p (src, reg_mode))
+	  else if (! rs6000_offsettable_memref_p (src, reg_mode, true))
 	    {
 	      if (GET_CODE (XEXP (src, 0)) == PRE_MODIFY)
 		{
@@ -26655,7 +26687,7 @@ rs6000_split_multireg_move (rtx dst, rtx src)
 		emit_insn (gen_add3_insn (breg, breg, delta_rtx));
 	      dst = replace_equiv_address (dst, breg);
 	    }
-	  else if (!rs6000_offsettable_memref_p (dst, reg_mode)
+	  else if (!rs6000_offsettable_memref_p (dst, reg_mode, true)
 		   && GET_CODE (XEXP (dst, 0)) != LO_SUM)
 	    {
 	      if (GET_CODE (XEXP (dst, 0)) == PRE_MODIFY)
@@ -26694,7 +26726,7 @@ rs6000_split_multireg_move (rtx dst, rtx src)
 		}
 	    }
 	  else if (GET_CODE (XEXP (dst, 0)) != LO_SUM)
-	    gcc_assert (rs6000_offsettable_memref_p (dst, reg_mode));
+	    gcc_assert (rs6000_offsettable_memref_p (dst, reg_mode, true));
 	}
 
       for (i = 0; i < nregs; i++)
@@ -26734,27 +26766,35 @@ save_reg_p (int r)
 static bool
 rs6000_reg_live_or_pic_offset_p (int reg)
 {
-  /* We need to mark the PIC offset register live for the same conditions
-     as it is set up, or otherwise it won't be saved before we clobber it.  */
-
   if (reg == RS6000_PIC_OFFSET_TABLE_REGNUM && !TARGET_SINGLE_PIC_BASE)
     {
+      /* When calling eh_return, we must return true for all the cases
+	 where conditional_register_usage marks the PIC offset reg
+	 call used or fixed.  */
+      if (crtl->calls_eh_return
+	  && ((DEFAULT_ABI == ABI_V4 && flag_pic)
+	      || (DEFAULT_ABI == ABI_DARWIN && flag_pic)
+	      || (TARGET_TOC && TARGET_MINIMAL_TOC)))
+	return true;
+
+      /* We need to mark the PIC offset register live for the same
+	 conditions as it is set up in rs6000_emit_prologue, or
+	 otherwise it won't be saved before we clobber it.  */
       if (TARGET_TOC && TARGET_MINIMAL_TOC
-	  && (crtl->calls_eh_return
-	      || df_regs_ever_live_p (reg)
-	      || !constant_pool_empty_p ()))
+	  && !constant_pool_empty_p ())
 	return true;
 
-      if ((DEFAULT_ABI == ABI_V4 || DEFAULT_ABI == ABI_DARWIN)
-	  && flag_pic)
+      if (DEFAULT_ABI == ABI_V4
+	  && (flag_pic == 1 || (flag_pic && TARGET_SECURE_PLT))
+	  && df_regs_ever_live_p (RS6000_PIC_OFFSET_TABLE_REGNUM))
 	return true;
-    }
 
-  /* If the function calls eh_return, claim used all the registers that would
-     be checked for liveness otherwise.  */
+      if (DEFAULT_ABI == ABI_DARWIN
+	  && flag_pic && crtl->uses_pic_offset_table)
+	return true;
+    }
 
-  return ((crtl->calls_eh_return || df_regs_ever_live_p (reg))
-	  && !call_used_regs[reg]);
+  return !call_used_regs[reg] && df_regs_ever_live_p (reg);
 }
 
 /* Return the first fixed-point register that is required to be
@@ -27813,6 +27853,12 @@ rs6000_function_ok_for_sibcall (tree decl, tree exp)
 {
   tree fntype;
 
+  /* The sibcall epilogue may clobber the static chain register.
+     ??? We could work harder and avoid that, but it's probably
+     not worth the hassle in practice.  */
+  if (CALL_EXPR_STATIC_CHAIN (exp))
+    return false;
+
   if (decl)
     fntype = TREE_TYPE (decl);
   else
@@ -31988,8 +32034,9 @@ rs6000_internal_arg_pointer (void)
 	  emit_insn_after (pat, get_insns ());
 	  pop_topmost_sequence ();
 	}
-      return plus_constant (Pmode, cfun->machine->split_stack_arg_pointer,
-			    FIRST_PARM_OFFSET (current_function_decl));
+      rtx ret = plus_constant (Pmode, cfun->machine->split_stack_arg_pointer,
+			       FIRST_PARM_OFFSET (current_function_decl));
+      return copy_to_reg (ret);
     }
   return virtual_incoming_args_rtx;
 }
@@ -35647,6 +35694,11 @@ rs6000_elf_in_small_data_p (const_tree decl)
     }
   else
     {
+      /* If we are told not to put readonly data in sdata, then don't.  */
+      if (TREE_READONLY (decl) && rs6000_sdata != SDATA_EABI
+	  && !rs6000_readonly_in_sdata)
+	return false;
+
       HOST_WIDE_INT size = int_size_in_bytes (TREE_TYPE (decl));
 
       if (size > 0
@@ -36417,6 +36469,10 @@ rs6000_xcoff_asm_init_sections (void)
 			   rs6000_xcoff_output_readwrite_section_asm_op,
 			   &xcoff_private_data_section_name);
 
+  read_only_private_data_section
+    = get_unnamed_section (0, rs6000_xcoff_output_readonly_section_asm_op,
+			   &xcoff_private_rodata_section_name);
+
   tls_data_section
     = get_unnamed_section (SECTION_TLS,
 			   rs6000_xcoff_output_tls_section_asm_op,
@@ -36427,10 +36483,6 @@ rs6000_xcoff_asm_init_sections (void)
 			   rs6000_xcoff_output_tls_section_asm_op,
 			   &xcoff_private_data_section_name);
 
-  read_only_private_data_section
-    = get_unnamed_section (0, rs6000_xcoff_output_readonly_section_asm_op,
-			   &xcoff_private_data_section_name);
-
   toc_section
     = get_unnamed_section (0, rs6000_xcoff_output_toc_section_asm_op, NULL);
 
@@ -36611,6 +36663,8 @@ rs6000_xcoff_file_start (void)
 			   main_input_filename, ".bss_");
   rs6000_gen_section_name (&xcoff_private_data_section_name,
 			   main_input_filename, ".rw_");
+  rs6000_gen_section_name (&xcoff_private_rodata_section_name,
+			   main_input_filename, ".rop_");
   rs6000_gen_section_name (&xcoff_read_only_section_name,
 			   main_input_filename, ".ro_");
   rs6000_gen_section_name (&xcoff_tls_data_section_name,
@@ -39167,6 +39221,7 @@ static struct rs6000_opt_mask const rs6000_builtin_mask_names[] =
   { "hard-dfp",		 RS6000_BTM_DFP,	false, false },
   { "hard-float",	 RS6000_BTM_HARD_FLOAT,	false, false },
   { "long-double-128",	 RS6000_BTM_LDBL128,	false, false },
+  { "powerpc64",	 RS6000_BTM_POWERPC64,  false, false },
   { "float128",		 RS6000_BTM_FLOAT128,   false, false },
 };
 
@@ -41657,6 +41712,38 @@ insn_is_swap_p (rtx insn)
   return 1;
 }
 
+/* Return 1 iff UID, known to reference a swap, is both fed by a load
+   and a feeder of a store.  */
+static unsigned int
+swap_feeds_both_load_and_store (swap_web_entry *insn_entry)
+{
+  rtx insn = insn_entry->insn;
+  struct df_insn_info *insn_info = DF_INSN_INFO_GET (insn);
+  df_ref def, use;
+  struct df_link *link = 0;
+  rtx_insn *load = 0, *store = 0;
+  bool fed_by_load = 0;
+  bool feeds_store = 0;
+
+  FOR_EACH_INSN_INFO_USE (use, insn_info)
+    {
+      link = DF_REF_CHAIN (use);
+      load = DF_REF_INSN (link->ref);
+      if (insn_is_load_p (load) && insn_is_swap_p (load))
+	fed_by_load = 1;
+    }
+
+  FOR_EACH_INSN_INFO_DEF (def, insn_info)
+    {
+      link = DF_REF_CHAIN (def);
+      store = DF_REF_INSN (link->ref);
+      if (insn_is_store_p (store) && insn_is_swap_p (store))
+	feeds_store = 1;
+    }
+
+  return fed_by_load && feeds_store;
+}
+
 /* Return TRUE if insn is a swap fed by a load from the constant pool.  */
 static bool
 const_load_sequence_p (swap_web_entry *insn_entry, rtx insn)
@@ -41860,6 +41947,7 @@ rtx_is_swappable_p (rtx op, unsigned int *special)
 	  {
 	  default:
 	    break;
+	  case UNSPEC_VBPERMQ:
 	  case UNSPEC_VMRGH_DIRECT:
 	  case UNSPEC_VMRGL_DIRECT:
 	  case UNSPEC_VPACK_SIGN_SIGN_SAT:
@@ -41871,6 +41959,7 @@ rtx_is_swappable_p (rtx op, unsigned int *special)
 	  case UNSPEC_VPERM_UNS:
 	  case UNSPEC_VPERMHI:
 	  case UNSPEC_VPERMSI:
+	  case UNSPEC_VPERMXOR:
 	  case UNSPEC_VPKPX:
 	  case UNSPEC_VSLDOI:
 	  case UNSPEC_VSLO:
@@ -42986,6 +43075,14 @@ rs6000_analyze_swaps (function *fun)
   /* Pre-pass to recombine lvx and stvx patterns so we don't lose info.  */
   recombine_lvx_stvx_patterns (fun);
 
+  /* Rebuild ud- and du-chains.  */                                            
+  df_remove_problem (df_chain);
+  df_process_deferred_rescans ();
+  df_set_flags (DF_RD_PRUNE_DEAD_DEFS);
+  df_chain_add_problem (DF_DU_CHAIN | DF_UD_CHAIN);
+  df_analyze ();
+  df_set_flags (DF_DEFER_INSN_RESCAN);
+
   /* Allocate structure to represent webs of insns.  */
   insn_entry = XCNEWVEC (swap_web_entry, get_max_uid ());
 
@@ -43129,6 +43226,14 @@ rs6000_analyze_swaps (function *fun)
 	  && !insn_entry[i].is_swap && !insn_entry[i].is_swappable)
 	root->web_not_optimizable = 1;
 
+      /* If we have a swap that is both fed by a permuting load
+	 and a feeder of a permuting store, then the optimization
+	 isn't appropriate.  (Consider vec_xl followed by vec_xst_be.)  */
+      else if (insn_entry[i].is_swap && !insn_entry[i].is_load
+	       && !insn_entry[i].is_store
+	       && swap_feeds_both_load_and_store (&insn_entry[i]))
+	root->web_not_optimizable = 1;
+
       /* If we have permuting loads or stores that are not accompanied
 	 by a register swap, the optimization isn't appropriate.  */
       else if (insn_entry[i].is_load && insn_entry[i].is_swap)
diff --git a/gcc/config/rs6000/rs6000.h b/gcc/config/rs6000/rs6000.h
index 3780a49d902..ba234fda718 100644
--- a/gcc/config/rs6000/rs6000.h
+++ b/gcc/config/rs6000/rs6000.h
@@ -1,5 +1,5 @@
 /* Definitions of target machine for GNU compiler, for IBM RS/6000.
-   Copyright (C) 1992-2017 Free Software Foundation, Inc.
+   Copyright (C) 1992-2018 Free Software Foundation, Inc.
    Contributed by Richard Kenner (kenner@vlsi1.ultra.nyu.edu)
 
    This file is part of GCC.
@@ -110,7 +110,8 @@
 /* Common ASM definitions used by ASM_SPEC among the various targets for
    handling -mcpu=xxx switches.  There is a parallel list in driver-rs6000.c to
    provide the default assembler options if the user uses -mcpu=native, so if
-   you make changes here, make them also there.  */
+   you make changes here, make them also there.  PR63177: Do not pass -mpower8
+   to the assembler if -mpower9-vector was also used.  */
 #define ASM_CPU_SPEC \
 "%{!mcpu*: \
   %{mpowerpc64*: -mppc64} \
@@ -124,7 +125,7 @@
 %{mcpu=power6: %(asm_cpu_power6) -maltivec} \
 %{mcpu=power6x: %(asm_cpu_power6) -maltivec} \
 %{mcpu=power7: %(asm_cpu_power7)} \
-%{mcpu=power8: %(asm_cpu_power8)} \
+%{mcpu=power8: %{!mpower9-vector: %(asm_cpu_power8)}} \
 %{mcpu=power9: %(asm_cpu_power9)} \
 %{mcpu=a2: -ma2} \
 %{mcpu=powerpc: -mppc} \
@@ -173,6 +174,7 @@
 %{maltivec: -maltivec} \
 %{mvsx: -mvsx %{!maltivec: -maltivec} %{!mcpu*: %(asm_cpu_power7)}} \
 %{mpower8-vector|mcrypto|mdirect-move|mhtm: %{!mcpu*: %(asm_cpu_power8)}} \
+%{mpower9-vector: %{!mcpu*|mcpu=power8: %(asm_cpu_power9)}} \
 -many"
 
 #define CPP_DEFAULT_SPEC ""
@@ -2735,6 +2737,7 @@ extern int frame_pointer_needed;
 #define RS6000_BTM_HARD_FLOAT	MASK_SOFT_FLOAT	/* Hardware floating point.  */
 #define RS6000_BTM_LDBL128	MASK_MULTIPLE	/* 128-bit long double.  */
 #define RS6000_BTM_64BIT	MASK_64BIT	/* 64-bit addressing.  */
+#define RS6000_BTM_POWERPC64	MASK_POWERPC64	/* 64-bit registers.  */
 #define RS6000_BTM_FLOAT128	MASK_FLOAT128_TYPE /* IEEE 128-bit float.  */
 
 #define RS6000_BTM_COMMON	(RS6000_BTM_ALTIVEC			\
@@ -2754,6 +2757,7 @@ extern int frame_pointer_needed;
 				 | RS6000_BTM_DFP			\
 				 | RS6000_BTM_HARD_FLOAT		\
 				 | RS6000_BTM_LDBL128			\
+				 | RS6000_BTM_POWERPC64			\
 				 | RS6000_BTM_FLOAT128)
 
 /* Define builtin enum index.  */
diff --git a/gcc/config/rs6000/rs6000.md b/gcc/config/rs6000/rs6000.md
index 4a199b767de..1e94214d0e6 100644
--- a/gcc/config/rs6000/rs6000.md
+++ b/gcc/config/rs6000/rs6000.md
@@ -1,5 +1,5 @@
 ;; Machine description for IBM RISC System 6000 (POWER) for GNU C compiler
-;; Copyright (C) 1990-2017 Free Software Foundation, Inc.
+;; Copyright (C) 1990-2018 Free Software Foundation, Inc.
 ;; Contributed by Richard Kenner (kenner@vlsi1.ultra.nyu.edu)
 
 ;; This file is part of GCC.
@@ -135,9 +135,7 @@
    UNSPEC_CDTBCD
    UNSPEC_CBCDTD
    UNSPEC_DIVE
-   UNSPEC_DIVEO
    UNSPEC_DIVEU
-   UNSPEC_DIVEUO
    UNSPEC_UNPACK_128BIT
    UNSPEC_PACK_128BIT
    UNSPEC_LSQ
@@ -544,7 +542,7 @@
 (define_code_attr su [(sign_extend	"s")
 		      (zero_extend	"u")
 		      (fix		"s")
-		      (unsigned_fix	"s")
+		      (unsigned_fix	"u")
 		      (float		"s")
 		      (unsigned_float	"u")])
 
@@ -1008,7 +1006,7 @@
 
 (define_insn "extendsi<mode>2"
   [(set (match_operand:EXTSI 0 "gpc_reg_operand" "=r,r,wl,wu,wj,wK,wH")
-	(sign_extend:EXTSI (match_operand:SI 1 "lwa_operand" "Y,r,Z,Z,r,wK,wH")))]
+	(sign_extend:EXTSI (match_operand:SI 1 "lwa_operand" "YZ,r,Z,Z,r,wK,wH")))]
   ""
   "@
    lwa%U1%X1 %0,%1
@@ -4757,12 +4755,19 @@
 {
   if (FLOAT128_IEEE_P (<MODE>mode))
     {
+      rtx dest = operands[0];
+      rtx src = operands[1];
+      rtx tmp = gen_reg_rtx (DImode);
+      rtx dest_di = gen_lowpart (DImode, dest);
+
       if (<MODE>mode == KFmode)
-	emit_insn (gen_signbitkf2_dm (operands[0], operands[1]));
+	emit_insn (gen_signbitkf2_dm (tmp, src));
       else if (<MODE>mode == TFmode)
-	emit_insn (gen_signbittf2_dm (operands[0], operands[1]));
+	emit_insn (gen_signbittf2_dm (tmp, src));
       else
 	gcc_unreachable ();
+
+      emit_insn (gen_lshrdi3 (dest_di, tmp, GEN_INT (63)));
       DONE;
     }
   operands[2] = gen_reg_rtx (DFmode);
@@ -4783,6 +4788,66 @@
     }
 })
 
+;; Optimize IEEE 128-bit signbit on 64-bit systems with direct move to avoid
+;; multiple direct moves.  If we used a SUBREG:DI of the Floa128 type, the
+;; register allocator would typically move the entire _Float128 item to GPRs (2
+;; instructions on ISA 3.0, 3-4 instructions on ISA 2.07).
+;;
+;; After register allocation, if the _Float128 had originally been in GPRs, the
+;; split allows the post reload phases to eliminate the move, and do the shift
+;; directly with the register that contains the signbit.
+(define_insn_and_split "signbit<mode>2_dm"
+  [(set (match_operand:DI 0 "gpc_reg_operand" "=r,r")
+	(unspec:DI [(match_operand:SIGNBIT 1 "gpc_reg_operand" "wa,r")]
+		   UNSPEC_SIGNBIT))]
+  "TARGET_POWERPC64 && TARGET_DIRECT_MOVE"
+  "@
+   mfvsrd %0,%x1
+   #"
+  "&& reload_completed && int_reg_operand (operands[1], <MODE>mode)"
+  [(set (match_dup 0)
+	(match_dup 2))]
+{
+  operands[2] = gen_highpart (DImode, operands[1]);
+}
+ [(set_attr "type" "mftgpr,*")])
+
+;; Optimize IEEE 128-bit signbit on to avoid loading the value into a vector
+;; register and then doing a direct move if the value comes from memory.  On
+;; little endian, we have to load the 2nd double-word to get the sign bit.
+(define_insn_and_split "*signbit<mode>2_dm_mem"
+  [(set (match_operand:DI 0 "gpc_reg_operand" "=b")
+	(unspec:DI [(match_operand:SIGNBIT 1 "memory_operand" "m")]
+		   UNSPEC_SIGNBIT))]
+  "TARGET_POWERPC64 && TARGET_DIRECT_MOVE"
+  "#"
+  "&& 1"
+  [(set (match_dup 0)
+	(match_dup 2))]
+{
+  rtx dest = operands[0];
+  rtx src = operands[1];
+  rtx addr = XEXP (src, 0);
+
+  if (WORDS_BIG_ENDIAN)
+    operands[2] = adjust_address (src, DImode, 0);
+
+  else if (REG_P (addr) || SUBREG_P (addr))
+    operands[2] = adjust_address (src, DImode, 8);
+
+  else if (GET_CODE (addr) == PLUS && REG_P (XEXP (addr, 0))
+	   && CONST_INT_P (XEXP (addr, 1)) && mem_operand_gpr (src, DImode))
+    operands[2] = adjust_address (src, DImode, 8);
+
+  else
+    {
+      rtx tmp = can_create_pseudo_p () ? gen_reg_rtx (DImode) : dest;
+      emit_insn (gen_rtx_SET (tmp, addr));
+      operands[2] = change_address (src, DImode,
+				    gen_rtx_PLUS (DImode, tmp, GEN_INT (8)));
+    }
+})
+
 (define_expand "copysign<mode>3"
   [(set (match_dup 3)
         (abs:SFDF (match_operand:SFDF 1 "gpc_reg_operand" "")))
@@ -4812,54 +4877,6 @@
    operands[5] = CONST0_RTX (<MODE>mode);
   })
 
-;; Optimize signbit on 64-bit systems with direct move to avoid doing the store
-;; and load.
-(define_insn_and_split "signbit<mode>2_dm"
-  [(set (match_operand:SI 0 "gpc_reg_operand" "=r,r,r")
-	(unspec:SI
-	 [(match_operand:SIGNBIT 1 "input_operand" "wa,m,r")]
-	 UNSPEC_SIGNBIT))]
-  "TARGET_POWERPC64 && TARGET_DIRECT_MOVE"
-  "#"
-  "&& reload_completed"
-  [(const_int 0)]
-{
-  rs6000_split_signbit (operands[0], operands[1]);
-  DONE;
-}
- [(set_attr "length" "8,8,4")
-  (set_attr "type" "mftgpr,load,integer")])
-
-(define_insn_and_split "*signbit<mode>2_dm_<su>ext"
-  [(set (match_operand:DI 0 "gpc_reg_operand" "=r,r,r")
-	(any_extend:DI
-	 (unspec:SI
-	  [(match_operand:SIGNBIT 1 "input_operand" "wa,m,r")]
-	  UNSPEC_SIGNBIT)))]
-  "TARGET_POWERPC64 && TARGET_DIRECT_MOVE"
-  "#"
-  "&& reload_completed"
-  [(const_int 0)]
-{
-  rs6000_split_signbit (operands[0], operands[1]);
-  DONE;
-}
- [(set_attr "length" "8,8,4")
-  (set_attr "type" "mftgpr,load,integer")])
-
-;; MODES_TIEABLE_P doesn't allow DImode to be tied with the various floating
-;; point types, which makes normal SUBREG's problematical. Instead use a
-;; special pattern to avoid using a normal movdi.
-(define_insn "signbit<mode>2_dm2"
-  [(set (match_operand:DI 0 "gpc_reg_operand" "=r")
-	(unspec:DI [(match_operand:SIGNBIT 1 "gpc_reg_operand" "wa")
-		    (const_int 0)]
-		   UNSPEC_SIGNBIT))]
-  "TARGET_POWERPC64 && TARGET_DIRECT_MOVE"
-  "mfvsrd %0,%x1"
- [(set_attr "type" "mftgpr")])
-
-
 ;; Use an unspec rather providing an if-then-else in RTL, to prevent the
 ;; compiler from optimizing -0.0
 (define_insn "copysign<mode>3_fcpsgn"
@@ -5694,45 +5711,59 @@
    xscvdpsxds %x0,%x1"
   [(set_attr "type" "fp")])
 
-(define_expand "fix_trunc<SFDF:mode><QHI:mode>2"
-  [(parallel [(set (match_operand:<QHI:MODE> 0 "nonimmediate_operand")
-		   (fix:QHI (match_operand:SFDF 1 "gpc_reg_operand")))
-	      (clobber (match_scratch:DI 2))])]
-  "TARGET_P9_VECTOR && TARGET_DIRECT_MOVE_64BIT
-   && TARGET_VSX_SMALL_INTEGER"
+;; If we have ISA 3.0, QI/HImode values can go in both VSX registers and GPR
+;; registers.  If we have ISA 2.07, we don't allow QI/HImode values in the
+;; vector registers, so we need to do direct moves to the GPRs, but SImode
+;; values can go in VSX registers.  Keeping the direct move part through
+;; register allocation prevents the register allocator from doing a direct move
+;; of the SImode value to a GPR, and then a store/load.
+(define_insn_and_split "fix<uns>_trunc<SFDF:mode><QHI:mode>2"
+  [(set (match_operand:<QHI:MODE> 0 "gpc_reg_operand" "=wJ,wJwK,r")
+	(any_fix:QHI (match_operand:SFDF 1 "gpc_reg_operand" "wJ,wJwK,wa")))
+   (clobber (match_scratch:SI 2 "=X,X,wi"))]
+  "TARGET_DIRECT_MOVE"
+  "@
+   fctiw<u>z %0,%1
+   xscvdp<su>xws %x0,%x1
+   #"
+  "&& reload_completed && int_reg_operand (operands[0], <QHI:MODE>mode)"
+  [(set (match_dup 2)
+	(any_fix:SI (match_dup 1)))
+   (set (match_dup 3)
+	(match_dup 2))]
 {
-  if (MEM_P (operands[0]))
-    operands[0] = rs6000_address_for_fpconvert (operands[0]);
-})
+  operands[3] = gen_rtx_REG (SImode, REGNO (operands[0]));
+}
+  [(set_attr "length" "4,4,8")
+   (set_attr "type" "fp")])
 
-(define_insn_and_split "*fix_trunc<SFDF:mode><QHI:mode>2_internal"
-  [(set (match_operand:<QHI:MODE> 0 "reg_or_indexed_operand" "=wIwJ,rZ")
-	(fix:QHI
-	 (match_operand:SFDF 1 "gpc_reg_operand" "<SFDF:Fv>,<SFDF:Fv>")))
-   (clobber (match_scratch:DI 2 "=X,wi"))]
-  "TARGET_P9_VECTOR && TARGET_DIRECT_MOVE_64BIT
-   && TARGET_VSX_SMALL_INTEGER"
+(define_insn "*fix<uns>_trunc<SFDF:mode>si2_p8"
+  [(set (match_operand:SI 0 "gpc_reg_operand" "=d,wa")
+	(any_fix:SI (match_operand:SFDF 1 "gpc_reg_operand" "d,wa")))]
+  "TARGET_DIRECT_MOVE"
+  "@
+   fctiw<u>z %0,%1
+   xscvdp<su>xws %x0,%x1"
+  [(set_attr "type" "fp")])
+
+;; Keep the convert and store together through register allocation to prevent
+;; the register allocator from getting clever and doing a direct move to a GPR
+;; and then store for reg+offset stores.
+(define_insn_and_split "*fix<uns>_trunc<SFDF:mode><QHSI:mode>2_mem"
+  [(set (match_operand:QHSI 0 "memory_operand" "=Z")
+	(any_fix:QHSI (match_operand:SFDF 1 "gpc_reg_operand" "wa")))
+   (clobber (match_scratch:SI 2 "=wa"))]
+    "(<QHSI:MODE>mode == SImode && TARGET_P8_VECTOR) || TARGET_P9_VECTOR"
   "#"
   "&& reload_completed"
-  [(const_int 0)]
+  [(set (match_dup 2)
+	(any_fix:SI (match_dup 1)))
+   (set (match_dup 0)
+	(match_dup 3))]
 {
-  rtx dest = operands[0];
-  rtx src = operands[1];
-
-  if (vsx_register_operand (dest, <QHI:MODE>mode))
-    {
-      rtx di_dest = gen_rtx_REG (DImode, REGNO (dest));
-      emit_insn (gen_fix_trunc<SFDF:mode>di2 (di_dest, src));
-    }
-  else
-    {
-      rtx tmp = operands[2];
-      rtx tmp2 = gen_rtx_REG (<QHI:MODE>mode, REGNO (tmp));
-
-      emit_insn (gen_fix_trunc<SFDF:mode>di2 (tmp, src));
-      emit_move_insn (dest, tmp2);
-    }
-  DONE;
+  operands[3] = (<QHSI:MODE>mode == SImode
+		 ? operands[2]
+		 : gen_rtx_REG (<QHSI:MODE>mode, REGNO (operands[2])));
 })
 
 (define_expand "fixuns_trunc<mode>si2"
@@ -5801,75 +5832,6 @@
    xscvdpuxds %x0,%x1"
   [(set_attr "type" "fp")])
 
-(define_expand "fixuns_trunc<SFDF:mode><QHI:mode>2"
-  [(parallel [(set (match_operand:<QHI:MODE> 0 "nonimmediate_operand")
-		   (unsigned_fix:QHI (match_operand:SFDF 1 "gpc_reg_operand")))
-	      (clobber (match_scratch:DI 2))])]
-  "TARGET_P9_VECTOR && TARGET_DIRECT_MOVE_64BIT
-   && TARGET_VSX_SMALL_INTEGER"
-{
-  if (MEM_P (operands[0]))
-    operands[0] = rs6000_address_for_fpconvert (operands[0]);
-})
-
-(define_insn_and_split "*fixuns_trunc<SFDF:mode><QHI:mode>2_internal"
-  [(set (match_operand:<QHI:MODE> 0 "reg_or_indexed_operand" "=wIwJ,rZ")
-	(unsigned_fix:QHI
-	 (match_operand:SFDF 1 "gpc_reg_operand" "<SFDF:Fv>,<SFDF:Fv>")))
-   (clobber (match_scratch:DI 2 "=X,wi"))]
-  "TARGET_P9_VECTOR && TARGET_DIRECT_MOVE_64BIT
-   && TARGET_VSX_SMALL_INTEGER"
-  "#"
-  "&& reload_completed"
-  [(const_int 0)]
-{
-  rtx dest = operands[0];
-  rtx src = operands[1];
-
-  if (vsx_register_operand (dest, <QHI:MODE>mode))
-    {
-      rtx di_dest = gen_rtx_REG (DImode, REGNO (dest));
-      emit_insn (gen_fixuns_trunc<SFDF:mode>di2 (di_dest, src));
-    }
-  else
-    {
-      rtx tmp = operands[2];
-      rtx tmp2 = gen_rtx_REG (<QHI:MODE>mode, REGNO (tmp));
-
-      emit_insn (gen_fixuns_trunc<SFDF:mode>di2 (tmp, src));
-      emit_move_insn (dest, tmp2);
-    }
-  DONE;
-})
-
-;; If -mvsx-small-integer, we can represent the FIX operation directly.  On
-;; older machines, we have to use an UNSPEC to produce a SImode and move it
-;; to another location, since SImode is not allowed in vector registers.
-(define_insn "*fctiw<u>z_<mode>_smallint"
-  [(set (match_operand:SI 0 "vsx_register_operand" "=d,wi")
-	(any_fix:SI (match_operand:SFDF 1 "gpc_reg_operand" "<Ff>,<Fv>")))]
-  "TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT
-   && TARGET_VSX_SMALL_INTEGER"
-  "@
-   fctiw<u>z %0,%1
-   xscvdp<su>xws %x0,%x1"
-  [(set_attr "type" "fp")])
-
-;; Combiner pattern to prevent moving the result of converting a floating point
-;; value to 32-bit integer to GPR in order to save it.
-(define_insn_and_split "*fctiw<u>z_<mode>_mem"
-  [(set (match_operand:SI 0 "memory_operand" "=Z")
-	(any_fix:SI (match_operand:SFDF 1 "gpc_reg_operand" "wa")))
-   (clobber (match_scratch:SI 2 "=wa"))]
-  "TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT
-   && TARGET_VSX_SMALL_INTEGER"
-  "#"
-  "&& reload_completed"
-  [(set (match_dup 2)
-	(any_fix:SI (match_dup 1)))
-   (set (match_dup 0)
-	(match_dup 2))])
-
 ;; Here, we use (set (reg) (unspec:DI [(fix:SI ...)] UNSPEC_FCTIWZ))
 ;; rather than (set (subreg:SI (reg)) (fix:SI ...))
 ;; because the first makes it clear that operand 0 is not live
@@ -8602,16 +8564,16 @@
 
 (define_insn "*movdi_internal32"
   [(set (match_operand:DI 0 "rs6000_nonimmediate_operand"
-         "=Y,        r,         r,         ^m,        ^d,         ^d,
-          r,         ^wY,       $Z,        ^wb,       $wv,        ^wi,
+         "=Y,        r,         r,         m,         ^d,         ^d,
+          r,         wY,        Z,         ^wb,       $wv,        ^wi,
           *wo,       *wo,       *wv,       *wi,       *wi,        *wv,
           *wv")
 
 	(match_operand:DI 1 "input_operand"
-          "r,        Y,         r,         d,         m,          d,
-           IJKnGHF,  wb,        wv,        wY,        Z,          wi,
-           Oj,       wM,        OjwM,      Oj,        wM,         wS,
-           wB"))]
+         "r,         Y,         r,         ^d,        m,          ^d,
+          IJKnGHF,   ^wb,       $wv,       wY,        Z,          ^wi,
+          Oj,        wM,        OjwM,      Oj,        wM,         wS,
+          wB"))]
 
   "! TARGET_POWERPC64
    && (gpc_reg_operand (operands[0], DImode)
@@ -8678,18 +8640,18 @@
 ;;              FPR->GPR   GPR->FPR   VSX->GPR   GPR->VSX
 (define_insn "*movdi_internal64"
   [(set (match_operand:DI 0 "nonimmediate_operand"
-               "=Y,        r,         r,         r,         r,          r,
-                ^m,        ^d,        ^d,        ^wY,       $Z,         $wb,
+               "=YZ,       r,         r,         r,         r,          r,
+                m,         ^d,        ^d,        wY,        Z,          $wb,
                 $wv,       ^wi,       *wo,       *wo,       *wv,        *wi,
                 *wi,       *wv,       *wv,       r,         *h,         *h,
                 ?*r,       ?*wg,      ?*r,       ?*wj")
 
 	(match_operand:DI 1 "input_operand"
-                "r,        Y,         r,         I,         L,          nF,
-                 d,        m,         d,         wb,        wv,         wY,
-                 Z,        wi,        Oj,        wM,        OjwM,       Oj,
-                 wM,       wS,        wB,        *h,        r,          0,
-                 wg,       r,         wj,        r"))]
+               "r,         YZ,        r,         I,         L,          nF,
+                ^d,        m,         ^d,        ^wb,       $wv,        wY,
+                Z,         ^wi,       Oj,        wM,        OjwM,       Oj,
+                wM,        wS,        wB,        *h,        r,          0,
+                wg,        r,         wj,        r"))]
 
   "TARGET_POWERPC64
    && (gpc_reg_operand (operands[0], DImode)
@@ -14419,14 +14381,10 @@
    (set_attr "length" "4")])
 
 (define_int_iterator UNSPEC_DIV_EXTEND [UNSPEC_DIVE
-					UNSPEC_DIVEO
-					UNSPEC_DIVEU
-					UNSPEC_DIVEUO])
+					UNSPEC_DIVEU])
 
 (define_int_attr div_extend [(UNSPEC_DIVE	"e")
-			     (UNSPEC_DIVEO	"eo")
-			     (UNSPEC_DIVEU	"eu")
-			     (UNSPEC_DIVEUO	"euo")])
+			     (UNSPEC_DIVEU	"eu")])
 
 (define_insn "div<div_extend>_<mode>"
   [(set (match_operand:GPR 0 "register_operand" "=r")
@@ -14505,16 +14463,14 @@
    (set_attr "length" "4")])
 
 (define_insn_and_split "pack<mode>"
-  [(set (match_operand:FMOVE128 0 "register_operand" "=d,&d")
+  [(set (match_operand:FMOVE128 0 "register_operand" "=&d")
 	(unspec:FMOVE128
-	 [(match_operand:<FP128_64> 1 "register_operand" "0,d")
-	  (match_operand:<FP128_64> 2 "register_operand" "d,d")]
+	 [(match_operand:<FP128_64> 1 "register_operand" "d")
+	  (match_operand:<FP128_64> 2 "register_operand" "d")]
 	 UNSPEC_PACK_128BIT))]
   "FLOAT128_2REG_P (<MODE>mode)"
-  "@
-   fmr %L0,%2
-   #"
-  "&& reload_completed && REGNO (operands[0]) != REGNO (operands[1])"
+  "#"
+  "&& reload_completed"
   [(set (match_dup 3) (match_dup 1))
    (set (match_dup 4) (match_dup 2))]
 {
@@ -14527,8 +14483,8 @@
   operands[3] = gen_rtx_REG (<FP128_64>mode, dest_hi);
   operands[4] = gen_rtx_REG (<FP128_64>mode, dest_lo);
 }
-  [(set_attr "type" "fpsimple,fp")
-   (set_attr "length" "4,8")])
+  [(set_attr "type" "fp")
+   (set_attr "length" "8")])
 
 (define_insn "unpack<mode>"
   [(set (match_operand:DI 0 "register_operand" "=d,d")
@@ -14803,49 +14759,45 @@
    (set_attr "length" "8")])
 
 ;; Conversion between IEEE 128-bit and integer types
-(define_insn "fix_<mode>di2_hw"
-  [(set (match_operand:DI 0 "altivec_register_operand" "=v")
-	(fix:DI (match_operand:IEEE128 1 "altivec_register_operand" "v")))]
-  "TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<MODE>mode)"
-  "xscvqpsdz %0,%1"
-  [(set_attr "type" "vecfloat")
-   (set_attr "size" "128")])
-
-(define_insn "fixuns_<mode>di2_hw"
-  [(set (match_operand:DI 0 "altivec_register_operand" "=v")
-	(unsigned_fix:DI (match_operand:IEEE128 1 "altivec_register_operand" "v")))]
-  "TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<MODE>mode)"
-  "xscvqpudz %0,%1"
-  [(set_attr "type" "vecfloat")
-   (set_attr "size" "128")])
 
-(define_insn "fix_<mode>si2_hw"
-  [(set (match_operand:SI 0 "altivec_register_operand" "=v")
-	(fix:SI (match_operand:IEEE128 1 "altivec_register_operand" "v")))]
-  "TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<MODE>mode)"
-  "xscvqpswz %0,%1"
+;; The fix function for DImode and SImode was declared earlier as a
+;; define_expand.  It calls into rs6000_expand_float128_convert if we don't
+;; have IEEE 128-bit hardware support.  QImode and HImode are not provided
+;; unless we have the IEEE 128-bit hardware.
+;;
+;; Unlike the code for converting SFmode/DFmode to QImode/HImode, we don't have
+;; to provide a GPR target that used direct move and a conversion in the GPR
+;; which works around QImode/HImode not being allowed in vector registers in
+;; ISA 2.07 (power8).
+(define_insn "fix<uns>_<IEEE128:mode><SDI:mode>2_hw"
+  [(set (match_operand:SDI 0 "altivec_register_operand" "=v")
+	(any_fix:SDI (match_operand:IEEE128 1 "altivec_register_operand" "v")))]
+  "TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<IEEE128:MODE>mode)"
+  "xscvqp<su><wd>z %0,%1"
   [(set_attr "type" "vecfloat")
    (set_attr "size" "128")])
 
-(define_insn "fixuns_<mode>si2_hw"
-  [(set (match_operand:SI 0 "altivec_register_operand" "=v")
-	(unsigned_fix:SI (match_operand:IEEE128 1 "altivec_register_operand" "v")))]
-  "TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<MODE>mode)"
-  "xscvqpuwz %0,%1"
+(define_insn "fix<uns>_trunc<IEEE128:mode><QHI:mode>2"
+  [(set (match_operand:QHI 0 "altivec_register_operand" "=v")
+	(any_fix:QHI
+	 (match_operand:IEEE128 1 "altivec_register_operand" "v")))]
+  "TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<IEEE128:MODE>mode)"
+  "xscvqp<su>wz %0,%1"
   [(set_attr "type" "vecfloat")
    (set_attr "size" "128")])
 
-;; Combiner pattern to prevent moving the result of converting an IEEE 128-bit
-;; floating point value to 32-bit integer to GPR in order to save it.
-(define_insn_and_split "*fix<uns>_<mode>_mem"
-  [(set (match_operand:SI 0 "memory_operand" "=Z")
-	(any_fix:SI (match_operand:IEEE128 1 "altivec_register_operand" "v")))
-   (clobber (match_scratch:SI 2 "=v"))]
+;; Combiner patterns to prevent moving the result of converting an IEEE 128-bit
+;; floating point value to 8/16/32-bit integer to GPR in order to save it.
+(define_insn_and_split "*fix<uns>_trunc<IEEE128:mode><QHSI:mode>2_mem"
+  [(set (match_operand:QHSI 0 "memory_operand" "=Z")
+	(any_fix:QHSI
+	 (match_operand:IEEE128 1 "altivec_register_operand" "v")))
+   (clobber (match_scratch:QHSI 2 "=v"))]
   "TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<MODE>mode)"
   "#"
   "&& reload_completed"
   [(set (match_dup 2)
-	(any_fix:SI (match_dup 1)))
+	(any_fix:QHSI (match_dup 1)))
    (set (match_dup 0)
 	(match_dup 2))])
 
diff --git a/gcc/config/rs6000/sysv4.opt b/gcc/config/rs6000/sysv4.opt
index 423300b8148..1492871da7d 100644
--- a/gcc/config/rs6000/sysv4.opt
+++ b/gcc/config/rs6000/sysv4.opt
@@ -27,6 +27,10 @@ msdata=
 Target RejectNegative Joined Var(rs6000_sdata_name)
 Select method for sdata handling.
 
+mreadonly-in-sdata
+Target Report Var(rs6000_readonly_in_sdata) Init(1) Save
+Allow readonly data in sdata.
+
 mtls-size=
 Target RejectNegative Joined Var(rs6000_tls_size) Enum(rs6000_tls_size)
 Specify bit size of immediate TLS offsets.
diff --git a/gcc/config/rs6000/vector.md b/gcc/config/rs6000/vector.md
index ea8169fabe0..a9ec9a9981a 100644
--- a/gcc/config/rs6000/vector.md
+++ b/gcc/config/rs6000/vector.md
@@ -180,12 +180,7 @@
       operands[1] = rs6000_address_for_altivec (operands[1]);
       rtx and_op = XEXP (operands[1], 0);
       gcc_assert (GET_CODE (and_op) == AND);
-      rtx addr = XEXP (and_op, 0);
-      if (GET_CODE (addr) == PLUS)
-        emit_insn (gen_altivec_lvx_<mode>_2op (operands[0], XEXP (addr, 0),
-	                                       XEXP (addr, 1)));
-      else
-        emit_insn (gen_altivec_lvx_<mode>_1op (operands[0], operands[1]));
+      emit_insn (gen_altivec_lvx_<mode> (operands[0], operands[1]));
       DONE;
     }
 }")
@@ -203,12 +198,7 @@
       operands[0] = rs6000_address_for_altivec (operands[0]);
       rtx and_op = XEXP (operands[0], 0);
       gcc_assert (GET_CODE (and_op) == AND);
-      rtx addr = XEXP (and_op, 0);
-      if (GET_CODE (addr) == PLUS)
-        emit_insn (gen_altivec_stvx_<mode>_2op (operands[1], XEXP (addr, 0),
-	                                        XEXP (addr, 1)));
-      else
-        emit_insn (gen_altivec_stvx_<mode>_1op (operands[1], operands[0]));
+      emit_insn (gen_altivec_stvx_<mode> (operands[1], operands[0]));
       DONE;
     }
 }")
diff --git a/gcc/config/rs6000/vsx.md b/gcc/config/rs6000/vsx.md
index 449574b893c..42e37ebb20a 100644
--- a/gcc/config/rs6000/vsx.md
+++ b/gcc/config/rs6000/vsx.md
@@ -157,6 +157,22 @@
 			 (TF	"wp")
 			 (KF	"wq")])
 
+;; A mode attribute to disparage use of GPR registers, except for scalar
+;; interger modes.
+(define_mode_attr ??r	[(V16QI "??r")
+			 (V8HI  "??r")
+			 (V4SI  "??r")
+			 (V4SF  "??r")
+			 (V2DI  "??r")
+			 (V2DF  "??r")
+			 (DI    "r")
+			 (DF    "??r")
+			 (SF    "??r")
+			 (V1TI  "??r")
+			 (TI    "r")
+			 (TF    "??r")
+			 (KF    "??r")])
+
 ;; Same size integer type for floating point data
 (define_mode_attr VSi [(V4SF  "v4si")
 		       (V2DF  "v2di")
@@ -323,6 +339,7 @@
    UNSPEC_VSX_CVDPSXWS
    UNSPEC_VSX_CVDPUXWS
    UNSPEC_VSX_CVSPDP
+   UNSPEC_VSX_CVHPSP
    UNSPEC_VSX_CVSPDPN
    UNSPEC_VSX_CVDPSPN
    UNSPEC_VSX_CVSXWDP
@@ -337,6 +354,8 @@
    UNSPEC_VSX_ROUND_I
    UNSPEC_VSX_ROUND_IC
    UNSPEC_VSX_SLDWI
+   UNSPEC_VSX_XXPERM
+
    UNSPEC_VSX_XXSPLTW
    UNSPEC_VSX_XXSPLTD
    UNSPEC_VSX_DIVSD
@@ -354,6 +373,8 @@
    UNSPEC_VSX_SIEXPDP
    UNSPEC_VSX_SCMPEXPDP
    UNSPEC_VSX_STSTDC
+   UNSPEC_VSX_VEXTRACT_FP_FROM_SHORTH
+   UNSPEC_VSX_VEXTRACT_FP_FROM_SHORTL
    UNSPEC_VSX_VXEXP
    UNSPEC_VSX_VXSIG
    UNSPEC_VSX_VIEXP
@@ -385,7 +406,7 @@
 ;; VSX moves so they match first.
 (define_insn_and_split "*vsx_le_perm_load_<mode>"
   [(set (match_operand:VSX_D 0 "vsx_register_operand" "=<VSa>")
-        (match_operand:VSX_D 1 "memory_operand" "Z"))]
+        (match_operand:VSX_D 1 "indexed_or_indirect_operand" "Z"))]
   "!BYTES_BIG_ENDIAN && TARGET_VSX && !TARGET_P9_VECTOR"
   "#"
   "!BYTES_BIG_ENDIAN && TARGET_VSX && !TARGET_P9_VECTOR"
@@ -408,7 +429,7 @@
 
 (define_insn_and_split "*vsx_le_perm_load_<mode>"
   [(set (match_operand:VSX_W 0 "vsx_register_operand" "=<VSa>")
-        (match_operand:VSX_W 1 "memory_operand" "Z"))]
+        (match_operand:VSX_W 1 "indexed_or_indirect_operand" "Z"))]
   "!BYTES_BIG_ENDIAN && TARGET_VSX && !TARGET_P9_VECTOR"
   "#"
   "!BYTES_BIG_ENDIAN && TARGET_VSX && !TARGET_P9_VECTOR"
@@ -433,7 +454,7 @@
 
 (define_insn_and_split "*vsx_le_perm_load_v8hi"
   [(set (match_operand:V8HI 0 "vsx_register_operand" "=wa")
-        (match_operand:V8HI 1 "memory_operand" "Z"))]
+        (match_operand:V8HI 1 "indexed_or_indirect_operand" "Z"))]
   "!BYTES_BIG_ENDIAN && TARGET_VSX && !TARGET_P9_VECTOR"
   "#"
   "!BYTES_BIG_ENDIAN && TARGET_VSX && !TARGET_P9_VECTOR"
@@ -462,7 +483,7 @@
 
 (define_insn_and_split "*vsx_le_perm_load_v16qi"
   [(set (match_operand:V16QI 0 "vsx_register_operand" "=wa")
-        (match_operand:V16QI 1 "memory_operand" "Z"))]
+        (match_operand:V16QI 1 "indexed_or_indirect_operand" "Z"))]
   "!BYTES_BIG_ENDIAN && TARGET_VSX && !TARGET_P9_VECTOR"
   "#"
   "!BYTES_BIG_ENDIAN && TARGET_VSX && !TARGET_P9_VECTOR"
@@ -498,7 +519,7 @@
    (set_attr "length" "8")])
 
 (define_insn "*vsx_le_perm_store_<mode>"
-  [(set (match_operand:VSX_D 0 "memory_operand" "=Z")
+  [(set (match_operand:VSX_D 0 "indexed_or_indirect_operand" "=Z")
         (match_operand:VSX_D 1 "vsx_register_operand" "+<VSa>"))]
   "!BYTES_BIG_ENDIAN && TARGET_VSX && !TARGET_P9_VECTOR"
   "#"
@@ -506,7 +527,7 @@
    (set_attr "length" "12")])
 
 (define_split
-  [(set (match_operand:VSX_D 0 "memory_operand" "")
+  [(set (match_operand:VSX_D 0 "indexed_or_indirect_operand" "")
         (match_operand:VSX_D 1 "vsx_register_operand" ""))]
   "!BYTES_BIG_ENDIAN && TARGET_VSX && !TARGET_P9_VECTOR && !reload_completed"
   [(set (match_dup 2)
@@ -525,7 +546,7 @@
 ;; The post-reload split requires that we re-permute the source
 ;; register in case it is still live.
 (define_split
-  [(set (match_operand:VSX_D 0 "memory_operand" "")
+  [(set (match_operand:VSX_D 0 "indexed_or_indirect_operand" "")
         (match_operand:VSX_D 1 "vsx_register_operand" ""))]
   "!BYTES_BIG_ENDIAN && TARGET_VSX && !TARGET_P9_VECTOR && reload_completed"
   [(set (match_dup 1)
@@ -543,7 +564,7 @@
   "")
 
 (define_insn "*vsx_le_perm_store_<mode>"
-  [(set (match_operand:VSX_W 0 "memory_operand" "=Z")
+  [(set (match_operand:VSX_W 0 "indexed_or_indirect_operand" "=Z")
         (match_operand:VSX_W 1 "vsx_register_operand" "+<VSa>"))]
   "!BYTES_BIG_ENDIAN && TARGET_VSX && !TARGET_P9_VECTOR"
   "#"
@@ -551,7 +572,7 @@
    (set_attr "length" "12")])
 
 (define_split
-  [(set (match_operand:VSX_W 0 "memory_operand" "")
+  [(set (match_operand:VSX_W 0 "indexed_or_indirect_operand" "")
         (match_operand:VSX_W 1 "vsx_register_operand" ""))]
   "!BYTES_BIG_ENDIAN && TARGET_VSX && !TARGET_P9_VECTOR && !reload_completed"
   [(set (match_dup 2)
@@ -572,7 +593,7 @@
 ;; The post-reload split requires that we re-permute the source
 ;; register in case it is still live.
 (define_split
-  [(set (match_operand:VSX_W 0 "memory_operand" "")
+  [(set (match_operand:VSX_W 0 "indexed_or_indirect_operand" "")
         (match_operand:VSX_W 1 "vsx_register_operand" ""))]
   "!BYTES_BIG_ENDIAN && TARGET_VSX && !TARGET_P9_VECTOR && reload_completed"
   [(set (match_dup 1)
@@ -593,7 +614,7 @@
   "")
 
 (define_insn "*vsx_le_perm_store_v8hi"
-  [(set (match_operand:V8HI 0 "memory_operand" "=Z")
+  [(set (match_operand:V8HI 0 "indexed_or_indirect_operand" "=Z")
         (match_operand:V8HI 1 "vsx_register_operand" "+wa"))]
   "!BYTES_BIG_ENDIAN && TARGET_VSX && !TARGET_P9_VECTOR"
   "#"
@@ -601,7 +622,7 @@
    (set_attr "length" "12")])
 
 (define_split
-  [(set (match_operand:V8HI 0 "memory_operand" "")
+  [(set (match_operand:V8HI 0 "indexed_or_indirect_operand" "")
         (match_operand:V8HI 1 "vsx_register_operand" ""))]
   "!BYTES_BIG_ENDIAN && TARGET_VSX && !TARGET_P9_VECTOR && !reload_completed"
   [(set (match_dup 2)
@@ -626,7 +647,7 @@
 ;; The post-reload split requires that we re-permute the source
 ;; register in case it is still live.
 (define_split
-  [(set (match_operand:V8HI 0 "memory_operand" "")
+  [(set (match_operand:V8HI 0 "indexed_or_indirect_operand" "")
         (match_operand:V8HI 1 "vsx_register_operand" ""))]
   "!BYTES_BIG_ENDIAN && TARGET_VSX && !TARGET_P9_VECTOR && reload_completed"
   [(set (match_dup 1)
@@ -653,7 +674,7 @@
   "")
 
 (define_insn "*vsx_le_perm_store_v16qi"
-  [(set (match_operand:V16QI 0 "memory_operand" "=Z")
+  [(set (match_operand:V16QI 0 "indexed_or_indirect_operand" "=Z")
         (match_operand:V16QI 1 "vsx_register_operand" "+wa"))]
   "!BYTES_BIG_ENDIAN && TARGET_VSX && !TARGET_P9_VECTOR"
   "#"
@@ -661,7 +682,7 @@
    (set_attr "length" "12")])
 
 (define_split
-  [(set (match_operand:V16QI 0 "memory_operand" "")
+  [(set (match_operand:V16QI 0 "indexed_or_indirect_operand" "")
         (match_operand:V16QI 1 "vsx_register_operand" ""))]
   "!BYTES_BIG_ENDIAN && TARGET_VSX && !TARGET_P9_VECTOR && !reload_completed"
   [(set (match_dup 2)
@@ -694,7 +715,7 @@
 ;; The post-reload split requires that we re-permute the source
 ;; register in case it is still live.
 (define_split
-  [(set (match_operand:V16QI 0 "memory_operand" "")
+  [(set (match_operand:V16QI 0 "indexed_or_indirect_operand" "")
         (match_operand:V16QI 1 "vsx_register_operand" ""))]
   "!BYTES_BIG_ENDIAN && TARGET_VSX && !TARGET_P9_VECTOR && reload_completed"
   [(set (match_dup 1)
@@ -961,7 +982,7 @@
 (define_insn "*vsx_mov<mode>_64bit"
   [(set (match_operand:VSX_M 0 "nonimmediate_operand"
                "=ZwO,      <VSa>,     <VSa>,     r,         we,        ?wQ,
-                ?&r,       ??r,       ??Y,       ??r,       wo,        v,
+                ?&r,       ??r,       ??Y,       <??r>,     wo,        v,
                 ?<VSa>,    *r,        v,         ??r,       wZ,        v")
 
 	(match_operand:VSX_M 1 "input_operand" 
@@ -990,7 +1011,7 @@
 ;;              LVX (VMX)  STVX (VMX)
 (define_insn "*vsx_mov<mode>_32bit"
   [(set (match_operand:VSX_M 0 "nonimmediate_operand"
-               "=ZwO,      <VSa>,     <VSa>,     ??r,       ??Y,       ??r,
+               "=ZwO,      <VSa>,     <VSa>,     ??r,       ??Y,       <??r>,
                 wo,        v,         ?<VSa>,    *r,        v,         ??r,
                 wZ,        v")
 
@@ -1763,6 +1784,15 @@
   "xscvspdp %x0,%x1"
   [(set_attr "type" "fp")])
 
+;; Generate xvcvhpsp instruction
+(define_insn "vsx_xvcvhpsp"
+  [(set (match_operand:V4SF 0 "vsx_register_operand" "=wa")
+	(unspec:V4SF [(match_operand: V16QI 1 "vsx_register_operand" "wa")]
+		     UNSPEC_VSX_CVHPSP))]
+  "TARGET_P9_VECTOR"
+  "xvcvhpsp %x0,%x1"
+  [(set_attr "type" "vecfloat")])
+
 ;; xscvdpsp used for splat'ing a scalar to V4SF, knowing that the internal SF
 ;; format of scalars is actually DF.
 (define_insn "vsx_xscvdpsp_scalar"
@@ -2422,7 +2452,7 @@
 	 (match_operand:VSX_D 1 "memory_operand" "m,m")
 	 (parallel [(match_operand:QI 2 "const_0_to_1_operand" "n,n")])))
    (clobber (match_scratch:P 3 "=&b,&b"))]
-  "VECTOR_MEM_VSX_P (<VSX_D:MODE>mode)"
+  "TARGET_POWERPC64 && VECTOR_MEM_VSX_P (<VSX_D:MODE>mode)"
   "#"
   "&& reload_completed"
   [(set (match_dup 0) (match_dup 4))]
@@ -2931,9 +2961,9 @@
   DONE;
 })
 
-(define_insn_and_split "*vsx_extract_<VSX_EXTRACT_I:mode>_<SDI:mode>_var"
-  [(set (match_operand:SDI 0 "gpc_reg_operand" "=r,r,r")
-	(zero_extend:SDI
+(define_insn_and_split "*vsx_extract_<mode>_<VS_scalar>mode_var"
+  [(set (match_operand:<VS_scalar> 0 "gpc_reg_operand" "=r,r,r")
+	(zero_extend:<VS_scalar>
 	 (unspec:<VSX_EXTRACT_I:VS_scalar>
 	  [(match_operand:VSX_EXTRACT_I 1 "input_operand" "wK,v,m")
 	   (match_operand:DI 2 "gpc_reg_operand" "r,r,r")]
@@ -2945,7 +2975,7 @@
   "&& reload_completed"
   [(const_int 0)]
 {
-  machine_mode smode = <VSX_EXTRACT_I:MODE>mode;
+  machine_mode smode = <VS_scalar>mode;
   rs6000_split_vec_extract_var (gen_rtx_REG (smode, REGNO (operands[0])),
 				operands[1], operands[2],
 				operands[3], operands[4]);
@@ -3569,7 +3599,7 @@
 	  (match_dup 1))
 	 (parallel [(const_int 1)])))
    (clobber (match_scratch:DF 2 "=0,0,&wd,&wa"))]
-  "VECTOR_UNIT_VSX_P (V2DFmode)"
+  "BYTES_BIG_ENDIAN && VECTOR_UNIT_VSX_P (V2DFmode)"
   "#"
   ""
   [(const_int 0)]
@@ -3597,7 +3627,7 @@
    (clobber (match_scratch:V4SF 2 "=&wf,&wa"))
    (clobber (match_scratch:V4SF 3 "=&wf,&wa"))
    (clobber (match_scratch:V4SF 4 "=0,0"))]
-  "VECTOR_UNIT_VSX_P (V4SFmode)"
+  "BYTES_BIG_ENDIAN && VECTOR_UNIT_VSX_P (V4SFmode)"
   "#"
   ""
   [(const_int 0)]
@@ -3930,7 +3960,7 @@
 	  (match_operand:DI 2 "register_operand" "+r")]
 	 UNSPEC_STXVL))]
   "TARGET_P9_VECTOR && TARGET_64BIT"
-  "sldi %2,%2\;stxvl %x0,%1,%2"
+  "sldi %2,%2,56\;stxvl %x0,%1,%2"
   [(set_attr "length" "8")
    (set_attr "type" "vecstore")])
 
@@ -4084,7 +4114,48 @@
 
 ;; Vector insert/extract word at arbitrary byte values.  Note, the little
 ;; endian version needs to adjust the byte number, and the V4SI element in
-;; vinsert4b.
+;; insert4b.
+(define_insn "extract4b"
+  [(set (match_operand:V2DI 0 "vsx_register_operand")
+       (unspec:V2DI [(match_operand:V16QI 1 "vsx_register_operand" "wa")
+                     (match_operand:QI 2 "const_0_to_12_operand" "n")]
+                    UNSPEC_XXEXTRACTUW))]
+  "TARGET_P9_VECTOR"
+{
+  if (!VECTOR_ELT_ORDER_BIG)
+    operands[2] = GEN_INT (12 - INTVAL (operands[2]));
+
+  return "xxextractuw %x0,%x1,%2";
+})
+
+(define_expand "insert4b"
+  [(set (match_operand:V16QI 0 "vsx_register_operand")
+	(unspec:V16QI [(match_operand:V4SI 1 "vsx_register_operand")
+		       (match_operand:V16QI 2 "vsx_register_operand")
+		       (match_operand:QI 3 "const_0_to_12_operand")]
+		   UNSPEC_XXINSERTW))]
+  "TARGET_P9_VECTOR"
+{
+  if (!VECTOR_ELT_ORDER_BIG)
+    {
+      rtx op1 = operands[1];
+      rtx v4si_tmp = gen_reg_rtx (V4SImode);
+      emit_insn (gen_vsx_xxpermdi_v4si_be (v4si_tmp, op1, op1, const1_rtx));
+      operands[1] = v4si_tmp;
+      operands[3] = GEN_INT (12 - INTVAL (operands[3]));
+    }
+})
+
+(define_insn "*insert4b_internal"
+  [(set (match_operand:V16QI 0 "vsx_register_operand" "=wa")
+	(unspec:V16QI [(match_operand:V4SI 1 "vsx_register_operand" "wa")
+		       (match_operand:V16QI 2 "vsx_register_operand" "0")
+		       (match_operand:QI 3 "const_0_to_12_operand" "n")]
+		   UNSPEC_XXINSERTW))]
+  "TARGET_P9_VECTOR"
+  "xxinsertw %x0,%x1,%3"
+  [(set_attr "type" "vecperm")])
+
 (define_expand "vextract4b"
   [(set (match_operand:DI 0 "gpc_reg_operand")
 	(unspec:DI [(match_operand:V16QI 1 "vsx_register_operand")
@@ -4123,57 +4194,65 @@
 }
   [(set_attr "type" "vecperm")])
 
-(define_expand "vinsert4b"
-  [(set (match_operand:V16QI 0 "vsx_register_operand")
-	(unspec:V16QI [(match_operand:V4SI 1 "vsx_register_operand")
-		       (match_operand:V16QI 2 "vsx_register_operand")
-		       (match_operand:QI 3 "const_0_to_12_operand")]
-		   UNSPEC_XXINSERTW))]
+;; Generate vector extract four float 32 values from left four elements
+;; of eight element vector of float 16 values.
+(define_expand "vextract_fp_from_shorth"
+  [(set (match_operand:V4SF 0 "register_operand" "=wa")
+	(unspec:V4SF [(match_operand:V8HI 1 "register_operand" "wa")]
+   UNSPEC_VSX_VEXTRACT_FP_FROM_SHORTH))]
   "TARGET_P9_VECTOR"
 {
-  if (!VECTOR_ELT_ORDER_BIG)
-    {
-      rtx op1 = operands[1];
-      rtx v4si_tmp = gen_reg_rtx (V4SImode);
-      emit_insn (gen_vsx_xxpermdi_v4si_be (v4si_tmp, op1, op1, const1_rtx));
-      operands[1] = v4si_tmp;
-      operands[3] = GEN_INT (12 - INTVAL (operands[3]));
-    }
-})
+  int vals[16] = {15, 14, 0, 0, 13, 12, 0, 0, 11, 10, 0, 0, 9, 8, 0, 0};
+  int i;
 
-(define_insn "*vinsert4b_internal"
-  [(set (match_operand:V16QI 0 "vsx_register_operand" "=wa")
-	(unspec:V16QI [(match_operand:V4SI 1 "vsx_register_operand" "wa")
-		       (match_operand:V16QI 2 "vsx_register_operand" "0")
-		       (match_operand:QI 3 "const_0_to_12_operand" "n")]
-		   UNSPEC_XXINSERTW))]
-  "TARGET_P9_VECTOR"
-  "xxinsertw %x0,%x1,%3"
-  [(set_attr "type" "vecperm")])
+  rtx rvals[16];
+  rtx mask = gen_reg_rtx (V16QImode);
+  rtx tmp = gen_reg_rtx (V16QImode);
+  rtvec v;
 
-(define_expand "vinsert4b_di"
-  [(set (match_operand:V16QI 0 "vsx_register_operand")
-	(unspec:V16QI [(match_operand:DI 1 "vsx_register_operand")
-		       (match_operand:V16QI 2 "vsx_register_operand")
-		       (match_operand:QI 3 "const_0_to_12_operand")]
-		   UNSPEC_XXINSERTW))]
-  "TARGET_P9_VECTOR"
-{
-  if (!VECTOR_ELT_ORDER_BIG)
-    operands[3] = GEN_INT (12 - INTVAL (operands[3]));
+  for (i = 0; i < 16; i++)
+    rvals[i] = GEN_INT (vals[i]);
+
+  /* xvcvhpsp - vector convert F16 to vector F32 requires the four F16
+     inputs in half words 1,3,5,7 (IBM numbering).  Use xxperm to move
+     src half words 0,1,2,3 for the conversion instruction.  */
+  v = gen_rtvec_v (16, rvals);
+  emit_insn (gen_vec_initv16qi (mask, gen_rtx_PARALLEL (V16QImode, v)));
+  emit_insn (gen_altivec_vperm_v8hiv16qi (tmp, operands[1],
+					  operands[1], mask));
+  emit_insn (gen_vsx_xvcvhpsp (operands[0], tmp));
+  DONE;
 })
 
-(define_insn "*vinsert4b_di_internal"
-  [(set (match_operand:V16QI 0 "vsx_register_operand" "=wa")
-	(unspec:V16QI [(match_operand:DI 1 "vsx_register_operand" "wj")
-		       (match_operand:V16QI 2 "vsx_register_operand" "0")
-		       (match_operand:QI 3 "const_0_to_12_operand" "n")]
-		   UNSPEC_XXINSERTW))]
+;; Generate vector extract four float 32 values from right four elements
+;; of eight element vector of float 16 values.
+(define_expand "vextract_fp_from_shortl"
+  [(set (match_operand:V4SF 0 "register_operand" "=wa")
+	(unspec:V4SF [(match_operand:V8HI 1 "register_operand" "wa")]
+	UNSPEC_VSX_VEXTRACT_FP_FROM_SHORTL))]
   "TARGET_P9_VECTOR"
-  "xxinsertw %x0,%x1,%3"
-  [(set_attr "type" "vecperm")])
+{
+  int vals[16] = {7, 6, 0, 0, 5, 4, 0, 0, 3, 2, 0, 0, 1, 0, 0, 0};
+  int i;
+  rtx rvals[16];
+  rtx mask = gen_reg_rtx (V16QImode);
+  rtx tmp = gen_reg_rtx (V16QImode);
+  rtvec v;
+
+  for (i = 0; i < 16; i++)
+    rvals[i] = GEN_INT (vals[i]);
+
+  /* xvcvhpsp - vector convert F16 to vector F32 requires the four F16
+     inputs in half words 1,3,5,7 (IBM numbering).  Use xxperm to move
+     src half words 4,5,6,7 for the conversion instruction.  */
+  v = gen_rtvec_v (16, rvals);
+  emit_insn (gen_vec_initv16qi (mask, gen_rtx_PARALLEL (V16QImode, v)));
+  emit_insn (gen_altivec_vperm_v8hiv16qi (tmp, operands[1],
+					  operands[1], mask));
+  emit_insn (gen_vsx_xvcvhpsp (operands[0], tmp));
+  DONE;
+})
 
-
 ;; Support for ISA 3.0 vector byte reverse
 
 ;; Swap all bytes with in a vector
diff --git a/gcc/config/rtems.h b/gcc/config/rtems.h
index 439199d4cbb..35026efa2c7 100644
--- a/gcc/config/rtems.h
+++ b/gcc/config/rtems.h
@@ -48,3 +48,7 @@
  -latomic -lc -lgcc --end-group %{!qnolinkcmds: -T linkcmds%s}}}"
 
 #define TARGET_POSIX_IO
+
+/* Prefer int for int32_t (see stdint-newlib.h).  */
+#undef STDINT_LONG32
+#define STDINT_LONG32 (INT_TYPE_SIZE != 32 && LONG_TYPE_SIZE == 32)
diff --git a/gcc/config/s390/s390-builtin-types.def b/gcc/config/s390/s390-builtin-types.def
index b7f33030eb9..915b050b2fb 100644
--- a/gcc/config/s390/s390-builtin-types.def
+++ b/gcc/config/s390/s390-builtin-types.def
@@ -124,6 +124,7 @@ DEF_OPAQUE_VECTOR_TYPE (BT_OUV4SI, BT_UINT, 4)
 DEF_OPAQUE_VECTOR_TYPE (BT_BV4SI, BT_BINT, 4)
 DEF_FN_TYPE_0 (BT_FN_INT, BT_INT)
 DEF_FN_TYPE_0 (BT_FN_UINT, BT_UINT)
+DEF_FN_TYPE_0 (BT_FN_VOID, BT_VOID)
 DEF_FN_TYPE_1 (BT_FN_INT_INT, BT_INT, BT_INT)
 DEF_FN_TYPE_1 (BT_FN_INT_VOIDPTR, BT_INT, BT_VOIDPTR)
 DEF_FN_TYPE_1 (BT_FN_OV4SI_INT, BT_OV4SI, BT_INT)
diff --git a/gcc/config/s390/s390-builtins.def b/gcc/config/s390/s390-builtins.def
index 9046cb08f94..5f9d1d98485 100644
--- a/gcc/config/s390/s390-builtins.def
+++ b/gcc/config/s390/s390-builtins.def
@@ -294,7 +294,7 @@
    flags: Flags applying to all its variants should be mentioned in the OB_DEF line instead.  */
 
 
-B_DEF      (tbeginc,                    tbeginc,            0,                  B_HTM,              0,                  BT_FN_INT)
+B_DEF      (tbeginc,                    tbeginc,            0,                  B_HTM,              0,                  BT_FN_VOID)
 B_DEF      (tbegin,                     tbegin,             returns_twice_attr, B_HTM,              0,                  BT_FN_INT_VOIDPTR)
 B_DEF      (tbegin_nofloat,             tbegin_nofloat,     returns_twice_attr, B_HTM,              0,                  BT_FN_INT_VOIDPTR)
 B_DEF      (tbegin_retry,               tbegin_retry,       returns_twice_attr, B_HTM,              0,                  BT_FN_INT_VOIDPTR_INT)
@@ -2804,8 +2804,8 @@ B_DEF      (s390_vfsqsb,                sqrtv4sf2,          0,
 B_DEF      (s390_vfsqdb,                sqrtv2df2,          0,                  B_VX,               0,                  BT_FN_V2DF_V2DF)
 
 OB_DEF     (s390_vec_double,            s390_vec_double_s64,s390_vec_double_u64,B_VX,               BT_FN_OV4SI_OV4SI)
-OB_DEF_VAR (s390_vec_double_s64,        s390_vcdgb,         0,                  0,                  BT_OV_V2DF_V2DI)
-OB_DEF_VAR (s390_vec_double_u64,        s390_vcdlgb,        0,                  0,                  BT_OV_V2DF_UV2DI)
+OB_DEF_VAR (s390_vec_double_s64,        s390_vec_double_s64,0,                  0,                  BT_OV_V2DF_V2DI)
+OB_DEF_VAR (s390_vec_double_u64,        s390_vec_double_u64,0,                  0,                  BT_OV_V2DF_UV2DI)
 
 B_DEF      (s390_vec_double_s64,        vec_double_s64,     0,                  B_INT | B_VX,       0,                  BT_FN_V2DF_V2DI)  /* vcdgb */
 B_DEF      (s390_vec_double_u64,        vec_double_u64,     0,                  B_INT | B_VX,       0,                  BT_FN_V2DF_UV2DI) /* vcdlgb */
diff --git a/gcc/config/s390/s390-opts.h b/gcc/config/s390/s390-opts.h
index 6d506e2c9e3..6ec891e877d 100644
--- a/gcc/config/s390/s390-opts.h
+++ b/gcc/config/s390/s390-opts.h
@@ -43,4 +43,13 @@ enum processor_type
   PROCESSOR_max
 };
 
+
+/* Values for -mindirect-branch and -mfunction-return options.  */
+enum indirect_branch {
+  indirect_branch_unset = 0,
+  indirect_branch_keep,
+  indirect_branch_thunk,
+  indirect_branch_thunk_inline,
+  indirect_branch_thunk_extern
+};
 #endif
diff --git a/gcc/config/s390/s390-protos.h b/gcc/config/s390/s390-protos.h
index 3fdb32059cd..3fb3268c306 100644
--- a/gcc/config/s390/s390-protos.h
+++ b/gcc/config/s390/s390-protos.h
@@ -53,6 +53,7 @@ extern int s390_class_max_nregs (enum reg_class, machine_mode);
 extern int s390_cannot_change_mode_class (machine_mode, machine_mode,
 					  enum reg_class);
 extern bool s390_function_arg_vector (machine_mode, const_tree);
+extern bool s390_return_addr_from_memory(void);
 #if S390_USE_TARGET_ATTRIBUTE
 extern tree s390_valid_target_attribute_tree (tree args,
 					      struct gcc_options *opts,
@@ -147,6 +148,17 @@ extern int s390_compare_and_branch_condition_mask (rtx);
 extern bool s390_extzv_shift_ok (int, int, unsigned HOST_WIDE_INT);
 extern void s390_asm_output_function_label (FILE *, const char *, tree);
 
+enum s390_indirect_branch_type
+  {
+    s390_indirect_branch_type_jump = 0,
+    s390_indirect_branch_type_call,
+    s390_indirect_branch_type_return
+  };
+extern void s390_indirect_branch_via_thunk (unsigned int regno,
+					    unsigned int return_addr_regno,
+					    rtx comparison_operator,
+					    enum s390_indirect_branch_type type);
+extern void s390_indirect_branch_via_inline_thunk (rtx execute_target);
 #endif /* RTX_CODE */
 
 /* s390-c.c routines */
diff --git a/gcc/config/s390/s390.c b/gcc/config/s390/s390.c
index c408d59efd2..f6b7dfc2bbe 100644
--- a/gcc/config/s390/s390.c
+++ b/gcc/config/s390/s390.c
@@ -377,84 +377,6 @@ struct s390_address
   bool literal_pool;
 };
 
-/* The following structure is embedded in the machine
-   specific part of struct function.  */
-
-struct GTY (()) s390_frame_layout
-{
-  /* Offset within stack frame.  */
-  HOST_WIDE_INT gprs_offset;
-  HOST_WIDE_INT f0_offset;
-  HOST_WIDE_INT f4_offset;
-  HOST_WIDE_INT f8_offset;
-  HOST_WIDE_INT backchain_offset;
-
-  /* Number of first and last gpr where slots in the register
-     save area are reserved for.  */
-  int first_save_gpr_slot;
-  int last_save_gpr_slot;
-
-  /* Location (FP register number) where GPRs (r0-r15) should
-     be saved to.
-      0 - does not need to be saved at all
-     -1 - stack slot  */
-#define SAVE_SLOT_NONE   0
-#define SAVE_SLOT_STACK -1
-  signed char gpr_save_slots[16];
-
-  /* Number of first and last gpr to be saved, restored.  */
-  int first_save_gpr;
-  int first_restore_gpr;
-  int last_save_gpr;
-  int last_restore_gpr;
-
-  /* Bits standing for floating point registers. Set, if the
-     respective register has to be saved. Starting with reg 16 (f0)
-     at the rightmost bit.
-     Bit 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0
-     fpr 15 13 11  9 14 12 10  8  7  5  3  1  6  4  2  0
-     reg 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16  */
-  unsigned int fpr_bitmap;
-
-  /* Number of floating point registers f8-f15 which must be saved.  */
-  int high_fprs;
-
-  /* Set if return address needs to be saved.
-     This flag is set by s390_return_addr_rtx if it could not use
-     the initial value of r14 and therefore depends on r14 saved
-     to the stack.  */
-  bool save_return_addr_p;
-
-  /* Size of stack frame.  */
-  HOST_WIDE_INT frame_size;
-};
-
-/* Define the structure for the machine field in struct function.  */
-
-struct GTY(()) machine_function
-{
-  struct s390_frame_layout frame_layout;
-
-  /* Literal pool base register.  */
-  rtx base_reg;
-
-  /* True if we may need to perform branch splitting.  */
-  bool split_branches_pending_p;
-
-  bool has_landing_pad_p;
-
-  /* True if the current function may contain a tbegin clobbering
-     FPRs.  */
-  bool tbegin_p;
-
-  /* For -fsplit-stack support: A stack local which holds a pointer to
-     the stack arguments for a function with a variable number of
-     arguments.  This is set at the start of the function and is used
-     to initialize the overflow_arg_area field of the va_list
-     structure.  */
-  rtx split_stack_varargs_pointer;
-};
-
 /* Few accessor macros for struct cfun->machine->s390_frame_layout.  */
 
 #define cfun_frame_layout (cfun->machine->frame_layout)
@@ -495,6 +417,33 @@ struct GTY(()) machine_function
    bytes on a z10 (or higher) CPU.  */
 #define PREDICT_DISTANCE (TARGET_Z10 ? 384 : 2048)
 
+/* Masks per jump target register indicating which thunk need to be
+   generated.  */
+static GTY(()) int indirect_branch_prez10thunk_mask = 0;
+static GTY(()) int indirect_branch_z10thunk_mask = 0;
+
+#define INDIRECT_BRANCH_NUM_OPTIONS 4
+
+enum s390_indirect_branch_option
+  {
+    s390_opt_indirect_branch_jump = 0,
+    s390_opt_indirect_branch_call,
+    s390_opt_function_return_reg,
+    s390_opt_function_return_mem
+  };
+
+static GTY(()) int indirect_branch_table_label_no[INDIRECT_BRANCH_NUM_OPTIONS] = { 0 };
+const char *indirect_branch_table_label[INDIRECT_BRANCH_NUM_OPTIONS] = \
+  { "LJUMP", "LCALL", "LRETREG", "LRETMEM" };
+const char *indirect_branch_table_name[INDIRECT_BRANCH_NUM_OPTIONS] =	\
+  { ".s390_indirect_jump", ".s390_indirect_call",
+    ".s390_return_reg", ".s390_return_mem" };
+
+bool
+s390_return_addr_from_memory ()
+{
+  return cfun_gpr_save_slot(RETURN_REGNUM) == SAVE_SLOT_STACK;
+}
 
 /* Indicate which ABI has been used for passing vector args.
    0 - no vector type arguments have been passed where the ABI is relevant
@@ -1148,9 +1097,83 @@ s390_handle_vectorbool_attribute (tree *node, tree name ATTRIBUTE_UNUSED,
   return NULL_TREE;
 }
 
+/* Check syntax of function decl attributes having a string type value.  */
+
+static tree
+s390_handle_string_attribute (tree *node, tree name ATTRIBUTE_UNUSED,
+			      tree args ATTRIBUTE_UNUSED,
+			      int flags ATTRIBUTE_UNUSED,
+			      bool *no_add_attrs)
+{
+  tree cst;
+
+  if (TREE_CODE (*node) != FUNCTION_DECL)
+    {
+      warning (OPT_Wattributes, "%qE attribute only applies to functions",
+	       name);
+      *no_add_attrs = true;
+    }
+
+  cst = TREE_VALUE (args);
+
+  if (TREE_CODE (cst) != STRING_CST)
+    {
+      warning (OPT_Wattributes,
+	       "%qE attribute requires a string constant argument",
+	       name);
+      *no_add_attrs = true;
+    }
+
+  if (is_attribute_p ("indirect_branch", name)
+      || is_attribute_p ("indirect_branch_call", name)
+      || is_attribute_p ("function_return", name)
+      || is_attribute_p ("function_return_reg", name)
+      || is_attribute_p ("function_return_mem", name))
+    {
+      if (strcmp (TREE_STRING_POINTER (cst), "keep") != 0
+	  && strcmp (TREE_STRING_POINTER (cst), "thunk") != 0
+	  && strcmp (TREE_STRING_POINTER (cst), "thunk-extern") != 0)
+      {
+	warning (OPT_Wattributes,
+		 "argument to %qE attribute is not "
+		 "(keep|thunk|thunk-extern)", name);
+	*no_add_attrs = true;
+      }
+    }
+
+  if (is_attribute_p ("indirect_branch_jump", name)
+      && strcmp (TREE_STRING_POINTER (cst), "keep") != 0
+      && strcmp (TREE_STRING_POINTER (cst), "thunk") != 0
+      && strcmp (TREE_STRING_POINTER (cst), "thunk-inline") != 0
+      && strcmp (TREE_STRING_POINTER (cst), "thunk-extern") != 0)
+    {
+      warning (OPT_Wattributes,
+	       "argument to %qE attribute is not "
+	       "(keep|thunk|thunk-inline|thunk-extern)", name);
+      *no_add_attrs = true;
+    }
+
+  return NULL_TREE;
+}
+
 static const struct attribute_spec s390_attribute_table[] = {
-  { "hotpatch", 2, 2, true, false, false, s390_handle_hotpatch_attribute, false },
-  { "s390_vector_bool", 0, 0, false, true, false, s390_handle_vectorbool_attribute, true },
+  { "hotpatch", 2, 2, true, false, false,
+    s390_handle_hotpatch_attribute, false },
+  { "s390_vector_bool", 0, 0, false, true, false,
+    s390_handle_vectorbool_attribute, true },
+  { "indirect_branch", 1, 1, true, false, false,
+    s390_handle_string_attribute, false },
+  { "indirect_branch_jump", 1, 1, true, false, false,
+    s390_handle_string_attribute, false },
+  { "indirect_branch_call", 1, 1, true, false, false,
+    s390_handle_string_attribute, false },
+  { "function_return", 1, 1, true, false, false,
+    s390_handle_string_attribute, false },
+  { "function_return_reg", 1, 1, true, false, false,
+    s390_handle_string_attribute, false },
+  { "function_return_mem", 1, 1, true, false, false,
+    s390_handle_string_attribute, false },
+
   /* End element.  */
   { NULL,        0, 0, false, false, false, NULL, false }
 };
@@ -6573,11 +6596,16 @@ s390_expand_vec_init (rtx target, rtx vals)
       return;
     }
 
+  /* Use vector replicate instructions.  vlrep/vrepi/vrep  */
   if (all_same)
     {
-      emit_insn (gen_rtx_SET (target,
-			      gen_rtx_VEC_DUPLICATE (mode,
-						     XVECEXP (vals, 0, 0))));
+      rtx elem = XVECEXP (vals, 0, 0);
+
+      /* vec_splats accepts general_operand as source.  */
+      if (!general_operand (elem, GET_MODE (elem)))
+	elem = force_reg (inner_mode, elem);
+
+      emit_insn (gen_rtx_SET (target, gen_rtx_VEC_DUPLICATE (mode, elem)));
       return;
     }
 
@@ -8583,11 +8611,25 @@ s390_find_constant (struct constant_pool *pool, rtx val,
 static rtx
 s390_execute_label (rtx insn)
 {
-  if (NONJUMP_INSN_P (insn)
+  if (INSN_P (insn)
       && GET_CODE (PATTERN (insn)) == PARALLEL
       && GET_CODE (XVECEXP (PATTERN (insn), 0, 0)) == UNSPEC
-      && XINT (XVECEXP (PATTERN (insn), 0, 0), 1) == UNSPEC_EXECUTE)
-    return XVECEXP (XVECEXP (PATTERN (insn), 0, 0), 0, 2);
+      && (XINT (XVECEXP (PATTERN (insn), 0, 0), 1) == UNSPEC_EXECUTE
+	  || XINT (XVECEXP (PATTERN (insn), 0, 0), 1) == UNSPEC_EXECUTE_JUMP))
+    {
+      if (XINT (XVECEXP (PATTERN (insn), 0, 0), 1) == UNSPEC_EXECUTE)
+	return XVECEXP (XVECEXP (PATTERN (insn), 0, 0), 0, 2);
+      else
+	{
+	  gcc_assert (JUMP_P (insn));
+	  /* For jump insns as execute target:
+	     - There is one operand less in the parallel (the
+	       modification register of the execute is always 0).
+	     - The execute target label is wrapped into an
+	       if_then_else in order to hide it from jump analysis.  */
+	  return XEXP (XVECEXP (XVECEXP (PATTERN (insn), 0, 0), 0, 0), 0);
+	}
+    }
 
   return NULL_RTX;
 }
@@ -11273,7 +11315,6 @@ s390_emit_epilogue (bool sibcall)
   rtx frame_pointer, return_reg, cfa_restores = NULL_RTX;
   int area_bottom, area_top, offset = 0;
   int next_offset;
-  rtvec p;
   int i;
 
   if (TARGET_TPF_PROFILING)
@@ -11427,10 +11468,15 @@ s390_emit_epilogue (bool sibcall)
 	  if (cfun_gpr_save_slot (RETURN_REGNUM) == SAVE_SLOT_STACK)
 	    {
 	      int return_regnum = find_unused_clobbered_reg();
-	      if (!return_regnum)
-		return_regnum = 4;
+	      if (!return_regnum
+		  || (TARGET_INDIRECT_BRANCH_NOBP_RET_OPTION
+		      && !TARGET_CPU_Z10
+		      && return_regnum == INDIRECT_BRANCH_THUNK_REGNUM))
+		{
+		  gcc_assert (INDIRECT_BRANCH_THUNK_REGNUM != 4);
+		  return_regnum = 4;
+		}
 	      return_reg = gen_rtx_REG (Pmode, return_regnum);
-
 	      addr = plus_constant (Pmode, frame_pointer,
 				    offset + cfun_frame_layout.gprs_offset
 				    + (RETURN_REGNUM
@@ -11466,16 +11512,7 @@ s390_emit_epilogue (bool sibcall)
   s390_restore_gprs_from_fprs ();
 
   if (! sibcall)
-    {
-
-      /* Return to caller.  */
-
-      p = rtvec_alloc (2);
-
-      RTVEC_ELT (p, 0) = ret_rtx;
-      RTVEC_ELT (p, 1) = gen_rtx_USE (VOIDmode, return_reg);
-      emit_jump_insn (gen_rtx_PARALLEL (VOIDmode, p));
-    }
+    emit_jump_insn (gen_return_use (return_reg));
 }
 
 /* Implement TARGET_SET_UP_BY_PROLOGUE.  */
@@ -13053,6 +13090,112 @@ s390_output_mi_thunk (FILE *file, tree thunk ATTRIBUTE_UNUSED,
   final_end_function ();
 }
 
+/* Output either an indirect jump or a an indirect call
+   (RETURN_ADDR_REGNO != INVALID_REGNUM) with target register REGNO
+   using a branch trampoline disabling branch target prediction.  */
+
+void
+s390_indirect_branch_via_thunk (unsigned int regno,
+				unsigned int return_addr_regno,
+				rtx comparison_operator,
+				enum s390_indirect_branch_type type)
+{
+  enum s390_indirect_branch_option option;
+
+  if (type == s390_indirect_branch_type_return)
+    {
+      if (s390_return_addr_from_memory ())
+	option = s390_opt_function_return_mem;
+      else
+	option = s390_opt_function_return_reg;
+    }
+  else if (type == s390_indirect_branch_type_jump)
+    option = s390_opt_indirect_branch_jump;
+  else if (type == s390_indirect_branch_type_call)
+    option = s390_opt_indirect_branch_call;
+  else
+    gcc_unreachable ();
+
+  if (TARGET_INDIRECT_BRANCH_TABLE)
+    {
+      char label[32];
+
+      ASM_GENERATE_INTERNAL_LABEL (label,
+				   indirect_branch_table_label[option],
+				   indirect_branch_table_label_no[option]++);
+      ASM_OUTPUT_LABEL (asm_out_file, label);
+    }
+
+  if (return_addr_regno != INVALID_REGNUM)
+    {
+      gcc_assert (comparison_operator == NULL_RTX);
+      fprintf (asm_out_file, " \tbrasl\t%%r%d,", return_addr_regno);
+    }
+  else
+    {
+      fputs (" \tjg", asm_out_file);
+      if (comparison_operator != NULL_RTX)
+	print_operand (asm_out_file, comparison_operator, 'C');
+
+      fputs ("\t", asm_out_file);
+    }
+
+  if (TARGET_CPU_Z10)
+    fprintf (asm_out_file,
+	     TARGET_INDIRECT_BRANCH_THUNK_NAME_EXRL "\n",
+	     regno);
+  else
+    fprintf (asm_out_file,
+	     TARGET_INDIRECT_BRANCH_THUNK_NAME_EX "\n",
+	     INDIRECT_BRANCH_THUNK_REGNUM, regno);
+
+  if ((option == s390_opt_indirect_branch_jump
+       && cfun->machine->indirect_branch_jump == indirect_branch_thunk)
+      || (option == s390_opt_indirect_branch_call
+	  && cfun->machine->indirect_branch_call == indirect_branch_thunk)
+      || (option == s390_opt_function_return_reg
+	  && cfun->machine->function_return_reg == indirect_branch_thunk)
+      || (option == s390_opt_function_return_mem
+	  && cfun->machine->function_return_mem == indirect_branch_thunk))
+    {
+      if (TARGET_CPU_Z10)
+	indirect_branch_z10thunk_mask |= (1 << regno);
+      else
+	indirect_branch_prez10thunk_mask |= (1 << regno);
+    }
+}
+
+/* Output an inline thunk for indirect jumps.  EXECUTE_TARGET can
+   either be an address register or a label pointing to the location
+   of the jump instruction.  */
+
+void
+s390_indirect_branch_via_inline_thunk (rtx execute_target)
+{
+  if (TARGET_INDIRECT_BRANCH_TABLE)
+    {
+      char label[32];
+
+      ASM_GENERATE_INTERNAL_LABEL (label,
+				   indirect_branch_table_label[s390_opt_indirect_branch_jump],
+				   indirect_branch_table_label_no[s390_opt_indirect_branch_jump]++);
+      ASM_OUTPUT_LABEL (asm_out_file, label);
+    }
+
+  if (!TARGET_ZARCH)
+    fputs ("\t.machinemode zarch\n", asm_out_file);
+
+  if (REG_P (execute_target))
+    fprintf (asm_out_file, "\tex\t%%r0,0(%%r%d)\n", REGNO (execute_target));
+  else
+    output_asm_insn ("exrl\t%%r0,%0", &execute_target);
+
+  if (!TARGET_ZARCH)
+    fputs ("\t.machinemode esa\n", asm_out_file);
+
+  fputs ("0:\tj\t0b\n", asm_out_file);
+}
+
 static bool
 s390_valid_pointer_mode (machine_mode mode)
 {
@@ -13158,6 +13301,14 @@ s390_function_ok_for_sibcall (tree decl, tree exp)
   if (!TARGET_64BIT && flag_pic && decl && !targetm.binds_local_p (decl))
     return false;
 
+  /* The thunks for indirect branches require r1 if no exrl is
+     available.  r1 might not be available when doing a sibling
+     call.  */
+  if (TARGET_INDIRECT_BRANCH_NOBP_CALL
+      && !TARGET_CPU_Z10
+      && !decl)
+    return false;
+
   /* Register 6 on s390 is available as an argument register but unfortunately
      "caller saved". This makes functions needing this register for arguments
      not suitable for sibcalls.  */
@@ -13191,9 +13342,13 @@ s390_emit_call (rtx addr_location, rtx tls_call, rtx result_reg,
 {
   bool plt_call = false;
   rtx_insn *insn;
-  rtx call;
-  rtx clobber;
-  rtvec vec;
+  rtx vec[4] = { NULL_RTX };
+  int elts = 0;
+  rtx *call = &vec[0];
+  rtx *clobber_ret_reg = &vec[1];
+  rtx *use = &vec[2];
+  rtx *clobber_thunk_reg = &vec[3];
+  int i;
 
   /* Direct function calls need special treatment.  */
   if (GET_CODE (addr_location) == SYMBOL_REF)
@@ -13245,26 +13400,58 @@ s390_emit_call (rtx addr_location, rtx tls_call, rtx result_reg,
       addr_location = gen_rtx_REG (Pmode, SIBCALL_REGNUM);
     }
 
+  if (TARGET_INDIRECT_BRANCH_NOBP_CALL
+      && GET_CODE (addr_location) != SYMBOL_REF
+      && !plt_call)
+    {
+      /* Indirect branch thunks require the target to be a single GPR.  */
+      addr_location = force_reg (Pmode, addr_location);
+
+      /* Without exrl the indirect branch thunks need an additional
+	 register for larl;ex */
+      if (!TARGET_CPU_Z10)
+	{
+	  *clobber_thunk_reg = gen_rtx_REG (Pmode, INDIRECT_BRANCH_THUNK_REGNUM);
+	  *clobber_thunk_reg = gen_rtx_CLOBBER (VOIDmode, *clobber_thunk_reg);
+	}
+    }
+
   addr_location = gen_rtx_MEM (QImode, addr_location);
-  call = gen_rtx_CALL (VOIDmode, addr_location, const0_rtx);
+  *call = gen_rtx_CALL (VOIDmode, addr_location, const0_rtx);
 
   if (result_reg != NULL_RTX)
-    call = gen_rtx_SET (result_reg, call);
+    *call = gen_rtx_SET (result_reg, *call);
 
   if (retaddr_reg != NULL_RTX)
     {
-      clobber = gen_rtx_CLOBBER (VOIDmode, retaddr_reg);
+      *clobber_ret_reg = gen_rtx_CLOBBER (VOIDmode, retaddr_reg);
 
       if (tls_call != NULL_RTX)
-	vec = gen_rtvec (3, call, clobber,
-			 gen_rtx_USE (VOIDmode, tls_call));
-      else
-	vec = gen_rtvec (2, call, clobber);
+	*use = gen_rtx_USE (VOIDmode, tls_call);
+    }
+
 
-      call = gen_rtx_PARALLEL (VOIDmode, vec);
+  for (i = 0; i < 4; i++)
+    if (vec[i] != NULL_RTX)
+      elts++;
+
+  if (elts > 1)
+    {
+      rtvec v;
+      int e = 0;
+
+      v = rtvec_alloc (elts);
+      for (i = 0; i < 4; i++)
+	if (vec[i] != NULL_RTX)
+	  {
+	    RTVEC_ELT (v, e) = vec[i];
+	    e++;
+	  }
+
+      *call = gen_rtx_PARALLEL (VOIDmode, v);
     }
 
-  insn = emit_call_insn (call);
+  insn = emit_call_insn (*call);
 
   /* 31-bit PLT stubs and tls calls use the GOT register implicitly.  */
   if ((!TARGET_64BIT && plt_call) || tls_call != NULL_RTX)
@@ -14046,7 +14233,16 @@ s390_reorg (void)
 	  target = emit_label (XEXP (label, 0));
 	  INSN_ADDRESSES_NEW (target, -1);
 
-	  target = emit_insn (s390_execute_target (insn));
+	  if (JUMP_P (insn))
+	    {
+	      target = emit_jump_insn (s390_execute_target (insn));
+	      /* This is important in order to keep a table jump
+		 pointing at the jump table label.  Only this makes it
+		 being recognized as table jump.  */
+	      JUMP_LABEL (target) = JUMP_LABEL (insn);
+	    }
+	  else
+	    target = emit_insn (s390_execute_target (insn));
 	  INSN_ADDRESSES_NEW (target, -1);
 	}
     }
@@ -14699,6 +14895,42 @@ s390_option_override_internal (bool main_args_p,
   if (TARGET_64BIT && !TARGET_ZARCH_P (opts->x_target_flags))
     error ("64-bit ABI not supported in ESA/390 mode");
 
+  if (opts->x_s390_indirect_branch == indirect_branch_thunk_inline
+      || opts->x_s390_indirect_branch_call == indirect_branch_thunk_inline
+      || opts->x_s390_function_return == indirect_branch_thunk_inline
+      || opts->x_s390_function_return_reg == indirect_branch_thunk_inline
+      || opts->x_s390_function_return_mem == indirect_branch_thunk_inline)
+    error ("thunk-inline is only supported with -mindirect-branch-jump");
+
+  if (opts->x_s390_indirect_branch != indirect_branch_keep)
+    {
+      if (!opts_set->x_s390_indirect_branch_call)
+	opts->x_s390_indirect_branch_call = opts->x_s390_indirect_branch;
+
+      if (!opts_set->x_s390_indirect_branch_jump)
+	opts->x_s390_indirect_branch_jump = opts->x_s390_indirect_branch;
+    }
+
+  if (opts->x_s390_function_return != indirect_branch_keep)
+    {
+      if (!opts_set->x_s390_function_return_reg)
+	opts->x_s390_function_return_reg = opts->x_s390_function_return;
+
+      if (!opts_set->x_s390_function_return_mem)
+	opts->x_s390_function_return_mem = opts->x_s390_function_return;
+    }
+
+  if (!TARGET_CPU_ZARCH)
+    {
+      if (opts->x_s390_indirect_branch_call != indirect_branch_keep
+	  || opts->x_s390_indirect_branch_jump != indirect_branch_keep)
+	error ("-mindirect-branch* options require -march=z900 or higher");
+      if (opts->x_s390_function_return_reg != indirect_branch_keep
+	  || opts->x_s390_function_return_mem != indirect_branch_keep)
+	error ("-mfunction-return* options require -march=z900 or higher");
+    }
+
+
   /* Enable hardware transactions if available and not explicitly
      disabled by user.  E.g. with -m31 -march=zEC12 -mzarch */
   if (!TARGET_OPT_HTM_P (opts_set->x_target_flags))
@@ -15267,6 +15499,79 @@ s390_valid_target_attribute_p (tree fndecl,
   return ret;
 }
 
+/* Set VAL to correct enum value according to the indirect-branch or
+   function-return attribute in ATTR.  */
+
+static inline void
+s390_indirect_branch_attrvalue (tree attr, enum indirect_branch *val)
+{
+  const char *str = TREE_STRING_POINTER (TREE_VALUE (TREE_VALUE (attr)));
+  if (strcmp (str, "keep") == 0)
+    *val = indirect_branch_keep;
+  else if (strcmp (str, "thunk") == 0)
+    *val = indirect_branch_thunk;
+  else if (strcmp (str, "thunk-inline") == 0)
+    *val = indirect_branch_thunk_inline;
+  else if (strcmp (str, "thunk-extern") == 0)
+    *val = indirect_branch_thunk_extern;
+}
+
+/* Memorize the setting for -mindirect-branch* and -mfunction-return*
+   from either the cmdline or the function attributes in
+   cfun->machine.  */
+
+static void
+s390_indirect_branch_settings (tree fndecl)
+{
+  tree attr;
+
+  if (!fndecl)
+    return;
+
+  /* Initialize with the cmdline options and let the attributes
+     override it.  */
+  cfun->machine->indirect_branch_jump = s390_indirect_branch_jump;
+  cfun->machine->indirect_branch_call = s390_indirect_branch_call;
+
+  cfun->machine->function_return_reg = s390_function_return_reg;
+  cfun->machine->function_return_mem = s390_function_return_mem;
+
+  if ((attr = lookup_attribute ("indirect_branch",
+				DECL_ATTRIBUTES (fndecl))))
+    {
+      s390_indirect_branch_attrvalue (attr,
+				      &cfun->machine->indirect_branch_jump);
+      s390_indirect_branch_attrvalue (attr,
+				      &cfun->machine->indirect_branch_call);
+    }
+
+  if ((attr = lookup_attribute ("indirect_branch_jump",
+				DECL_ATTRIBUTES (fndecl))))
+    s390_indirect_branch_attrvalue (attr, &cfun->machine->indirect_branch_jump);
+
+  if ((attr = lookup_attribute ("indirect_branch_call",
+				DECL_ATTRIBUTES (fndecl))))
+    s390_indirect_branch_attrvalue (attr, &cfun->machine->indirect_branch_call);
+
+  if ((attr = lookup_attribute ("function_return",
+				DECL_ATTRIBUTES (fndecl))))
+    {
+      s390_indirect_branch_attrvalue (attr,
+				      &cfun->machine->function_return_reg);
+      s390_indirect_branch_attrvalue (attr,
+				      &cfun->machine->function_return_mem);
+    }
+
+  if ((attr = lookup_attribute ("function_return_reg",
+				DECL_ATTRIBUTES (fndecl))))
+    s390_indirect_branch_attrvalue (attr, &cfun->machine->function_return_reg);
+
+  if ((attr = lookup_attribute ("function_return_mem",
+				DECL_ATTRIBUTES (fndecl))))
+    s390_indirect_branch_attrvalue (attr, &cfun->machine->function_return_mem);
+}
+
+
 /* Restore targets globals from NEW_TREE and invalidate s390_previous_fndecl
    cache.  */
 
@@ -15293,7 +15598,10 @@ s390_set_current_function (tree fndecl)
      several times in the course of compiling a function, and we don't want to
      slow things down too much or call target_reinit when it isn't safe.  */
   if (fndecl == s390_previous_fndecl)
-    return;
+    {
+      s390_indirect_branch_settings (fndecl);
+      return;
+    }
 
   tree old_tree;
   if (s390_previous_fndecl == NULL_TREE)
@@ -15317,6 +15625,8 @@ s390_set_current_function (tree fndecl)
   if (old_tree != new_tree)
     s390_activate_target_options (new_tree);
   s390_previous_fndecl = fndecl;
+
+  s390_indirect_branch_settings (fndecl);
 }
 #endif
 
@@ -15598,6 +15908,186 @@ s390_asan_shadow_offset (void)
   return TARGET_64BIT ? HOST_WIDE_INT_1U << 52 : HOST_WIDE_INT_UC (0x20000000);
 }
 
+#ifdef HAVE_GAS_HIDDEN
+# define USE_HIDDEN_LINKONCE 1
+#else
+# define USE_HIDDEN_LINKONCE 0
+#endif
+
+/* Output an indirect branch trampoline for target register REGNO.  */
+
+static void
+s390_output_indirect_thunk_function (unsigned int regno, bool z10_p)
+{
+  tree decl;
+  char thunk_label[32];
+  int i;
+
+  if (z10_p)
+    sprintf (thunk_label, TARGET_INDIRECT_BRANCH_THUNK_NAME_EXRL, regno);
+  else
+    sprintf (thunk_label, TARGET_INDIRECT_BRANCH_THUNK_NAME_EX,
+	     INDIRECT_BRANCH_THUNK_REGNUM, regno);
+
+  decl = build_decl (BUILTINS_LOCATION, FUNCTION_DECL,
+		     get_identifier (thunk_label),
+		     build_function_type_list (void_type_node, NULL_TREE));
+  DECL_RESULT (decl) = build_decl (BUILTINS_LOCATION, RESULT_DECL,
+				   NULL_TREE, void_type_node);
+  TREE_PUBLIC (decl) = 1;
+  TREE_STATIC (decl) = 1;
+  DECL_IGNORED_P (decl) = 1;
+
+  if (USE_HIDDEN_LINKONCE)
+    {
+      cgraph_node::create (decl)->set_comdat_group (DECL_ASSEMBLER_NAME (decl));
+
+      targetm.asm_out.unique_section (decl, 0);
+      switch_to_section (get_named_section (decl, NULL, 0));
+
+      targetm.asm_out.globalize_label (asm_out_file, thunk_label);
+      fputs ("\t.hidden\t", asm_out_file);
+      assemble_name (asm_out_file, thunk_label);
+      putc ('\n', asm_out_file);
+      ASM_DECLARE_FUNCTION_NAME (asm_out_file, thunk_label, decl);
+    }
+  else
+    {
+      switch_to_section (text_section);
+      ASM_OUTPUT_LABEL (asm_out_file, thunk_label);
+    }
+
+  DECL_INITIAL (decl) = make_node (BLOCK);
+  current_function_decl = decl;
+  allocate_struct_function (decl, false);
+  init_function_start (decl);
+  cfun->is_thunk = true;
+  first_function_block_is_cold = false;
+  final_start_function (emit_barrier (), asm_out_file, 1);
+
+  /* This makes CFI at least usable for indirect jumps.
+
+     Stopping in the thunk: backtrace will point to the thunk target
+     is if it was interrupted by a signal.  For a call this means that
+     the call chain will be: caller->callee->thunk   */
+  if (flag_asynchronous_unwind_tables && flag_dwarf2_cfi_asm)
+    {
+      fputs ("\t.cfi_signal_frame\n", asm_out_file);
+      fprintf (asm_out_file, "\t.cfi_return_column %d\n", regno);
+      for (i = 0; i < FPR15_REGNUM; i++)
+	fprintf (asm_out_file, "\t.cfi_same_value %s\n", reg_names[i]);
+    }
+
+  if (z10_p)
+    {
+      /* exrl  0,1f  */
+
+      /* We generate a thunk for z10 compiled code although z10 is
+	 currently not enabled.  Tell the assembler to accept the
+	 instruction.  */
+      if (!TARGET_CPU_Z10)
+	{
+	  fputs ("\t.machine push\n", asm_out_file);
+	  fputs ("\t.machine z10\n", asm_out_file);
+	}
+      /* We use exrl even if -mzarch hasn't been specified on the
+	 command line so we have to tell the assembler to accept
+	 it.  */
+      if (!TARGET_ZARCH)
+	fputs ("\t.machinemode zarch\n", asm_out_file);
+
+      fputs ("\texrl\t0,1f\n", asm_out_file);
+
+      if (!TARGET_ZARCH)
+	fputs ("\t.machinemode esa\n", asm_out_file);
+
+      if (!TARGET_CPU_Z10)
+	fputs ("\t.machine pop\n", asm_out_file);
+    }
+  else if (TARGET_CPU_ZARCH)
+    {
+      /* larl %r1,1f  */
+      fprintf (asm_out_file, "\tlarl\t%%r%d,1f\n",
+	       INDIRECT_BRANCH_THUNK_REGNUM);
+
+      /* ex 0,0(%r1)  */
+      fprintf (asm_out_file, "\tex\t0,0(%%r%d)\n",
+	       INDIRECT_BRANCH_THUNK_REGNUM);
+    }
+  else
+    gcc_unreachable ();
+
+  /* 0:    j 0b  */
+  fputs ("0:\tj\t0b\n", asm_out_file);
+
+  /* 1:    br <regno>  */
+  fprintf (asm_out_file, "1:\tbr\t%%r%d\n", regno);
+
+  final_end_function ();
+  init_insn_lengths ();
+  free_after_compilation (cfun);
+  set_cfun (NULL);
+  current_function_decl = NULL;
+}
+
+/* Implement the asm.code_end target hook.  */
+
+static void
+s390_code_end (void)
+{
+  int i;
+
+  for (i = 1; i < 16; i++)
+    {
+      if (indirect_branch_z10thunk_mask & (1 << i))
+	s390_output_indirect_thunk_function (i, true);
+
+      if (indirect_branch_prez10thunk_mask & (1 << i))
+	s390_output_indirect_thunk_function (i, false);
+    }
+
+  if (TARGET_INDIRECT_BRANCH_TABLE)
+    {
+      int o;
+      int i;
+
+      for (o = 0; o < INDIRECT_BRANCH_NUM_OPTIONS; o++)
+	{
+	  if (indirect_branch_table_label_no[o] == 0)
+	    continue;
+
+	  switch_to_section (get_section (indirect_branch_table_name[o],
+					  0,
+					  NULL_TREE));
+	  for (i = 0; i < indirect_branch_table_label_no[o]; i++)
+	    {
+	      char label_start[32];
+
+	      ASM_GENERATE_INTERNAL_LABEL (label_start,
+					   indirect_branch_table_label[o], i);
+
+	      fputs ("\t.long\t", asm_out_file);
+	      assemble_name_raw (asm_out_file, label_start);
+	      fputs ("-.\n", asm_out_file);
+	    }
+	  switch_to_section (current_function_section ());
+	}
+    }
+}
+
+/* Implement the TARGET_CASE_VALUES_THRESHOLD target hook.  */
+
+unsigned int
+s390_case_values_threshold (void)
+{
+  /* Disabling branch prediction for indirect jumps makes jump tables
+     much more expensive.  */
+  if (TARGET_INDIRECT_BRANCH_NOBP_JUMP)
+    return 20;
+
+  return default_case_values_threshold ();
+}
+
 /* Initialize GCC target structure.  */
 
 #undef  TARGET_ASM_ALIGNED_HI_OP
@@ -15854,6 +16344,12 @@ s390_asan_shadow_offset (void)
 #undef TARGET_OPTION_RESTORE
 #define TARGET_OPTION_RESTORE s390_function_specific_restore
 
+#undef TARGET_ASM_CODE_END
+#define TARGET_ASM_CODE_END s390_code_end
+
+#undef TARGET_CASE_VALUES_THRESHOLD
+#define TARGET_CASE_VALUES_THRESHOLD s390_case_values_threshold
+
 struct gcc_target targetm = TARGET_INITIALIZER;
 
 #include "gt-s390.h"
diff --git a/gcc/config/s390/s390.h b/gcc/config/s390/s390.h
index a372981ff3a..f204204b435 100644
--- a/gcc/config/s390/s390.h
+++ b/gcc/config/s390/s390.h
@@ -205,7 +205,7 @@ enum processor_flags
 #define OPTION_DEFAULT_SPECS 					\
   { "mode", "%{!mesa:%{!mzarch:-m%(VALUE)}}" },			\
   { "arch", "%{!march=*:-march=%(VALUE)}" },			\
-  { "tune", "%{!mtune=*:-mtune=%(VALUE)}" }
+  { "tune", "%{!mtune=*:%{!march=*:-mtune=%(VALUE)}}" }
 
 #ifdef __s390__
 extern const char *s390_host_detect_local_cpu (int argc, const char **argv);
@@ -1120,4 +1120,124 @@ extern const int processor_flags_table[];
     s390_register_target_pragmas ();		\
   } while (0)
 
+#ifndef USED_FOR_TARGET
+/* The following structure is embedded in the machine
+   specific part of struct function.  */
+
+struct GTY (()) s390_frame_layout
+{
+  /* Offset within stack frame.  */
+  HOST_WIDE_INT gprs_offset;
+  HOST_WIDE_INT f0_offset;
+  HOST_WIDE_INT f4_offset;
+  HOST_WIDE_INT f8_offset;
+  HOST_WIDE_INT backchain_offset;
+
+  /* Number of first and last gpr where slots in the register
+     save area are reserved for.  */
+  int first_save_gpr_slot;
+  int last_save_gpr_slot;
+
+  /* Location (FP register number) where GPRs (r0-r15) should
+     be saved to.
+      0 - does not need to be saved at all
+     -1 - stack slot  */
+#define SAVE_SLOT_NONE   0
+#define SAVE_SLOT_STACK -1
+  signed char gpr_save_slots[16];
+
+  /* Number of first and last gpr to be saved, restored.  */
+  int first_save_gpr;
+  int first_restore_gpr;
+  int last_save_gpr;
+  int last_restore_gpr;
+
+  /* Bits standing for floating point registers. Set, if the
+     respective register has to be saved. Starting with reg 16 (f0)
+     at the rightmost bit.
+     Bit 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0
+     fpr 15 13 11  9 14 12 10  8  7  5  3  1  6  4  2  0
+     reg 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16  */
+  unsigned int fpr_bitmap;
+
+  /* Number of floating point registers f8-f15 which must be saved.  */
+  int high_fprs;
+
+  /* Set if return address needs to be saved.
+     This flag is set by s390_return_addr_rtx if it could not use
+     the initial value of r14 and therefore depends on r14 saved
+     to the stack.  */
+  bool save_return_addr_p;
+
+  /* Size of stack frame.  */
+  HOST_WIDE_INT frame_size;
+};
+
+
+/* Define the structure for the machine field in struct function.  */
+
+struct GTY(()) machine_function
+{
+  struct s390_frame_layout frame_layout;
+
+  /* Literal pool base register.  */
+  rtx base_reg;
+
+  /* True if we may need to perform branch splitting.  */
+  bool split_branches_pending_p;
+
+  bool has_landing_pad_p;
+
+  /* True if the current function may contain a tbegin clobbering
+     FPRs.  */
+  bool tbegin_p;
+
+  /* For -fsplit-stack support: A stack local which holds a pointer to
+     the stack arguments for a function with a variable number of
+     arguments.  This is set at the start of the function and is used
+     to initialize the overflow_arg_area field of the va_list
+     structure.  */
+  rtx split_stack_varargs_pointer;
+
+  enum indirect_branch indirect_branch_jump;
+  enum indirect_branch indirect_branch_call;
+
+  enum indirect_branch function_return_mem;
+  enum indirect_branch function_return_reg;
+};
+#endif
+
+#define TARGET_INDIRECT_BRANCH_NOBP_RET_OPTION				\
+  (cfun->machine->function_return_reg != indirect_branch_keep		\
+   || cfun->machine->function_return_mem != indirect_branch_keep)
+
+#define TARGET_INDIRECT_BRANCH_NOBP_RET					\
+  ((cfun->machine->function_return_reg != indirect_branch_keep		\
+    && !s390_return_addr_from_memory ())				\
+   || (cfun->machine->function_return_mem != indirect_branch_keep	\
+       && s390_return_addr_from_memory ()))
+
+#define TARGET_INDIRECT_BRANCH_NOBP_JUMP				\
+  (cfun->machine->indirect_branch_jump != indirect_branch_keep)
+
+#define TARGET_INDIRECT_BRANCH_NOBP_JUMP_THUNK				\
+  (cfun->machine->indirect_branch_jump == indirect_branch_thunk		\
+   || cfun->machine->indirect_branch_jump == indirect_branch_thunk_extern)
+
+#define TARGET_INDIRECT_BRANCH_NOBP_JUMP_INLINE_THUNK			\
+  (cfun->machine->indirect_branch_jump == indirect_branch_thunk_inline)
+
+#define TARGET_INDIRECT_BRANCH_NOBP_CALL			\
+  (cfun->machine->indirect_branch_call != indirect_branch_keep)
+
+#ifndef TARGET_DEFAULT_INDIRECT_BRANCH_TABLE
+#define TARGET_DEFAULT_INDIRECT_BRANCH_TABLE 0
+#endif
+
+#define TARGET_INDIRECT_BRANCH_THUNK_NAME_EXRL "__s390_indirect_jump_r%d"
+#define TARGET_INDIRECT_BRANCH_THUNK_NAME_EX   "__s390_indirect_jump_r%duse_r%d"
+
+#define TARGET_INDIRECT_BRANCH_TABLE s390_indirect_branch_table
+
+
 #endif /* S390_H */
diff --git a/gcc/config/s390/s390.md b/gcc/config/s390/s390.md
index 7b6d09bcb41..bb399354855 100644
--- a/gcc/config/s390/s390.md
+++ b/gcc/config/s390/s390.md
@@ -89,6 +89,7 @@
    UNSPEC_LTREF
    UNSPEC_INSN
    UNSPEC_EXECUTE
+   UNSPEC_EXECUTE_JUMP
 
    ; Atomic Support
    UNSPEC_MB
@@ -302,6 +303,8 @@
   [
    ; Sibling call register.
    (SIBCALL_REGNUM		 1)
+   ; A call-clobbered reg which can be used in indirect branch thunks
+   (INDIRECT_BRANCH_THUNK_REGNUM 1)
    ; Literal pool base register.
    (BASE_REGNUM			13)
    ; Return address register.
@@ -398,6 +401,10 @@
    ; Bitposition of operand types
    (PFPO_OP0_TYPE_SHIFT          16)
    (PFPO_OP1_TYPE_SHIFT           8)
+   ; Decide whether current DFP or BFD rounding mode should be used
+   ; for the conversion.
+   (PFPO_RND_MODE_DFP             0)
+   (PFPO_RND_MODE_BFP             1)
   ])
 
 ; Immediate operands for tbegin and tbeginc
@@ -471,7 +478,10 @@
                          z196_cracked"
              (const_string "none"))
 
-(define_attr "mnemonic" "bcr_flush,unknown" (const_string "unknown"))
+; mnemonics which only get defined through if_then_else currently
+; don't get added to the list values automatically and hence need to
+; be listed here.
+(define_attr "mnemonic" "b,bas,bc,bcr_flush,unknown" (const_string "unknown"))
 
 ;; Length in bytes.
 
@@ -1322,10 +1332,11 @@
 ; (TF|DF|SF|TD|DD|SD) instructions
 
 
-; load and test instructions turn SNaN into QNaN what is not
+; FIXME: load and test instructions turn SNaN into QNaN what is not
 ; acceptable if the target will be used afterwards.  On the other hand
 ; they are quite convenient for implementing comparisons with 0.0. So
-; try to enable them via splitter if the value isn't needed anymore.
+; try to enable them via splitter/peephole if the value isn't needed anymore.
+; See testcases: load-and-test-fp-1.c and load-and-test-fp-2.c
 
 ; ltxbr, ltdbr, ltebr, ltxtr, ltdtr
 (define_insn "*cmp<mode>_ccs_0"
@@ -1338,22 +1349,6 @@
    [(set_attr "op_type" "RRE")
     (set_attr "type"  "fsimp<mode>")])
 
-(define_split
-  [(set (match_operand 0 "cc_reg_operand")
-	(compare (match_operand:FP 1 "register_operand")
-		 (match_operand:FP 2 "const0_operand")))]
-  "TARGET_HARD_FLOAT && REG_P (operands[1]) && dead_or_set_p (insn, operands[1])"
-  [(parallel
-    [(set (match_dup 0) (match_dup 3))
-     (clobber (match_dup 1))])]
- {
-   /* s390_match_ccmode requires the compare to have the same CC mode
-      as the CC destination register.  */
-   operands[3] = gen_rtx_COMPARE (GET_MODE (operands[0]),
-				  operands[1], operands[2]);
- })
-
-
 ; VX: TFmode in FPR pairs: use cxbr instead of wfcxb
 ; cxtr, cdtr, cxbr, cdbr, cebr, cdb, ceb, wfcsb, wfcdb
 (define_insn "*cmp<mode>_ccs"
@@ -5348,9 +5343,13 @@
 {
   HOST_WIDE_INT flags;
 
+  /* According to IEEE 754 2008 4.3 'Rounding-direction attributes' the
+     rounding mode of the target format needs to be used.  */
+
   flags = (PFPO_CONVERT |
            PFPO_OP_TYPE_<DFP_ALL:MODE> << PFPO_OP0_TYPE_SHIFT |
-           PFPO_OP_TYPE_<BFP:MODE> << PFPO_OP1_TYPE_SHIFT);
+           PFPO_OP_TYPE_<BFP:MODE> << PFPO_OP1_TYPE_SHIFT |
+	   PFPO_RND_MODE_DFP);
 
   operands[2] = GEN_INT (flags);
 })
@@ -5370,9 +5369,13 @@
 {
   HOST_WIDE_INT flags;
 
+  /* According to IEEE 754 2008 4.3 'Rounding-direction attributes' the
+     rounding mode of the target format needs to be used.  */
+
   flags = (PFPO_CONVERT |
            PFPO_OP_TYPE_<BFP:MODE> << PFPO_OP0_TYPE_SHIFT |
-           PFPO_OP_TYPE_<DFP_ALL:MODE> << PFPO_OP1_TYPE_SHIFT);
+           PFPO_OP_TYPE_<DFP_ALL:MODE> << PFPO_OP1_TYPE_SHIFT |
+	   PFPO_RND_MODE_BFP);
 
   operands[2] = GEN_INT (flags);
 })
@@ -5413,9 +5416,13 @@
 {
   HOST_WIDE_INT flags;
 
+  /* According to IEEE 754 2008 4.3 'Rounding-direction attributes' the
+     rounding mode of the target format needs to be used.  */
+
   flags = (PFPO_CONVERT |
            PFPO_OP_TYPE_<DFP_ALL:MODE> << PFPO_OP0_TYPE_SHIFT |
-           PFPO_OP_TYPE_<BFP:MODE> << PFPO_OP1_TYPE_SHIFT);
+           PFPO_OP_TYPE_<BFP:MODE> << PFPO_OP1_TYPE_SHIFT |
+	   PFPO_RND_MODE_DFP);
 
   operands[2] = GEN_INT (flags);
 })
@@ -5435,9 +5442,13 @@
 {
   HOST_WIDE_INT flags;
 
+  /* According to IEEE 754 2008 4.3 'Rounding-direction attributes' the
+     rounding mode of the target format needs to be used.  */
+
   flags = (PFPO_CONVERT |
            PFPO_OP_TYPE_<BFP:MODE> << PFPO_OP0_TYPE_SHIFT |
-           PFPO_OP_TYPE_<DFP_ALL:MODE> << PFPO_OP1_TYPE_SHIFT);
+           PFPO_OP_TYPE_<DFP_ALL:MODE> << PFPO_OP1_TYPE_SHIFT |
+	   PFPO_RND_MODE_BFP);
 
   operands[2] = GEN_INT (flags);
 })
@@ -8845,17 +8856,17 @@
   DONE;
 })
 
+; CLZ result is in hard reg op0 - this is the high part of the target operand
+; The source with the left-most one bit cleared is in hard reg op0 + 1 - the low part
 (define_insn "clztidi2"
   [(set (match_operand:TI 0 "register_operand" "=d")
 	(ior:TI
-	  (ashift:TI
-            (zero_extend:TI
-   	      (xor:DI (match_operand:DI 1 "register_operand" "d")
-                      (lshiftrt (match_operand:DI 2 "const_int_operand" "")
-				(subreg:SI (clz:DI (match_dup 1)) 4))))
-
-	    (const_int 64))
-          (zero_extend:TI (clz:DI (match_dup 1)))))
+	  (ashift:TI (zero_extend:TI (clz:DI (match_operand:DI 1 "register_operand" "d")))
+		     (const_int 64))
+	  (zero_extend:TI
+	   (xor:DI (match_dup 1)
+		   (lshiftrt (match_operand:DI 2 "const_int_operand" "")
+			     (subreg:SI (clz:DI (match_dup 1)) 4))))))
    (clobber (reg:CC CC_REGNUM))]
   "UINTVAL (operands[2]) == HOST_WIDE_INT_1U << 63
    && TARGET_EXTIMM && TARGET_ZARCH"
@@ -9069,7 +9080,7 @@
           (match_operator 1 "s390_comparison" [(reg CC_REGNUM) (const_int 0)])
           (match_operand 0 "address_operand" "ZQZR")
           (pc)))]
-  ""
+  "!TARGET_INDIRECT_BRANCH_NOBP_JUMP"
 {
   if (get_attr_op_type (insn) == OP_TYPE_RR)
     return "b%C1r\t%0";
@@ -9079,6 +9090,9 @@
   [(set (attr "op_type")
         (if_then_else (match_operand 0 "register_operand" "")
                       (const_string "RR") (const_string "RX")))
+   (set (attr "mnemonic")
+        (if_then_else (match_operand 0 "register_operand" "")
+                      (const_string "bcr") (const_string "bc")))
    (set_attr "type"  "branch")
    (set_attr "atype" "agen")])
 
@@ -9090,8 +9104,26 @@
           (ANY_RETURN)
           (pc)))]
   "s390_can_use_<code>_insn ()"
-  "b%C0r\t%%r14"
-  [(set_attr "op_type" "RR")
+{
+  if (TARGET_INDIRECT_BRANCH_NOBP_RET)
+    {
+      s390_indirect_branch_via_thunk (RETURN_REGNUM,
+				      INVALID_REGNUM,
+				      operands[0],
+				      s390_indirect_branch_type_return);
+      return "";
+    }
+  else
+    return "b%C0r\t%%r14";
+}
+  [(set (attr "op_type")
+	(if_then_else (match_test "TARGET_INDIRECT_BRANCH_NOBP_RET")
+		      (const_string "RIL")
+		      (const_string "RR")))
+   (set (attr "mnemonic")
+	(if_then_else (match_test "TARGET_INDIRECT_BRANCH_NOBP_RET")
+		      (const_string "brcl")
+		      (const_string "bcr")))
    (set_attr "type"  "jsr")
    (set_attr "atype" "agen")])
 
@@ -9144,7 +9176,7 @@
           (match_operator 1 "s390_comparison" [(reg CC_REGNUM) (const_int 0)])
           (pc)
           (match_operand 0 "address_operand" "ZQZR")))]
-  ""
+  "!TARGET_INDIRECT_BRANCH_NOBP_JUMP"
 {
   if (get_attr_op_type (insn) == OP_TYPE_RR)
     return "b%D1r\t%0";
@@ -9154,6 +9186,9 @@
   [(set (attr "op_type")
         (if_then_else (match_operand 0 "register_operand" "")
                       (const_string "RR") (const_string "RX")))
+   (set (attr "mnemonic")
+        (if_then_else (match_operand 0 "register_operand" "")
+                      (const_string "bcr") (const_string "bc")))
    (set_attr "type"  "branch")
    (set_attr "atype" "agen")])
 
@@ -9658,21 +9693,144 @@
     ;
   else
     operands[0] = force_reg (Pmode, operands[0]);
+
+  if (TARGET_INDIRECT_BRANCH_NOBP_JUMP_THUNK)
+    {
+      operands[0] = force_reg (Pmode, operands[0]);
+      if (TARGET_CPU_Z10)
+	{
+	  if (TARGET_64BIT)
+	    emit_jump_insn (gen_indirect_jump_via_thunkdi_z10 (operands[0]));
+	  else
+	    emit_jump_insn (gen_indirect_jump_via_thunksi_z10 (operands[0]));
+	}
+      else
+	{
+	  if (TARGET_64BIT)
+	    emit_jump_insn (gen_indirect_jump_via_thunkdi (operands[0]));
+	  else
+	    emit_jump_insn (gen_indirect_jump_via_thunksi (operands[0]));
+	}
+      DONE;
+    }
+
+  if (TARGET_INDIRECT_BRANCH_NOBP_JUMP_INLINE_THUNK)
+    {
+      operands[0] = force_reg (Pmode, operands[0]);
+      rtx label_ref = gen_rtx_LABEL_REF (VOIDmode, gen_label_rtx ());
+      if (TARGET_CPU_Z10)
+	{
+	  if (TARGET_64BIT)
+	    emit_jump_insn (gen_indirect_jump_via_inlinethunkdi_z10 (operands[0],
+								     label_ref));
+	  else
+	    emit_jump_insn (gen_indirect_jump_via_inlinethunksi_z10 (operands[0],
+								     label_ref));
+	}
+      else
+	{
+	  if (TARGET_64BIT)
+	    emit_jump_insn (gen_indirect_jump_via_inlinethunkdi (operands[0],
+								 label_ref,
+								 force_reg (Pmode, label_ref)));
+	  else
+	    emit_jump_insn (gen_indirect_jump_via_inlinethunksi (operands[0],
+								 label_ref,
+								 force_reg (Pmode, label_ref)));
+	}
+      DONE;
+    }
 })
 
-; The first constraint must be an "extra address constraint" in order
-; to trigger address reloading in LRA/reload
 (define_insn "*indirect_jump"
   [(set (pc)
-	(match_operand 0 "address_operand" "ZR,a"))]
- ""
- "@
-  b\t%a0
-  br\t%0"
- [(set_attr "op_type" "RX,RR")
+	(match_operand 0 "address_operand" "ZR"))]
+ "!TARGET_INDIRECT_BRANCH_NOBP_JUMP_THUNK"
+{
+  if (get_attr_op_type (insn) == OP_TYPE_RR)
+    return "br\t%0";
+  else
+    return "b\t%a0";
+}
+ [(set (attr "op_type")
+       (if_then_else (match_operand 0 "register_operand" "")
+		     (const_string "RR") (const_string "RX")))
+  (set (attr "mnemonic")
+       (if_then_else (match_operand 0 "register_operand" "")
+		     (const_string "br") (const_string "b")))
   (set_attr "type"  "branch")
-  (set_attr "atype" "agen")
-  (set_attr "cpu_facility" "*")])
+  (set_attr "atype" "agen")])
+
+(define_insn "indirect_jump_via_thunk<mode>_z10"
+  [(set (pc)
+	(match_operand:P 0 "register_operand" "a"))]
+ "TARGET_INDIRECT_BRANCH_NOBP_JUMP_THUNK
+  && TARGET_CPU_Z10"
+{
+  s390_indirect_branch_via_thunk (REGNO (operands[0]),
+				  INVALID_REGNUM,
+				  NULL_RTX,
+				  s390_indirect_branch_type_jump);
+  return "";
+}
+ [(set_attr "op_type"  "RIL")
+  (set_attr "mnemonic" "jg")
+  (set_attr "type"  "branch")
+  (set_attr "atype" "agen")])
+
+(define_insn "indirect_jump_via_thunk<mode>"
+  [(set (pc)
+	(match_operand:P 0 "register_operand" " a"))
+   (clobber (reg:P INDIRECT_BRANCH_THUNK_REGNUM))]
+ "TARGET_INDIRECT_BRANCH_NOBP_JUMP_THUNK
+  && !TARGET_CPU_Z10"
+{
+  s390_indirect_branch_via_thunk (REGNO (operands[0]),
+				  INVALID_REGNUM,
+				  NULL_RTX,
+				  s390_indirect_branch_type_jump);
+  return "";
+}
+ [(set_attr "op_type"  "RIL")
+  (set_attr "mnemonic" "jg")
+  (set_attr "type"  "branch")
+  (set_attr "atype" "agen")])
+
+
+; The label_ref is wrapped into an if_then_else in order to hide it
+; from mark_jump_label.  Without this the label_ref would become the
+; ONLY jump target of that jump breaking the control flow graph.
+(define_insn "indirect_jump_via_inlinethunk<mode>_z10"
+  [(unspec [(if_then_else (match_operand:P 1 "larl_operand" "X")
+			  (const_int 0)
+			  (const_int 0))
+	    (const_int 0)] UNSPEC_EXECUTE_JUMP)
+   (set (pc) (match_operand:P 0 "register_operand" "a"))]
+  "TARGET_INDIRECT_BRANCH_NOBP_JUMP_INLINE_THUNK
+   && TARGET_CPU_Z10"
+{
+  s390_indirect_branch_via_inline_thunk (operands[1]);
+  return "";
+}
+  [(set_attr "op_type" "RIL")
+   (set_attr "type"    "branch")
+   (set_attr "length"  "10")])
+
+(define_insn "indirect_jump_via_inlinethunk<mode>"
+  [(unspec [(if_then_else (match_operand:P 1 "larl_operand" "X")
+			  (const_int 0)
+			  (const_int 0))
+	    (match_operand:P 2 "register_operand" "a")] UNSPEC_EXECUTE_JUMP)
+   (set (pc) (match_operand:P 0 "register_operand" "a"))]
+  "TARGET_INDIRECT_BRANCH_NOBP_JUMP_INLINE_THUNK
+   && !TARGET_CPU_Z10"
+{
+  s390_indirect_branch_via_inline_thunk (operands[2]);
+  return "";
+}
+  [(set_attr "op_type" "RX")
+   (set_attr "type"    "branch")
+   (set_attr "length"  "8")])
 
 ; FIXME: LRA does not appear to be able to deal with MEMs being
 ; checked against address constraints like ZR above.  So make this a
@@ -9680,7 +9838,7 @@
 (define_insn "*indirect2_jump"
   [(set (pc)
 	(match_operand 0 "nonimmediate_operand" "a,T"))]
- ""
+ "!TARGET_INDIRECT_BRANCH_NOBP_JUMP"
  "@
   br\t%0
   bi\t%0"
@@ -9693,10 +9851,73 @@
 ; casesi instruction pattern(s).
 ;
 
-(define_insn "casesi_jump"
- [(set (pc) (match_operand 0 "address_operand" "ZR"))
-   (use (label_ref (match_operand 1 "" "")))]
+(define_expand "casesi_jump"
+  [(parallel
+    [(set (pc) (match_operand 0 "address_operand"))
+     (use (label_ref (match_operand 1 "")))])]
   ""
+{
+  if (TARGET_INDIRECT_BRANCH_NOBP_JUMP_THUNK)
+    {
+      operands[0] = force_reg (GET_MODE (operands[0]), operands[0]);
+
+      if (TARGET_CPU_Z10)
+	{
+	  if (TARGET_64BIT)
+	    emit_jump_insn (gen_casesi_jump_via_thunkdi_z10 (operands[0],
+							     operands[1]));
+	  else
+	    emit_jump_insn (gen_casesi_jump_via_thunksi_z10 (operands[0],
+							     operands[1]));
+	}
+      else
+	{
+	  if (TARGET_64BIT)
+	    emit_jump_insn (gen_casesi_jump_via_thunkdi (operands[0],
+							 operands[1]));
+	  else
+	    emit_jump_insn (gen_casesi_jump_via_thunksi (operands[0],
+							 operands[1]));
+	}
+      DONE;
+    }
+
+    if (TARGET_INDIRECT_BRANCH_NOBP_JUMP_INLINE_THUNK)
+    {
+      operands[0] = force_reg (Pmode, operands[0]);
+      rtx label_ref = gen_rtx_LABEL_REF (VOIDmode, gen_label_rtx ());
+      if (TARGET_CPU_Z10)
+	{
+	  if (TARGET_64BIT)
+	    emit_jump_insn (gen_casesi_jump_via_inlinethunkdi_z10 (operands[0],
+								   operands[1],
+								   label_ref));
+	  else
+	    emit_jump_insn (gen_casesi_jump_via_inlinethunksi_z10 (operands[0],
+								   operands[1],
+								   label_ref));
+	}
+      else
+	{
+	  if (TARGET_64BIT)
+	    emit_jump_insn (gen_casesi_jump_via_inlinethunkdi (operands[0],
+							       operands[1],
+							       label_ref,
+							       force_reg (Pmode, label_ref)));
+	  else
+	    emit_jump_insn (gen_casesi_jump_via_inlinethunksi (operands[0],
+							       operands[1],
+							       label_ref,
+							       force_reg (Pmode, label_ref)));
+	}
+      DONE;
+    }
+})
+
+(define_insn "*casesi_jump"
+ [(set (pc) (match_operand 0 "address_operand" "ZR"))
+  (use (label_ref (match_operand 1 "" "")))]
+ "!TARGET_INDIRECT_BRANCH_NOBP_JUMP_THUNK"
 {
   if (get_attr_op_type (insn) == OP_TYPE_RR)
     return "br\t%0";
@@ -9706,9 +9927,85 @@
   [(set (attr "op_type")
         (if_then_else (match_operand 0 "register_operand" "")
                       (const_string "RR") (const_string "RX")))
+   (set (attr "mnemonic")
+        (if_then_else (match_operand 0 "register_operand" "")
+                      (const_string "br") (const_string "b")))
    (set_attr "type"  "branch")
    (set_attr "atype" "agen")])
 
+(define_insn "casesi_jump_via_thunk<mode>_z10"
+ [(set (pc) (match_operand:P 0 "register_operand" "a"))
+  (use (label_ref (match_operand 1 "" "")))]
+ "TARGET_INDIRECT_BRANCH_NOBP_JUMP_THUNK
+  && TARGET_CPU_Z10"
+{
+  s390_indirect_branch_via_thunk (REGNO (operands[0]),
+				  INVALID_REGNUM,
+				  NULL_RTX,
+				  s390_indirect_branch_type_jump);
+  return "";
+}
+  [(set_attr "op_type" "RIL")
+   (set_attr "mnemonic" "jg")
+   (set_attr "type"  "branch")
+   (set_attr "atype" "agen")])
+
+(define_insn "casesi_jump_via_thunk<mode>"
+ [(set (pc) (match_operand:P 0 "register_operand" "a"))
+  (use (label_ref (match_operand 1 "" "")))
+  (clobber (reg:P INDIRECT_BRANCH_THUNK_REGNUM))]
+ "TARGET_INDIRECT_BRANCH_NOBP_JUMP_THUNK
+  && !TARGET_CPU_Z10"
+{
+  s390_indirect_branch_via_thunk (REGNO (operands[0]),
+				  INVALID_REGNUM,
+				  NULL_RTX,
+				  s390_indirect_branch_type_jump);
+  return "";
+}
+  [(set_attr "op_type" "RIL")
+   (set_attr "mnemonic" "jg")
+   (set_attr "type"  "branch")
+   (set_attr "atype" "agen")])
+
+
+; The label_ref is wrapped into an if_then_else in order to hide it
+; from mark_jump_label.  Without this the label_ref would become the
+; ONLY jump target of that jump breaking the control flow graph.
+(define_insn "casesi_jump_via_inlinethunk<mode>_z10"
+  [(unspec [(if_then_else (match_operand:P 2 "larl_operand" "X")
+			  (const_int 0)
+			  (const_int 0))
+	    (const_int 0)] UNSPEC_EXECUTE_JUMP)
+   (set (pc) (match_operand:P 0 "register_operand" "a"))
+   (use (label_ref (match_operand 1 "" "")))]
+  "TARGET_INDIRECT_BRANCH_NOBP_JUMP_INLINE_THUNK
+   && TARGET_CPU_Z10"
+{
+  s390_indirect_branch_via_inline_thunk (operands[2]);
+  return "";
+}
+  [(set_attr "op_type" "RIL")
+   (set_attr "type"    "cs")
+   (set_attr "length"  "10")])
+
+(define_insn "casesi_jump_via_inlinethunk<mode>"
+  [(unspec [(if_then_else (match_operand:P 2 "larl_operand" "X")
+			  (const_int 0)
+			  (const_int 0))
+	    (match_operand:P 3 "register_operand" "a")] UNSPEC_EXECUTE_JUMP)
+   (set (pc) (match_operand:P 0 "register_operand" "a"))
+   (use (label_ref (match_operand 1 "" "")))]
+  "TARGET_INDIRECT_BRANCH_NOBP_JUMP_INLINE_THUNK
+   && !TARGET_CPU_Z10"
+{
+  s390_indirect_branch_via_inline_thunk (operands[3]);
+  return "";
+}
+  [(set_attr "op_type" "RX")
+   (set_attr "type"    "cs")
+   (set_attr "length"  "8")])
+
 (define_expand "casesi"
   [(match_operand:SI 0 "general_operand" "")
    (match_operand:SI 1 "general_operand" "")
@@ -9813,8 +10110,27 @@
          (match_operand 0 "const_int_operand" "n"))]
   "SIBLING_CALL_P (insn)
    && GET_MODE (XEXP (XEXP (PATTERN (insn), 0), 0)) == Pmode"
-  "br\t%%r1"
-  [(set_attr "op_type" "RR")
+{
+  if (TARGET_INDIRECT_BRANCH_NOBP_CALL)
+    {
+      gcc_assert (TARGET_CPU_Z10);
+      s390_indirect_branch_via_thunk (SIBCALL_REGNUM,
+				      INVALID_REGNUM,
+				      NULL_RTX,
+				      s390_indirect_branch_type_call);
+      return "";
+    }
+  else
+    return "br\t%%r1";
+}
+ [(set (attr "op_type")
+       (if_then_else (match_test "TARGET_INDIRECT_BRANCH_NOBP_CALL")
+		     (const_string "RIL")
+		     (const_string "RR")))
+  (set (attr "mnemonic")
+       (if_then_else (match_test "TARGET_INDIRECT_BRANCH_NOBP_CALL")
+		     (const_string "jg")
+		     (const_string "br")))
    (set_attr "type"  "branch")
    (set_attr "atype" "agen")])
 
@@ -9854,8 +10170,27 @@
 	      (match_operand 1 "const_int_operand" "n")))]
   "SIBLING_CALL_P (insn)
    && GET_MODE (XEXP (XEXP (XEXP (PATTERN (insn), 1), 0), 0)) == Pmode"
-  "br\t%%r1"
-  [(set_attr "op_type" "RR")
+{
+  if (TARGET_INDIRECT_BRANCH_NOBP_CALL)
+    {
+      gcc_assert (TARGET_CPU_Z10);
+      s390_indirect_branch_via_thunk (SIBCALL_REGNUM,
+				      INVALID_REGNUM,
+				      NULL_RTX,
+				      s390_indirect_branch_type_call);
+      return "";
+    }
+  else
+    return "br\t%%r1";
+}
+  [(set (attr "op_type")
+       (if_then_else (match_test "TARGET_INDIRECT_BRANCH_NOBP_CALL")
+		     (const_string "RIL")
+		     (const_string "RR")))
+   (set (attr "mnemonic")
+       (if_then_else (match_test "TARGET_INDIRECT_BRANCH_NOBP_CALL")
+		     (const_string "jg")
+		     (const_string "br")))
    (set_attr "type"  "branch")
    (set_attr "atype" "agen")])
 
@@ -9921,7 +10256,9 @@
   [(call (mem:QI (match_operand 0 "address_operand" "ZR"))
          (match_operand 1 "const_int_operand" "n"))
    (clobber (match_operand 2 "register_operand" "=r"))]
-  "!SIBLING_CALL_P (insn) && GET_MODE (operands[2]) == Pmode"
+  "!TARGET_INDIRECT_BRANCH_NOBP_CALL
+   && !SIBLING_CALL_P (insn)
+   && GET_MODE (operands[2]) == Pmode"
 {
   if (get_attr_op_type (insn) == OP_TYPE_RR)
     return "basr\t%2,%0";
@@ -9931,6 +10268,50 @@
   [(set (attr "op_type")
         (if_then_else (match_operand 0 "register_operand" "")
                       (const_string "RR") (const_string "RX")))
+   (set (attr "mnemonic")
+        (if_then_else (match_operand 0 "register_operand" "")
+                      (const_string "basr") (const_string "bas")))
+   (set_attr "type"  "jsr")
+   (set_attr "atype" "agen")
+   (set_attr "z196prop" "z196_cracked")])
+
+(define_insn "*basr_via_thunk<mode>_z10"
+  [(call (mem:QI (match_operand:P 0 "register_operand" "a"))
+         (match_operand 1 "const_int_operand"          "n"))
+   (clobber (match_operand:P 2 "register_operand"    "=&r"))]
+  "TARGET_INDIRECT_BRANCH_NOBP_CALL
+   && TARGET_CPU_Z10
+   && !SIBLING_CALL_P (insn)"
+{
+  s390_indirect_branch_via_thunk (REGNO (operands[0]),
+				  REGNO (operands[2]),
+				  NULL_RTX,
+				  s390_indirect_branch_type_call);
+  return "";
+}
+  [(set_attr "op_type" "RIL")
+   (set_attr "mnemonic" "brasl")
+   (set_attr "type"  "jsr")
+   (set_attr "atype" "agen")
+   (set_attr "z196prop" "z196_cracked")])
+
+(define_insn "*basr_via_thunk<mode>"
+  [(call (mem:QI (match_operand:P 0 "register_operand" "a"))
+         (match_operand 1 "const_int_operand"          "n"))
+   (clobber (match_operand:P 2 "register_operand"    "=&r"))
+   (clobber (reg:P INDIRECT_BRANCH_THUNK_REGNUM))]
+  "TARGET_INDIRECT_BRANCH_NOBP_CALL
+   && !TARGET_CPU_Z10
+   && !SIBLING_CALL_P (insn)"
+{
+  s390_indirect_branch_via_thunk (REGNO (operands[0]),
+				  REGNO (operands[2]),
+				  NULL_RTX,
+				  s390_indirect_branch_type_call);
+  return "";
+}
+  [(set_attr "op_type" "RIL")
+   (set_attr "mnemonic" "brasl")
    (set_attr "type"  "jsr")
    (set_attr "atype" "agen")
    (set_attr "z196prop" "z196_cracked")])
@@ -9982,7 +10363,9 @@
         (call (mem:QI (match_operand 1 "address_operand" "ZR"))
               (match_operand 2 "const_int_operand" "n")))
    (clobber (match_operand 3 "register_operand" "=r"))]
-  "!SIBLING_CALL_P (insn) && GET_MODE (operands[3]) == Pmode"
+  "!TARGET_INDIRECT_BRANCH_NOBP_CALL
+   && !SIBLING_CALL_P (insn)
+   && GET_MODE (operands[3]) == Pmode"
 {
   if (get_attr_op_type (insn) == OP_TYPE_RR)
     return "basr\t%3,%1";
@@ -9992,6 +10375,54 @@
   [(set (attr "op_type")
         (if_then_else (match_operand 1 "register_operand" "")
                       (const_string "RR") (const_string "RX")))
+   (set (attr "mnemonic")
+        (if_then_else (match_operand 1 "register_operand" "")
+                      (const_string "basr") (const_string "bas")))
+   (set_attr "type"  "jsr")
+   (set_attr "atype" "agen")
+   (set_attr "z196prop" "z196_cracked")])
+
+(define_insn "*basr_r_via_thunk_z10"
+  [(set (match_operand 0 "" "")
+        (call (mem:QI (match_operand 1 "register_operand" "a"))
+              (match_operand 2 "const_int_operand"        "n")))
+   (clobber (match_operand 3 "register_operand"         "=&r"))]
+  "TARGET_INDIRECT_BRANCH_NOBP_CALL
+   && TARGET_CPU_Z10
+   && !SIBLING_CALL_P (insn)
+   && GET_MODE (operands[3]) == Pmode"
+{
+  s390_indirect_branch_via_thunk (REGNO (operands[1]),
+				  REGNO (operands[3]),
+				  NULL_RTX,
+				  s390_indirect_branch_type_call);
+  return "";
+}
+  [(set_attr "op_type" "RIL")
+   (set_attr "mnemonic" "brasl")
+   (set_attr "type"  "jsr")
+   (set_attr "atype" "agen")
+   (set_attr "z196prop" "z196_cracked")])
+
+(define_insn "*basr_r_via_thunk"
+  [(set (match_operand 0 "" "")
+        (call (mem:QI (match_operand 1 "register_operand" "a"))
+              (match_operand 2 "const_int_operand"        "n")))
+   (clobber (match_operand 3 "register_operand"         "=&r"))
+   (clobber (reg:P INDIRECT_BRANCH_THUNK_REGNUM))]
+  "TARGET_INDIRECT_BRANCH_NOBP_CALL
+   && !TARGET_CPU_Z10
+   && !SIBLING_CALL_P (insn)
+   && GET_MODE (operands[3]) == Pmode"
+{
+  s390_indirect_branch_via_thunk (REGNO (operands[1]),
+				  REGNO (operands[3]),
+				  NULL_RTX,
+				  s390_indirect_branch_type_call);
+  return "";
+}
+  [(set_attr "op_type" "RIL")
+   (set_attr "mnemonic"  "brasl")
    (set_attr "type"  "jsr")
    (set_attr "atype" "agen")
    (set_attr "z196prop" "z196_cracked")])
@@ -10737,17 +11168,101 @@
 (define_insn "<code>"
   [(ANY_RETURN)]
   "s390_can_use_<code>_insn ()"
-  "br\t%%r14"
-  [(set_attr "op_type" "RR")
+{
+  if (TARGET_INDIRECT_BRANCH_NOBP_RET)
+    {
+      /* The target is always r14 so there is no clobber
+	 of r1 needed for pre z10 targets.  */
+      s390_indirect_branch_via_thunk (RETURN_REGNUM,
+				      INVALID_REGNUM,
+				      NULL_RTX,
+				      s390_indirect_branch_type_return);
+      return "";
+    }
+  else
+    return "br\t%%r14";
+}
+  [(set (attr "op_type")
+	(if_then_else (match_test "TARGET_INDIRECT_BRANCH_NOBP_RET")
+		      (const_string "RIL")
+		      (const_string "RR")))
+   (set (attr "mnemonic")
+	(if_then_else (match_test "TARGET_INDIRECT_BRANCH_NOBP_RET")
+		      (const_string "jg")
+		      (const_string "br")))
+   (set_attr "type"    "jsr")
+   (set_attr "atype"   "agen")])
+
+
+(define_expand "return_use"
+  [(parallel
+    [(return)
+     (use (match_operand 0 "register_operand" "a"))])]
+  ""
+{
+  if (!TARGET_CPU_Z10
+      && TARGET_INDIRECT_BRANCH_NOBP_RET_OPTION)
+    {
+      if (TARGET_64BIT)
+        emit_jump_insn (gen_returndi_prez10 (operands[0]));
+      else
+        emit_jump_insn (gen_returnsi_prez10 (operands[0]));
+      DONE;
+    }
+})
+
+(define_insn "*return<mode>"
+  [(return)
+   (use (match_operand:P 0 "register_operand" "a"))]
+  "TARGET_CPU_Z10 || !TARGET_INDIRECT_BRANCH_NOBP_RET_OPTION"
+{
+  if (TARGET_INDIRECT_BRANCH_NOBP_RET)
+    {
+      s390_indirect_branch_via_thunk (REGNO (operands[0]),
+                                      INVALID_REGNUM,
+                                      NULL_RTX,
+                                      s390_indirect_branch_type_return);
+      return "";
+    }
+  else
+    return "br\t%0";
+}
+  [(set (attr "op_type")
+       (if_then_else (match_test "TARGET_INDIRECT_BRANCH_NOBP_RET")
+                     (const_string "RIL")
+                     (const_string "RR")))
+   (set (attr "mnemonic")
+       (if_then_else (match_test "TARGET_INDIRECT_BRANCH_NOBP_RET")
+                     (const_string "jg")
+                     (const_string "br")))
    (set_attr "type"    "jsr")
    (set_attr "atype"   "agen")])
 
-(define_insn "*return"
+(define_insn "return<mode>_prez10"
   [(return)
-   (use (match_operand 0 "register_operand" "a"))]
-  "GET_MODE (operands[0]) == Pmode"
-  "br\t%0"
-  [(set_attr "op_type" "RR")
+   (use (match_operand:P 0 "register_operand" "a"))
+   (clobber (reg:P INDIRECT_BRANCH_THUNK_REGNUM))]
+  "!TARGET_CPU_Z10 && TARGET_INDIRECT_BRANCH_NOBP_RET_OPTION"
+{
+  if (TARGET_INDIRECT_BRANCH_NOBP_RET)
+    {
+      s390_indirect_branch_via_thunk (REGNO (operands[0]),
+                                      INVALID_REGNUM,
+                                      NULL_RTX,
+                                      s390_indirect_branch_type_return);
+      return "";
+    }
+  else
+    return "br\t%0";
+}
+  [(set (attr "op_type")
+       (if_then_else (match_test "TARGET_INDIRECT_BRANCH_NOBP_RET")
+                     (const_string "RIL")
+                     (const_string "RR")))
+   (set (attr "mnemonic")
+       (if_then_else (match_test "TARGET_INDIRECT_BRANCH_NOBP_RET")
+                     (const_string "jg")
+                     (const_string "br")))
    (set_attr "type"    "jsr")
    (set_attr "atype"   "agen")])
 
diff --git a/gcc/config/s390/s390.opt b/gcc/config/s390/s390.opt
index 28ba631e259..85d09855280 100644
--- a/gcc/config/s390/s390.opt
+++ b/gcc/config/s390/s390.opt
@@ -229,3 +229,62 @@ values are small, non-negative integers.  The default branch cost is
 mlra
 Target Report Var(s390_lra_flag) Init(1) Save
 Use LRA instead of reload.
+
+mindirect-branch=
+Target Report RejectNegative Joined Enum(indirect_branch) Var(s390_indirect_branch) Init(indirect_branch_keep)
+Wrap all indirect branches into execute in order to disable branch
+prediction.
+
+mindirect-branch-jump=
+Target Report RejectNegative Joined Enum(indirect_branch) Var(s390_indirect_branch_jump) Init(indirect_branch_keep)
+Wrap indirect table jumps and computed gotos into execute in order to
+disable branch prediction.  Using thunk or thunk-extern with this
+option requires the thunks to be considered signal handlers to order to
+generate correct CFI.  For environments where unwinding (e.g. for
+exceptions) is required please use thunk-inline instead.
+
+mindirect-branch-call=
+Target Report RejectNegative Joined Enum(indirect_branch) Var(s390_indirect_branch_call) Init(indirect_branch_keep)
+Wrap all indirect calls into execute in order to disable branch prediction.
+
+mfunction-return=
+Target Report RejectNegative Joined Enum(indirect_branch) Var(s390_function_return) Init(indirect_branch_keep)
+Wrap all indirect return branches into execute in order to disable branch
+prediction.
+
+mfunction-return-mem=
+Target Report RejectNegative Joined Enum(indirect_branch) Var(s390_function_return_mem) Init(indirect_branch_keep)
+Wrap indirect return branches into execute in order to disable branch
+prediction. This affects only branches where the return address is
+going to be restored from memory.
+
+mfunction-return-reg=
+Target Report RejectNegative Joined Enum(indirect_branch) Var(s390_function_return_reg) Init(indirect_branch_keep)
+Wrap indirect return branches into execute in order to disable branch
+prediction. This affects only branches where the return address
+doesn't need to be restored from memory.
+
+Enum
+Name(indirect_branch) Type(enum indirect_branch)
+Known indirect branch choices (for use with the -mindirect-branch=/-mfunction-return= options):
+
+EnumValue
+Enum(indirect_branch) String(keep) Value(indirect_branch_keep)
+
+EnumValue
+Enum(indirect_branch) String(thunk) Value(indirect_branch_thunk)
+
+EnumValue
+Enum(indirect_branch) String(thunk-inline) Value(indirect_branch_thunk_inline)
+
+EnumValue
+Enum(indirect_branch) String(thunk-extern) Value(indirect_branch_thunk_extern)
+
+mindirect-branch-table
+Target Report Var(s390_indirect_branch_table) Init(TARGET_DEFAULT_INDIRECT_BRANCH_TABLE)
+Generate sections .s390_indirect_jump, .s390_indirect_call,
+.s390_return_reg, and .s390_return_mem to contain the indirect branch
+locations which have been patched as part of using one of the
+-mindirect-branch* or -mfunction-return* options.  The sections
+consist of an array of 32 bit elements. Each entry holds the offset
+from the entry to the patched location.
diff --git a/gcc/config/s390/vx-builtins.md b/gcc/config/s390/vx-builtins.md
index cf79c7bc859..e526659a85f 100644
--- a/gcc/config/s390/vx-builtins.md
+++ b/gcc/config/s390/vx-builtins.md
@@ -1607,7 +1607,7 @@
 (define_expand "vec_ctd_s64"
   [(set (match_operand:V2DF               0 "register_operand" "")
 	(unspec:V2DF [(match_operand:V2DI 1 "register_operand" "")
-		      (const_int 4) ; inexact suppressed
+		      (const_int VEC_NOINEXACT)
 		      (const_int VEC_RND_CURRENT)]
 		     UNSPEC_VEC_VCDGB))
    (use (match_operand:QI 2 "const_int_operand" ""))
@@ -1638,7 +1638,7 @@
 (define_expand "vec_ctd_u64"
   [(set (match_operand:V2DF               0 "register_operand" "")
 	(unspec:V2DF [(match_operand:V2DI 1 "register_operand" "")
-		      (const_int 4) ; inexact suppressed
+		      (const_int VEC_NOINEXACT)
 		      (const_int VEC_RND_CURRENT)]
 		     UNSPEC_VEC_VCDLGB))
    (use (match_operand:QI 2 "const_int_operand" ""))
@@ -1672,7 +1672,7 @@
 				 (match_dup 3)))
    (set (match_operand:V2DI 0 "register_operand" "")
 	(unspec:V2DI [(match_dup 4)
-		      (const_int 4) ; inexact suppressed
+		      (const_int VEC_NOINEXACT)
 		      (const_int VEC_RND_CURRENT)]
 		     UNSPEC_VEC_VCGDB))]
   "TARGET_VX"
@@ -1705,7 +1705,7 @@
 				 (match_dup 3)))
    (set (match_operand:V2DI 0 "register_operand" "")
 	(unspec:V2DI [(match_dup 4)
-		      (const_int 4) ; inexact suppressed
+		      (const_int VEC_NOINEXACT)
 		      (const_int VEC_RND_CURRENT)]
 		     UNSPEC_VEC_VCLGDB))]
   "TARGET_VX"
@@ -2026,7 +2026,7 @@
 (define_expand "vec_double_s64"
   [(set (match_operand:V2DF               0 "register_operand")
 	(unspec:V2DF [(match_operand:V2DI 1 "register_operand")
-		      (const_int 0)  ; inexact suppression disabled
+		      (const_int VEC_INEXACT)
 		      (const_int VEC_RND_CURRENT)]
 		     UNSPEC_VEC_VCDGB))]
   "TARGET_VX")
@@ -2034,7 +2034,7 @@
 (define_expand "vec_double_u64"
   [(set (match_operand:V2DF               0 "register_operand")
 	(unspec:V2DF [(match_operand:V2DI 1 "register_operand")
-		      (const_int 0)  ; inexact suppression disabled
+		      (const_int VEC_INEXACT)
 		      (const_int VEC_RND_CURRENT)]
 		     UNSPEC_VEC_VCDLGB))]
   "TARGET_VX")
diff --git a/gcc/config/sparc/sparc.c b/gcc/config/sparc/sparc.c
index b9c8dcc57c1..b2d82efbe7b 100644
--- a/gcc/config/sparc/sparc.c
+++ b/gcc/config/sparc/sparc.c
@@ -2188,7 +2188,7 @@ sparc_expand_move (machine_mode mode, rtx *operands)
 	}
     }
 
-  /* Fixup TLS cases.  */
+  /* Fix up TLS cases.  */
   if (TARGET_HAVE_TLS
       && CONSTANT_P (operands[1])
       && sparc_tls_referenced_p (operands [1]))
@@ -2197,15 +2197,20 @@ sparc_expand_move (machine_mode mode, rtx *operands)
       return false;
     }
 
-  /* Fixup PIC cases.  */
+  /* Fix up PIC cases.  */
   if (flag_pic && CONSTANT_P (operands[1]))
     {
       if (pic_address_needs_scratch (operands[1]))
 	operands[1] = sparc_legitimize_pic_address (operands[1], NULL_RTX);
 
       /* We cannot use the mov{si,di}_pic_label_ref patterns in all cases.  */
-      if (GET_CODE (operands[1]) == LABEL_REF
-	  && can_use_mov_pic_label_ref (operands[1]))
+      if ((GET_CODE (operands[1]) == LABEL_REF
+	   && can_use_mov_pic_label_ref (operands[1]))
+	  || (GET_CODE (operands[1]) == CONST
+	      && GET_CODE (XEXP (operands[1], 0)) == PLUS
+	      && GET_CODE (XEXP (XEXP (operands[1], 0), 0)) == LABEL_REF
+	      && GET_CODE (XEXP (XEXP (operands[1], 0), 1)) == CONST_INT
+	      && can_use_mov_pic_label_ref (XEXP (XEXP (operands[1], 0), 0))))
 	{
 	  if (mode == SImode)
 	    {
@@ -2215,7 +2220,6 @@ sparc_expand_move (machine_mode mode, rtx *operands)
 
 	  if (mode == DImode)
 	    {
-	      gcc_assert (TARGET_ARCH64);
 	      emit_insn (gen_movdi_pic_label_ref (operands[0], operands[1]));
 	      return true;
 	    }
@@ -4216,10 +4220,11 @@ int
 pic_address_needs_scratch (rtx x)
 {
   /* An address which is a symbolic plus a non SMALL_INT needs a temp reg.  */
-  if (GET_CODE (x) == CONST && GET_CODE (XEXP (x, 0)) == PLUS
+  if (GET_CODE (x) == CONST
+      && GET_CODE (XEXP (x, 0)) == PLUS
       && GET_CODE (XEXP (XEXP (x, 0), 0)) == SYMBOL_REF
       && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT
-      && ! SMALL_INT (XEXP (XEXP (x, 0), 1)))
+      && !SMALL_INT (XEXP (XEXP (x, 0), 1)))
     return 1;
 
   return 0;
@@ -4526,30 +4531,38 @@ sparc_legitimize_tls_address (rtx addr)
   gcc_assert (can_create_pseudo_p ());
 
   if (GET_CODE (addr) == SYMBOL_REF)
+    /* Although the various sethi/or sequences generate SImode values, many of
+       them can be transformed by the linker when relaxing and, if relaxing to
+       local-exec, will become a sethi/xor pair, which is signed and therefore
+       a full DImode value in 64-bit mode.  Thus we must use Pmode, lest these
+       values be spilled onto the stack in 64-bit mode.  */
     switch (SYMBOL_REF_TLS_MODEL (addr))
       {
       case TLS_MODEL_GLOBAL_DYNAMIC:
 	start_sequence ();
-	temp1 = gen_reg_rtx (SImode);
-	temp2 = gen_reg_rtx (SImode);
+	temp1 = gen_reg_rtx (Pmode);
+	temp2 = gen_reg_rtx (Pmode);
 	ret = gen_reg_rtx (Pmode);
 	o0 = gen_rtx_REG (Pmode, 8);
 	got = sparc_tls_got ();
-	emit_insn (gen_tgd_hi22 (temp1, addr));
-	emit_insn (gen_tgd_lo10 (temp2, temp1, addr));
 	if (TARGET_ARCH32)
 	  {
-	    emit_insn (gen_tgd_add32 (o0, got, temp2, addr));
-	    insn = emit_call_insn (gen_tgd_call32 (o0, sparc_tls_get_addr (),
+	    emit_insn (gen_tgd_hi22si (temp1, addr));
+	    emit_insn (gen_tgd_lo10si (temp2, temp1, addr));
+	    emit_insn (gen_tgd_addsi (o0, got, temp2, addr));
+	    insn = emit_call_insn (gen_tgd_callsi (o0, sparc_tls_get_addr (),
 						   addr, const1_rtx));
 	  }
 	else
 	  {
-	    emit_insn (gen_tgd_add64 (o0, got, temp2, addr));
-	    insn = emit_call_insn (gen_tgd_call64 (o0, sparc_tls_get_addr (),
+	    emit_insn (gen_tgd_hi22di (temp1, addr));
+	    emit_insn (gen_tgd_lo10di (temp2, temp1, addr));
+	    emit_insn (gen_tgd_adddi (o0, got, temp2, addr));
+	    insn = emit_call_insn (gen_tgd_calldi (o0, sparc_tls_get_addr (),
 						   addr, const1_rtx));
 	  }
 	use_reg (&CALL_INSN_FUNCTION_USAGE (insn), o0);
+	RTL_CONST_CALL_P (insn) = 1;
 	insn = get_insns ();
 	end_sequence ();
 	emit_libcall_block (insn, ret, o0, addr);
@@ -4557,61 +4570,78 @@ sparc_legitimize_tls_address (rtx addr)
 
       case TLS_MODEL_LOCAL_DYNAMIC:
 	start_sequence ();
-	temp1 = gen_reg_rtx (SImode);
-	temp2 = gen_reg_rtx (SImode);
+	temp1 = gen_reg_rtx (Pmode);
+	temp2 = gen_reg_rtx (Pmode);
 	temp3 = gen_reg_rtx (Pmode);
 	ret = gen_reg_rtx (Pmode);
 	o0 = gen_rtx_REG (Pmode, 8);
 	got = sparc_tls_got ();
-	emit_insn (gen_tldm_hi22 (temp1));
-	emit_insn (gen_tldm_lo10 (temp2, temp1));
 	if (TARGET_ARCH32)
 	  {
-	    emit_insn (gen_tldm_add32 (o0, got, temp2));
-	    insn = emit_call_insn (gen_tldm_call32 (o0, sparc_tls_get_addr (),
+	    emit_insn (gen_tldm_hi22si (temp1));
+	    emit_insn (gen_tldm_lo10si (temp2, temp1));
+	    emit_insn (gen_tldm_addsi (o0, got, temp2));
+	    insn = emit_call_insn (gen_tldm_callsi (o0, sparc_tls_get_addr (),
 						    const1_rtx));
 	  }
 	else
 	  {
-	    emit_insn (gen_tldm_add64 (o0, got, temp2));
-	    insn = emit_call_insn (gen_tldm_call64 (o0, sparc_tls_get_addr (),
+	    emit_insn (gen_tldm_hi22di (temp1));
+	    emit_insn (gen_tldm_lo10di (temp2, temp1));
+	    emit_insn (gen_tldm_adddi (o0, got, temp2));
+	    insn = emit_call_insn (gen_tldm_calldi (o0, sparc_tls_get_addr (),
 						    const1_rtx));
 	  }
 	use_reg (&CALL_INSN_FUNCTION_USAGE (insn), o0);
+	RTL_CONST_CALL_P (insn) = 1;
 	insn = get_insns ();
 	end_sequence ();
+	/* Attach a unique REG_EQUAL, to allow the RTL optimizers to
+	  share the LD_BASE result with other LD model accesses.  */
 	emit_libcall_block (insn, temp3, o0,
 			    gen_rtx_UNSPEC (Pmode, gen_rtvec (1, const0_rtx),
 					    UNSPEC_TLSLD_BASE));
-	temp1 = gen_reg_rtx (SImode);
-	temp2 = gen_reg_rtx (SImode);
-	emit_insn (gen_tldo_hix22 (temp1, addr));
-	emit_insn (gen_tldo_lox10 (temp2, temp1, addr));
+	temp1 = gen_reg_rtx (Pmode);
+	temp2 = gen_reg_rtx (Pmode);
 	if (TARGET_ARCH32)
-	  emit_insn (gen_tldo_add32 (ret, temp3, temp2, addr));
+	  {
+	    emit_insn (gen_tldo_hix22si (temp1, addr));
+	    emit_insn (gen_tldo_lox10si (temp2, temp1, addr));
+	    emit_insn (gen_tldo_addsi (ret, temp3, temp2, addr));
+	  }
 	else
-	  emit_insn (gen_tldo_add64 (ret, temp3, temp2, addr));
+	  {
+	    emit_insn (gen_tldo_hix22di (temp1, addr));
+	    emit_insn (gen_tldo_lox10di (temp2, temp1, addr));
+	    emit_insn (gen_tldo_adddi (ret, temp3, temp2, addr));
+	  }
 	break;
 
       case TLS_MODEL_INITIAL_EXEC:
-	temp1 = gen_reg_rtx (SImode);
-	temp2 = gen_reg_rtx (SImode);
+	temp1 = gen_reg_rtx (Pmode);
+	temp2 = gen_reg_rtx (Pmode);
 	temp3 = gen_reg_rtx (Pmode);
 	got = sparc_tls_got ();
-	emit_insn (gen_tie_hi22 (temp1, addr));
-	emit_insn (gen_tie_lo10 (temp2, temp1, addr));
 	if (TARGET_ARCH32)
-	  emit_insn (gen_tie_ld32 (temp3, got, temp2, addr));
+	  {
+	    emit_insn (gen_tie_hi22si (temp1, addr));
+	    emit_insn (gen_tie_lo10si (temp2, temp1, addr));
+	    emit_insn (gen_tie_ld32 (temp3, got, temp2, addr));
+	  }
 	else
-	  emit_insn (gen_tie_ld64 (temp3, got, temp2, addr));
+	  {
+	    emit_insn (gen_tie_hi22di (temp1, addr));
+	    emit_insn (gen_tie_lo10di (temp2, temp1, addr));
+	    emit_insn (gen_tie_ld64 (temp3, got, temp2, addr));
+	  }
         if (TARGET_SUN_TLS)
 	  {
 	    ret = gen_reg_rtx (Pmode);
 	    if (TARGET_ARCH32)
-	      emit_insn (gen_tie_add32 (ret, gen_rtx_REG (Pmode, 7),
+	      emit_insn (gen_tie_addsi (ret, gen_rtx_REG (Pmode, 7),
 					temp3, addr));
 	    else
-	      emit_insn (gen_tie_add64 (ret, gen_rtx_REG (Pmode, 7),
+	      emit_insn (gen_tie_adddi (ret, gen_rtx_REG (Pmode, 7),
 					temp3, addr));
 	  }
 	else
@@ -4623,13 +4653,13 @@ sparc_legitimize_tls_address (rtx addr)
 	temp2 = gen_reg_rtx (Pmode);
 	if (TARGET_ARCH32)
 	  {
-	    emit_insn (gen_tle_hix22_sp32 (temp1, addr));
-	    emit_insn (gen_tle_lox10_sp32 (temp2, temp1, addr));
+	    emit_insn (gen_tle_hix22si (temp1, addr));
+	    emit_insn (gen_tle_lox10si (temp2, temp1, addr));
 	  }
 	else
 	  {
-	    emit_insn (gen_tle_hix22_sp64 (temp1, addr));
-	    emit_insn (gen_tle_lox10_sp64 (temp2, temp1, addr));
+	    emit_insn (gen_tle_hix22di (temp1, addr));
+	    emit_insn (gen_tle_lox10di (temp2, temp1, addr));
 	  }
 	ret = gen_rtx_PLUS (Pmode, gen_rtx_REG (Pmode, 7), temp2);
 	break;
@@ -4667,16 +4697,15 @@ sparc_legitimize_tls_address (rtx addr)
 static rtx
 sparc_legitimize_pic_address (rtx orig, rtx reg)
 {
-  bool gotdata_op = false;
-
   if (GET_CODE (orig) == SYMBOL_REF
       /* See the comment in sparc_expand_move.  */
       || (GET_CODE (orig) == LABEL_REF && !can_use_mov_pic_label_ref (orig)))
     {
+      bool gotdata_op = false;
       rtx pic_ref, address;
       rtx_insn *insn;
 
-      if (reg == 0)
+      if (!reg)
 	{
 	  gcc_assert (can_create_pseudo_p ());
 	  reg = gen_reg_rtx (Pmode);
@@ -4687,8 +4716,7 @@ sparc_legitimize_pic_address (rtx orig, rtx reg)
 	  /* If not during reload, allocate another temp reg here for loading
 	     in the address, so that these instructions can be optimized
 	     properly.  */
-	  rtx temp_reg = (! can_create_pseudo_p ()
-			  ? reg : gen_reg_rtx (Pmode));
+	  rtx temp_reg = can_create_pseudo_p () ? gen_reg_rtx (Pmode) : reg;
 
 	  /* Must put the SYMBOL_REF inside an UNSPEC here so that cse
 	     won't get confused into thinking that these two instructions
@@ -4704,6 +4732,7 @@ sparc_legitimize_pic_address (rtx orig, rtx reg)
 	      emit_insn (gen_movsi_high_pic (temp_reg, orig));
 	      emit_insn (gen_movsi_lo_sum_pic (temp_reg, temp_reg, orig));
 	    }
+
 	  address = temp_reg;
 	  gotdata_op = true;
 	}
@@ -4744,7 +4773,7 @@ sparc_legitimize_pic_address (rtx orig, rtx reg)
 	  && XEXP (XEXP (orig, 0), 0) == pic_offset_table_rtx)
 	return orig;
 
-      if (reg == 0)
+      if (!reg)
 	{
 	  gcc_assert (can_create_pseudo_p ());
 	  reg = gen_reg_rtx (Pmode);
@@ -4853,7 +4882,11 @@ sparc_delegitimize_address (rtx x)
       && XINT (XEXP (XEXP (x, 1), 1), 1) == UNSPEC_MOVE_PIC_LABEL)
     {
       x = XVECEXP (XEXP (XEXP (x, 1), 1), 0, 0);
-      gcc_assert (GET_CODE (x) == LABEL_REF);
+      gcc_assert (GET_CODE (x) == LABEL_REF
+		  || (GET_CODE (x) == CONST
+		      && GET_CODE (XEXP (x, 0)) == PLUS
+		      && GET_CODE (XEXP (XEXP (x, 0), 0)) == LABEL_REF
+		      && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT));
     }
 
   return x;
diff --git a/gcc/config/sparc/sparc.md b/gcc/config/sparc/sparc.md
index 4ddbe56fbf4..02ac09305a3 100644
--- a/gcc/config/sparc/sparc.md
+++ b/gcc/config/sparc/sparc.md
@@ -1758,7 +1758,7 @@
 
 (define_expand "movsi_pic_label_ref"
   [(set (match_dup 3) (high:SI
-     (unspec:SI [(match_operand:SI 1 "label_ref_operand" "")
+     (unspec:SI [(match_operand:SI 1 "symbolic_operand" "")
 		 (match_dup 2)] UNSPEC_MOVE_PIC_LABEL)))
    (set (match_dup 4) (lo_sum:SI (match_dup 3)
      (unspec:SI [(match_dup 1) (match_dup 2)] UNSPEC_MOVE_PIC_LABEL)))
@@ -1784,7 +1784,7 @@
 (define_insn "*movsi_high_pic_label_ref"
   [(set (match_operand:SI 0 "register_operand" "=r")
       (high:SI
-        (unspec:SI [(match_operand:SI 1 "label_ref_operand" "")
+        (unspec:SI [(match_operand:SI 1 "symbolic_operand" "")
 		    (match_operand:SI 2 "" "")] UNSPEC_MOVE_PIC_LABEL)))]
   "flag_pic"
   "sethi\t%%hi(%a2-(%a1-.)), %0")
@@ -1792,7 +1792,7 @@
 (define_insn "*movsi_lo_sum_pic_label_ref"
   [(set (match_operand:SI 0 "register_operand" "=r")
       (lo_sum:SI (match_operand:SI 1 "register_operand" "r")
-        (unspec:SI [(match_operand:SI 2 "label_ref_operand" "")
+        (unspec:SI [(match_operand:SI 2 "symbolic_operand" "")
 		    (match_operand:SI 3 "" "")] UNSPEC_MOVE_PIC_LABEL)))]
   "flag_pic"
   "or\t%1, %%lo(%a3-(%a2-.)), %0")
@@ -1896,7 +1896,7 @@ visl")
 
 (define_expand "movdi_pic_label_ref"
   [(set (match_dup 3) (high:DI
-     (unspec:DI [(match_operand:DI 1 "label_ref_operand" "")
+     (unspec:DI [(match_operand:DI 1 "symbolic_operand" "")
                  (match_dup 2)] UNSPEC_MOVE_PIC_LABEL)))
    (set (match_dup 4) (lo_sum:DI (match_dup 3)
      (unspec:DI [(match_dup 1) (match_dup 2)] UNSPEC_MOVE_PIC_LABEL)))
@@ -1922,7 +1922,7 @@ visl")
 (define_insn "*movdi_high_pic_label_ref"
   [(set (match_operand:DI 0 "register_operand" "=r")
         (high:DI
-          (unspec:DI [(match_operand:DI 1 "label_ref_operand" "")
+          (unspec:DI [(match_operand:DI 1 "symbolic_operand" "")
                       (match_operand:DI 2 "" "")] UNSPEC_MOVE_PIC_LABEL)))]
   "TARGET_ARCH64 && flag_pic"
   "sethi\t%%hi(%a2-(%a1-.)), %0")
@@ -1930,7 +1930,7 @@ visl")
 (define_insn "*movdi_lo_sum_pic_label_ref"
   [(set (match_operand:DI 0 "register_operand" "=r")
       (lo_sum:DI (match_operand:DI 1 "register_operand" "r")
-        (unspec:DI [(match_operand:DI 2 "label_ref_operand" "")
+        (unspec:DI [(match_operand:DI 2 "symbolic_operand" "")
                     (match_operand:DI 3 "" "")] UNSPEC_MOVE_PIC_LABEL)))]
   "TARGET_ARCH64 && flag_pic"
   "or\t%1, %%lo(%a3-(%a2-.)), %0")
@@ -7961,158 +7961,112 @@ visl")
 
 ;; TLS support instructions.
 
-(define_insn "tgd_hi22"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-        (high:SI (unspec:SI [(match_operand 1 "tgd_symbolic_operand" "")]
-			    UNSPEC_TLSGD)))]
+(define_insn "tgd_hi22<P:mode>"
+  [(set (match_operand:P 0 "register_operand" "=r")
+        (high:P (unspec:P [(match_operand 1 "tgd_symbolic_operand" "")]
+			  UNSPEC_TLSGD)))]
   "TARGET_TLS"
   "sethi\\t%%tgd_hi22(%a1), %0")
 
-(define_insn "tgd_lo10"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(lo_sum:SI (match_operand:SI 1 "register_operand" "r")
-		   (unspec:SI [(match_operand 2 "tgd_symbolic_operand" "")]
-			      UNSPEC_TLSGD)))]
+(define_insn "tgd_lo10<P:mode>"
+  [(set (match_operand:P 0 "register_operand" "=r")
+	(lo_sum:P (match_operand:P 1 "register_operand" "r")
+		  (unspec:P [(match_operand 2 "tgd_symbolic_operand" "")]
+			    UNSPEC_TLSGD)))]
   "TARGET_TLS"
   "add\\t%1, %%tgd_lo10(%a2), %0")
 
-(define_insn "tgd_add32"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(plus:SI (match_operand:SI 1 "register_operand" "r")
-		 (unspec:SI [(match_operand:SI 2 "register_operand" "r")
-			     (match_operand 3 "tgd_symbolic_operand" "")]
-			    UNSPEC_TLSGD)))]
-  "TARGET_TLS && TARGET_ARCH32"
-  "add\\t%1, %2, %0, %%tgd_add(%a3)")
-
-(define_insn "tgd_add64"
-  [(set (match_operand:DI 0 "register_operand" "=r")
-	(plus:DI (match_operand:DI 1 "register_operand" "r")
-		 (unspec:DI [(match_operand:SI 2 "register_operand" "r")
-			     (match_operand 3 "tgd_symbolic_operand" "")]
-			    UNSPEC_TLSGD)))]
-  "TARGET_TLS && TARGET_ARCH64"
+(define_insn "tgd_add<P:mode>"
+  [(set (match_operand:P 0 "register_operand" "=r")
+	(plus:P (match_operand:P 1 "register_operand" "r")
+		(unspec:P [(match_operand:P 2 "register_operand" "r")
+			   (match_operand 3 "tgd_symbolic_operand" "")]
+			  UNSPEC_TLSGD)))]
+  "TARGET_TLS"
   "add\\t%1, %2, %0, %%tgd_add(%a3)")
 
-(define_insn "tgd_call32"
+(define_insn "tgd_call<P:mode>"
   [(set (match_operand 0 "register_operand" "=r")
-	(call (mem:SI (unspec:SI [(match_operand:SI 1 "symbolic_operand" "s")
-				  (match_operand 2 "tgd_symbolic_operand" "")]
-				 UNSPEC_TLSGD))
+	(call (mem:P (unspec:P [(match_operand:P 1 "symbolic_operand" "s")
+				(match_operand 2 "tgd_symbolic_operand" "")]
+			       UNSPEC_TLSGD))
 	      (match_operand 3 "" "")))
-   (clobber (reg:SI O7_REG))]
-  "TARGET_TLS && TARGET_ARCH32"
-  "call\t%a1, %%tgd_call(%a2)%#"
-  [(set_attr "type" "call")])
-
-(define_insn "tgd_call64"
-  [(set (match_operand 0 "register_operand" "=r")
-	(call (mem:DI (unspec:DI [(match_operand:DI 1 "symbolic_operand" "s")
-				  (match_operand 2 "tgd_symbolic_operand" "")]
-				 UNSPEC_TLSGD))
-	      (match_operand 3 "" "")))
-   (clobber (reg:DI O7_REG))]
-  "TARGET_TLS && TARGET_ARCH64"
+   (clobber (reg:P O7_REG))]
+  "TARGET_TLS"
   "call\t%a1, %%tgd_call(%a2)%#"
   [(set_attr "type" "call")])
 
-(define_insn "tldm_hi22"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-        (high:SI (unspec:SI [(const_int 0)] UNSPEC_TLSLDM)))]
+(define_insn "tldm_hi22<P:mode>"
+  [(set (match_operand:P 0 "register_operand" "=r")
+        (high:P (unspec:P [(const_int 0)] UNSPEC_TLSLDM)))]
   "TARGET_TLS"
   "sethi\\t%%tldm_hi22(%&), %0")
 
-(define_insn "tldm_lo10"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(lo_sum:SI (match_operand:SI 1 "register_operand" "r")
-		    (unspec:SI [(const_int 0)] UNSPEC_TLSLDM)))]
+(define_insn "tldm_lo10<P:mode>"
+  [(set (match_operand:P 0 "register_operand" "=r")
+	(lo_sum:P (match_operand:P 1 "register_operand" "r")
+		  (unspec:P [(const_int 0)] UNSPEC_TLSLDM)))]
   "TARGET_TLS"
   "add\\t%1, %%tldm_lo10(%&), %0")
 
-(define_insn "tldm_add32"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(plus:SI (match_operand:SI 1 "register_operand" "r")
-		 (unspec:SI [(match_operand:SI 2 "register_operand" "r")]
-			    UNSPEC_TLSLDM)))]
-  "TARGET_TLS && TARGET_ARCH32"
-  "add\\t%1, %2, %0, %%tldm_add(%&)")
-
-(define_insn "tldm_add64"
-  [(set (match_operand:DI 0 "register_operand" "=r")
-	(plus:DI (match_operand:DI 1 "register_operand" "r")
-		 (unspec:DI [(match_operand:SI 2 "register_operand" "r")]
-			    UNSPEC_TLSLDM)))]
-  "TARGET_TLS && TARGET_ARCH64"
+(define_insn "tldm_add<P:mode>"
+  [(set (match_operand:P 0 "register_operand" "=r")
+	(plus:P (match_operand:P 1 "register_operand" "r")
+		(unspec:P [(match_operand:P 2 "register_operand" "r")]
+			  UNSPEC_TLSLDM)))]
+  "TARGET_TLS"
   "add\\t%1, %2, %0, %%tldm_add(%&)")
 
-(define_insn "tldm_call32"
-  [(set (match_operand 0 "register_operand" "=r")
-	(call (mem:SI (unspec:SI [(match_operand:SI 1 "symbolic_operand" "s")]
-				 UNSPEC_TLSLDM))
-	      (match_operand 2 "" "")))
-   (clobber (reg:SI O7_REG))]
-  "TARGET_TLS && TARGET_ARCH32"
-  "call\t%a1, %%tldm_call(%&)%#"
-  [(set_attr "type" "call")])
-
-(define_insn "tldm_call64"
+(define_insn "tldm_call<P:mode>"
   [(set (match_operand 0 "register_operand" "=r")
-	(call (mem:DI (unspec:DI [(match_operand:DI 1 "symbolic_operand" "s")]
-				 UNSPEC_TLSLDM))
+	(call (mem:P (unspec:P [(match_operand:P 1 "symbolic_operand" "s")]
+			       UNSPEC_TLSLDM))
 	      (match_operand 2 "" "")))
-   (clobber (reg:DI O7_REG))]
-  "TARGET_TLS && TARGET_ARCH64"
+   (clobber (reg:P O7_REG))]
+  "TARGET_TLS"
   "call\t%a1, %%tldm_call(%&)%#"
   [(set_attr "type" "call")])
 
-(define_insn "tldo_hix22"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-        (high:SI (unspec:SI [(match_operand 1 "tld_symbolic_operand" "")]
-			    UNSPEC_TLSLDO)))]
+(define_insn "tldo_hix22<P:mode>"
+  [(set (match_operand:P 0 "register_operand" "=r")
+        (high:P (unspec:P [(match_operand 1 "tld_symbolic_operand" "")]
+			  UNSPEC_TLSLDO)))]
   "TARGET_TLS"
   "sethi\\t%%tldo_hix22(%a1), %0")
 
-(define_insn "tldo_lox10"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(lo_sum:SI (match_operand:SI 1 "register_operand" "r")
-		   (unspec:SI [(match_operand 2 "tld_symbolic_operand" "")]
-			      UNSPEC_TLSLDO)))]
+(define_insn "tldo_lox10<P:mode>"
+  [(set (match_operand:P 0 "register_operand" "=r")
+	(lo_sum:P (match_operand:P 1 "register_operand" "r")
+		  (unspec:P [(match_operand 2 "tld_symbolic_operand" "")]
+			    UNSPEC_TLSLDO)))]
   "TARGET_TLS"
   "xor\\t%1, %%tldo_lox10(%a2), %0")
 
-(define_insn "tldo_add32"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(plus:SI (match_operand:SI 1 "register_operand" "r")
-		 (unspec:SI [(match_operand:SI 2 "register_operand" "r")
-			     (match_operand 3 "tld_symbolic_operand" "")]
-			    UNSPEC_TLSLDO)))]
-  "TARGET_TLS && TARGET_ARCH32"
-  "add\\t%1, %2, %0, %%tldo_add(%a3)")
-
-(define_insn "tldo_add64"
-  [(set (match_operand:DI 0 "register_operand" "=r")
-	(plus:DI (match_operand:DI 1 "register_operand" "r")
-		 (unspec:DI [(match_operand:SI 2 "register_operand" "r")
-			     (match_operand 3 "tld_symbolic_operand" "")]
-			    UNSPEC_TLSLDO)))]
-  "TARGET_TLS && TARGET_ARCH64"
+(define_insn "tldo_add<P:mode>"
+  [(set (match_operand:P 0 "register_operand" "=r")
+	(plus:P (match_operand:P 1 "register_operand" "r")
+		(unspec:P [(match_operand:P 2 "register_operand" "r")
+			   (match_operand 3 "tld_symbolic_operand" "")]
+			  UNSPEC_TLSLDO)))]
+  "TARGET_TLS"
   "add\\t%1, %2, %0, %%tldo_add(%a3)")
 
-(define_insn "tie_hi22"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-        (high:SI (unspec:SI [(match_operand 1 "tie_symbolic_operand" "")]
-			    UNSPEC_TLSIE)))]
+(define_insn "tie_hi22<P:mode>"
+  [(set (match_operand:P 0 "register_operand" "=r")
+        (high:P (unspec:P [(match_operand 1 "tie_symbolic_operand" "")]
+			  UNSPEC_TLSIE)))]
   "TARGET_TLS"
   "sethi\\t%%tie_hi22(%a1), %0")
 
-(define_insn "tie_lo10"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(lo_sum:SI (match_operand:SI 1 "register_operand" "r")
-		   (unspec:SI [(match_operand 2 "tie_symbolic_operand" "")]
-			      UNSPEC_TLSIE)))]
+(define_insn "tie_lo10<P:mode>"
+  [(set (match_operand:P 0 "register_operand" "=r")
+	(lo_sum:P (match_operand:P 1 "register_operand" "r")
+		  (unspec:P [(match_operand 2 "tie_symbolic_operand" "")]
+			    UNSPEC_TLSIE)))]
   "TARGET_TLS"
   "add\\t%1, %%tie_lo10(%a2), %0")
 
+; Note the %%tie_ld operator
 (define_insn "tie_ld32"
   [(set (match_operand:SI 0 "register_operand" "=r")
 	(unspec:SI [(match_operand:SI 1 "register_operand" "r")
@@ -8124,10 +8078,11 @@ visl")
   [(set_attr "type" "load")
    (set_attr "subtype" "regular")])
 
+; Note the %%tie_ldx operator
 (define_insn "tie_ld64"
   [(set (match_operand:DI 0 "register_operand" "=r")
 	(unspec:DI [(match_operand:DI 1 "register_operand" "r")
-		    (match_operand:SI 2 "register_operand" "r")
+		    (match_operand:DI 2 "register_operand" "r")
 		    (match_operand 3 "tie_symbolic_operand" "")]
 		   UNSPEC_TLSIE))]
   "TARGET_TLS && TARGET_ARCH64"
@@ -8135,159 +8090,97 @@ visl")
   [(set_attr "type" "load")
    (set_attr "subtype" "regular")])
 
-(define_insn "tie_add32"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(plus:SI (match_operand:SI 1 "register_operand" "r")
-		 (unspec:SI [(match_operand:SI 2 "register_operand" "r")
-			     (match_operand 3 "tie_symbolic_operand" "")]
-			    UNSPEC_TLSIE)))]
-  "TARGET_SUN_TLS && TARGET_ARCH32"
-  "add\\t%1, %2, %0, %%tie_add(%a3)")
-
-(define_insn "tie_add64"
-  [(set (match_operand:DI 0 "register_operand" "=r")
-	(plus:DI (match_operand:DI 1 "register_operand" "r")
-		 (unspec:DI [(match_operand:DI 2 "register_operand" "r")
-			     (match_operand 3 "tie_symbolic_operand" "")]
-			    UNSPEC_TLSIE)))]
-  "TARGET_SUN_TLS && TARGET_ARCH64"
+(define_insn "tie_add<P:mode>"
+  [(set (match_operand:P 0 "register_operand" "=r")
+	(plus:P (match_operand:P 1 "register_operand" "r")
+		(unspec:P [(match_operand:P 2 "register_operand" "r")
+			   (match_operand 3 "tie_symbolic_operand" "")]
+			  UNSPEC_TLSIE)))]
+  "TARGET_SUN_TLS"
   "add\\t%1, %2, %0, %%tie_add(%a3)")
 
-(define_insn "tle_hix22_sp32"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-        (high:SI (unspec:SI [(match_operand 1 "tle_symbolic_operand" "")]
-			    UNSPEC_TLSLE)))]
-  "TARGET_TLS && TARGET_ARCH32"
+(define_insn "tle_hix22<P:mode>"
+  [(set (match_operand:P 0 "register_operand" "=r")
+        (high:P (unspec:P [(match_operand 1 "tle_symbolic_operand" "")]
+			  UNSPEC_TLSLE)))]
+  "TARGET_TLS"
   "sethi\\t%%tle_hix22(%a1), %0")
 
-(define_insn "tle_lox10_sp32"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(lo_sum:SI (match_operand:SI 1 "register_operand" "r")
-		   (unspec:SI [(match_operand 2 "tle_symbolic_operand" "")]
-			      UNSPEC_TLSLE)))]
-  "TARGET_TLS && TARGET_ARCH32"
-  "xor\\t%1, %%tle_lox10(%a2), %0")
-
-(define_insn "tle_hix22_sp64"
-  [(set (match_operand:DI 0 "register_operand" "=r")
-        (high:DI (unspec:DI [(match_operand 1 "tle_symbolic_operand" "")]
+(define_insn "tle_lox10<P:mode>"
+  [(set (match_operand:P 0 "register_operand" "=r")
+	(lo_sum:P (match_operand:P 1 "register_operand" "r")
+		  (unspec:P [(match_operand 2 "tle_symbolic_operand" "")]
 			    UNSPEC_TLSLE)))]
-  "TARGET_TLS && TARGET_ARCH64"
-  "sethi\\t%%tle_hix22(%a1), %0")
-
-(define_insn "tle_lox10_sp64"
-  [(set (match_operand:DI 0 "register_operand" "=r")
-	(lo_sum:DI (match_operand:DI 1 "register_operand" "r")
-		   (unspec:DI [(match_operand 2 "tle_symbolic_operand" "")]
-			      UNSPEC_TLSLE)))]
-  "TARGET_TLS && TARGET_ARCH64"
+  "TARGET_TLS"
   "xor\\t%1, %%tle_lox10(%a2), %0")
 
-;; Now patterns combining tldo_add{32,64} with some integer loads or stores
-(define_insn "*tldo_ldub_sp32"
+;; Now patterns combining tldo_add with some integer loads or stores
+(define_insn "*tldo_ldub<P:mode>"
   [(set (match_operand:QI 0 "register_operand" "=r")
-	(mem:QI (plus:SI (unspec:SI [(match_operand:SI 2 "register_operand" "r")
-				     (match_operand 3 "tld_symbolic_operand" "")]
-				    UNSPEC_TLSLDO)
-			 (match_operand:SI 1 "register_operand" "r"))))]
-  "TARGET_TLS && TARGET_ARCH32"
+	(mem:QI (plus:P (unspec:P [(match_operand:P 2 "register_operand" "r")
+				   (match_operand 3 "tld_symbolic_operand" "")]
+				  UNSPEC_TLSLDO)
+			(match_operand:P 1 "register_operand" "r"))))]
+  "TARGET_TLS"
   "ldub\t[%1 + %2], %0, %%tldo_add(%3)"
   [(set_attr "type" "load")
    (set_attr "subtype" "regular")
    (set_attr "us3load_type" "3cycle")])
 
-(define_insn "*tldo_ldub1_sp32"
+(define_insn "*tldo_ldub1<P:mode>"
   [(set (match_operand:HI 0 "register_operand" "=r")
 	(zero_extend:HI
-	  (mem:QI (plus:SI (unspec:SI [(match_operand:SI 2 "register_operand" "r")
-				       (match_operand 3 "tld_symbolic_operand" "")]
-				      UNSPEC_TLSLDO)
-			   (match_operand:SI 1 "register_operand" "r")))))]
-  "TARGET_TLS && TARGET_ARCH32"
+	  (mem:QI (plus:P (unspec:P [(match_operand:P 2 "register_operand" "r")
+				     (match_operand 3 "tld_symbolic_operand" "")]
+				    UNSPEC_TLSLDO)
+			  (match_operand:P 1 "register_operand" "r")))))]
+  "TARGET_TLS"
   "ldub\t[%1 + %2], %0, %%tldo_add(%3)"
   [(set_attr "type" "load")
    (set_attr "subtype" "regular")
    (set_attr "us3load_type" "3cycle")])
 
-(define_insn "*tldo_ldub2_sp32"
+(define_insn "*tldo_ldub2<P:mode>"
   [(set (match_operand:SI 0 "register_operand" "=r")
 	(zero_extend:SI
-	  (mem:QI (plus:SI (unspec:SI [(match_operand:SI 2 "register_operand" "r")
-				       (match_operand 3 "tld_symbolic_operand" "")]
-				      UNSPEC_TLSLDO)
-			   (match_operand:SI 1 "register_operand" "r")))))]
-  "TARGET_TLS && TARGET_ARCH32"
+	  (mem:QI (plus:P (unspec:P [(match_operand:P 2 "register_operand" "r")
+				     (match_operand 3 "tld_symbolic_operand" "")]
+				    UNSPEC_TLSLDO)
+			  (match_operand:P 1 "register_operand" "r")))))]
+  "TARGET_TLS"
   "ldub\t[%1 + %2], %0, %%tldo_add(%3)"
   [(set_attr "type" "load")
    (set_attr "subtype" "regular")
    (set_attr "us3load_type" "3cycle")])
 
-(define_insn "*tldo_ldsb1_sp32"
+(define_insn "*tldo_ldsb1<P:mode>"
   [(set (match_operand:HI 0 "register_operand" "=r")
 	(sign_extend:HI
-	  (mem:QI (plus:SI (unspec:SI [(match_operand:SI 2 "register_operand" "r")
-				       (match_operand 3 "tld_symbolic_operand" "")]
-				      UNSPEC_TLSLDO)
-			   (match_operand:SI 1 "register_operand" "r")))))]
-  "TARGET_TLS && TARGET_ARCH32"
+	  (mem:QI (plus:P (unspec:P [(match_operand:P 2 "register_operand" "r")
+				     (match_operand 3 "tld_symbolic_operand" "")]
+				    UNSPEC_TLSLDO)
+			  (match_operand:P 1 "register_operand" "r")))))]
+  "TARGET_TLS"
   "ldsb\t[%1 + %2], %0, %%tldo_add(%3)"
   [(set_attr "type" "sload")
    (set_attr "us3load_type" "3cycle")])
 
-(define_insn "*tldo_ldsb2_sp32"
+(define_insn "*tldo_ldsb2<P:mode>"
   [(set (match_operand:SI 0 "register_operand" "=r")
 	(sign_extend:SI
-	  (mem:QI (plus:SI (unspec:SI [(match_operand:SI 2 "register_operand" "r")
-				       (match_operand 3 "tld_symbolic_operand" "")]
-				      UNSPEC_TLSLDO)
-			   (match_operand:SI 1 "register_operand" "r")))))]
-  "TARGET_TLS && TARGET_ARCH32"
-  "ldsb\t[%1 + %2], %0, %%tldo_add(%3)"
-  [(set_attr "type" "sload")
-   (set_attr "us3load_type" "3cycle")])
-
-(define_insn "*tldo_ldub_sp64"
-  [(set (match_operand:QI 0 "register_operand" "=r")
-	(mem:QI (plus:DI (unspec:DI [(match_operand:SI 2 "register_operand" "r")
+	  (mem:QI (plus:P (unspec:P [(match_operand:P 2 "register_operand" "r")
 				     (match_operand 3 "tld_symbolic_operand" "")]
 				    UNSPEC_TLSLDO)
-			 (match_operand:DI 1 "register_operand" "r"))))]
-  "TARGET_TLS && TARGET_ARCH64"
-  "ldub\t[%1 + %2], %0, %%tldo_add(%3)"
-  [(set_attr "type" "load")
-   (set_attr "subtype" "regular")
-   (set_attr "us3load_type" "3cycle")])
-
-(define_insn "*tldo_ldub1_sp64"
-  [(set (match_operand:HI 0 "register_operand" "=r")
-	(zero_extend:HI
-	  (mem:QI (plus:DI (unspec:DI [(match_operand:SI 2 "register_operand" "r")
-				       (match_operand 3 "tld_symbolic_operand" "")]
-				      UNSPEC_TLSLDO)
-			   (match_operand:DI 1 "register_operand" "r")))))]
-  "TARGET_TLS && TARGET_ARCH64"
-  "ldub\t[%1 + %2], %0, %%tldo_add(%3)"
-  [(set_attr "type" "load")
-   (set_attr "subtype" "regular")
-   (set_attr "us3load_type" "3cycle")])
-
-(define_insn "*tldo_ldub2_sp64"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(zero_extend:SI
-	  (mem:QI (plus:DI (unspec:DI [(match_operand:SI 2 "register_operand" "r")
-				       (match_operand 3 "tld_symbolic_operand" "")]
-				      UNSPEC_TLSLDO)
-			   (match_operand:DI 1 "register_operand" "r")))))]
-  "TARGET_TLS && TARGET_ARCH64"
-  "ldub\t[%1 + %2], %0, %%tldo_add(%3)"
-  [(set_attr "type" "load")
-   (set_attr "subtype" "regular")
+			  (match_operand:P 1 "register_operand" "r")))))]
+  "TARGET_TLS"
+  "ldsb\t[%1 + %2], %0, %%tldo_add(%3)"
+  [(set_attr "type" "sload")
    (set_attr "us3load_type" "3cycle")])
 
 (define_insn "*tldo_ldub3_sp64"
   [(set (match_operand:DI 0 "register_operand" "=r")
 	(zero_extend:DI
-	  (mem:QI (plus:DI (unspec:DI [(match_operand:SI 2 "register_operand" "r")
+	  (mem:QI (plus:DI (unspec:DI [(match_operand:DI 2 "register_operand" "r")
 				       (match_operand 3 "tld_symbolic_operand" "")]
 				      UNSPEC_TLSLDO)
 			   (match_operand:DI 1 "register_operand" "r")))))]
@@ -8297,34 +8190,10 @@ visl")
    (set_attr "subtype" "regular")
    (set_attr "us3load_type" "3cycle")])
 
-(define_insn "*tldo_ldsb1_sp64"
-  [(set (match_operand:HI 0 "register_operand" "=r")
-	(sign_extend:HI
-	  (mem:QI (plus:DI (unspec:DI [(match_operand:SI 2 "register_operand" "r")
-				       (match_operand 3 "tld_symbolic_operand" "")]
-				      UNSPEC_TLSLDO)
-			   (match_operand:DI 1 "register_operand" "r")))))]
-  "TARGET_TLS && TARGET_ARCH64"
-  "ldsb\t[%1 + %2], %0, %%tldo_add(%3)"
-  [(set_attr "type" "sload")
-   (set_attr "us3load_type" "3cycle")])
-
-(define_insn "*tldo_ldsb2_sp64"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(sign_extend:SI
-	  (mem:QI (plus:DI (unspec:DI [(match_operand:SI 2 "register_operand" "r")
-				       (match_operand 3 "tld_symbolic_operand" "")]
-				      UNSPEC_TLSLDO)
-			   (match_operand:DI 1 "register_operand" "r")))))]
-  "TARGET_TLS && TARGET_ARCH64"
-  "ldsb\t[%1 + %2], %0, %%tldo_add(%3)"
-  [(set_attr "type" "sload")
-   (set_attr "us3load_type" "3cycle")])
-
 (define_insn "*tldo_ldsb3_sp64"
   [(set (match_operand:DI 0 "register_operand" "=r")
 	(sign_extend:DI
-	  (mem:QI (plus:DI (unspec:DI [(match_operand:SI 2 "register_operand" "r")
+	  (mem:QI (plus:DI (unspec:DI [(match_operand:DI 2 "register_operand" "r")
 				       (match_operand 3 "tld_symbolic_operand" "")]
 				      UNSPEC_TLSLDO)
 			   (match_operand:DI 1 "register_operand" "r")))))]
@@ -8333,72 +8202,47 @@ visl")
   [(set_attr "type" "sload")
    (set_attr "us3load_type" "3cycle")])
 
-(define_insn "*tldo_lduh_sp32"
+(define_insn "*tldo_lduh<P:mode>"
   [(set (match_operand:HI 0 "register_operand" "=r")
-	(mem:HI (plus:SI (unspec:SI [(match_operand:SI 2 "register_operand" "r")
-				     (match_operand 3 "tld_symbolic_operand" "")]
-				    UNSPEC_TLSLDO)
-			 (match_operand:SI 1 "register_operand" "r"))))]
-  "TARGET_TLS && TARGET_ARCH32"
+	(mem:HI (plus:P (unspec:P [(match_operand:P 2 "register_operand" "r")
+				   (match_operand 3 "tld_symbolic_operand" "")]
+				  UNSPEC_TLSLDO)
+			(match_operand:P 1 "register_operand" "r"))))]
+  "TARGET_TLS"
   "lduh\t[%1 + %2], %0, %%tldo_add(%3)"
   [(set_attr "type" "load")
    (set_attr "subtype" "regular")
    (set_attr "us3load_type" "3cycle")])
 
-(define_insn "*tldo_lduh1_sp32"
+(define_insn "*tldo_lduh1<P:mode>"
   [(set (match_operand:SI 0 "register_operand" "=r")
 	(zero_extend:SI
-	  (mem:HI (plus:SI (unspec:SI [(match_operand:SI 2 "register_operand" "r")
-				       (match_operand 3 "tld_symbolic_operand" "")]
-				      UNSPEC_TLSLDO)
-			   (match_operand:SI 1 "register_operand" "r")))))]
-  "TARGET_TLS && TARGET_ARCH32"
+	  (mem:HI (plus:P (unspec:P [(match_operand:P 2 "register_operand" "r")
+				     (match_operand 3 "tld_symbolic_operand" "")]
+				    UNSPEC_TLSLDO)
+			  (match_operand:P 1 "register_operand" "r")))))]
+  "TARGET_TLS"
   "lduh\t[%1 + %2], %0, %%tldo_add(%3)"
   [(set_attr "type" "load")
    (set_attr "subtype" "regular")
    (set_attr "us3load_type" "3cycle")])
 
-(define_insn "*tldo_ldsh1_sp32"
+(define_insn "*tldo_ldsh1<P:mode>"
   [(set (match_operand:SI 0 "register_operand" "=r")
 	(sign_extend:SI
-	  (mem:HI (plus:SI (unspec:SI [(match_operand:SI 2 "register_operand" "r")
-				       (match_operand 3 "tld_symbolic_operand" "")]
-				      UNSPEC_TLSLDO)
-			   (match_operand:SI 1 "register_operand" "r")))))]
-  "TARGET_TLS && TARGET_ARCH32"
-  "ldsh\t[%1 + %2], %0, %%tldo_add(%3)"
-  [(set_attr "type" "sload")
-   (set_attr "us3load_type" "3cycle")])
-
-(define_insn "*tldo_lduh_sp64"
-  [(set (match_operand:HI 0 "register_operand" "=r")
-	(mem:HI (plus:DI (unspec:DI [(match_operand:SI 2 "register_operand" "r")
+	  (mem:HI (plus:P (unspec:P [(match_operand:P 2 "register_operand" "r")
 				     (match_operand 3 "tld_symbolic_operand" "")]
 				    UNSPEC_TLSLDO)
-			 (match_operand:DI 1 "register_operand" "r"))))]
-  "TARGET_TLS && TARGET_ARCH64"
-  "lduh\t[%1 + %2], %0, %%tldo_add(%3)"
-  [(set_attr "type" "load")
-   (set_attr "subtype" "regular")
-   (set_attr "us3load_type" "3cycle")])
-
-(define_insn "*tldo_lduh1_sp64"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(zero_extend:SI
-	  (mem:HI (plus:DI (unspec:DI [(match_operand:SI 2 "register_operand" "r")
-				       (match_operand 3 "tld_symbolic_operand" "")]
-				      UNSPEC_TLSLDO)
-			   (match_operand:DI 1 "register_operand" "r")))))]
-  "TARGET_TLS && TARGET_ARCH64"
-  "lduh\t[%1 + %2], %0, %%tldo_add(%3)"
-  [(set_attr "type" "load")
-   (set_attr "subtype" "regular")
+			  (match_operand:P 1 "register_operand" "r")))))]
+  "TARGET_TLS"
+  "ldsh\t[%1 + %2], %0, %%tldo_add(%3)"
+  [(set_attr "type" "sload")
    (set_attr "us3load_type" "3cycle")])
 
 (define_insn "*tldo_lduh2_sp64"
   [(set (match_operand:DI 0 "register_operand" "=r")
 	(zero_extend:DI
-	  (mem:HI (plus:DI (unspec:DI [(match_operand:SI 2 "register_operand" "r")
+	  (mem:HI (plus:DI (unspec:DI [(match_operand:DI 2 "register_operand" "r")
 				       (match_operand 3 "tld_symbolic_operand" "")]
 				      UNSPEC_TLSLDO)
 			   (match_operand:DI 1 "register_operand" "r")))))]
@@ -8408,22 +8252,10 @@ visl")
    (set_attr "subtype" "regular")
    (set_attr "us3load_type" "3cycle")])
 
-(define_insn "*tldo_ldsh1_sp64"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(sign_extend:SI
-	  (mem:HI (plus:DI (unspec:DI [(match_operand:SI 2 "register_operand" "r")
-				       (match_operand 3 "tld_symbolic_operand" "")]
-				      UNSPEC_TLSLDO)
-			   (match_operand:DI 1 "register_operand" "r")))))]
-  "TARGET_TLS && TARGET_ARCH64"
-  "ldsh\t[%1 + %2], %0, %%tldo_add(%3)"
-  [(set_attr "type" "sload")
-   (set_attr "us3load_type" "3cycle")])
-
 (define_insn "*tldo_ldsh2_sp64"
   [(set (match_operand:DI 0 "register_operand" "=r")
 	(sign_extend:DI
-	  (mem:HI (plus:DI (unspec:DI [(match_operand:SI 2 "register_operand" "r")
+	  (mem:HI (plus:DI (unspec:DI [(match_operand:DI 2 "register_operand" "r")
 				       (match_operand 3 "tld_symbolic_operand" "")]
 				      UNSPEC_TLSLDO)
 			   (match_operand:DI 1 "register_operand" "r")))))]
@@ -8432,32 +8264,21 @@ visl")
   [(set_attr "type" "sload")
    (set_attr "us3load_type" "3cycle")])
 
-(define_insn "*tldo_lduw_sp32"
+(define_insn "*tldo_lduw<P:mode>"
   [(set (match_operand:SI 0 "register_operand" "=r")
-	(mem:SI (plus:SI (unspec:SI [(match_operand:SI 2 "register_operand" "r")
-				     (match_operand 3 "tld_symbolic_operand" "")]
-				    UNSPEC_TLSLDO)
-			 (match_operand:SI 1 "register_operand" "r"))))]
-  "TARGET_TLS && TARGET_ARCH32"
+	(mem:SI (plus:P (unspec:P [(match_operand:P 2 "register_operand" "r")
+				   (match_operand 3 "tld_symbolic_operand" "")]
+				  UNSPEC_TLSLDO)
+			(match_operand:P 1 "register_operand" "r"))))]
+  "TARGET_TLS"
   "ld\t[%1 + %2], %0, %%tldo_add(%3)"
   [(set_attr "type" "load")
    (set_attr "subtype" "regular")])
 
-(define_insn "*tldo_lduw_sp64"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(mem:SI (plus:DI (unspec:DI [(match_operand:SI 2 "register_operand" "r")
-				     (match_operand 3 "tld_symbolic_operand" "")]
-				    UNSPEC_TLSLDO)
-			 (match_operand:DI 1 "register_operand" "r"))))]
-  "TARGET_TLS && TARGET_ARCH64"
-  "lduw\t[%1 + %2], %0, %%tldo_add(%3)"
-  [(set_attr "type" "load")
-   (set_attr "subtype" "regular")])
-
 (define_insn "*tldo_lduw1_sp64"
   [(set (match_operand:DI 0 "register_operand" "=r")
 	(zero_extend:DI
-	  (mem:SI (plus:DI (unspec:DI [(match_operand:SI 2 "register_operand" "r")
+	  (mem:SI (plus:DI (unspec:DI [(match_operand:DI 2 "register_operand" "r")
 				       (match_operand 3 "tld_symbolic_operand" "")]
 				      UNSPEC_TLSLDO)
 			   (match_operand:DI 1 "register_operand" "r")))))]
@@ -8469,8 +8290,8 @@ visl")
 (define_insn "*tldo_ldsw1_sp64"
   [(set (match_operand:DI 0 "register_operand" "=r")
 	(sign_extend:DI
-	  (mem:SI (plus:DI (unspec:DI [(match_operand:SI 2 "register_operand" "r")
-					(match_operand 3 "tld_symbolic_operand" "")]
+	  (mem:SI (plus:DI (unspec:DI [(match_operand:DI 2 "register_operand" "r")
+				       (match_operand 3 "tld_symbolic_operand" "")]
 				      UNSPEC_TLSLDO)
 			   (match_operand:DI 1 "register_operand" "r")))))]
   "TARGET_TLS && TARGET_ARCH64"
@@ -8480,7 +8301,7 @@ visl")
 
 (define_insn "*tldo_ldx_sp64"
   [(set (match_operand:DI 0 "register_operand" "=r")
-	(mem:DI (plus:DI (unspec:DI [(match_operand:SI 2 "register_operand" "r")
+	(mem:DI (plus:DI (unspec:DI [(match_operand:DI 2 "register_operand" "r")
 				     (match_operand 3 "tld_symbolic_operand" "")]
 				    UNSPEC_TLSLDO)
 			 (match_operand:DI 1 "register_operand" "r"))))]
@@ -8489,68 +8310,38 @@ visl")
   [(set_attr "type" "load")
    (set_attr "subtype" "regular")])
 
-(define_insn "*tldo_stb_sp32"
-  [(set (mem:QI (plus:SI (unspec:SI [(match_operand:SI 2 "register_operand" "r")
-				     (match_operand 3 "tld_symbolic_operand" "")]
-				    UNSPEC_TLSLDO)
-			 (match_operand:SI 1 "register_operand" "r")))
-	(match_operand:QI 0 "register_operand" "r"))]
-  "TARGET_TLS && TARGET_ARCH32"
-  "stb\t%0, [%1 + %2], %%tldo_add(%3)"
-  [(set_attr "type" "store")])
-
-(define_insn "*tldo_stb_sp64"
-  [(set (mem:QI (plus:DI (unspec:DI [(match_operand:SI 2 "register_operand" "r")
-				     (match_operand 3 "tld_symbolic_operand" "")]
-				    UNSPEC_TLSLDO)
-			 (match_operand:DI 1 "register_operand" "r")))
+(define_insn "*tldo_stb<P:mode>"
+  [(set (mem:QI (plus:P (unspec:P [(match_operand:P 2 "register_operand" "r")
+				   (match_operand 3 "tld_symbolic_operand" "")]
+				  UNSPEC_TLSLDO)
+			(match_operand:P 1 "register_operand" "r")))
 	(match_operand:QI 0 "register_operand" "r"))]
-  "TARGET_TLS && TARGET_ARCH64"
+  "TARGET_TLS"
   "stb\t%0, [%1 + %2], %%tldo_add(%3)"
   [(set_attr "type" "store")])
 
-(define_insn "*tldo_sth_sp32"
-  [(set (mem:HI (plus:SI (unspec:SI [(match_operand:SI 2 "register_operand" "r")
-				     (match_operand 3 "tld_symbolic_operand" "")]
-				    UNSPEC_TLSLDO)
-			 (match_operand:SI 1 "register_operand" "r")))
-	(match_operand:HI 0 "register_operand" "r"))]
-  "TARGET_TLS && TARGET_ARCH32"
-  "sth\t%0, [%1 + %2], %%tldo_add(%3)"
-  [(set_attr "type" "store")])
-
-(define_insn "*tldo_sth_sp64"
-  [(set (mem:HI (plus:DI (unspec:DI [(match_operand:SI 2 "register_operand" "r")
-				     (match_operand 3 "tld_symbolic_operand" "")]
-				    UNSPEC_TLSLDO)
-			 (match_operand:DI 1 "register_operand" "r")))
+(define_insn "*tldo_sth<P:mode>"
+  [(set (mem:HI (plus:P (unspec:P [(match_operand:P 2 "register_operand" "r")
+				   (match_operand 3 "tld_symbolic_operand" "")]
+				   UNSPEC_TLSLDO)
+			(match_operand:P 1 "register_operand" "r")))
 	(match_operand:HI 0 "register_operand" "r"))]
-  "TARGET_TLS && TARGET_ARCH64"
+  "TARGET_TLS"
   "sth\t%0, [%1 + %2], %%tldo_add(%3)"
   [(set_attr "type" "store")])
 
-(define_insn "*tldo_stw_sp32"
-  [(set (mem:SI (plus:SI (unspec:SI [(match_operand:SI 2 "register_operand" "r")
-				     (match_operand 3 "tld_symbolic_operand" "")]
-				    UNSPEC_TLSLDO)
-			 (match_operand:SI 1 "register_operand" "r")))
+(define_insn "*tldo_stw<P:mode>"
+  [(set (mem:SI (plus:P (unspec:P [(match_operand:P 2 "register_operand" "r")
+				   (match_operand 3 "tld_symbolic_operand" "")]
+				  UNSPEC_TLSLDO)
+			(match_operand:P 1 "register_operand" "r")))
 	(match_operand:SI 0 "register_operand" "r"))]
-  "TARGET_TLS && TARGET_ARCH32"
+  "TARGET_TLS"
   "st\t%0, [%1 + %2], %%tldo_add(%3)"
   [(set_attr "type" "store")])
 
-(define_insn "*tldo_stw_sp64"
-  [(set (mem:SI (plus:DI (unspec:DI [(match_operand:SI 2 "register_operand" "r")
-				     (match_operand 3 "tld_symbolic_operand" "")]
-				    UNSPEC_TLSLDO)
-			 (match_operand:DI 1 "register_operand" "r")))
-	(match_operand:SI 0 "register_operand" "r"))]
-  "TARGET_TLS && TARGET_ARCH64"
-  "stw\t%0, [%1 + %2], %%tldo_add(%3)"
-  [(set_attr "type" "store")])
-
 (define_insn "*tldo_stx_sp64"
-  [(set (mem:DI (plus:DI (unspec:DI [(match_operand:SI 2 "register_operand" "r")
+  [(set (mem:DI (plus:DI (unspec:DI [(match_operand:DI 2 "register_operand" "r")
 				     (match_operand 3 "tld_symbolic_operand" "")]
 				    UNSPEC_TLSLDO)
 			 (match_operand:DI 1 "register_operand" "r")))
diff --git a/gcc/config/xtensa/uclinux.h b/gcc/config/xtensa/uclinux.h
index ae023d57351..577294cfbd3 100644
--- a/gcc/config/xtensa/uclinux.h
+++ b/gcc/config/xtensa/uclinux.h
@@ -59,8 +59,8 @@ along with GCC; see the file COPYING3.  If not see
 #undef LOCAL_LABEL_PREFIX
 #define LOCAL_LABEL_PREFIX	"."
 
-/* Always enable "-fpic" for Xtensa Linux.  */
-#define XTENSA_ALWAYS_PIC 1
+/* Don't enable "-fpic" for Xtensa uclinux.  */
+#define XTENSA_ALWAYS_PIC 0
 
 #undef TARGET_LIBC_HAS_FUNCTION
 #define TARGET_LIBC_HAS_FUNCTION no_c99_libc_has_function
diff --git a/gcc/config/xtensa/xtensa.c b/gcc/config/xtensa/xtensa.c
index 9bdf870a0fd..db561e8feb7 100644
--- a/gcc/config/xtensa/xtensa.c
+++ b/gcc/config/xtensa/xtensa.c
@@ -1591,9 +1591,9 @@ xtensa_expand_atomic (enum rtx_code code, rtx target, rtx mem, rtx val,
       break;
 
     case MULT: /* NAND */
-      tmp = expand_simple_binop (SImode, XOR, old, ac.modemask,
+      tmp = expand_simple_binop (SImode, AND, old, val,
 				 NULL_RTX, 1, OPTAB_DIRECT);
-      tmp = expand_simple_binop (SImode, AND, tmp, val,
+      tmp = expand_simple_binop (SImode, XOR, tmp, ac.modemask,
 				 new_rtx, 1, OPTAB_DIRECT);
       break;
 
diff --git a/gcc/config/xtensa/xtensa.md b/gcc/config/xtensa/xtensa.md
index d5596e25d82..0eba10b742c 100644
--- a/gcc/config/xtensa/xtensa.md
+++ b/gcc/config/xtensa/xtensa.md
@@ -38,6 +38,7 @@
   (UNSPEC_MEMW		11)
   (UNSPEC_LSETUP_START  12)
   (UNSPEC_LSETUP_END    13)
+  (UNSPEC_FRAME_BLOCKAGE 14)
 
   (UNSPECV_SET_FP	1)
   (UNSPECV_ENTRY	2)
@@ -1676,6 +1677,32 @@
 
 ;; Miscellaneous instructions.
 
+;; In windowed ABI stack pointer adjustment must happen before any access
+;; to the space allocated on stack is allowed, otherwise register spill
+;; area may be clobbered.  That's what frame blockage is supposed to enforce.
+
+(define_expand "allocate_stack"
+  [(set (match_operand 0 "nonimmed_operand")
+        (minus (reg A1_REG) (match_operand 1 "add_operand")))
+   (set (reg A1_REG)
+        (minus (reg A1_REG) (match_dup 1)))]
+  "TARGET_WINDOWED_ABI"
+{
+  if (CONST_INT_P (operands[1]))
+    {
+      rtx neg_op0 = GEN_INT (-INTVAL (operands[1]));
+      emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx, neg_op0));
+    }
+  else
+    {
+      emit_insn (gen_subsi3 (stack_pointer_rtx, stack_pointer_rtx,
+			     operands[1]));
+    }
+  emit_move_insn (operands[0], virtual_stack_dynamic_rtx);
+  emit_insn (gen_frame_blockage ());
+  DONE;
+})
+
 (define_expand "prologue"
   [(const_int 0)]
   ""
@@ -1767,6 +1794,25 @@
   [(set_attr "length" "0")
    (set_attr "type" "nop")])
 
+;; Do not schedule instructions accessing memory before this point.
+
+(define_expand "frame_blockage"
+  [(set (match_dup 0)
+        (unspec:BLK [(match_dup 1)] UNSPEC_FRAME_BLOCKAGE))]
+  ""
+{
+  operands[0] = gen_rtx_MEM (BLKmode, gen_rtx_SCRATCH (Pmode));
+  MEM_VOLATILE_P (operands[0]) = 1;
+  operands[1] = stack_pointer_rtx;
+})
+
+(define_insn "*frame_blockage"
+  [(set (match_operand:BLK 0 "" "")
+        (unspec:BLK [(match_operand:SI 1 "" "")] UNSPEC_FRAME_BLOCKAGE))]
+  ""
+  ""
+  [(set_attr "length" "0")])
+
 (define_insn "trap"
   [(trap_if (const_int 1) (const_int 0))]
   ""
diff --git a/gcc/configure b/gcc/configure
index 043a62b0de9..5dab9142e1a 100755
--- a/gcc/configure
+++ b/gcc/configure
@@ -11871,7 +11871,7 @@ EOF
 # Check whether --with-gcc-major-version-only was given.
 if test "${with_gcc_major_version_only+set}" = set; then :
   withval=$with_gcc_major_version_only; if test x$with_gcc_major_version_only = xyes ; then
-        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*\$\$/\1/'"
+        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*/\1/'"
       fi
 
 fi
@@ -23571,6 +23571,14 @@ $as_echo "$gcc_cv_as_shf_merge" >&6; }
 
 
 fi
+case "$target" in
+  i?86-*-solaris2.10* | x86_64-*-solaris2.10*)
+    # SHF_MERGE support in Solaris 10/x86 ld is broken.
+    if test x"$gnu_ld" = xno; then
+      gcc_cv_as_shf_merge=no
+    fi
+    ;;
+esac
 
 cat >>confdefs.h <<_ACEOF
 #define HAVE_GAS_SHF_MERGE `if test $gcc_cv_as_shf_merge = yes; then echo 1; else echo 0; fi`
@@ -25217,6 +25225,7 @@ $as_echo "#define HAVE_AS_SPARC5_VIS4 1" >>confdefs.h
 
 fi
 
+
     { $as_echo "$as_me:${as_lineno-$LINENO}: checking assembler for SPARC6 instructions" >&5
 $as_echo_n "checking assembler for SPARC6 instructions... " >&6; }
 if test "${gcc_cv_as_sparc_sparc6+set}" = set; then :
@@ -25253,6 +25262,7 @@ $as_echo "#define HAVE_AS_SPARC6 1" >>confdefs.h
 
 fi
 
+
     { $as_echo "$as_me:${as_lineno-$LINENO}: checking assembler for LEON instructions" >&5
 $as_echo_n "checking assembler for LEON instructions... " >&6; }
 if test "${gcc_cv_as_sparc_leon+set}" = set; then :
@@ -29777,8 +29787,10 @@ _ACEOF
 
 # Generate gcc-driver-name.h containing GCC_DRIVER_NAME for the benefit
 # of jit/jit-playback.c.
+gcc_driver_version=`eval "${get_gcc_base_ver} $srcdir/BASE-VER"`
+echo "gcc_driver_version: ${gcc_driver_version}"
 cat > gcc-driver-name.h <<EOF
-#define GCC_DRIVER_NAME "${target_noncanonical}-gcc-${gcc_BASEVER}${exeext}"
+#define GCC_DRIVER_NAME "${target_noncanonical}-gcc-${gcc_driver_version}${exeext}"
 EOF
 
 # Check whether --enable-default-pie was given.
diff --git a/gcc/configure.ac b/gcc/configure.ac
index 2b52da3bbcc..e1fa8af5e4f 100644
--- a/gcc/configure.ac
+++ b/gcc/configure.ac
@@ -2946,6 +2946,14 @@ if test $gcc_cv_as_shf_merge = no; then
     [elf,2,12,0], [--fatal-warnings],
     [.section .rodata.str, "aMS", %progbits, 1])
 fi
+case "$target" in
+  i?86-*-solaris2.10* | x86_64-*-solaris2.10*)
+    # SHF_MERGE support in Solaris 10/x86 ld is broken.
+    if test x"$gnu_ld" = xno; then
+      gcc_cv_as_shf_merge=no
+    fi
+    ;;
+esac
 AC_DEFINE_UNQUOTED(HAVE_GAS_SHF_MERGE,
   [`if test $gcc_cv_as_shf_merge = yes; then echo 1; else echo 0; fi`],
 [Define 0/1 if your assembler supports marking sections with SHF_MERGE flag.])
@@ -6292,8 +6300,10 @@ AC_DEFINE_UNQUOTED(DIAGNOSTICS_COLOR_DEFAULT, $DIAGNOSTICS_COLOR_DEFAULT,
 
 # Generate gcc-driver-name.h containing GCC_DRIVER_NAME for the benefit
 # of jit/jit-playback.c.
+gcc_driver_version=`eval "${get_gcc_base_ver} $srcdir/BASE-VER"`
+echo "gcc_driver_version: ${gcc_driver_version}"
 cat > gcc-driver-name.h <<EOF
-#define GCC_DRIVER_NAME "${target_noncanonical}-gcc-${gcc_BASEVER}${exeext}"
+#define GCC_DRIVER_NAME "${target_noncanonical}-gcc-${gcc_driver_version}${exeext}"
 EOF
 
 # Check whether --enable-default-pie was given.
diff --git a/gcc/cp/ChangeLog b/gcc/cp/ChangeLog
index b5d15c7b615..f9d98365517 100644
--- a/gcc/cp/ChangeLog
+++ b/gcc/cp/ChangeLog
@@ -1,3 +1,660 @@
+2019-04-10  Matthias Klose  <doko@ubuntu.com>
+
+	Backport from the gcc-8 branch
+	2019-03-07  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/89585
+	* parser.c (cp_parser_asm_definition): Parse asm qualifiers even
+	at toplevel, but diagnose them.
+
+2018-01-02  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	Backport from trunk
+	2018-12-06  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	PR inline-asm/55681
+	* parser.c (cp_parser_asm_definition): Update grammar.  Allow any
+	combination of volatile and goto, in any order, without repetitions.
+
+	Backport from trunk
+	2018-12-06  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	* cp-tree.h (finish_asm_stmt): Update declaration.
+	* parser.c (cp_parser_asm_definition): Detect the inline keyword
+	after asm.  Pass a flag for it to finish_asm_stmt.
+	* pt.c (tsubst_expr): Pass the ASM_INLINE_P flag to finish_asm_stmt.
+	* semantics.c (finish_asm_stmt): Add inline_p parameter.  Use it to
+	set ASM_INLINE_P.
+
+	Backport from trunk
+	2018-12-19  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	* parser.c (cp_parser_asm_definition): Rewrite the loop to work without
+	"done" boolean variable.
+
+	Backport from trunk
+	2018-12-19  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	* parser.c (cp_parser_asm_definition): Rewrite the loop to work without
+	"done" boolean variable.
+	* parser.c (cp_parser_asm_definition): Keep track of the location each
+	asm qualifier is first seen; use that to give nicer "duplicate asm
+	qualifier" messages.
+
+	Backport from trunk
+	2018-12-19  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	* parser.c (cp_parser_asm_definition) <RID_CONST, RID_RESTRICT>: Give
+	a more specific error message (instead of just falling through).
+
+	Backport from trunk
+	2018-12-10  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	* parser.c (cp_parser_asm_definition): Do not allow any asm qualifiers
+	on top-level asm.
+
+2018-12-06  Release Manager
+
+	* GCC 7.4.0 released.
+
+2018-11-26  Richard Biener  <rguenther@suse.de>
+
+	PR c++/84281
+	* constexpr.c (cxx_eval_vec_init_1): Use a RANGE_EXPR to compact
+	uniform constructors and delay allocating them fully.
+
+2018-11-26  Jason Merrill  <jason@redhat.com>
+
+	PR c++/87075 - ICE with constexpr array initialization.
+	* constexpr.c (cxx_eval_vec_init_1): Handle trivial initialization.
+
+2018-10-23  Tom de Vries  <tdevries@suse.de>
+
+	backport from trunk:
+	2018-07-31  Tom de Vries  <tdevries@suse.de>
+
+	PR debug/86687
+	* optimize.c (update_cloned_parm): Copy DECL_BY_REFERENCE.
+
+2018-10-12  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-07-16  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/3698
+	PR c++/86208
+	* cp-gimplify.c (cp_genericize_r): When using extern_decl_map, or
+	in TREE_USED flag from stmt to h->to.
+
+2018-08-17  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2018-08-02  Richard Biener  <rguenther@suse.de>
+
+	PR c++/86763
+	* class.c (layout_class_type): Copy TYPE_TYPELESS_STORAGE
+	to the CLASSTYPE_AS_BASE.
+
+2018-08-10  Jason Merrill  <jason@redhat.com>
+
+	PR c++/86728 - C variadic generic lambda.
+	* parser.c (cp_parser_parameter_declaration): Don't turn 'auto' into
+	a pack if it's followed by a declarator-id.
+
+2018-07-03  Jason Merrill  <jason@redhat.com>
+
+	PR c++/86378 - functional cast in noexcept-specifier.
+	* tree.c (strip_typedefs_expr) [TREE_LIST]: Fix iteration.
+
+2018-06-26  Jason Merrill  <jason@redhat.com>
+
+	PR c++/80290 - memory-hog with std::pair.
+	* pt.c (type_unification_real): Skip non-dependent conversion
+	check for a nested list argument.
+	(braced_init_depth): New.
+
+2018-06-26  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/86291
+	* parser.c (cp_parser_omp_for_loop_init): Change for_block argument
+	type from vec<tree, va_gc> * to vec<tree, va_gc> *&.
+
+2018-06-22  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-05-29  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/85952
+	* init.c (build_aggr_init): For structured binding initialized from
+	array call mark_rvalue_use on the initializer.
+
+	2018-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/85696
+	* cp-tree.h (cxx_omp_predetermined_sharing_1): New prototype.
+	* cp-gimplify.c (cxx_omp_predetermined_sharing): New wrapper around
+	cxx_omp_predetermined_sharing_1.  Rename old function to ...
+	(cxx_omp_predetermined_sharing_1): ... this.
+	* semantics.c (finish_omp_clauses): Use cxx_omp_predetermined_sharing_1
+	instead of cxx_omp_predetermined_sharing.
+
+	2018-05-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/85662
+	* cp-gimplify.c (cp_fold): Use fold_offsetof rather than
+	fold_offsetof_1, pass TREE_TYPE (x) as TYPE to it and drop the
+	fold_convert.
+
+	2018-04-18  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/84463
+	* typeck.c (cp_build_addr_expr_1): Move handling of offsetof-like
+	tricks from here to ...
+	* cp-gimplify.c (cp_fold) <case ADDR_EXPR>: ... here.  Only use it
+	if INDIRECT_REF's operand is INTEGER_CST cast to pointer type.
+
+	2018-04-06  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/85210
+	* pt.c (tsubst_decomp_names): Return error_mark_node and assert
+	errorcount is set if tsubst doesn't return a VAR_DECL.
+
+	2018-04-05  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/85208
+	* decl.c (start_decl): For DECL_DECOMPOSITION_P decls, don't call
+	maybe_apply_pragma_weak here...
+	(cp_maybe_mangle_decomp): ... but call it here instead.
+
+	2018-04-04  Jakub Jelinek  <jakub@redhat.com>
+
+	PR inline-asm/85172
+	* constexpr.c (cxx_eval_builtin_function_call): For calls to
+	builtin_valid_in_constant_expr_p functions, don't call
+	cxx_eval_constant_expression if argument is not
+	potential_constant_expression.
+
+	2018-04-03  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/85147
+	* pt.c (fixed_parameter_pack_p_1): Punt if parm is error_mark_node.
+
+	PR c++/85140
+	* name-lookup.c (handle_namespace_attrs): Return early if attributes
+	is error_mark_node.
+
+	2018-03-30  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/84791
+	* semantics.c (finish_omp_reduction_clause): If
+	OMP_CLAUSE_REDUCTION_PLACEHOLDER is error_mark_node, return true
+	even if processing_template_decl.
+
+	2018-03-27  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/85076
+	* tree.c (cp_build_reference_type): If to_type is error_mark_node,
+	return it right away.
+
+	PR c++/85068
+	* class.c (update_vtable_entry_for_fn): Don't ICE if base_binfo
+	is NULL.  Assert if thunk_binfo is NULL then errorcount is non-zero.
+
+	2018-03-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/84961
+	* cp-tree.h (genericize_compound_lvalue): Declare.
+	* typeck.c (genericize_compound_lvalue): New function.
+	(unary_complex_lvalue, cp_build_modify_expr): Use it.
+	* semantics.c (finish_asm_stmt): Replace MODIFY_EXPR, PREINCREMENT_EXPR
+	and PREDECREMENT_EXPR in output and "m" constrained input operands with
+	COMPOUND_EXPR.  Call cxx_mark_addressable on the rightmost
+	COMPOUND_EXPR operand.
+
+	2018-03-16  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/84874
+	* decl.c (reshape_init_class): Don't assert d->cur->index == field
+	if d->cur->index is a FIELD_DECL, instead set field to d->cur->index.
+
+	2018-03-15  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/84222
+	* cp-tree.h (cp_warn_deprecated_use): Declare.
+	* tree.c (cp_warn_deprecated_use): New function.
+	* typeck2.c (build_functional_cast): Use it.
+	* decl.c (grokparms): Likewise.
+	(grokdeclarator): Likewise.  Temporarily push nested class scope
+	around grokparms call for out of class member definitions.
+
+	2018-03-09  Jason Merrill  <jason@redhat.com>
+		    Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/84076
+	* call.c (convert_arg_to_ellipsis): Instead of cp_build_addr_expr
+	build ADDR_EXPR with REFERENCE_TYPE.
+	(build_over_call): For purposes of check_function_arguments, if
+	argarray[j] is ADDR_EXPR with REFERENCE_TYPE created above, use
+	its operand rather than the argument itself.
+
+	2018-03-08  Jason Merrill  <jason@redhat.com>
+		    Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/80598
+	* call.c (build_over_call): In templates set TREE_USED (first_fn) when
+	not calling mark_used for the benefit of -Wunused-function warning.
+
+	2018-03-02  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/84662
+	* pt.c (tsubst_copy_and_build) <case TEMPLATE_ID_EXPR>: Use
+	RETURN instead of return.
+	<case POINTER_PLUS_EXPR>: Likewise.
+	<case CONVERT_EXPR>: If op0 is error_mark_node, just return
+	it instead of wrapping it into CONVERT_EXPR.
+
+2018-06-12  Jason Merrill  <jason@redhat.com>
+
+	PR c++/85815 - reference to member of enclosing template.
+	* parser.c (cp_parser_postfix_dot_deref_expression): Check
+	currently_open_class.
+
+	PR c++/86060 - ICE on range for with -std=c++98.
+	* parser.c (cp_parser_init_statement): Don't clobber *decl after
+	pedwarn.
+
+2018-05-07  Jason Merrill  <jason@redhat.com>
+
+	PR c++/85646 - lambda visibility.
+	* decl2.c (determine_visibility): Don't mess with template arguments
+	from the containing scope.
+	(vague_linkage_p): Check DECL_ABSTRACT_P before looking at a 'tor
+	thunk.
+
+2018-04-23  Ville Voutilainen  <ville.voutilainen@gmail.com>
+
+	Backport from mainline
+	2018-04-05  Ville Voutilainen  <ville.voutilainen@gmail.com>
+
+	Implement P0969
+	* decl.c (find_decomp_class_base): Check accessibility instead
+	of declared access, adjust diagnostic.
+
+2018-04-23  Jakub Jelinek  <jakub@redhat.com>
+	    Jason Merrill  <jason@redhat.com>
+
+	PR c++/85470 - wrong error with static data member.
+	* decl.c (check_initializer): Check DECL_INITIALIZED_IN_CLASS_P.
+	* typeck2.c (store_init_value): Likewise.
+
+2018-04-23  Ville Voutilainen  <ville.voutilainen@gmail.com>
+
+	Backport from mainline
+	2018-04-05  Ville Voutilainen  <ville.voutilainen@gmail.com>
+
+	Implement P0961
+	* decl.c (get_tuple_decomp_init): Check the templatedness
+	of a member get.
+
+2018-04-19  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR c++/85464 - missing location for -Wignored-qualifiers diagnostic
+	* decl.c (grokdeclarator): If declspecs->locations[ds_type_spec]
+	is UNKNOWN_LOCATION fall back to input_location.
+
+2018-04-09  Jason Merrill  <jason@redhat.com>
+
+	PR c++/85279 - dump_expr doesn't understand decltype.
+	* error.c (dump_expr): Handle DECLTYPE_TYPE.
+
+2018-04-05  Jason Merrill  <jason@redhat.com>
+
+	PR c++/82152 - ICE with class deduction and inherited ctor.
+	* pt.c (do_class_deduction): Ignore inherited ctors.
+
+	PR c++/84665 - ICE with array of empty class.
+	* decl2.c (cp_check_const_attributes): Use fold_non_dependent_expr.
+
+	PR c++/85006 - -fconcepts ICE with A<auto...> return type
+	* pt.c (tsubst_pack_expansion): Allow unsubstituted auto pack.
+
+2018-04-04  Jason Merrill  <jason@redhat.com>
+
+	PR c++/85118 - wrong error with generic lambda and std::bind.
+	* call.c (add_template_conv_candidate): Disable if there are any
+	call operators.
+
+	PR c++/85148 - ICE with 'this' in array NSDMI.
+	* tree.c (replace_placeholders_r): Use handled_component_p.
+
+2018-04-03  Jason Merrill  <jason@redhat.com>
+
+	PR c++/85113 - ICE with constexpr and __builtin_constant_p.
+	* constexpr.c (cxx_eval_builtin_function_call): Only defer
+	__builtin_constant_p if ctx->quiet.
+
+	* typeck.c (merge_types): Limit matching attribute shortcut to
+	the default case.
+
+	PR c++/64095 - auto... parameter pack.
+	* parser.c (cp_parser_parameter_declaration): Handle turning autos
+	into packs here.
+	(cp_parser_parameter_declaration_list): Not here.
+
+	PR c++/85060 - wrong-code with call to base member in template.
+	* search.c (any_dependent_bases_p): Check uses_template_parms
+	rather than processing_template_decl.
+
+2018-03-29  Ville Voutilainen  <ville.voutilainen@gmail.com>
+
+	Backport from mainline
+	2018-03-23  Ville Voutilainen  <ville.voutilainen@gmail.com>
+
+	Implement P0962
+	* parser.c (cp_parser_perform_range_for_lookup): Change
+	the condition for deciding whether to use members.
+
+2018-03-23  Jason Merrill  <jason@redhat.com>
+
+	PR c++/78489 - Substitution in wrong order
+	PR c++/84489
+	* pt.c (type_unification_real): Revert last two changes.
+
+	PR c++/71834 - template-id with too few arguments.
+	* pt.c (coerce_template_parms): Make sure we gave an error.
+
+	PR c++/84937 - ICE with class deduction and auto.
+	* pt.c (rewrite_template_parm): Fix auto handling.
+
+	PR c++/80227 - SFINAE and negative array size.
+	* decl.c (compute_array_index_type): Convert to signed for negative
+	check.
+
+	PR c++/84839 - ICE with decltype of parameter pack.
+	* pt.c (tsubst_pack_expansion): Set cp_unevaluated_operand while
+	instantiating dummy parms.
+
+	PR c++/84798 - ICE with auto in abstract function declarator.
+	* parser.c (cp_parser_parameter_declaration_clause): Check
+	parser->default_arg_ok_p.
+
+	PR c++/84355 - ICE with deduction for member class template.
+	* pt.c (tsubst) [TEMPLATE_TYPE_PARM]: Always substitute into
+	CLASS_PLACEHOLDER_TEMPLATE.
+
+2018-03-23  Paolo Carlini  <paolo.carlini@oracle.com>
+	    Jason Merrill  <jason@redhat.com>
+
+	PR c++/82336 - link error with list-init default argument.
+	* decl.c (check_default_argument): Unshare an initializer list.
+
+2018-03-22  Marek Polacek  <polacek@redhat.com>
+
+	Backported from mainline
+	2018-03-22  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/84854
+	* semantics.c (finish_if_stmt_cond): Check if the type of the condition
+	is boolean.
+
+	2018-03-19  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/84927
+	* constexpr.c (cxx_eval_bare_aggregate): Update constructor's flags
+	as we evaluate the elements.
+	(cxx_eval_constant_expression): Verify constructor's flags
+	unconditionally.
+
+	2018-03-21  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/71638, ICE with NSDMI and reference.
+	* constexpr.c (cxx_eval_bare_aggregate): Update constructor's flags
+	even when we replace an element.
+
+2018-03-09  Jason Merrill  <jason@redhat.com>
+
+	PR c++/84785 - ICE with alias template and default targs.
+	* pt.c (type_unification_real): Set processing_template_decl if
+	saw_undeduced == 1.
+
+2018-03-07  Marek Polacek  <polacek@redhat.com>
+
+	Backported from mainline
+	2018-03-06  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/84684
+	* constexpr.c (cxx_bind_parameters_in_call): Unshare evaluated
+	arguments.
+
+2018-03-03  Jason Merrill  <jason@redhat.com>
+
+	PR c++/84686 - missing volatile loads.
+	* cvt.c (convert_to_void): Call maybe_undo_parenthesized_ref.
+
+2018-03-03  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-02-26  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/84558
+	* constexpr.c (cxx_eval_vec_init_1): For reuse, treat NULL eltinit like
+	a valid constant initializer.  Formatting fixes.
+
+	PR c++/84557
+	* parser.c (cp_parser_omp_var_list_no_open): Only call
+	cp_parser_lookup_name_simple on names satisfying identifier_p.
+	(cp_parser_oacc_routine): Likewise.
+
+	2018-02-20  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/84445
+	* class.c (fixed_type_or_null) <case CALL_EXPR>: Only test
+	TREE_HAS_CONSTRUCTOR if instance is not an internal function call.
+
+	PR c++/84449
+	* tree.c (bot_manip): If build_cplus_new or break_out_target_exprs
+	returns error_mark_node, return it immediately.
+	(break_out_target_exprs): If cp_walk_tree with bot_manip returns
+	error_mark_node, return error_mark_node.
+
+	2018-02-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/84448
+	* parser.c (cp_parser_binary_expression): For no_toplevel_fold_p, if
+	either operand is error_mark_node, set current.lhs to that instead of
+	creating a binary op with error_mark_node operands.
+
+	PR c++/84430
+	* constexpr.c (potential_constant_expression_1): Handle OMP_SIMD.
+
+	2018-02-16  Marek Polacek  <polacek@redhat.com>
+		    Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/84192
+	* constexpr.c (cxx_eval_constant_expression) <case RETURN_EXPR>: Don't
+	set *jump_target to anything if jump_target is NULL.
+
+	2018-02-12  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/84341
+	* parser.c (cp_parser_binary_expression): Use build_min instead of
+	build2_loc to build the no_toplevel_fold_p toplevel binary expression.
+
+	2018-02-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR sanitizer/83987
+	* tree.c (cp_free_lang_data): Revert 2018-01-23 change.
+
+	2018-02-09  Marek Polacek  <polacek@redhat.com>
+		    Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/83659
+	* constexpr.c (cxx_fold_indirect_ref): Sync some changes from
+	fold_indirect_ref_1.  Verify first that tree_fits_shwi_p (op01).
+	Formatting fixes.
+
+	2018-02-07  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/84082
+	* parser.c (cp_parser_dot_deref_incomplete): New function.
+	(cp_parser_postfix_dot_deref_expression): Use it.
+
+	2018-01-31  Jason Merrill  <jason@redhat.com>
+		    Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/83993
+	* constexpr.c (cxx_eval_outermost_constant_expr): Build NOP_EXPR
+	around non-constant ADDR_EXPRs rather than clearing TREE_CONSTANT
+	on ADDR_EXPR.
+
+	2018-01-25  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/84031
+	* decl.c (find_decomp_class_base): Ignore unnamed bitfields.  Ignore
+	recursive calls that return ret.
+	(cp_finish_decomp): Ignore unnamed bitfields.
+
+	2018-01-23  Jakub Jelinek  <jakub@redhat.com>
+
+	PR sanitizer/83987
+	* tree.c (cp_free_lang_data): Change DECL_VALUE_EXPR of
+	DECL_OMP_PRIVATIZED_MEMBER vars to error_mark_node.
+
+	PR c++/83958
+	* decl.c (cp_finish_decomp): Diagnose if reference structure binding
+	refers to incomplete type.
+
+	2018-01-18  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/83824
+	* parser.c (attr_chainon): New function.
+	(cp_parser_label_for_labeled_statement, cp_parser_decl_specifier_seq,
+	cp_parser_namespace_definition, cp_parser_init_declarator,
+	cp_parser_type_specifier_seq, cp_parser_parameter_declaration,
+	cp_parser_gnu_attributes_opt): Use it.
+	(cp_parser_member_declaration, cp_parser_objc_class_ivars,
+	cp_parser_objc_struct_declaration): Likewise.  Don't reset
+	prefix_attributes if attributes is error_mark_node.
+
+	2018-01-16  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/83817
+	* pt.c (tsubst_copy_and_build) <case CALL_EXPR>: If function
+	is AGGR_INIT_EXPR rather than CALL_EXPR, set AGGR_INIT_FROM_THUNK_P
+	instead of CALL_FROM_THUNK_P.
+
+2018-03-02  Jason Merrill  <jason@redhat.com>
+
+	Fix MIPS16 ICE.
+	* pt.c (type_dependent_expression_p): Check DECL_LANG_SPECIFIC.
+
+2018-02-27  Jason Merrill  <jason@redhat.com>
+
+	PR c++/84489 - dependent default template argument
+	* pt.c (type_unification_real): Handle early substitution failure.
+
+2018-03-01  Jason Merrill  <jason@redhat.com>
+
+	PR c++/71569 - decltype of template.
+	* parser.c (cp_parser_decltype_expr): Handle missing template args.
+
+2018-03-01  Jason Merrill  <jason@redhat.com>
+	    Alexandre Oliva <aoliva@redhat.com>
+
+	PR c++/71569 - ICE with redundant args on member variable template.
+	* decl.c (start_decl): Handle partial specialization of member
+	variable template.
+	* pt.c (determine_specialization): Allow partial specialization
+	of member variable template without specializing enclosing class.
+	(process_partial_specialization): Improve error message.
+
+2018-02-28  Jason Merrill  <jason@redhat.com>
+
+	PR c++/71784 - ICE with ref-qualifier and explicit specialization.
+	* pt.c (determine_specialization): Check ref-qualifier.
+
+2018-02-27  Jason Merrill  <jason@redhat.com>
+
+	PR c++/84496 - ICE with generic lambda in lambda.
+	* pt.c (type_dependent_expression_p): Fix dependency checking of
+	functions without DECL_TEMPLATE_INFO.
+
+2018-02-26  Jason Merrill  <jason@redhat.com>
+
+	PR c++/84441 - ICE with base initialized from ?:
+	* call.c (unsafe_copy_elision_p): Handle COND_EXPR.
+
+	PR c++/84520 - ICE with generic lambda in NSDMI.
+	* lambda.c (lambda_expr_this_capture): Don't look for fake NSDMI
+	'this' in a generic lambda instantiation.
+
+2018-02-26  Jason Merrill  <jason@redhat.com>
+	    Ville Voutilainen  <ville.voutilainen@gmail.com>
+
+	PR c++/81589 - error with is_trivially_constructible.
+	* method.c (constructible_expr): Set cp_unevaluated.
+
+2018-02-25  Jason Merrill  <jason@redhat.com>
+
+	PR c++/84015 - ICE with class deduction and auto template parm.
+	* pt.c (rewrite_template_parm): Use tf_partial in first tsubst.
+
+2018-02-19  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2017-08-29  Jason Merrill  <jason@redhat.com>
+
+	Fix lambdas in template default argument of inherited ctor.
+	* method.c (synthesized_method_base_walk): Replace an inherited
+	template with its specialization.
+	(synthesized_method_walk): Make inheriting_ctor a pointer.
+	(maybe_explain_implicit_delete, explain_implicit_non_constexpr)
+	(deduce_inheriting_ctor, implicitly_declare_fn): Adjust.
+
+2018-02-16  Jason Merrill  <jason@redhat.com>
+
+	PR c++/84151 - unnecessary volatile load with static member.
+	* call.c (build_new_method_call_1): Avoid loading from a volatile
+	lvalue used as the object argument for a static member function.
+
+	PR c++/81853 - using-directive and constexpr.
+	* constexpr.c (cxx_eval_constant_expression): Handle USING_STMT.
+
+	PR c++/84420 - ICE with structured binding in lambda.
+	* lambda.c (is_capture_proxy): Check DECL_DECOMPOSITION_P.
+
+	PR c++/83835 - C++17 error with constructor ctors.
+	* call.c (build_special_member_call): Set TARGET_EXPR_DIRECT_INIT_P.
+
+	PR c++/82664 - ICE with reference to function template parm.
+	* pt.c (convert_nontype_argument_function): Avoid obfuscationg
+	NOP_EXPRs.
+
+	PR c++/82764 - C++17 ICE with empty base
+	* class.c (build_base_field_1): Set DECL_SIZE to zero for empty base.
+
+	PR c++/83227 - C++17 ICE with init-list derived-to-base conversion.
+	* call.c (convert_like_real): Don't use the copy-list-initialization
+	shortcut for ck_base.
+
+	PR c++/84045 - ICE with typedef and noexcept.
+	* except.c (build_noexcept_spec): Use strip_typedefs_expr.
+
+2018-01-29  Jason Merrill  <jason@redhat.com>
+
+	PR c++/82461 - constexpr list-initialized member
+	* constexpr.c (potential_constant_expression_1): Check
+	TARGET_EXPR_DIRECT_INIT_P.
+
+2018-01-26  Nathan Sidwell  <nathan@acm.org>
+
+	PR c++/82878
+	PR c++/78495
+	* call.c (build_call_a): Don't set CALL_FROM_THUNK_P for inherited
+	ctor.
+	* cp-gimplify.c	(cp_genericize_r): Restore THUNK dereference
+	inhibibition check removed in previous c++/78495 change.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
diff --git a/gcc/cp/call.c b/gcc/cp/call.c
index 56f6b93230b..5145e438460 100644
--- a/gcc/cp/call.c
+++ b/gcc/cp/call.c
@@ -375,18 +375,10 @@ build_call_a (tree function, int n, tree *argarray)
 
   TREE_HAS_CONSTRUCTOR (function) = (decl && DECL_CONSTRUCTOR_P (decl));
 
-  if (current_function_decl && decl
-      && flag_new_inheriting_ctors
-      && DECL_INHERITED_CTOR (current_function_decl)
-      && (DECL_INHERITED_CTOR (current_function_decl)
-	  == DECL_CLONED_FUNCTION (decl)))
-    /* Pass arguments directly to the inherited constructor.  */
-    CALL_FROM_THUNK_P (function) = true;
-
   /* Don't pass empty class objects by value.  This is useful
      for tags in STL, which are used to control overload resolution.
      We don't need to handle other cases of copying empty classes.  */
-  else if (! decl || ! DECL_BUILT_IN (decl))
+  if (! decl || ! DECL_BUILT_IN (decl))
     for (i = 0; i < n; i++)
       {
 	tree arg = CALL_EXPR_ARG (function, i);
@@ -3267,10 +3259,10 @@ add_template_conv_candidate (struct z_candidate **candidates, tree tmpl,
 			     tree return_type, tree access_path,
 			     tree conversion_path, tsubst_flags_t complain)
 {
-  /* Making this work broke PR 71117, so until the committee resolves core
-     issue 2189, let's disable this candidate if there are any viable call
+  /* Making this work broke PR 71117 and 85118, so until the committee resolves
+     core issue 2189, let's disable this candidate if there are any call
      operators.  */
-  if (any_strictly_viable (*candidates))
+  if (*candidates)
     return NULL;
 
   return
@@ -6886,6 +6878,11 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,
 	  && DECL_INHERITED_CTOR (current_function_decl))
 	return expr;
 
+      if (TREE_CODE (expr) == TARGET_EXPR
+	  && TARGET_EXPR_LIST_INIT_P (expr))
+	/* Copy-list-initialization doesn't actually involve a copy.  */
+	return expr;
+
       /* Fall through.  */
     case ck_base:
       if (convs->kind == ck_base && !convs->need_temporary_p)
@@ -6911,10 +6908,6 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,
 	flags |= LOOKUP_ONLYCONVERTING;
       if (convs->rvaluedness_matches_p)
 	flags |= LOOKUP_PREFER_RVALUE;
-      if (TREE_CODE (expr) == TARGET_EXPR
-	  && TARGET_EXPR_LIST_INIT_P (expr))
-	/* Copy-list-initialization doesn't actually involve a copy.  */
-	return expr;
       expr = build_temp (expr, totype, flags, &diag_kind, complain);
       if (diag_kind && complain)
 	{
@@ -7151,7 +7144,7 @@ convert_arg_to_ellipsis (tree arg, tsubst_flags_t complain)
 		     "passing objects of non-trivially-copyable "
 		     "type %q#T through %<...%> is conditionally supported",
 		     arg_type);
-	  return cp_build_addr_expr (arg, complain);
+	  return build1 (ADDR_EXPR, build_reference_type (arg_type), arg);
 	}
       /* Build up a real lvalue-to-rvalue conversion in case the
 	 copy constructor is trivial but not callable.  */
@@ -7525,6 +7518,15 @@ unsafe_copy_elision_p (tree target, tree exp)
   /* build_compound_expr pushes COMPOUND_EXPR inside TARGET_EXPR.  */
   while (TREE_CODE (init) == COMPOUND_EXPR)
     init = TREE_OPERAND (init, 1);
+  if (TREE_CODE (init) == COND_EXPR)
+    {
+      /* We'll end up copying from each of the arms of the COND_EXPR directly
+	 into the target, so look at them. */
+      if (tree op = TREE_OPERAND (init, 1))
+	if (unsafe_copy_elision_p (target, op))
+	  return true;
+      return unsafe_copy_elision_p (target, TREE_OPERAND (init, 2));
+    }
   return (TREE_CODE (init) == AGGR_INIT_EXPR
 	  && !AGGR_INIT_VIA_CTOR_P (init));
 }
@@ -7566,6 +7568,10 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)
 
       if (undeduced_auto_decl (fn))
 	mark_used (fn, complain);
+      else
+	/* Otherwise set TREE_USED for the benefit of -Wunused-function.
+	   See PR80598.  */
+	TREE_USED (fn) = 1;
 
       return_type = TREE_TYPE (TREE_TYPE (fn));
       nargs = vec_safe_length (args);
@@ -7929,7 +7935,15 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)
       tree *fargs = (!nargs ? argarray
 			    : (tree *) alloca (nargs * sizeof (tree)));
       for (j = 0; j < nargs; j++)
-	fargs[j] = maybe_constant_value (argarray[j]);
+	{
+	  /* For -Wformat undo the implicit passing by hidden reference
+	     done by convert_arg_to_ellipsis.  */
+	  if (TREE_CODE (argarray[j]) == ADDR_EXPR
+	      && TREE_CODE (TREE_TYPE (argarray[j])) == REFERENCE_TYPE)
+	    fargs[j] = TREE_OPERAND (argarray[j], 0);
+	  else
+	    fargs[j] = maybe_constant_value (argarray[j]);
+	}
 
       warned_p = check_function_arguments (input_location, fn, TREE_TYPE (fn),
 					   nargs, fargs);
@@ -8399,6 +8413,9 @@ build_special_member_call (tree instance, tree name, vec<tree, va_gc> **args,
 	{
 	  if (is_dummy_object (instance))
 	    return arg;
+	  else if (TREE_CODE (arg) == TARGET_EXPR)
+	    TARGET_EXPR_DIRECT_INIT_P (arg) = true;
+
 	  if ((complain & tf_error)
 	      && (flags & LOOKUP_DELEGATING_CONS))
 	    check_self_delegation (arg);
@@ -8851,8 +8868,14 @@ build_new_method_call_1 (tree instance, tree fns, vec<tree, va_gc> **args,
 	      if (TREE_CODE (TREE_TYPE (fn)) != METHOD_TYPE
 		  && !is_dummy_object (instance)
 		  && TREE_SIDE_EFFECTS (instance))
-		call = build2 (COMPOUND_EXPR, TREE_TYPE (call),
-			       instance, call);
+		{
+		  /* But avoid the implicit lvalue-rvalue conversion when 'a'
+		     is volatile.  */
+		  tree a = instance;
+		  if (TREE_THIS_VOLATILE (a))
+		    a = build_this (a);
+		  call = build2 (COMPOUND_EXPR, TREE_TYPE (call), a, call);
+		}
 	      else if (call != error_mark_node
 		       && DECL_DESTRUCTOR_P (cand->fn)
 		       && !VOID_TYPE_P (TREE_TYPE (call)))
diff --git a/gcc/cp/class.c b/gcc/cp/class.c
index c6f8f3fa41d..688cc0e58d3 100644
--- a/gcc/cp/class.c
+++ b/gcc/cp/class.c
@@ -2732,19 +2732,20 @@ update_vtable_entry_for_fn (tree t, tree binfo, tree fn, tree* virtuals,
 	     order.  Of course it is lame that we have to repeat the
 	     search here anyway -- we should really be caching pieces
 	     of the vtable and avoiding this repeated work.  */
-	  tree thunk_binfo, base_binfo;
+	  tree thunk_binfo = NULL_TREE;
+	  tree base_binfo = TYPE_BINFO (base_return);
 
 	  /* Find the base binfo within the overriding function's
 	     return type.  We will always find a thunk_binfo, except
 	     when the covariancy is invalid (which we will have
 	     already diagnosed).  */
-	  for (base_binfo = TYPE_BINFO (base_return),
-	       thunk_binfo = TYPE_BINFO (over_return);
-	       thunk_binfo;
-	       thunk_binfo = TREE_CHAIN (thunk_binfo))
-	    if (SAME_BINFO_TYPE_P (BINFO_TYPE (thunk_binfo),
-				   BINFO_TYPE (base_binfo)))
-	      break;
+	  if (base_binfo)
+	    for (thunk_binfo = TYPE_BINFO (over_return); thunk_binfo;
+		 thunk_binfo = TREE_CHAIN (thunk_binfo))
+	      if (SAME_BINFO_TYPE_P (BINFO_TYPE (thunk_binfo),
+				     BINFO_TYPE (base_binfo)))
+		break;
+	  gcc_assert (thunk_binfo || errorcount);
 
 	  /* See if virtual inheritance is involved.  */
 	  for (virtual_offset = thunk_binfo;
@@ -4532,8 +4533,14 @@ build_base_field_1 (tree t, tree basetype, tree *&next_field)
   DECL_ARTIFICIAL (decl) = 1;
   DECL_IGNORED_P (decl) = 1;
   DECL_FIELD_CONTEXT (decl) = t;
-  DECL_SIZE (decl) = CLASSTYPE_SIZE (basetype);
-  DECL_SIZE_UNIT (decl) = CLASSTYPE_SIZE_UNIT (basetype);
+  if (is_empty_class (basetype))
+    /* CLASSTYPE_SIZE is one byte, but the field needs to have size zero.  */
+    DECL_SIZE (decl) = DECL_SIZE_UNIT (decl) = size_zero_node;
+  else
+    {
+      DECL_SIZE (decl) = CLASSTYPE_SIZE (basetype);
+      DECL_SIZE_UNIT (decl) = CLASSTYPE_SIZE_UNIT (basetype);
+    }
   SET_DECL_ALIGN (decl, CLASSTYPE_ALIGN (basetype));
   DECL_USER_ALIGN (decl) = CLASSTYPE_USER_ALIGN (basetype);
   SET_DECL_MODE (decl, TYPE_MODE (basetype));
@@ -6655,6 +6662,7 @@ layout_class_type (tree t, tree *virtuals_p)
 				  bitsize_int (BITS_PER_UNIT)));
       SET_TYPE_ALIGN (base_t, rli->record_align);
       TYPE_USER_ALIGN (base_t) = TYPE_USER_ALIGN (t);
+      TYPE_TYPELESS_STORAGE (base_t) = TYPE_TYPELESS_STORAGE (t);
 
       /* Copy the fields from T.  */
       next_field = &TYPE_FIELDS (base_t);
@@ -7592,7 +7600,8 @@ fixed_type_or_null (tree instance, int *nonnull, int *cdtorp)
 
     case CALL_EXPR:
       /* This is a call to a constructor, hence it's never zero.  */
-      if (TREE_HAS_CONSTRUCTOR (instance))
+      if (CALL_EXPR_FN (instance)
+	  && TREE_HAS_CONSTRUCTOR (instance))
 	{
 	  if (nonnull)
 	    *nonnull = 1;
diff --git a/gcc/cp/constexpr.c b/gcc/cp/constexpr.c
index 9082230b9d5..cfd6a3a0e6e 100644
--- a/gcc/cp/constexpr.c
+++ b/gcc/cp/constexpr.c
@@ -1140,7 +1140,10 @@ cxx_eval_builtin_function_call (const constexpr_ctx *ctx, tree t, tree fun,
   /* Don't fold __builtin_constant_p within a constexpr function.  */
   bool bi_const_p = (DECL_FUNCTION_CODE (fun) == BUILT_IN_CONSTANT_P);
 
+  /* If we aren't requiring a constant expression, defer __builtin_constant_p
+     in a constexpr function until we have values for the parameters.  */
   if (bi_const_p
+      && ctx->quiet
       && current_function_decl
       && DECL_DECLARED_CONSTEXPR_P (current_function_decl))
     {
@@ -1155,8 +1158,14 @@ cxx_eval_builtin_function_call (const constexpr_ctx *ctx, tree t, tree fun,
   bool dummy1 = false, dummy2 = false;
   for (i = 0; i < nargs; ++i)
     {
-      args[i] = cxx_eval_constant_expression (&new_ctx, CALL_EXPR_ARG (t, i),
-					      false, &dummy1, &dummy2);
+      args[i] = CALL_EXPR_ARG (t, i);
+      /* If builtin_valid_in_constant_expr_p is true,
+	 potential_constant_expression_1 has not recursed into the arguments
+	 of the builtin, verify it here.  */
+      if (!builtin_valid_in_constant_expr_p (fun)
+	  || potential_constant_expression (args[i]))
+	args[i] = cxx_eval_constant_expression (&new_ctx, args[i], false,
+						&dummy1, &dummy2);
       if (bi_const_p)
 	/* For __built_in_constant_p, fold all expressions with constant values
 	   even if they aren't C++ constant-expressions.  */
@@ -1274,6 +1283,8 @@ cxx_bind_parameters_in_call (const constexpr_ctx *ctx, tree t,
 
       if (!*non_constant_p)
 	{
+	  /* Don't share a CONSTRUCTOR that might be changed.  */
+	  arg = unshare_constructor (arg);
 	  /* Make sure the binding has the same type as the parm.  But
 	     only for constant args.  */
 	  if (TREE_CODE (type) != REFERENCE_TYPE)
@@ -2783,14 +2794,20 @@ cxx_eval_bare_aggregate (const constexpr_ctx *ctx, tree t,
 	  gcc_assert (is_empty_class (TREE_TYPE (TREE_TYPE (index))));
 	  changed = true;
 	}
-      else if (new_ctx.ctor != ctx->ctor)
+      else
 	{
-	  /* We appended this element above; update the value.  */
-	  gcc_assert ((*p)->last().index == index);
-	  (*p)->last().value = elt;
+	  if (new_ctx.ctor != ctx->ctor)
+	    {
+	      /* We appended this element above; update the value.  */
+	      gcc_assert ((*p)->last().index == index);
+	      (*p)->last().value = elt;
+	    }
+	  else
+	    CONSTRUCTOR_APPEND_ELT (*p, index, elt);
+	  /* Adding or replacing an element might change the ctor's flags.  */
+	  TREE_CONSTANT (ctx->ctor) = constant_p;
+	  TREE_SIDE_EFFECTS (ctx->ctor) = side_effects_p;
 	}
-      else
-	CONSTRUCTOR_APPEND_ELT (*p, index, elt);
     }
   if (*non_constant_p || !changed)
     return t;
@@ -2826,7 +2843,6 @@ cxx_eval_vec_init_1 (const constexpr_ctx *ctx, tree atype, tree init,
   unsigned HOST_WIDE_INT max = tree_to_uhwi (array_type_nelts_top (atype));
   verify_ctor_sanity (ctx, atype);
   vec<constructor_elt, va_gc> **p = &CONSTRUCTOR_ELTS (ctx->ctor);
-  vec_alloc (*p, max + 1);
   bool pre_init = false;
   unsigned HOST_WIDE_INT i;
 
@@ -2881,6 +2897,9 @@ cxx_eval_vec_init_1 (const constexpr_ctx *ctx, tree atype, tree init,
 	{
 	  /* Initializing an element using value or default initialization
 	     we just pre-built above.  */
+	  if (init == void_node)
+	    /* Trivial default-init, don't do anything to the CONSTRUCTOR.  */
+	    return ctx->ctor;
 	  eltinit = cxx_eval_constant_expression (&new_ctx, init, lval,
 						  non_constant_p, overflow_p);
 	  reuse = i == 0;
@@ -2895,9 +2914,8 @@ cxx_eval_vec_init_1 (const constexpr_ctx *ctx, tree atype, tree init,
 	  if (!lvalue_p (init))
 	    eltinit = move (eltinit);
 	  eltinit = force_rvalue (eltinit, tf_warning_or_error);
-	  eltinit = (cxx_eval_constant_expression
-		     (&new_ctx, eltinit, lval,
-		      non_constant_p, overflow_p));
+	  eltinit = cxx_eval_constant_expression (&new_ctx, eltinit, lval,
+						  non_constant_p, overflow_p);
 	}
       if (*non_constant_p && !ctx->quiet)
 	break;
@@ -2910,22 +2928,24 @@ cxx_eval_vec_init_1 (const constexpr_ctx *ctx, tree atype, tree init,
       else
 	CONSTRUCTOR_APPEND_ELT (*p, idx, eltinit);
       /* Reuse the result of cxx_eval_constant_expression call
-	  from the first iteration to all others if it is a constant
-	  initializer that doesn't require relocations.  */
+	 from the first iteration to all others if it is a constant
+	 initializer that doesn't require relocations.  */
       if (reuse
 	  && max > 1
-	  && (initializer_constant_valid_p (eltinit, TREE_TYPE (eltinit))
-	      == null_pointer_node))
+	  && (eltinit == NULL_TREE
+	      || (initializer_constant_valid_p (eltinit, TREE_TYPE (eltinit))
+		  == null_pointer_node)))
 	{
 	  if (new_ctx.ctor != ctx->ctor)
 	    eltinit = new_ctx.ctor;
-	  for (i = 1; i < max; ++i)
-	    {
-	      idx = build_int_cst (size_type_node, i);
-	      CONSTRUCTOR_APPEND_ELT (*p, idx, unshare_constructor (eltinit));
-	    }
+	  tree range = build2 (RANGE_EXPR, size_type_node,
+			       build_int_cst (size_type_node, 1),
+			       build_int_cst (size_type_node, max - 1));
+	  CONSTRUCTOR_APPEND_ELT (*p, range, unshare_constructor (eltinit));
 	  break;
 	}
+      else if (i == 0)
+	vec_safe_reserve (*p, max);
     }
 
   if (!*non_constant_p)
@@ -2966,9 +2986,9 @@ cxx_eval_vec_init (const constexpr_ctx *ctx, tree t,
 static tree
 cxx_fold_indirect_ref (location_t loc, tree type, tree op0, bool *empty_base)
 {
-  tree sub, subtype;
+  tree sub = op0;
+  tree subtype;
 
-  sub = op0;
   STRIP_NOPS (sub);
   subtype = TREE_TYPE (sub);
   if (!POINTER_TYPE_P (subtype))
@@ -3023,7 +3043,8 @@ cxx_fold_indirect_ref (location_t loc, tree type, tree op0, bool *empty_base)
 	{
 	  tree part_width = TYPE_SIZE (type);
 	  tree index = bitsize_int (0);
-	  return fold_build3_loc (loc, BIT_FIELD_REF, type, op, part_width, index);
+	  return fold_build3_loc (loc, BIT_FIELD_REF, type, op, part_width,
+				  index);
 	}
       /* Also handle conversion to an empty base class, which
 	 is represented with a NOP_EXPR.  */
@@ -3063,19 +3084,31 @@ cxx_fold_indirect_ref (location_t loc, tree type, tree op0, bool *empty_base)
 	  /* ((foo*)&vectorfoo)[1] => BIT_FIELD_REF<vectorfoo,...> */
 	  if (VECTOR_TYPE_P (op00type)
 	      && (same_type_ignoring_top_level_qualifiers_p
-		  (type, TREE_TYPE (op00type))))
+						(type, TREE_TYPE (op00type)))
+	      /* POINTER_PLUS_EXPR second operand is sizetype, unsigned,
+		 but we want to treat offsets with MSB set as negative.
+		 For the code below negative offsets are invalid and
+		 TYPE_SIZE of the element is something unsigned, so
+		 check whether op01 fits into HOST_WIDE_INT, which
+		 implies it is from 0 to INTTYPE_MAXIMUM (HOST_WIDE_INT), and
+		 then just use unsigned HOST_WIDE_INT because we want to treat
+		 the value as unsigned.  */
+	      && tree_fits_shwi_p (op01))
 	    {
-	      HOST_WIDE_INT offset = tree_to_shwi (op01);
 	      tree part_width = TYPE_SIZE (type);
-	      unsigned HOST_WIDE_INT part_widthi = tree_to_shwi (part_width)/BITS_PER_UNIT;
-	      unsigned HOST_WIDE_INT indexi = offset * BITS_PER_UNIT;
-	      tree index = bitsize_int (indexi);
-
-	      if (offset / part_widthi < TYPE_VECTOR_SUBPARTS (op00type))
-		return fold_build3_loc (loc,
-					BIT_FIELD_REF, type, op00,
-					part_width, index);
-
+	      unsigned HOST_WIDE_INT max_offset
+		= (tree_to_uhwi (part_width) / BITS_PER_UNIT
+		   * TYPE_VECTOR_SUBPARTS (op00type));
+	      if (tree_int_cst_sign_bit (op01) == 0
+		  && compare_tree_int (op01, max_offset) == -1)
+		{
+		  unsigned HOST_WIDE_INT offset = tree_to_uhwi (op01);
+		  unsigned HOST_WIDE_INT indexi = offset * BITS_PER_UNIT;
+		  tree index = bitsize_int (indexi);
+		  return fold_build3_loc (loc,
+					  BIT_FIELD_REF, type, op00,
+					  part_width, index);
+		}
 	    }
 	  /* ((foo*)&complexfoo)[1] => __imag__ complexfoo */
 	  else if (TREE_CODE (op00type) == COMPLEX_TYPE
@@ -3132,7 +3165,8 @@ cxx_fold_indirect_ref (location_t loc, tree type, tree op0, bool *empty_base)
     {
       tree type_domain;
       tree min_val = size_zero_node;
-      tree newsub = cxx_fold_indirect_ref (loc, TREE_TYPE (subtype), sub, NULL);
+      tree newsub
+	= cxx_fold_indirect_ref (loc, TREE_TYPE (subtype), sub, NULL);
       if (newsub)
 	sub = newsub;
       else
@@ -4170,7 +4204,16 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,
 	r = cxx_eval_constant_expression (ctx, TREE_OPERAND (t, 0),
 					  lval,
 					  non_constant_p, overflow_p);
-      *jump_target = t;
+      if (jump_target)
+	*jump_target = t;
+      else
+	{
+	  /* Can happen with ({ return true; }) && false; passed to
+	     maybe_constant_value.  There is nothing to jump over in this
+	     case, and the bug will be diagnosed later.  */
+	  gcc_assert (ctx->quiet);
+	  *non_constant_p = true;
+	}
       break;
 
     case SAVE_EXPR:
@@ -4414,11 +4457,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,
 	{
 	  /* Don't re-process a constant CONSTRUCTOR, but do fold it to
 	     VECTOR_CST if applicable.  */
-	  /* FIXME after GCC 6 branches, make the verify unconditional.  */
-	  if (CHECKING_P)
-	    verify_constructor_flags (t);
-	  else
-	    recompute_constructor_flags (t);
+	  verify_constructor_flags (t);
 	  if (TREE_CONSTANT (t))
 	    return fold (t);
 	}
@@ -4640,6 +4679,10 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,
 					jump_target);
       break;
 
+    case USING_STMT:
+      r = void_node;
+      break;
+
     default:
       if (STATEMENT_CODE_P (TREE_CODE (t)))
 	{
@@ -4763,8 +4806,12 @@ cxx_eval_outermost_constant_expr (tree t, bool allow_non_constant,
     return error_mark_node;
   else if (non_constant_p && TREE_CONSTANT (r))
     {
-      /* This isn't actually constant, so unset TREE_CONSTANT.  */
-      if (EXPR_P (r))
+      /* This isn't actually constant, so unset TREE_CONSTANT.
+	 Don't clear TREE_CONSTANT on ADDR_EXPR, as the middle-end requires
+	 it to be set if it is invariant address, even when it is not
+	 a valid C++ constant expression.  Wrap it with a NOP_EXPR
+	 instead.  */
+      if (EXPR_P (r) && TREE_CODE (r) != ADDR_EXPR)
 	r = copy_node (r);
       else if (TREE_CODE (r) == CONSTRUCTOR)
 	r = build1 (VIEW_CONVERT_EXPR, TREE_TYPE (r), r);
@@ -5453,6 +5500,7 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict,
     case OMP_PARALLEL:
     case OMP_TASK:
     case OMP_FOR:
+    case OMP_SIMD:
     case OMP_DISTRIBUTE:
     case OMP_TASKLOOP:
     case OMP_TEAMS:
@@ -5627,7 +5675,8 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict,
       return RECUR (TREE_OPERAND (t, 1), want_rval);
 
     case TARGET_EXPR:
-      if (!literal_type_p (TREE_TYPE (t)))
+      if (!TARGET_EXPR_DIRECT_INIT_P (t)
+	  && !literal_type_p (TREE_TYPE (t)))
 	{
 	  if (flags & tf_error)
 	    {
diff --git a/gcc/cp/cp-gimplify.c b/gcc/cp/cp-gimplify.c
index b0e010e18ce..9c107b79d8a 100644
--- a/gcc/cp/cp-gimplify.c
+++ b/gcc/cp/cp-gimplify.c
@@ -1107,6 +1107,14 @@ cp_genericize_r (tree *stmt_p, int *walk_subtrees, void *data)
       && omp_var_to_track (stmt))
     omp_cxx_notice_variable (wtd->omp_ctx, stmt);
 
+  /* Don't dereference parms in a thunk, pass the references through. */
+  if ((TREE_CODE (stmt) == CALL_EXPR && CALL_FROM_THUNK_P (stmt))
+      || (TREE_CODE (stmt) == AGGR_INIT_EXPR && AGGR_INIT_FROM_THUNK_P (stmt)))
+    {
+      *walk_subtrees = 0;
+      return NULL;
+    }
+
   /* Dereference invisible reference parms.  */
   if (wtd->handle_invisiref_parm_p && is_invisiref_parm (stmt))
     {
@@ -1128,6 +1136,7 @@ cp_genericize_r (tree *stmt_p, int *walk_subtrees, void *data)
       if (h)
 	{
 	  *stmt_p = h->to;
+	  TREE_USED (h->to) |= TREE_USED (stmt);
 	  *walk_subtrees = 0;
 	  return NULL;
 	}
@@ -1910,7 +1919,7 @@ cxx_omp_const_qual_no_mutable (tree decl)
 /* True if OpenMP sharing attribute of DECL is predetermined.  */
 
 enum omp_clause_default_kind
-cxx_omp_predetermined_sharing (tree decl)
+cxx_omp_predetermined_sharing_1 (tree decl)
 {
   /* Static data members are predetermined shared.  */
   if (TREE_STATIC (decl))
@@ -1928,6 +1937,32 @@ cxx_omp_predetermined_sharing (tree decl)
   return OMP_CLAUSE_DEFAULT_UNSPECIFIED;
 }
 
+/* Likewise, but also include the artificial vars.  We don't want to
+   disallow the artificial vars being mentioned in explicit clauses,
+   as we use artificial vars e.g. for loop constructs with random
+   access iterators other than pointers, but during gimplification
+   we want to treat them as predetermined.  */
+
+enum omp_clause_default_kind
+cxx_omp_predetermined_sharing (tree decl)
+{
+  enum omp_clause_default_kind ret = cxx_omp_predetermined_sharing_1 (decl);
+  if (ret != OMP_CLAUSE_DEFAULT_UNSPECIFIED)
+    return ret;
+
+  /* Predetermine artificial variables holding integral values, those
+     are usually result of gimplify_one_sizepos or SAVE_EXPR
+     gimplification.  */
+  if (VAR_P (decl)
+      && DECL_ARTIFICIAL (decl)
+      && INTEGRAL_TYPE_P (TREE_TYPE (decl))
+      && !(DECL_LANG_SPECIFIC (decl)
+	   && DECL_OMP_PRIVATIZED_MEMBER (decl)))
+    return OMP_CLAUSE_DEFAULT_SHARED;
+
+  return OMP_CLAUSE_DEFAULT_UNSPECIFIED;
+}
+
 /* Finalize an implicitly determined clause.  */
 
 void
@@ -2148,6 +2183,28 @@ cp_fold (tree x)
       goto unary;
 
     case ADDR_EXPR:
+      loc = EXPR_LOCATION (x);
+      op0 = cp_fold_maybe_rvalue (TREE_OPERAND (x, 0), false);
+
+      /* Cope with user tricks that amount to offsetof.  */
+      if (op0 != error_mark_node
+	  && TREE_CODE (TREE_TYPE (op0)) != FUNCTION_TYPE
+	  && TREE_CODE (TREE_TYPE (op0)) != METHOD_TYPE)
+	{
+	  tree val = get_base_address (op0);
+	  if (val
+	      && INDIRECT_REF_P (val)
+	      && COMPLETE_TYPE_P (TREE_TYPE (val))
+	      && TREE_CONSTANT (TREE_OPERAND (val, 0)))
+	    {
+	      val = TREE_OPERAND (val, 0);
+	      STRIP_NOPS (val);
+	      if (TREE_CODE (val) == INTEGER_CST)
+		return fold_offsetof (op0, TREE_TYPE (x));
+	    }
+	}
+      goto finish_unary;
+
     case REALPART_EXPR:
     case IMAGPART_EXPR:
       rval_ops = false;
@@ -2165,6 +2222,7 @@ cp_fold (tree x)
       loc = EXPR_LOCATION (x);
       op0 = cp_fold_maybe_rvalue (TREE_OPERAND (x, 0), rval_ops);
 
+    finish_unary:
       if (op0 != TREE_OPERAND (x, 0))
 	{
 	  if (op0 == error_mark_node)
diff --git a/gcc/cp/cp-tree.h b/gcc/cp/cp-tree.h
index fadf6ecb1a2..842d410f842 100644
--- a/gcc/cp/cp-tree.h
+++ b/gcc/cp/cp-tree.h
@@ -6455,7 +6455,7 @@ extern tree begin_compound_stmt			(unsigned int);
 
 extern void finish_compound_stmt		(tree);
 extern tree finish_asm_stmt			(int, tree, tree, tree, tree,
-						 tree);
+						 tree, bool);
 extern tree finish_label_stmt			(tree);
 extern void finish_label_decl			(tree);
 extern cp_expr finish_parenthesized_expr	(cp_expr);
@@ -6708,6 +6708,7 @@ extern tree cxx_copy_lang_qualifiers		(const_tree, const_tree);
 
 extern void cxx_print_statistics		(void);
 extern bool maybe_warn_zero_as_null_pointer_constant (tree, location_t);
+extern void cp_warn_deprecated_use		(tree);
 
 /* in ptree.c */
 extern void cxx_print_xnode			(FILE *, tree, int);
@@ -6777,6 +6778,7 @@ extern tree cp_build_addressof			(location_t, tree,
 extern tree cp_build_addr_expr			(tree, tsubst_flags_t);
 extern tree cp_build_unary_op                   (enum tree_code, tree, bool,
                                                  tsubst_flags_t);
+extern tree genericize_compound_lvalue		(tree);
 extern tree unary_complex_lvalue		(enum tree_code, tree);
 extern tree build_x_conditional_expr		(location_t, tree, tree, tree, 
                                                  tsubst_flags_t);
@@ -6941,6 +6943,7 @@ extern int cp_gimplify_expr			(tree *, gimple_seq *,
 						 gimple_seq *);
 extern void cp_genericize			(tree);
 extern bool cxx_omp_const_qual_no_mutable	(tree);
+extern enum omp_clause_default_kind cxx_omp_predetermined_sharing_1 (tree);
 extern enum omp_clause_default_kind cxx_omp_predetermined_sharing (tree);
 extern tree cxx_omp_clause_default_ctor		(tree, tree, tree);
 extern tree cxx_omp_clause_copy_ctor		(tree, tree, tree);
diff --git a/gcc/cp/cvt.c b/gcc/cp/cvt.c
index 5f4b5e30a5f..5d3a47ec640 100644
--- a/gcc/cp/cvt.c
+++ b/gcc/cp/cvt.c
@@ -1053,6 +1053,8 @@ convert_to_void (tree expr, impl_conv_void implicit, tsubst_flags_t complain)
       || TREE_TYPE (expr) == error_mark_node)
     return error_mark_node;
 
+  expr = maybe_undo_parenthesized_ref (expr);
+
   if (implicit == ICV_CAST)
     mark_exp_read (expr);
   else
diff --git a/gcc/cp/decl.c b/gcc/cp/decl.c
index 6bb7f6efe4f..950e04a6680 100644
--- a/gcc/cp/decl.c
+++ b/gcc/cp/decl.c
@@ -5022,7 +5022,7 @@ start_decl (const cp_declarator *declarator,
     }
 
   /* If #pragma weak was used, mark the decl weak now.  */
-  if (!processing_template_decl)
+  if (!processing_template_decl && !DECL_DECOMPOSITION_P (decl))
     maybe_apply_pragma_weak (decl);
 
   if (TREE_CODE (decl) == FUNCTION_DECL
@@ -5042,19 +5042,17 @@ start_decl (const cp_declarator *declarator,
 	  if (field == NULL_TREE
 	      || !(VAR_P (field) || variable_template_p (field)))
 	    error ("%q+#D is not a static data member of %q#T", decl, context);
+	  else if (variable_template_p (field)
+		   && (DECL_LANG_SPECIFIC (decl)
+		       && DECL_TEMPLATE_SPECIALIZATION (decl)))
+	    /* OK, specialization was already checked.  */;
 	  else if (variable_template_p (field) && !this_tmpl)
 	    {
-	      if (DECL_LANG_SPECIFIC (decl)
-		  && DECL_TEMPLATE_SPECIALIZATION (decl))
-		/* OK, specialization was already checked.  */;
-	      else
-		{
-		  error_at (DECL_SOURCE_LOCATION (decl),
-			    "non-member-template declaration of %qD", decl);
-		  inform (DECL_SOURCE_LOCATION (field), "does not match "
-			  "member template declaration here");
-		  return error_mark_node;
-		}
+	      error_at (DECL_SOURCE_LOCATION (decl),
+			"non-member-template declaration of %qD", decl);
+	      inform (DECL_SOURCE_LOCATION (field), "does not match "
+		      "member template declaration here");
+	      return error_mark_node;
 	    }
 	  else
 	    {
@@ -5798,8 +5796,18 @@ reshape_init_class (tree type, reshape_iter *d, bool first_initializer_p,
 	    return error_mark_node;
 
 	  if (TREE_CODE (d->cur->index) == FIELD_DECL)
-	    /* We already reshaped this.  */
-	    gcc_assert (d->cur->index == field);
+	    {
+	      /* We already reshaped this.  */
+	      if (field != d->cur->index)
+		{
+		  tree id = DECL_NAME (d->cur->index);
+		  gcc_assert (id);
+		  gcc_checking_assert (lookup_field_1 (type, id,
+						       /*want_type=*/false)
+				       == d->cur->index);
+		  field = d->cur->index;
+		}
+	    }
 	  else if (TREE_CODE (d->cur->index) == IDENTIFIER_NODE)
 	    field = lookup_field_1 (type, d->cur->index, /*want_type=*/false);
 	  else
@@ -6402,7 +6410,9 @@ check_initializer (tree decl, tree init, int flags, vec<tree, va_gc> **cleanups)
     }
 
   if (init_code
-      && (DECL_IN_AGGR_P (decl) && !DECL_VAR_DECLARED_INLINE_P (decl)))
+      && (DECL_IN_AGGR_P (decl)
+	  && DECL_INITIALIZED_IN_CLASS_P (decl)
+	  && !DECL_VAR_DECLARED_INLINE_P (decl)))
     {
       static int explained = 0;
 
@@ -7213,7 +7223,9 @@ find_decomp_class_base (location_t loc, tree type, tree ret)
 {
   bool member_seen = false;
   for (tree field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))
-    if (TREE_CODE (field) != FIELD_DECL || DECL_ARTIFICIAL (field))
+    if (TREE_CODE (field) != FIELD_DECL
+	|| DECL_ARTIFICIAL (field)
+	|| (DECL_C_BIT_FIELD (field) && !DECL_NAME (field)))
       continue;
     else if (ret)
       return type;
@@ -7228,9 +7240,9 @@ find_decomp_class_base (location_t loc, tree type, tree ret)
 	inform (DECL_SOURCE_LOCATION (field), "declared here");
 	return error_mark_node;
       }
-    else if (TREE_PRIVATE (field) || TREE_PROTECTED (field))
+    else if (!accessible_p (type, field, true))
       {
-	error_at (loc, "cannot decompose non-public member %qD of %qT",
+	error_at (loc, "cannot decompose inaccessible member %qD of %qT",
 		  field, type);
 	inform (DECL_SOURCE_LOCATION (field),
 		TREE_PRIVATE (field)
@@ -7252,7 +7264,7 @@ find_decomp_class_base (location_t loc, tree type, tree ret)
       tree t = find_decomp_class_base (loc, TREE_TYPE (base_binfo), ret);
       if (t == error_mark_node)
 	return error_mark_node;
-      if (t != NULL_TREE)
+      if (t != NULL_TREE && t != ret)
 	{
 	  if (ret == type)
 	    {
@@ -7263,9 +7275,6 @@ find_decomp_class_base (location_t loc, tree type, tree ret)
 	    }
 	  else if (orig_ret != NULL_TREE)
 	    return t;
-	  else if (ret == t)
-	    /* OK, found the same base along another path.  We'll complain
-	       in convert_to_base if it's ambiguous.  */;
 	  else if (ret != NULL_TREE)
 	    {
 	      error_at (loc, "cannot decompose class type %qT: its base "
@@ -7341,7 +7350,29 @@ get_tuple_decomp_init (tree decl, unsigned i)
 
   tree fns = lookup_qualified_name (TREE_TYPE (e), get_id,
 				    /*type*/false, /*complain*/false);
-  if (fns != error_mark_node)
+  bool use_member_get = false;
+
+  /* To use a member get, member lookup must find at least one
+     declaration that is a function template
+     whose first template parameter is a non-type parameter.  */
+  for (tree iter = BASELINK_P (fns) ? BASELINK_FUNCTIONS (fns) : fns;
+       iter;
+       iter = OVL_NEXT (iter))
+    {
+      tree fn = OVL_CURRENT (iter);
+      if (TREE_CODE (fn) == TEMPLATE_DECL)
+	{
+	  tree tparms = DECL_TEMPLATE_PARMS (fn);
+	  tree parm = TREE_VEC_ELT (INNERMOST_TEMPLATE_PARMS (tparms), 0);
+	  if (TREE_CODE (TREE_VALUE (parm)) == PARM_DECL)
+	    {
+	      use_member_get = true;
+	      break;
+	    }
+	}
+    }
+
+  if (use_member_get)
     {
       fns = lookup_template_function (fns, targs);
       return build_new_method_call (e, fns, /*args*/NULL,
@@ -7391,6 +7422,7 @@ cp_maybe_mangle_decomp (tree decl, tree first, unsigned int count)
       for (unsigned int i = 0; i < count; i++, d = DECL_CHAIN (d))
 	v[count - i - 1] = d;
       SET_DECL_ASSEMBLER_NAME (decl, mangle_decomp (decl, v));
+      maybe_apply_pragma_weak (decl);
     }
 }
 
@@ -7466,6 +7498,12 @@ cp_finish_decomp (tree decl, tree first, unsigned int count)
       type = complete_type (TREE_TYPE (type));
       if (type == error_mark_node)
 	goto error_out;
+      if (!COMPLETE_TYPE_P (type))
+	{
+	  error_at (loc, "structured binding refers to incomplete type %qT",
+		    type);
+	  goto error_out;
+	}
     }
 
   tree eltype = NULL_TREE;
@@ -7640,7 +7678,9 @@ cp_finish_decomp (tree decl, tree first, unsigned int count)
 	  goto error_out;
 	}
       for (tree field = TYPE_FIELDS (btype); field; field = TREE_CHAIN (field))
-	if (TREE_CODE (field) != FIELD_DECL || DECL_ARTIFICIAL (field))
+	if (TREE_CODE (field) != FIELD_DECL
+	    || DECL_ARTIFICIAL (field)
+	    || (DECL_C_BIT_FIELD (field) && !DECL_NAME (field)))
 	  continue;
 	else
 	  eltscnt++;
@@ -7655,7 +7695,9 @@ cp_finish_decomp (tree decl, tree first, unsigned int count)
 	}
       unsigned int i = 0;
       for (tree field = TYPE_FIELDS (btype); field; field = TREE_CHAIN (field))
-	if (TREE_CODE (field) != FIELD_DECL || DECL_ARTIFICIAL (field))
+	if (TREE_CODE (field) != FIELD_DECL
+	    || DECL_ARTIFICIAL (field)
+	    || (DECL_C_BIT_FIELD (field) && !DECL_NAME (field)))
 	  continue;
 	else
 	  {
@@ -9517,7 +9559,8 @@ compute_array_index_type (tree name, tree size, tsubst_flags_t complain)
       constant_expression_error (size);
 
       /* An array must have a positive number of elements.  */
-      if (tree_int_cst_lt (size, integer_zero_node))
+      tree signed_size = fold_convert (ssizetype, size);
+      if (tree_int_cst_lt (signed_size, integer_zero_node))
 	{
 	  if (!(complain & tf_error))
 	    return error_mark_node;
@@ -10097,6 +10140,8 @@ grokdeclarator (const cp_declarator *declarator,
 						      declspecs->locations);
   if (typespec_loc == UNKNOWN_LOCATION)
     typespec_loc = declspecs->locations[ds_type_spec];
+  if (typespec_loc == UNKNOWN_LOCATION)
+    typespec_loc = input_location;
 
   /* Look inside a declarator for the name being declared
      and get it as a string, for an error message.  */
@@ -10366,7 +10411,7 @@ grokdeclarator (const cp_declarator *declarator,
      suppress reports of deprecated items.  */
   if (type && TREE_DEPRECATED (type)
       && deprecated_state != DEPRECATED_SUPPRESS)
-    warn_deprecated_use (type, NULL_TREE);
+    cp_warn_deprecated_use (type);
   if (type && TREE_CODE (type) == TYPE_DECL)
     {
       typedef_decl = type;
@@ -10374,7 +10419,7 @@ grokdeclarator (const cp_declarator *declarator,
       if (TREE_DEPRECATED (type)
 	  && DECL_ARTIFICIAL (typedef_decl)
 	  && deprecated_state != DEPRECATED_SUPPRESS)
-	warn_deprecated_use (type, NULL_TREE);
+	cp_warn_deprecated_use (type);
     }
   /* No type at all: default to `int', and set DEFAULTED_INT
      because it was not a user-defined typedef.  */
@@ -11169,8 +11214,18 @@ grokdeclarator (const cp_declarator *declarator,
 		  explicitp = 2;
 	      }
 
-	    arg_types = grokparms (declarator->u.function.parameters,
-				   &parms);
+	    tree pushed_scope = NULL_TREE;
+	    if (funcdecl_p
+		&& decl_context != FIELD
+		&& inner_declarator->u.id.qualifying_scope
+		&& CLASS_TYPE_P (inner_declarator->u.id.qualifying_scope))
+	      pushed_scope
+		= push_scope (inner_declarator->u.id.qualifying_scope);
+
+	    arg_types = grokparms (declarator->u.function.parameters, &parms);
+
+	    if (pushed_scope)
+	      pop_scope (pushed_scope);
 
 	    if (inner_declarator
 		&& inner_declarator->kind == cdk_id
@@ -12556,7 +12611,9 @@ check_default_argument (tree decl, tree arg, tsubst_flags_t complain)
      A default argument expression is implicitly converted to the
      parameter type.  */
   ++cp_unevaluated_operand;
-  perform_implicit_conversion_flags (decl_type, arg, complain,
+  /* Avoid digest_init clobbering the initializer.  */
+  tree carg = BRACE_ENCLOSED_INITIALIZER_P (arg) ? unshare_expr (arg): arg;
+  perform_implicit_conversion_flags (decl_type, carg, complain,
 				     LOOKUP_IMPLICIT);
   --cp_unevaluated_operand;
 
@@ -12685,7 +12742,7 @@ grokparms (tree parmlist, tree *parms)
 	    {
 	      tree deptype = type_is_deprecated (type);
 	      if (deptype)
-		warn_deprecated_use (deptype, NULL_TREE);
+		cp_warn_deprecated_use (deptype);
 	    }
 
 	  /* Top-level qualifiers on the parameters are
diff --git a/gcc/cp/decl2.c b/gcc/cp/decl2.c
index b1c3c30521f..7ad6a108224 100644
--- a/gcc/cp/decl2.c
+++ b/gcc/cp/decl2.c
@@ -1360,7 +1360,7 @@ cp_check_const_attributes (tree attributes)
 	{
 	  tree expr = TREE_VALUE (arg);
 	  if (EXPR_P (expr))
-	    TREE_VALUE (arg) = maybe_constant_value (expr);
+	    TREE_VALUE (arg) = fold_non_dependent_expr (expr);
 	}
     }
 }
@@ -1829,10 +1829,13 @@ vague_linkage_p (tree decl)
 {
   if (!TREE_PUBLIC (decl))
     {
-      /* maybe_thunk_body clears TREE_PUBLIC on the maybe-in-charge 'tor
-	 variants, check one of the "clones" for the real linkage.  */
+      /* maybe_thunk_body clears TREE_PUBLIC and DECL_ABSTRACT_P on the
+	 maybe-in-charge 'tor variants; in that case we need to check one of
+	 the "clones" for the real linkage.  But only in that case; before
+	 maybe_clone_body we haven't yet copied the linkage to the clones.  */
       if ((DECL_MAYBE_IN_CHARGE_DESTRUCTOR_P (decl)
 	   || DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P (decl))
+	  && !DECL_ABSTRACT_P (decl)
 	  && DECL_CHAIN (decl)
 	  && DECL_CLONED_FUNCTION (DECL_CHAIN (decl)))
 	return vague_linkage_p (DECL_CHAIN (decl));
@@ -2310,11 +2313,8 @@ determine_visibility (tree decl)
 	    }
 
 	  /* Local classes in templates have CLASSTYPE_USE_TEMPLATE set,
-	     but have no TEMPLATE_INFO.  Their containing template
-	     function does, and the local class could be constrained
-	     by that.  */
-	  if (template_decl)
-	    template_decl = fn;
+	     but have no TEMPLATE_INFO, so don't try to check it.  */
+	  template_decl = NULL_TREE;
 	}
       else if (VAR_P (decl) && DECL_TINFO_P (decl)
 	       && flag_visibility_ms_compat)
diff --git a/gcc/cp/error.c b/gcc/cp/error.c
index 38bc0b2474a..989a5e8eda1 100644
--- a/gcc/cp/error.c
+++ b/gcc/cp/error.c
@@ -2695,6 +2695,7 @@ dump_expr (cxx_pretty_printer *pp, tree t, int flags)
     case INTEGER_TYPE:
     case COMPLEX_TYPE:
     case VECTOR_TYPE:
+    case DECLTYPE_TYPE:
       pp_type_specifier_seq (pp, t);
       break;
 
diff --git a/gcc/cp/except.c b/gcc/cp/except.c
index f65b717c32b..3487dec9275 100644
--- a/gcc/cp/except.c
+++ b/gcc/cp/except.c
@@ -1218,6 +1218,10 @@ build_noexcept_spec (tree expr, int complain)
     {
       gcc_assert (processing_template_decl
 		  || TREE_CODE (expr) == DEFERRED_NOEXCEPT);
+      if (TREE_CODE (expr) != DEFERRED_NOEXCEPT)
+	/* Avoid problems with a function type built with a dependent typedef
+	   being reused in another scope (c++/84045).  */
+	expr = strip_typedefs_expr (expr);
       return build_tree_list (expr, NULL_TREE);
     }
 }
diff --git a/gcc/cp/init.c b/gcc/cp/init.c
index e9c39ff25e6..ec01f6b6776 100644
--- a/gcc/cp/init.c
+++ b/gcc/cp/init.c
@@ -1632,6 +1632,7 @@ build_aggr_init (tree exp, tree init, int flags, tsubst_flags_t complain)
       if (VAR_P (exp) && DECL_DECOMPOSITION_P (exp))
 	{
 	  from_array = 1;
+	  init = mark_rvalue_use (init);
 	  if (init && DECL_P (init)
 	      && !(flags & LOOKUP_ONLYCONVERTING))
 	    {
diff --git a/gcc/cp/lambda.c b/gcc/cp/lambda.c
index a9ddba83fc0..08874794eaf 100644
--- a/gcc/cp/lambda.c
+++ b/gcc/cp/lambda.c
@@ -262,6 +262,7 @@ is_capture_proxy (tree decl)
   return (VAR_P (decl)
 	  && DECL_HAS_VALUE_EXPR_P (decl)
 	  && !DECL_ANON_UNION_VAR_P (decl)
+	  && !DECL_DECOMPOSITION_P (decl)
 	  && LAMBDA_FUNCTION_P (DECL_CONTEXT (decl)));
 }
 
@@ -712,11 +713,14 @@ lambda_expr_this_capture (tree lambda, bool add_capture_p)
                                     lambda_stack);
 
 	  if (LAMBDA_EXPR_EXTRA_SCOPE (tlambda)
+	      && !COMPLETE_TYPE_P (LAMBDA_EXPR_CLOSURE (tlambda))
 	      && TREE_CODE (LAMBDA_EXPR_EXTRA_SCOPE (tlambda)) == FIELD_DECL)
 	    {
 	      /* In an NSDMI, we don't have a function to look up the decl in,
 		 but the fake 'this' pointer that we're using for parsing is
-		 in scope_chain.  */
+		 in scope_chain.  But if the closure is already complete, we're
+	         in an instantiation of a generic lambda, and the fake 'this'
+	         is gone.  */
 	      init = scope_chain->x_current_class_ptr;
 	      gcc_checking_assert
 		(init && (TREE_TYPE (TREE_TYPE (init))
@@ -1072,7 +1076,6 @@ maybe_add_lambda_conv_op (tree type)
       }
   }
 
-
   if (generic_lambda_p)
     {
       if (decltype_call)
diff --git a/gcc/cp/method.c b/gcc/cp/method.c
index c7b67589924..a2d4c071efa 100644
--- a/gcc/cp/method.c
+++ b/gcc/cp/method.c
@@ -1165,6 +1165,7 @@ constructible_expr (tree to, tree from)
     {
       tree ctype = to;
       vec<tree, va_gc> *args = NULL;
+      cp_unevaluated cp_uneval_guard;
       if (TREE_CODE (to) != REFERENCE_TYPE)
 	to = cp_build_reference_type (to, /*rval*/false);
       tree ob = build_stub_object (to);
@@ -1430,7 +1431,7 @@ static tree
 synthesized_method_base_walk (tree binfo, tree base_binfo, 
 			      int quals, bool copy_arg_p,
 			      bool move_p, bool ctor_p,
-			      tree inheriting_ctor, tree inherited_parms,
+			      tree *inheriting_ctor, tree inherited_parms,
 			      tree fnname, int flags, bool diag,
 			      tree *spec_p, bool *trivial_p,
 			      bool *deleted_p, bool *constexpr_p)
@@ -1441,8 +1442,9 @@ synthesized_method_base_walk (tree binfo, tree base_binfo,
 
   if (copy_arg_p)
     argtype = build_stub_type (BINFO_TYPE (base_binfo), quals, move_p);
-  else if ((inherited_binfo
-	    = binfo_inherited_from (binfo, base_binfo, inheriting_ctor)))
+  else if (inheriting_ctor
+	   && (inherited_binfo
+	       = binfo_inherited_from (binfo, base_binfo, *inheriting_ctor)))
     {
       argtype = inherited_parms;
       /* Don't check access on the inherited constructor.  */
@@ -1464,6 +1466,12 @@ synthesized_method_base_walk (tree binfo, tree base_binfo,
   if (defer != dk_no_deferred)
     pop_deferring_access_checks ();
 
+  /* Replace an inherited template with the appropriate specialization.  */
+  if (inherited_binfo && rval
+      && DECL_P (*inheriting_ctor) && DECL_P (rval)
+      && DECL_CONTEXT (*inheriting_ctor) == DECL_CONTEXT (rval))
+    *inheriting_ctor = DECL_CLONED_FUNCTION (rval);
+
   process_subob_fn (rval, spec_p, trivial_p, deleted_p,
 		    constexpr_p, diag, BINFO_TYPE (base_binfo));
   if (ctor_p &&
@@ -1498,7 +1506,7 @@ static void
 synthesized_method_walk (tree ctype, special_function_kind sfk, bool const_p,
 			 tree *spec_p, bool *trivial_p, bool *deleted_p,
 			 bool *constexpr_p, bool diag,
-			 tree inheriting_ctor, tree inherited_parms)
+			 tree *inheriting_ctor, tree inherited_parms)
 {
   tree binfo, base_binfo, fnname;
   int i;
@@ -1553,7 +1561,7 @@ synthesized_method_walk (tree ctype, special_function_kind sfk, bool const_p,
     }
 
   gcc_assert ((sfk == sfk_inheriting_constructor)
-	      == (inheriting_ctor != NULL_TREE));
+	      == (inheriting_ctor && *inheriting_ctor != NULL_TREE));
 
   /* If that user-written default constructor would satisfy the
      requirements of a constexpr constructor (7.1.5), the
@@ -1628,7 +1636,7 @@ synthesized_method_walk (tree ctype, special_function_kind sfk, bool const_p,
   tree scope = push_scope (ctype);
 
   int flags = LOOKUP_NORMAL | LOOKUP_SPECULATIVE;
-  if (!inheriting_ctor)
+  if (sfk != sfk_inheriting_constructor)
     flags |= LOOKUP_DEFAULTED;
 
   tsubst_flags_t complain = diag ? tf_warning_or_error : tf_none;
@@ -1731,9 +1739,9 @@ get_defaulted_eh_spec (tree decl)
   tree parm_type = TREE_VALUE (parms);
   bool const_p = CP_TYPE_CONST_P (non_reference (parm_type));
   tree spec = empty_except_spec;
+  tree inh = DECL_INHERITED_CTOR (decl);
   synthesized_method_walk (ctype, sfk, const_p, &spec, NULL, NULL,
-			   NULL, false, DECL_INHERITED_CTOR (decl),
-			   parms);
+			   NULL, false, &inh, parms);
   return spec;
 }
 
@@ -1810,10 +1818,11 @@ maybe_explain_implicit_delete (tree decl)
 	  tree raises = NULL_TREE;
 	  bool deleted_p = false;
 	  tree scope = push_scope (ctype);
+	  tree inh = DECL_INHERITED_CTOR (decl);
 
 	  synthesized_method_walk (ctype, sfk, const_p,
 				   &raises, NULL, &deleted_p, NULL, false,
-				   DECL_INHERITED_CTOR (decl), parms);
+				   &inh, parms);
 	  if (deleted_p)
 	    {
 	      inform (DECL_SOURCE_LOCATION (decl),
@@ -1821,7 +1830,7 @@ maybe_explain_implicit_delete (tree decl)
 		      "definition would be ill-formed:", decl);
 	      synthesized_method_walk (ctype, sfk, const_p,
 				       NULL, NULL, NULL, NULL, true,
-				       DECL_INHERITED_CTOR (decl), parms);
+				       &inh, parms);
 	    }
 	  else if (!comp_except_specs
 		   (TYPE_RAISES_EXCEPTIONS (TREE_TYPE (decl)),
@@ -1850,11 +1859,12 @@ explain_implicit_non_constexpr (tree decl)
 {
   tree parm_type = TREE_VALUE (FUNCTION_FIRST_USER_PARMTYPE (decl));
   bool const_p = CP_TYPE_CONST_P (non_reference (parm_type));
+  tree inh = DECL_INHERITED_CTOR (decl);
   bool dummy;
   synthesized_method_walk (DECL_CLASS_CONTEXT (decl),
 			   special_function_p (decl), const_p,
 			   NULL, NULL, NULL, &dummy, true,
-			   DECL_INHERITED_CTOR (decl),
+			   &inh,
 			   FUNCTION_FIRST_USER_PARMTYPE (decl));
 }
 
@@ -1869,22 +1879,25 @@ deduce_inheriting_ctor (tree decl)
   gcc_assert (DECL_INHERITED_CTOR (decl));
   tree spec;
   bool trivial, constexpr_, deleted;
+  tree inh = DECL_INHERITED_CTOR (decl);
   synthesized_method_walk (DECL_CONTEXT (decl), sfk_inheriting_constructor,
 			   false, &spec, &trivial, &deleted, &constexpr_,
 			   /*diag*/false,
-			   DECL_INHERITED_CTOR (decl),
+			   &inh,
 			   FUNCTION_FIRST_USER_PARMTYPE (decl));
   if (TREE_CODE (inherited_ctor_binfo (decl)) != TREE_BINFO)
     /* Inherited the same constructor from different base subobjects.  */
     deleted = true;
   DECL_DELETED_FN (decl) = deleted;
   TREE_TYPE (decl) = build_exception_variant (TREE_TYPE (decl), spec);
+  SET_DECL_INHERITED_CTOR (decl, inh);
 
   tree clone;
   FOR_EACH_CLONE (clone, decl)
     {
       DECL_DELETED_FN (clone) = deleted;
       TREE_TYPE (clone) = build_exception_variant (TREE_TYPE (clone), spec);
+      SET_DECL_INHERITED_CTOR (clone, inh);
     }
 }
 
@@ -1999,12 +2012,12 @@ implicitly_declare_fn (special_function_kind kind, tree type,
       raises = unevaluated_noexcept_spec ();
       synthesized_method_walk (type, kind, const_p, NULL, &trivial_p,
 			       &deleted_p, &constexpr_p, false,
-			       inherited_ctor, inherited_parms);
+			       &inherited_ctor, inherited_parms);
     }
   else
     synthesized_method_walk (type, kind, const_p, &raises, &trivial_p,
 			     &deleted_p, &constexpr_p, false,
-			     inherited_ctor, inherited_parms);
+			     &inherited_ctor, inherited_parms);
   /* Don't bother marking a deleted constructor as constexpr.  */
   if (deleted_p)
     constexpr_p = false;
@@ -2120,7 +2133,7 @@ implicitly_declare_fn (special_function_kind kind, tree type,
       input_location = DECL_SOURCE_LOCATION (fn);
       synthesized_method_walk (type, kind, const_p,
 			       NULL, NULL, NULL, NULL, true,
-			       NULL_TREE, NULL_TREE);
+			       NULL, NULL_TREE);
       input_location = loc;
     }
 
diff --git a/gcc/cp/name-lookup.c b/gcc/cp/name-lookup.c
index dc8e82c2fe2..6ccfdbfdb71 100644
--- a/gcc/cp/name-lookup.c
+++ b/gcc/cp/name-lookup.c
@@ -3684,6 +3684,9 @@ handle_namespace_attrs (tree ns, tree attributes)
   tree d;
   bool saw_vis = false;
 
+  if (attributes == error_mark_node)
+    return false;
+
   for (d = attributes; d; d = TREE_CHAIN (d))
     {
       tree name = get_attribute_name (d);
diff --git a/gcc/cp/optimize.c b/gcc/cp/optimize.c
index d646ef73803..7cca0135360 100644
--- a/gcc/cp/optimize.c
+++ b/gcc/cp/optimize.c
@@ -46,6 +46,8 @@ update_cloned_parm (tree parm, tree cloned_parm, bool first)
   /* We may have taken its address.  */
   TREE_ADDRESSABLE (cloned_parm) = TREE_ADDRESSABLE (parm);
 
+  DECL_BY_REFERENCE (cloned_parm) = DECL_BY_REFERENCE (parm);
+
   /* The definition might have different constness.  */
   TREE_READONLY (cloned_parm) = TREE_READONLY (parm);
 
diff --git a/gcc/cp/parser.c b/gcc/cp/parser.c
index 29aa76b5dab..a29b3940ab0 100644
--- a/gcc/cp/parser.c
+++ b/gcc/cp/parser.c
@@ -7252,6 +7252,60 @@ cp_parser_postfix_open_square_expression (cp_parser *parser,
   return postfix_expression;
 }
 
+/* A subroutine of cp_parser_postfix_dot_deref_expression.  Handle dot
+   dereference of incomplete type, returns true if error_mark_node should
+   be returned from caller, otherwise adjusts *SCOPE, *POSTFIX_EXPRESSION
+   and *DEPENDENT_P.  */
+
+bool
+cp_parser_dot_deref_incomplete (tree *scope, cp_expr *postfix_expression,
+				bool *dependent_p)
+{
+  /* In a template, be permissive by treating an object expression
+     of incomplete type as dependent (after a pedwarn).  */
+  diagnostic_t kind = (processing_template_decl
+		       && MAYBE_CLASS_TYPE_P (*scope) ? DK_PEDWARN : DK_ERROR);
+
+  switch (TREE_CODE (*postfix_expression))
+    {
+    case CAST_EXPR:
+    case REINTERPRET_CAST_EXPR:
+    case CONST_CAST_EXPR:
+    case STATIC_CAST_EXPR:
+    case DYNAMIC_CAST_EXPR:
+    case IMPLICIT_CONV_EXPR:
+    case VIEW_CONVERT_EXPR:
+    case NON_LVALUE_EXPR:
+      kind = DK_ERROR;
+      break;
+    case OVERLOAD:
+      /* Don't emit any diagnostic for OVERLOADs.  */
+      kind = DK_IGNORED;
+      break;
+    default:
+      /* Avoid clobbering e.g. DECLs.  */
+      if (!EXPR_P (*postfix_expression))
+	kind = DK_ERROR;
+      break;
+    }
+
+  if (kind == DK_IGNORED)
+    return false;
+
+  location_t exploc = location_of (*postfix_expression);
+  cxx_incomplete_type_diagnostic (exploc, *postfix_expression, *scope, kind);
+  if (!MAYBE_CLASS_TYPE_P (*scope))
+    return true;
+  if (kind == DK_ERROR)
+    *scope = *postfix_expression = error_mark_node;
+  else if (processing_template_decl)
+    {
+      *dependent_p = true;
+      *scope = TREE_TYPE (*postfix_expression) = NULL_TREE;
+    }
+  return false;
+}
+
 /* A subroutine of cp_parser_postfix_expression that also gets hijacked
    by cp_parser_builtin_offsetof.  We're looking for
 
@@ -7310,29 +7364,13 @@ cp_parser_postfix_dot_deref_expression (cp_parser *parser,
       if (postfix_expression != current_class_ref
 	  && scope != error_mark_node
 	  && !(processing_template_decl
-	       && current_class_type
-	       && (same_type_ignoring_top_level_qualifiers_p
-		   (scope, current_class_type))))
+	       && currently_open_class (scope)))
 	{
 	  scope = complete_type (scope);
 	  if (!COMPLETE_TYPE_P (scope)
-	      /* Avoid clobbering e.g. OVERLOADs or DECLs.  */
-	      && EXPR_P (postfix_expression))
-	    {
-	      /* In a template, be permissive by treating an object expression
-		 of incomplete type as dependent (after a pedwarn).  */
-	      diagnostic_t kind = (processing_template_decl
-				   ? DK_PEDWARN
-				   : DK_ERROR);
-	      cxx_incomplete_type_diagnostic
-		(location_of (postfix_expression),
-		 postfix_expression, scope, kind);
-	      if (processing_template_decl)
-		{
-		  dependent_p = true;
-		  scope = TREE_TYPE (postfix_expression) = NULL_TREE;
-		}
-	    }
+	      && cp_parser_dot_deref_incomplete (&scope, &postfix_expression,
+						 &dependent_p))
+	    return error_mark_node;
 	}
 
       if (!dependent_p)
@@ -9030,12 +9068,20 @@ cp_parser_binary_expression (cp_parser* parser, bool cast_p,
       if (no_toplevel_fold_p
 	  && lookahead_prec <= current.prec
 	  && sp == stack)
-	current.lhs = build2_loc (combined_loc,
-				  current.tree_type,
-				  TREE_CODE_CLASS (current.tree_type)
-				  == tcc_comparison
-				  ? boolean_type_node : TREE_TYPE (current.lhs),
-				  current.lhs, rhs);
+	{
+	  if (current.lhs == error_mark_node || rhs == error_mark_node)
+	    current.lhs = error_mark_node;
+	  else
+	    {
+	      current.lhs
+		= build_min (current.tree_type,
+			     TREE_CODE_CLASS (current.tree_type)
+			     == tcc_comparison
+			     ? boolean_type_node : TREE_TYPE (current.lhs),
+			     current.lhs.get_value (), rhs.get_value ());
+	      SET_EXPR_LOCATION (current.lhs, combined_loc);
+	    }
+	}
       else
         {
           current.lhs = build_x_binary_op (combined_loc, current.tree_type,
@@ -10743,6 +10789,18 @@ cp_parser_statement (cp_parser* parser, tree in_statement_expr,
 		"attributes at the beginning of statement are ignored");
 }
 
+/* Append ATTR to attribute list ATTRS.  */
+
+static tree
+attr_chainon (tree attrs, tree attr)
+{
+  if (attrs == error_mark_node)
+    return error_mark_node;
+  if (attr == error_mark_node)
+    return error_mark_node;
+  return chainon (attrs, attr);
+}
+
 /* Parse the label for a labeled-statement, i.e.
 
    identifier :
@@ -10862,7 +10920,7 @@ cp_parser_label_for_labeled_statement (cp_parser* parser, tree attributes)
       else if (!cp_parser_parse_definitely (parser))
 	;
       else
-	attributes = chainon (attributes, attrs);
+	attributes = attr_chainon (attributes, attrs);
     }
 
   if (attributes != NULL_TREE)
@@ -11798,7 +11856,7 @@ cp_parser_perform_range_for_lookup (tree range, tree *begin, tree *end)
 				  /*protect=*/2, /*want_type=*/false,
 				  tf_warning_or_error);
 
-      if (member_begin != NULL_TREE || member_end != NULL_TREE)
+      if (member_begin != NULL_TREE && member_end != NULL_TREE)
 	{
 	  /* Use the member functions.  */
 	  if (member_begin != NULL_TREE)
@@ -12043,12 +12101,9 @@ cp_parser_init_statement (cp_parser* parser, tree *decl)
 	  cp_lexer_consume_token (parser->lexer);
 	  is_range_for = true;
 	  if (cxx_dialect < cxx11)
-	    {
-	      pedwarn (cp_lexer_peek_token (parser->lexer)->location, 0,
-		       "range-based %<for%> loops only available with "
-		       "-std=c++11 or -std=gnu++11");
-	      *decl = error_mark_node;
-	    }
+	    pedwarn (cp_lexer_peek_token (parser->lexer)->location, 0,
+		     "range-based %<for%> loops only available with "
+		     "-std=c++11 or -std=gnu++11");
 	}
       else
 	  /* The ';' is not consumed yet because we told
@@ -13194,8 +13249,7 @@ cp_parser_decl_specifier_seq (cp_parser* parser,
 		  else
 		    {
 		      decl_specs->std_attributes
-			= chainon (decl_specs->std_attributes,
-				   attrs);
+			= attr_chainon (decl_specs->std_attributes, attrs);
 		      if (decl_specs->locations[ds_std_attribute] == 0)
 			decl_specs->locations[ds_std_attribute] = token->location;
 		    }
@@ -13203,9 +13257,8 @@ cp_parser_decl_specifier_seq (cp_parser* parser,
 		}
 	    }
 
-	    decl_specs->attributes
-	      = chainon (decl_specs->attributes,
-			 attrs);
+	  decl_specs->attributes
+	    = attr_chainon (decl_specs->attributes, attrs);
 	  if (decl_specs->locations[ds_attribute] == 0)
 	    decl_specs->locations[ds_attribute] = token->location;
 	  continue;
@@ -13688,6 +13741,10 @@ cp_parser_decltype_expr (cp_parser *parser,
 	expr = cp_parser_lookup_name_simple (parser, expr,
 					     id_expr_start_token->location);
 
+      if (expr && TREE_CODE (expr) == TEMPLATE_DECL)
+	/* A template without args is not a complete id-expression.  */
+	expr = error_mark_node;
+
       if (expr
           && expr != error_mark_node
           && TREE_CODE (expr) != TYPE_DECL
@@ -13753,6 +13810,9 @@ cp_parser_decltype_expr (cp_parser *parser,
          expression.  */
       cp_parser_abort_tentative_parse (parser);
 
+      /* Commit to the tentative_firewall so we get syntax errors.  */
+      cp_parser_commit_to_tentative_parse (parser);
+
       /* Parse a full expression.  */
       expr = cp_parser_expression (parser, /*pidk=*/NULL, /*cast_p=*/false,
 				   /*decltype_p=*/true);
@@ -18220,7 +18280,7 @@ cp_parser_namespace_definition (cp_parser* parser)
   if (post_ident_attribs)
     {
       if (attribs)
-        attribs = chainon (attribs, post_ident_attribs);
+        attribs = attr_chainon (attribs, post_ident_attribs);
       else
         attribs = post_ident_attribs;
     }
@@ -18729,22 +18789,35 @@ cp_parser_using_directive (cp_parser* parser)
 
 /* Parse an asm-definition.
 
+  asm-qualifier:
+    volatile
+    inline
+    goto
+
+  asm-qualifier-list:
+    asm-qualifier
+    asm-qualifier-list asm-qualifier
+
    asm-definition:
      asm ( string-literal ) ;
 
    GNU Extension:
 
    asm-definition:
-     asm volatile [opt] ( string-literal ) ;
-     asm volatile [opt] ( string-literal : asm-operand-list [opt] ) ;
-     asm volatile [opt] ( string-literal : asm-operand-list [opt]
-			  : asm-operand-list [opt] ) ;
-     asm volatile [opt] ( string-literal : asm-operand-list [opt]
-			  : asm-operand-list [opt]
+     asm asm-qualifier-list [opt] ( string-literal ) ;
+     asm asm-qualifier-list [opt] ( string-literal : asm-operand-list [opt] ) ;
+     asm asm-qualifier-list [opt] ( string-literal : asm-operand-list [opt]
+				    : asm-operand-list [opt] ) ;
+     asm asm-qualifier-list [opt] ( string-literal : asm-operand-list [opt]
+				    : asm-operand-list [opt]
 			  : asm-clobber-list [opt] ) ;
-     asm volatile [opt] goto ( string-literal : : asm-operand-list [opt]
-			       : asm-clobber-list [opt]
-			       : asm-goto-list ) ;  */
+     asm asm-qualifier-list [opt] ( string-literal : : asm-operand-list [opt]
+				    : asm-clobber-list [opt]
+				    : asm-goto-list ) ;
+
+  The form with asm-goto-list is valid if and only if the asm-qualifier-list
+  contains goto, and is the only allowed form in that case.  No duplicates are
+  allowed in an asm-qualifier-list.  */
 
 static void
 cp_parser_asm_definition (cp_parser* parser)
@@ -18755,11 +18828,9 @@ cp_parser_asm_definition (cp_parser* parser)
   tree clobbers = NULL_TREE;
   tree labels = NULL_TREE;
   tree asm_stmt;
-  bool volatile_p = false;
   bool extended_p = false;
   bool invalid_inputs_p = false;
   bool invalid_outputs_p = false;
-  bool goto_p = false;
   required_token missing = RT_NONE;
 
   /* Look for the `asm' keyword.  */
@@ -18772,24 +18843,78 @@ cp_parser_asm_definition (cp_parser* parser)
       cp_function_chain->invalid_constexpr = true;
     }
 
-  /* See if the next token is `volatile'.  */
-  if (cp_parser_allow_gnu_extensions_p (parser)
-      && cp_lexer_next_token_is_keyword (parser->lexer, RID_VOLATILE))
-    {
-      /* Remember that we saw the `volatile' keyword.  */
-      volatile_p = true;
-      /* Consume the token.  */
-      cp_lexer_consume_token (parser->lexer);
-    }
-  if (cp_parser_allow_gnu_extensions_p (parser)
-      && parser->in_function_body
-      && cp_lexer_next_token_is_keyword (parser->lexer, RID_GOTO))
+  /* Handle the asm-qualifier-list.  */
+  location_t volatile_loc = UNKNOWN_LOCATION;
+  location_t inline_loc = UNKNOWN_LOCATION;
+  location_t goto_loc = UNKNOWN_LOCATION;
+  location_t first_loc = UNKNOWN_LOCATION;
+
+  if (cp_parser_allow_gnu_extensions_p (parser))
+    for (;;)
+      {
+	cp_token *token = cp_lexer_peek_token (parser->lexer);
+	location_t loc = token->location;
+	switch (cp_lexer_peek_token (parser->lexer)->keyword)
+	  {
+	  case RID_VOLATILE:
+	    if (volatile_loc)
+	      {
+		error_at (loc, "duplicate asm qualifier %qT", token->u.value);
+		inform (volatile_loc, "first seen here");
+	      }
+	    else
+	      volatile_loc = loc;
+	    cp_lexer_consume_token (parser->lexer);
+	    continue;
+
+	  case RID_INLINE:
+	    if (inline_loc)
+	      {
+		error_at (loc, "duplicate asm qualifier %qT", token->u.value);
+		inform (inline_loc, "first seen here");
+	      }
+	    else
+	      inline_loc = loc;
+	    if (!first_loc)
+	      first_loc = loc;
+	    cp_lexer_consume_token (parser->lexer);
+	    continue;
+
+	  case RID_GOTO:
+	    if (goto_loc)
+	      {
+		error_at (loc, "duplicate asm qualifier %qT", token->u.value);
+		inform (goto_loc, "first seen here");
+	      }
+	    else
+	      goto_loc = loc;
+	    if (!first_loc)
+	      first_loc = loc;
+	    cp_lexer_consume_token (parser->lexer);
+	    continue;
+
+	  case RID_CONST:
+	  case RID_RESTRICT:
+	    error_at (loc, "%qT is not an asm qualifier", token->u.value);
+	    cp_lexer_consume_token (parser->lexer);
+	    continue;
+
+	  default:
+	    break;
+	  }
+	break;
+      }
+
+  bool volatile_p = (volatile_loc != UNKNOWN_LOCATION);
+  bool inline_p = (inline_loc != UNKNOWN_LOCATION);
+  bool goto_p = (goto_loc != UNKNOWN_LOCATION);
+
+  if (!parser->in_function_body && (inline_p || goto_p))
     {
-      /* Remember that we saw the `goto' keyword.  */
-      goto_p = true;
-      /* Consume the token.  */
-      cp_lexer_consume_token (parser->lexer);
+      error_at (first_loc, "asm qualifier outside of function body");
+      inline_p = goto_p = false;
     }
+
   /* Look for the opening `('.  */
   if (!cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))
     return;
@@ -18881,8 +19006,7 @@ cp_parser_asm_definition (cp_parser* parser)
 					     CPP_CLOSE_PAREN))
 	    clobbers = cp_parser_asm_clobber_list (parser);
 	}
-      else if (goto_p
-	       && cp_lexer_next_token_is (parser->lexer, CPP_SCOPE))
+      else if (goto_p && cp_lexer_next_token_is (parser->lexer, CPP_SCOPE))
 	/* The labels are coming next.  */
 	labels_p = true;
 
@@ -18916,7 +19040,7 @@ cp_parser_asm_definition (cp_parser* parser)
       if (parser->in_function_body)
 	{
 	  asm_stmt = finish_asm_stmt (volatile_p, string, outputs,
-				      inputs, clobbers, labels);
+				      inputs, clobbers, labels, inline_p);
 	  /* If the extended syntax was not used, mark the ASM_EXPR.  */
 	  if (!extended_p)
 	    {
@@ -19394,7 +19518,7 @@ cp_parser_init_declarator (cp_parser* parser,
       decl = grokfield (declarator, decl_specifiers,
 			initializer, !is_non_constant_init,
 			/*asmspec=*/NULL_TREE,
-			chainon (attributes, prefix_attributes));
+			attr_chainon (attributes, prefix_attributes));
       if (decl && TREE_CODE (decl) == FUNCTION_DECL)
 	cp_parser_save_default_args (parser, decl);
       cp_finalize_omp_declare_simd (parser, decl);
@@ -20789,9 +20913,9 @@ cp_parser_type_specifier_seq (cp_parser* parser,
       /* Check for attributes first.  */
       if (cp_next_tokens_can_be_attribute_p (parser))
 	{
-	  type_specifier_seq->attributes =
-	    chainon (type_specifier_seq->attributes,
-		     cp_parser_attributes_opt (parser));
+	  type_specifier_seq->attributes
+	    = attr_chainon (type_specifier_seq->attributes,
+			    cp_parser_attributes_opt (parser));
 	  continue;
 	}
 
@@ -20904,7 +21028,10 @@ cp_parser_parameter_declaration_clause (cp_parser* parser)
 
   if (!processing_specialization
       && !processing_template_parmlist
-      && !processing_explicit_instantiation)
+      && !processing_explicit_instantiation
+      /* default_arg_ok_p tracks whether this is a parameter-clause for an
+         actual function or a random abstract declarator.  */
+      && parser->default_arg_ok_p)
     if (!current_function_decl
 	|| (current_class_type && LAMBDA_TYPE_P (current_class_type)))
       parser->auto_is_implicit_function_template_parm_p = true;
@@ -21013,9 +21140,6 @@ cp_parser_parameter_declaration_list (cp_parser* parser, bool *is_error)
       cp_parameter_declarator *parameter;
       tree decl = error_mark_node;
       bool parenthesized_p = false;
-      int template_parm_idx = (function_being_declared_is_template_p (parser)?
-			       TREE_VEC_LENGTH (INNERMOST_TEMPLATE_PARMS
-						(current_template_parms)) : 0);
 
       /* Parse the parameter.  */
       parameter
@@ -21029,22 +21153,6 @@ cp_parser_parameter_declaration_list (cp_parser* parser, bool *is_error)
 
       if (parameter)
 	{
-	  /* If a function parameter pack was specified and an implicit template
-	     parameter was introduced during cp_parser_parameter_declaration,
-	     change any implicit parameters introduced into packs.  */
-	  if (parser->implicit_template_parms
-	      && parameter->declarator
-	      && parameter->declarator->parameter_pack_p)
-	    {
-	      int latest_template_parm_idx = TREE_VEC_LENGTH
-		(INNERMOST_TEMPLATE_PARMS (current_template_parms));
-
-	      if (latest_template_parm_idx != template_parm_idx)
-		parameter->decl_specifiers.type = convert_generic_types_to_packs
-		  (parameter->decl_specifiers.type,
-		   template_parm_idx, latest_template_parm_idx);
-	    }
-
 	  decl = grokdeclarator (parameter->declarator,
 				 &parameter->decl_specifiers,
 				 PARM,
@@ -21202,6 +21310,10 @@ cp_parser_parameter_declaration (cp_parser *parser,
   parser->type_definition_forbidden_message
     = G_("types may not be defined in parameter types");
 
+  int template_parm_idx = (function_being_declared_is_template_p (parser) ?
+			   TREE_VEC_LENGTH (INNERMOST_TEMPLATE_PARMS
+					    (current_template_parms)) : 0);
+
   /* Parse the declaration-specifiers.  */
   cp_parser_decl_specifier_seq (parser,
 				CP_PARSER_FLAGS_NONE,
@@ -21270,8 +21382,8 @@ cp_parser_parameter_declaration (cp_parser *parser,
       parser->default_arg_ok_p = saved_default_arg_ok_p;
       /* After the declarator, allow more attributes.  */
       decl_specifiers.attributes
-	= chainon (decl_specifiers.attributes,
-		   cp_parser_attributes_opt (parser));
+	= attr_chainon (decl_specifiers.attributes,
+			cp_parser_attributes_opt (parser));
 
       /* If the declarator is a template parameter pack, remember that and
 	 clear the flag in the declarator itself so we don't get errors
@@ -21290,6 +21402,24 @@ cp_parser_parameter_declaration (cp_parser *parser,
      parameter pack expansion expression. Otherwise, leave the ellipsis
      for a C-style variadic function. */
   token = cp_lexer_peek_token (parser->lexer);
+
+  /* If a function parameter pack was specified and an implicit template
+     parameter was introduced during cp_parser_parameter_declaration,
+     change any implicit parameters introduced into packs.  */
+  if (parser->implicit_template_parms
+      && ((token->type == CPP_ELLIPSIS
+	   && declarator_can_be_parameter_pack (declarator))
+	  || (declarator && declarator->parameter_pack_p)))
+    {
+      int latest_template_parm_idx = TREE_VEC_LENGTH
+	(INNERMOST_TEMPLATE_PARMS (current_template_parms));
+
+      if (latest_template_parm_idx != template_parm_idx)
+	decl_specifiers.type = convert_generic_types_to_packs
+	  (decl_specifiers.type,
+	   template_parm_idx, latest_template_parm_idx);
+    }
+
   if (cp_lexer_next_token_is (parser->lexer, CPP_ELLIPSIS))
     {
       tree type = decl_specifiers.type;
@@ -23261,7 +23391,7 @@ cp_parser_member_declaration (cp_parser* parser)
 		 which are not.  */
 	      first_attribute = attributes;
 	      /* Combine the attributes.  */
-	      attributes = chainon (prefix_attributes, attributes);
+	      attributes = attr_chainon (prefix_attributes, attributes);
 
 	      /* Create the bitfield declaration.  */
 	      decl = grokbitfield (identifier
@@ -23318,7 +23448,7 @@ cp_parser_member_declaration (cp_parser* parser)
 		 which are not.  */
 	      first_attribute = attributes;
 	      /* Combine the attributes.  */
-	      attributes = chainon (prefix_attributes, attributes);
+	      attributes = attr_chainon (prefix_attributes, attributes);
 
 	      /* If it's an `=', then we have a constant-initializer or a
 		 pure-specifier.  It is not correct to parse the
@@ -23432,10 +23562,13 @@ cp_parser_member_declaration (cp_parser* parser)
 	  cp_finalize_oacc_routine (parser, decl, false);
 
 	  /* Reset PREFIX_ATTRIBUTES.  */
-	  while (attributes && TREE_CHAIN (attributes) != first_attribute)
-	    attributes = TREE_CHAIN (attributes);
-	  if (attributes)
-	    TREE_CHAIN (attributes) = NULL_TREE;
+	  if (attributes != error_mark_node)
+	    {
+	      while (attributes && TREE_CHAIN (attributes) != first_attribute)
+		attributes = TREE_CHAIN (attributes);
+	      if (attributes)
+		TREE_CHAIN (attributes) = NULL_TREE;
+	    }
 
 	  /* If there is any qualification still in effect, clear it
 	     now; we will be starting fresh with the next declarator.  */
@@ -24547,7 +24680,7 @@ cp_parser_gnu_attributes_opt (cp_parser* parser)
 	cp_parser_skip_to_end_of_statement (parser);
 
       /* Add these new attributes to the list.  */
-      attributes = chainon (attributes, attribute_list);
+      attributes = attr_chainon (attributes, attribute_list);
     }
 
   return attributes;
@@ -29725,7 +29858,7 @@ cp_parser_objc_class_ivars (cp_parser* parser)
 	     which are not.  */
 	  first_attribute = attributes;
 	  /* Combine the attributes.  */
-	  attributes = chainon (prefix_attributes, attributes);
+	  attributes = attr_chainon (prefix_attributes, attributes);
 
 	  if (width)
 	      /* Create the bitfield declaration.  */
@@ -29742,10 +29875,13 @@ cp_parser_objc_class_ivars (cp_parser* parser)
 	    objc_add_instance_variable (decl);
 
 	  /* Reset PREFIX_ATTRIBUTES.  */
-	  while (attributes && TREE_CHAIN (attributes) != first_attribute)
-	    attributes = TREE_CHAIN (attributes);
-	  if (attributes)
-	    TREE_CHAIN (attributes) = NULL_TREE;
+	  if (attributes != error_mark_node)
+	    {
+	      while (attributes && TREE_CHAIN (attributes) != first_attribute)
+		attributes = TREE_CHAIN (attributes);
+	      if (attributes)
+		TREE_CHAIN (attributes) = NULL_TREE;
+	    }
 
 	  token = cp_lexer_peek_token (parser->lexer);
 
@@ -30275,8 +30411,8 @@ cp_parser_objc_struct_declaration (cp_parser *parser)
 	 which are not.  */
       first_attribute = attributes;
       /* Combine the attributes.  */
-      attributes = chainon (prefix_attributes, attributes);
-      
+      attributes = attr_chainon (prefix_attributes, attributes);
+
       decl = grokfield (declarator, &declspecs,
 			NULL_TREE, /*init_const_expr_p=*/false,
 			NULL_TREE, attributes);
@@ -30285,10 +30421,13 @@ cp_parser_objc_struct_declaration (cp_parser *parser)
 	return error_mark_node;
       
       /* Reset PREFIX_ATTRIBUTES.  */
-      while (attributes && TREE_CHAIN (attributes) != first_attribute)
-	attributes = TREE_CHAIN (attributes);
-      if (attributes)
-	TREE_CHAIN (attributes) = NULL_TREE;
+      if (attributes != error_mark_node)
+	{
+	  while (attributes && TREE_CHAIN (attributes) != first_attribute)
+	    attributes = TREE_CHAIN (attributes);
+	  if (attributes)
+	    TREE_CHAIN (attributes) = NULL_TREE;
+	}
 
       DECL_CHAIN (decl) = decls;
       decls = decl;
@@ -30888,7 +31027,10 @@ cp_parser_omp_var_list_no_open (cp_parser *parser, enum omp_clause_code kind,
 	  if (name == error_mark_node)
 	    goto skip_comma;
 
-	  decl = cp_parser_lookup_name_simple (parser, name, token->location);
+	  if (identifier_p (name))
+	    decl = cp_parser_lookup_name_simple (parser, name, token->location);
+	  else
+	    decl = name;
 	  if (decl == error_mark_node)
 	    cp_parser_name_lookup_error (parser, name, decl, NLE_NULL,
 					 token->location);
@@ -34209,7 +34351,7 @@ static tree
 cp_parser_omp_for_loop_init (cp_parser *parser,
 			     enum tree_code code,
 			     tree &this_pre_body,
-			     vec<tree, va_gc> *for_block,
+			     vec<tree, va_gc> *&for_block,
 			     tree &init,
 			     tree &orig_init,
 			     tree &decl,
@@ -37448,7 +37590,9 @@ cp_parser_oacc_routine (cp_parser *parser, cp_token *pragma_tok,
 					   /*template_p=*/NULL,
 					   /*declarator_p=*/false,
 					   /*optional_p=*/false);
-      tree decl = cp_parser_lookup_name_simple (parser, name, name_loc);
+      tree decl = (identifier_p (name)
+		   ? cp_parser_lookup_name_simple (parser, name, name_loc)
+		   : name);
       if (name != error_mark_node && decl == error_mark_node)
 	cp_parser_name_lookup_error (parser, name, decl, NLE_NULL, name_loc);
 
diff --git a/gcc/cp/pt.c b/gcc/cp/pt.c
index 5687bb21252..2df7402c905 100644
--- a/gcc/cp/pt.c
+++ b/gcc/cp/pt.c
@@ -2072,7 +2072,8 @@ determine_specialization (tree template_id,
   /* We shouldn't be specializing a member template of an
      unspecialized class template; we already gave an error in
      check_specialization_scope, now avoid crashing.  */
-  if (template_count && DECL_CLASS_SCOPE_P (decl)
+  if (!VAR_P (decl)
+      && template_count && DECL_CLASS_SCOPE_P (decl)
       && template_class_depth (DECL_CONTEXT (decl)) > 0)
     {
       gcc_assert (errorcount);
@@ -2175,10 +2176,17 @@ determine_specialization (tree template_id,
 	     that the const qualification is the same.  Since
 	     get_bindings does not try to merge the "this" parameter,
 	     we must do the comparison explicitly.  */
-	  if (DECL_NONSTATIC_MEMBER_FUNCTION_P (fn)
-	      && !same_type_p (TREE_VALUE (fn_arg_types),
-			       TREE_VALUE (decl_arg_types)))
-	    continue;
+	  if (DECL_NONSTATIC_MEMBER_FUNCTION_P (fn))
+	    {
+	      if (!same_type_p (TREE_VALUE (fn_arg_types),
+				TREE_VALUE (decl_arg_types)))
+		continue;
+
+	      /* And the ref-qualification.  */
+	      if (type_memfn_rqual (TREE_TYPE (decl))
+		  != type_memfn_rqual (TREE_TYPE (fn)))
+		continue;
+	    }
 
 	  /* Skip the "this" parameter and, for constructors of
 	     classes with virtual bases, the VTT parameter.  A
@@ -2284,6 +2292,11 @@ determine_specialization (tree template_id,
 			 decl_arg_types))
             continue;
 
+	  if (DECL_NONSTATIC_MEMBER_FUNCTION_P (fn)
+	      && (type_memfn_rqual (TREE_TYPE (decl))
+		  != type_memfn_rqual (TREE_TYPE (fn))))
+	    continue;
+
           // If the deduced arguments do not satisfy the constraints,
           // this is not a candidate.
           if (flag_concepts && !constraints_satisfied_p (fn))
@@ -4601,10 +4614,13 @@ process_partial_specialization (tree decl)
     {
       if (!flag_concepts)
         error ("partial specialization %q+D does not specialize "
-	       "any template arguments", decl);
+	       "any template arguments; to define the primary template, "
+	       "remove the template argument list", decl);
       else
         error ("partial specialization %q+D does not specialize any "
-	       "template arguments and is not more constrained than", decl);
+	       "template arguments and is not more constrained than "
+	       "the primary template; to define the primary template, "
+	       "remove the template argument list", decl);
       inform (DECL_SOURCE_LOCATION (maintmpl), "primary template here");
     }
 
@@ -4848,7 +4864,7 @@ static void
 fixed_parameter_pack_p_1 (tree parm, struct find_parameter_pack_data *ppd)
 {
   /* A type parm can't refer to another parm.  */
-  if (TREE_CODE (parm) == TYPE_DECL)
+  if (TREE_CODE (parm) == TYPE_DECL || parm == error_mark_node)
     return;
   else if (TREE_CODE (parm) == PARM_DECL)
     {
@@ -6032,7 +6048,12 @@ convert_nontype_argument_function (tree type, tree expr,
 
  accept:
   if (TREE_CODE (type) == REFERENCE_TYPE)
-    fn = build_address (fn);
+    {
+      if (REFERENCE_REF_P (fn))
+	fn = TREE_OPERAND (fn, 0);
+      else
+	fn = build_address (fn);
+    }
   if (!same_type_ignoring_top_level_qualifiers_p (type, TREE_TYPE (fn)))
     fn = build_nop (type, fn);
 
@@ -8244,7 +8265,11 @@ coerce_template_parms (tree parms,
     }
 
   if (lost)
-    return error_mark_node;
+    {
+      if ((complain & tf_error) && !seen_error())
+	error ("wrong number of template arguments");
+      return error_mark_node;
+    }
 
   if (CHECKING_P && !NON_DEFAULT_TEMPLATE_ARGS_COUNT (new_inner_args))
     SET_NON_DEFAULT_TEMPLATE_ARGS_COUNT (new_inner_args,
@@ -11454,7 +11479,9 @@ tsubst_pack_expansion (tree t, tree args, tsubst_flags_t complain,
 	    {
 	      /* This parameter pack was used in an unevaluated context.  Just
 		 make a dummy decl, since it's only used for its type.  */
+	      ++cp_unevaluated_operand;
 	      arg_pack = tsubst_decl (parm_pack, args, complain);
+	      --cp_unevaluated_operand;
 	      if (arg_pack && DECL_PACK_P (arg_pack))
 		/* Partial instantiation of the parm_pack, we can't build
 		   up an argument pack yet.  */
@@ -11524,7 +11551,7 @@ tsubst_pack_expansion (tree t, tree args, tsubst_flags_t complain,
 	  /* We can't substitute for this parameter pack.  We use a flag as
 	     well as the missing_level counter because function parameter
 	     packs don't have a level.  */
-	  gcc_assert (processing_template_decl);
+	  gcc_assert (processing_template_decl || is_auto (parm_pack));
 	  unsubstituted_packs = true;
 	}
     }
@@ -13755,8 +13782,7 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)
 			= tsubst_constraint (constr, args, complain, in_decl);
 		    else if (tree pl = CLASS_PLACEHOLDER_TEMPLATE (t))
 		      {
-			if (DECL_TEMPLATE_TEMPLATE_PARM_P (pl))
-			  pl = tsubst (pl, args, complain, in_decl);
+			pl = tsubst_copy (pl, args, complain, in_decl);
 			CLASS_PLACEHOLDER_TEMPLATE (r) = pl;
 		      }
 		  }
@@ -15778,6 +15804,12 @@ tsubst_decomp_names (tree decl, tree pattern_decl, tree args,
       DECL_HAS_VALUE_EXPR_P (decl2) = 1;
       if (VAR_P (decl3))
 	DECL_TEMPLATE_INSTANTIATED (decl3) = 1;
+      else
+	{
+	  gcc_assert (errorcount);
+	  decl = error_mark_node;
+	  continue;
+	}
       maybe_push_decl (decl3);
       if (error_operand_p (decl3))
 	decl = error_mark_node;
@@ -16127,7 +16159,7 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,
 	tree labels = tsubst_copy_asm_operands (ASM_LABELS (t), args,
 						complain, in_decl);
 	tmp = finish_asm_stmt (ASM_VOLATILE_P (t), string, outputs, inputs,
-			       clobbers, labels);
+			       clobbers, labels, ASM_INLINE_P (t));
 	tree asm_expr = tmp;
 	if (TREE_CODE (asm_expr) == CLEANUP_POINT_EXPR)
 	  asm_expr = TREE_OPERAND (asm_expr, 0);
@@ -16766,14 +16798,14 @@ tsubst_copy_and_build (tree t,
 	if (targs)
 	  targs = tsubst_template_args (targs, args, complain, in_decl);
 	if (targs == error_mark_node)
-	  return error_mark_node;
+	  RETURN (error_mark_node);
 
 	if (TREE_CODE (templ) == SCOPE_REF)
 	  {
 	    tree name = TREE_OPERAND (templ, 1);
 	    tree tid = lookup_template_function (name, targs);
 	    TREE_OPERAND (templ, 1) = tid;
-	    return templ;
+	    RETURN (templ);
 	  }
 
 	if (variable_template_p (templ))
@@ -16838,6 +16870,8 @@ tsubst_copy_and_build (tree t,
       {
 	tree type = tsubst (TREE_TYPE (t), args, complain, in_decl);
 	tree op0 = RECUR (TREE_OPERAND (t, 0));
+	if (op0 == error_mark_node)
+	  RETURN (error_mark_node);
 	RETURN (build1 (CONVERT_EXPR, type, op0));
       }
 
@@ -16985,7 +17019,7 @@ tsubst_copy_and_build (tree t,
       {
 	tree op0 = RECUR (TREE_OPERAND (t, 0));
 	tree op1 = RECUR (TREE_OPERAND (t, 1));
-	return fold_build_pointer_plus (op0, op1);
+	RETURN (fold_build_pointer_plus (op0, op1));
       }
 
     case SCOPE_REF:
@@ -17492,7 +17526,10 @@ tsubst_copy_and_build (tree t,
 		CALL_EXPR_REVERSE_ARGS (function) = rev;
 		if (thk)
 		  {
-		    CALL_FROM_THUNK_P (function) = true;
+		    if (TREE_CODE (function) == CALL_EXPR)
+		      CALL_FROM_THUNK_P (function) = true;
+		    else
+		      AGGR_INIT_FROM_THUNK_P (function) = true;
 		    /* The thunk location is not interesting.  */
 		    SET_EXPR_LOCATION (function, UNKNOWN_LOCATION);
 		  }
@@ -19205,6 +19242,24 @@ try_array_deduction (tree tparms, tree targs, tree parm)
 			  /*nondeduced*/false, array_deduction_r);
 }
 
+/* Returns how many levels of { } INIT contains.  */
+
+static int
+braced_init_depth (tree init)
+{
+  if (!init || !BRACE_ENCLOSED_INITIALIZER_P (init))
+    return 0;
+  unsigned i; tree val;
+  unsigned max = 0;
+  FOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (init), i, val)
+    {
+      unsigned elt_d = braced_init_depth (val);
+      if (elt_d > max)
+	max = elt_d;
+    }
+  return max + 1;
+}
+
 /* Most parms like fn_type_unification.
 
    If SUBR is 1, we're being called recursively (to unify the
@@ -19441,6 +19496,10 @@ type_unification_real (tree tparms,
 
 	    if (uses_template_parms (parm))
 	      continue;
+	    /* Workaround for c++/80290: avoid combinatorial explosion on
+	       deeply nested braced init-lists.  */
+	    if (braced_init_depth (arg) > 2)
+	      continue;
 	    if (check_non_deducible_conversion (parm, arg, strict, flags,
 						explain_p))
 	      return 1;
@@ -24065,20 +24124,21 @@ type_dependent_expression_p (tree expression)
 	  && (any_dependent_template_arguments_p
 	      (INNERMOST_TEMPLATE_ARGS (DECL_TI_ARGS (expression)))))
 	return true;
+    }
 
-      /* Otherwise, if the decl isn't from a dependent scope, it can't be
-	 type-dependent.  Checking this is important for functions with auto
-	 return type, which looks like a dependent type.  */
-      if (TREE_CODE (expression) == FUNCTION_DECL
-	  && undeduced_auto_decl (expression)
-	  && (!DECL_CLASS_SCOPE_P (expression)
-	      || !dependent_type_p (DECL_CONTEXT (expression)))
-	  && (!DECL_FRIEND_CONTEXT (expression)
-	      || !dependent_type_p (DECL_FRIEND_CONTEXT (expression)))
-	  && !DECL_LOCAL_FUNCTION_P (expression))
-	{
-	  return false;
-	}
+  /* Otherwise, if the decl isn't from a dependent scope, it can't be
+     type-dependent.  Checking this is important for functions with auto
+     return type, which looks like a dependent type.  */
+  if (TREE_CODE (expression) == FUNCTION_DECL
+      && undeduced_auto_decl (expression)
+      && (!DECL_CLASS_SCOPE_P (expression)
+	  || !dependent_type_p (DECL_CONTEXT (expression)))
+      && (!DECL_LANG_SPECIFIC (expression)
+	  || !DECL_FRIEND_CONTEXT (expression)
+	  || !dependent_type_p (DECL_FRIEND_CONTEXT (expression)))
+      && !DECL_LOCAL_FUNCTION_P (expression))
+    {
+      return false;
     }
 
   /* Always dependent, on the number of arguments if nothing else.  */
@@ -25105,8 +25165,21 @@ rewrite_template_parm (tree olddecl, unsigned index, unsigned level,
 	  = TEMPLATE_TYPE_PARM_FOR_CLASS (oldtype);
     }
   else
-    newtype = tsubst (TREE_TYPE (olddecl), tsubst_args,
-		      complain, NULL_TREE);
+    {
+      newtype = TREE_TYPE (olddecl);
+      if (type_uses_auto (newtype))
+	{
+	  // Substitute once to fix references to other template parameters.
+	  newtype = tsubst (newtype, tsubst_args,
+			    complain|tf_partial, NULL_TREE);
+	  // Now substitute again to reduce the level of the auto.
+	  newtype = tsubst (newtype, current_template_args (),
+			    complain, NULL_TREE);
+	}
+      else
+	newtype = tsubst (newtype, tsubst_args,
+			  complain, NULL_TREE);
+    }
 
   tree newdecl
     = build_decl (DECL_SOURCE_LOCATION (olddecl), TREE_CODE (olddecl),
@@ -25145,7 +25218,7 @@ rewrite_template_parm (tree olddecl, unsigned index, unsigned level,
 	  // Substitute ttargs into ttparms to fix references to
 	  // other template parameters.
 	  ttparms = tsubst_template_parms_level (ttparms, ttargs,
-						 complain);
+						 complain|tf_partial);
 	  // Now substitute again with args based on tparms, to reduce
 	  // the level of the ttparms.
 	  ttargs = current_template_args ();
@@ -25386,6 +25459,9 @@ do_class_deduction (tree ptype, tree tmpl, tree init, int flags,
     // FIXME cache artificial deduction guides
     for (tree fns = CLASSTYPE_CONSTRUCTORS (type); fns; fns = OVL_NEXT (fns))
       {
+	if (TREE_CODE (fns) == OVERLOAD && OVL_USED (fns))
+	  continue;
+
 	tree fn = OVL_CURRENT (fns);
 	tree guide = build_deduction_guide (fn, outer_args, complain);
 	cands = ovl_cons (guide, cands);
diff --git a/gcc/cp/search.c b/gcc/cp/search.c
index f9d770ad8ee..e72ce5a427c 100644
--- a/gcc/cp/search.c
+++ b/gcc/cp/search.c
@@ -2879,7 +2879,7 @@ original_binfo (tree binfo, tree here)
 bool
 any_dependent_bases_p (tree type)
 {
-  if (!type || !CLASS_TYPE_P (type) || !processing_template_decl)
+  if (!type || !CLASS_TYPE_P (type) || !uses_template_parms (type))
     return false;
 
   unsigned i;
diff --git a/gcc/cp/semantics.c b/gcc/cp/semantics.c
index e0663764638..785fc4a7b38 100644
--- a/gcc/cp/semantics.c
+++ b/gcc/cp/semantics.c
@@ -730,7 +730,10 @@ finish_if_stmt_cond (tree cond, tree if_stmt)
   cond = maybe_convert_cond (cond);
   if (IF_STMT_CONSTEXPR_P (if_stmt)
       && require_potential_rvalue_constant_expression (cond)
-      && !value_dependent_expression_p (cond))
+      && !value_dependent_expression_p (cond)
+      /* Wait until instantiation time, since only then COND has been
+	 converted to bool.  */
+      && TREE_TYPE (cond) == boolean_type_node)
     {
       cond = instantiate_non_dependent_expr (cond);
       cond = cxx_constant_value (cond, NULL_TREE);
@@ -1426,11 +1429,11 @@ finish_compound_stmt (tree stmt)
 /* Finish an asm-statement, whose components are a STRING, some
    OUTPUT_OPERANDS, some INPUT_OPERANDS, some CLOBBERS and some
    LABELS.  Also note whether the asm-statement should be
-   considered volatile.  */
+   considered volatile, and whether it is asm inline.  */
 
 tree
 finish_asm_stmt (int volatile_p, tree string, tree output_operands,
-		 tree input_operands, tree clobbers, tree labels)
+		 tree input_operands, tree clobbers, tree labels, bool inline_p)
 {
   tree r;
   tree t;
@@ -1480,6 +1483,21 @@ finish_asm_stmt (int volatile_p, tree string, tree output_operands,
 		      && C_TYPE_FIELDS_READONLY (TREE_TYPE (operand)))))
 	    cxx_readonly_error (operand, lv_asm);
 
+	  tree *op = &operand;
+	  while (TREE_CODE (*op) == COMPOUND_EXPR)
+	    op = &TREE_OPERAND (*op, 1);
+	  switch (TREE_CODE (*op))
+	    {
+	    case PREINCREMENT_EXPR:
+	    case PREDECREMENT_EXPR:
+	    case MODIFY_EXPR:
+	      *op = genericize_compound_lvalue (*op);
+	      op = &TREE_OPERAND (*op, 1);
+	      break;
+	    default:
+	      break;
+	    }
+
 	  constraint = TREE_STRING_POINTER (TREE_VALUE (TREE_PURPOSE (t)));
 	  oconstraints[i] = constraint;
 
@@ -1488,7 +1506,7 @@ finish_asm_stmt (int volatile_p, tree string, tree output_operands,
 	    {
 	      /* If the operand is going to end up in memory,
 		 mark it addressable.  */
-	      if (!allows_reg && !cxx_mark_addressable (operand))
+	      if (!allows_reg && !cxx_mark_addressable (*op))
 		operand = error_mark_node;
 	    }
 	  else
@@ -1530,7 +1548,23 @@ finish_asm_stmt (int volatile_p, tree string, tree output_operands,
 		  /* Strip the nops as we allow this case.  FIXME, this really
 		     should be rejected or made deprecated.  */
 		  STRIP_NOPS (operand);
-		  if (!cxx_mark_addressable (operand))
+
+		  tree *op = &operand;
+		  while (TREE_CODE (*op) == COMPOUND_EXPR)
+		    op = &TREE_OPERAND (*op, 1);
+		  switch (TREE_CODE (*op))
+		    {
+		    case PREINCREMENT_EXPR:
+		    case PREDECREMENT_EXPR:
+		    case MODIFY_EXPR:
+		      *op = genericize_compound_lvalue (*op);
+		      op = &TREE_OPERAND (*op, 1);
+		      break;
+		    default:
+		      break;
+		    }
+
+		  if (!cxx_mark_addressable (*op))
 		    operand = error_mark_node;
 		}
 	      else if (!allows_reg && !allows_mem)
@@ -1553,6 +1587,7 @@ finish_asm_stmt (int volatile_p, tree string, tree output_operands,
 		  output_operands, input_operands,
 		  clobbers, labels);
   ASM_VOLATILE_P (r) = volatile_p || noutputs == 0;
+  ASM_INLINE_P (r) = inline_p;
   r = maybe_cleanup_point_expr_void (r);
   return add_stmt (r);
 }
@@ -5604,7 +5639,11 @@ finish_omp_reduction_clause (tree c, bool *need_default_ctor, bool *need_dtor)
       return false;
     }
   else if (processing_template_decl)
-    return false;
+    {
+      if (OMP_CLAUSE_REDUCTION_PLACEHOLDER (c) == error_mark_node)
+	return true;
+      return false;
+    }
 
   tree id = OMP_CLAUSE_REDUCTION_PLACEHOLDER (c);
 
@@ -7333,7 +7372,7 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)
 
 	  if (VAR_P (t) && CP_DECL_THREAD_LOCAL_P (t))
 	    share_name = "threadprivate";
-	  else switch (cxx_omp_predetermined_sharing (t))
+	  else switch (cxx_omp_predetermined_sharing_1 (t))
 	    {
 	    case OMP_CLAUSE_DEFAULT_UNSPECIFIED:
 	      break;
diff --git a/gcc/cp/tree.c b/gcc/cp/tree.c
index 6501f127d7c..f24e272b0fd 100644
--- a/gcc/cp/tree.c
+++ b/gcc/cp/tree.c
@@ -1050,6 +1050,9 @@ cp_build_reference_type (tree to_type, bool rval)
 {
   tree lvalue_ref, t;
 
+  if (to_type == error_mark_node)
+    return error_mark_node;
+
   if (TREE_CODE (to_type) == REFERENCE_TYPE)
     {
       rval = rval && TYPE_REF_IS_RVALUE (to_type);
@@ -1667,9 +1670,9 @@ strip_typedefs_expr (tree t, bool *remove_attributes)
 	tree it;
 	for (it = t; it; it = TREE_CHAIN (it))
 	  {
-	    tree val = strip_typedefs_expr (TREE_VALUE (t), remove_attributes);
+	    tree val = strip_typedefs_expr (TREE_VALUE (it), remove_attributes);
 	    vec_safe_push (vec, val);
-	    if (val != TREE_VALUE (t))
+	    if (val != TREE_VALUE (it))
 	      changed = true;
 	    gcc_assert (TREE_PURPOSE (it) == NULL_TREE);
 	  }
@@ -2589,6 +2592,8 @@ bot_manip (tree* tp, int* walk_subtrees, void* data)
 	{
 	  u = build_cplus_new (TREE_TYPE (t), TREE_OPERAND (t, 1),
 			       tf_warning_or_error);
+	  if (u == error_mark_node)
+	    return u;
 	  if (AGGR_INIT_ZERO_FIRST (TREE_OPERAND (t, 1)))
 	    AGGR_INIT_ZERO_FIRST (TREE_OPERAND (u, 1)) = true;
 	}
@@ -2606,6 +2611,8 @@ bot_manip (tree* tp, int* walk_subtrees, void* data)
 			 (splay_tree_value) TREE_OPERAND (u, 0));
 
       TREE_OPERAND (u, 1) = break_out_target_exprs (TREE_OPERAND (u, 1));
+      if (TREE_OPERAND (u, 1) == error_mark_node)
+	return error_mark_node;
 
       /* Replace the old expression with the new version.  */
       *tp = u;
@@ -2718,7 +2725,8 @@ break_out_target_exprs (tree t)
     target_remap = splay_tree_new (splay_tree_compare_pointers,
 				   /*splay_tree_delete_key_fn=*/NULL,
 				   /*splay_tree_delete_value_fn=*/NULL);
-  cp_walk_tree (&t, bot_manip, target_remap, NULL);
+  if (cp_walk_tree (&t, bot_manip, target_remap, NULL) == error_mark_node)
+    t = error_mark_node;
   cp_walk_tree (&t, bot_replace, target_remap, NULL);
 
   if (!--target_remap_count)
@@ -2793,7 +2801,7 @@ replace_placeholders_r (tree* t, int* walk_subtrees, void* data_)
 	for (; !same_type_ignoring_top_level_qualifiers_p (TREE_TYPE (*t),
 							   TREE_TYPE (x));
 	     x = TREE_OPERAND (x, 0))
-	  gcc_assert (TREE_CODE (x) == COMPONENT_REF);
+	  gcc_assert (handled_component_p (x));
 	*t = x;
 	*walk_subtrees = false;
 	d->seen = true;
@@ -4895,6 +4903,19 @@ cp_tree_code_length (enum tree_code code)
     }
 }
 
+/* Wrapper around warn_deprecated_use that doesn't warn for
+   current_class_type.  */
+
+void
+cp_warn_deprecated_use (tree node)
+{
+  if (TYPE_P (node)
+      && current_class_type
+      && TYPE_MAIN_VARIANT (node) == current_class_type)
+    return;
+  warn_deprecated_use (node, NULL_TREE);
+}
+
 /* Implement -Wzero_as_null_pointer_constant.  Return true if the
    conditions for the warning hold, false otherwise.  */
 bool
diff --git a/gcc/cp/typeck.c b/gcc/cp/typeck.c
index d79b724ecca..0da2da1c30f 100644
--- a/gcc/cp/typeck.c
+++ b/gcc/cp/typeck.c
@@ -905,14 +905,14 @@ merge_types (tree t1, tree t2)
       return t1;
 
     default:;
+      if (attribute_list_equal (TYPE_ATTRIBUTES (t1), attributes))
+	return t1;
+      else if (attribute_list_equal (TYPE_ATTRIBUTES (t2), attributes))
+	return t2;
+      break;
     }
 
-  if (attribute_list_equal (TYPE_ATTRIBUTES (t1), attributes))
-    return t1;
-  else if (attribute_list_equal (TYPE_ATTRIBUTES (t2), attributes))
-    return t2;
-  else
-    return cp_build_type_attribute_variant (t1, attributes);
+  return cp_build_type_attribute_variant (t1, attributes);
 }
 
 /* Return the ARRAY_TYPE type without its domain.  */
@@ -5713,19 +5713,6 @@ cp_build_addr_expr_1 (tree arg, bool strict_lvalue, tsubst_flags_t complain)
       return arg;
     }
 
-  /* ??? Cope with user tricks that amount to offsetof.  */
-  if (TREE_CODE (argtype) != FUNCTION_TYPE
-      && TREE_CODE (argtype) != METHOD_TYPE
-      && argtype != unknown_type_node
-      && (val = get_base_address (arg))
-      && COMPLETE_TYPE_P (TREE_TYPE (val))
-      && INDIRECT_REF_P (val)
-      && TREE_CONSTANT (TREE_OPERAND (val, 0)))
-    {
-      tree type = build_pointer_type (argtype);
-      return fold_convert (type, fold_offsetof_1 (arg));
-    }
-
   /* Handle complex lvalues (when permitted)
      by reduction to simpler cases.  */
   val = unary_complex_lvalue (ADDR_EXPR, arg);
@@ -6177,6 +6164,25 @@ build_unary_op (location_t /*location*/,
   return cp_build_unary_op (code, xarg, noconvert, tf_warning_or_error);
 }
 
+/* Adjust LVALUE, an MODIFY_EXPR, PREINCREMENT_EXPR or PREDECREMENT_EXPR,
+   so that it is a valid lvalue even for GENERIC by replacing
+   (lhs = rhs) with ((lhs = rhs), lhs)
+   (--lhs) with ((--lhs), lhs)
+   (++lhs) with ((++lhs), lhs)
+   and if lhs has side-effects, calling cp_stabilize_reference on it, so
+   that it can be evaluated multiple times.  */
+
+tree
+genericize_compound_lvalue (tree lvalue)
+{
+  if (TREE_SIDE_EFFECTS (TREE_OPERAND (lvalue, 0)))
+    lvalue = build2 (TREE_CODE (lvalue), TREE_TYPE (lvalue),
+		     cp_stabilize_reference (TREE_OPERAND (lvalue, 0)),
+		     TREE_OPERAND (lvalue, 1));
+  return build2 (COMPOUND_EXPR, TREE_TYPE (TREE_OPERAND (lvalue, 0)),
+		 lvalue, TREE_OPERAND (lvalue, 0));
+}
+
 /* Apply unary lvalue-demanding operator CODE to the expression ARG
    for certain kinds of expressions which are not really lvalues
    but which we can accept as lvalues.
@@ -6211,17 +6217,7 @@ unary_complex_lvalue (enum tree_code code, tree arg)
   if (TREE_CODE (arg) == MODIFY_EXPR
       || TREE_CODE (arg) == PREINCREMENT_EXPR
       || TREE_CODE (arg) == PREDECREMENT_EXPR)
-    {
-      tree lvalue = TREE_OPERAND (arg, 0);
-      if (TREE_SIDE_EFFECTS (lvalue))
-	{
-	  lvalue = cp_stabilize_reference (lvalue);
-	  arg = build2 (TREE_CODE (arg), TREE_TYPE (arg),
-			lvalue, TREE_OPERAND (arg, 1));
-	}
-      return unary_complex_lvalue
-	(code, build2 (COMPOUND_EXPR, TREE_TYPE (lvalue), arg, lvalue));
-    }
+    return unary_complex_lvalue (code, genericize_compound_lvalue (arg));
 
   if (code != ADDR_EXPR)
     return NULL_TREE;
@@ -7617,11 +7613,7 @@ cp_build_modify_expr (location_t loc, tree lhs, enum tree_code modifycode,
     case PREINCREMENT_EXPR:
       if (compound_side_effects_p)
 	newrhs = rhs = stabilize_expr (rhs, &preeval);
-      if (TREE_SIDE_EFFECTS (TREE_OPERAND (lhs, 0)))
-	lhs = build2 (TREE_CODE (lhs), TREE_TYPE (lhs),
-		      cp_stabilize_reference (TREE_OPERAND (lhs, 0)),
-		      TREE_OPERAND (lhs, 1));
-      lhs = build2 (COMPOUND_EXPR, lhstype, lhs, TREE_OPERAND (lhs, 0));
+      lhs = genericize_compound_lvalue (lhs);
     maybe_add_compound:
       /* If we had (bar, --foo) = 5; or (bar, (baz, --foo)) = 5;
 	 and looked through the COMPOUND_EXPRs, readd them now around
@@ -7644,11 +7636,7 @@ cp_build_modify_expr (location_t loc, tree lhs, enum tree_code modifycode,
     case MODIFY_EXPR:
       if (compound_side_effects_p)
 	newrhs = rhs = stabilize_expr (rhs, &preeval);
-      if (TREE_SIDE_EFFECTS (TREE_OPERAND (lhs, 0)))
-	lhs = build2 (TREE_CODE (lhs), TREE_TYPE (lhs),
-		      cp_stabilize_reference (TREE_OPERAND (lhs, 0)),
-		      TREE_OPERAND (lhs, 1));
-      lhs = build2 (COMPOUND_EXPR, lhstype, lhs, TREE_OPERAND (lhs, 0));
+      lhs = genericize_compound_lvalue (lhs);
       goto maybe_add_compound;
 
     case MIN_EXPR:
diff --git a/gcc/cp/typeck2.c b/gcc/cp/typeck2.c
index 1f0eb454754..c8b9d787ac5 100644
--- a/gcc/cp/typeck2.c
+++ b/gcc/cp/typeck2.c
@@ -817,9 +817,12 @@ store_init_value (tree decl, tree init, vec<tree, va_gc>** cleanups, int flags)
       bool const_init;
       value = instantiate_non_dependent_expr (value);
       if (DECL_DECLARED_CONSTEXPR_P (decl)
-	  || (DECL_IN_AGGR_P (decl) && !DECL_VAR_DECLARED_INLINE_P (decl)))
+	  || (DECL_IN_AGGR_P (decl)
+	      && DECL_INITIALIZED_IN_CLASS_P (decl)
+	      && !DECL_VAR_DECLARED_INLINE_P (decl)))
 	{
-	  /* Diagnose a non-constant initializer for constexpr.  */
+	  /* Diagnose a non-constant initializer for constexpr variable or
+	     non-inline in-class-initialized static data member.  */
 	  if (processing_template_decl
 	      && !require_potential_constant_expression (value))
 	    value = error_mark_node;
@@ -1954,7 +1957,7 @@ build_functional_cast (tree exp, tree parms, tsubst_flags_t complain)
       if (complain & tf_warning
 	  && TREE_DEPRECATED (type)
 	  && DECL_ARTIFICIAL (exp))
-	warn_deprecated_use (type, NULL_TREE);
+	cp_warn_deprecated_use (type);
     }
   else
     type = exp;
diff --git a/gcc/dce.c b/gcc/dce.c
index 7534d2abadf..0c7874d4f2a 100644
--- a/gcc/dce.c
+++ b/gcc/dce.c
@@ -131,6 +131,12 @@ deletable_insn_p (rtx_insn *insn, bool fast, bitmap arg_stores)
 	     && REGNO (pic_offset_table_rtx) >= FIRST_PSEUDO_REGISTER)
       return false;
 
+  /* Callee-save restores are needed.  */
+  if (RTX_FRAME_RELATED_P (insn)
+      && crtl->shrink_wrapped_separate
+      && find_reg_note (insn, REG_CFA_RESTORE, NULL))
+    return false;
+
   body = PATTERN (insn);
   switch (GET_CODE (body))
     {
@@ -560,9 +566,19 @@ delete_unmarked_insns (void)
     FOR_BB_INSNS_REVERSE_SAFE (bb, insn, next)
       if (NONDEBUG_INSN_P (insn))
 	{
+	  rtx turn_into_use = NULL_RTX;
+
 	  /* Always delete no-op moves.  */
 	  if (noop_move_p (insn))
-	    ;
+	    {
+	      if (RTX_FRAME_RELATED_P (insn))
+		turn_into_use
+		  = find_reg_note (insn, REG_CFA_RESTORE, NULL);
+	      if (turn_into_use && REG_P (XEXP (turn_into_use, 0)))
+		turn_into_use = XEXP (turn_into_use, 0);
+	      else
+		turn_into_use = NULL_RTX;
+	    }
 
 	  /* Otherwise rely only on the DCE algorithm.  */
 	  else if (marked_insn_p (insn))
@@ -589,15 +605,6 @@ delete_unmarked_insns (void)
 	  if (!dbg_cnt (dce))
 	    continue;
 
-	  if (crtl->shrink_wrapped_separate
-	      && find_reg_note (insn, REG_CFA_RESTORE, NULL))
-	    {
-	      if (dump_file)
-		fprintf (dump_file, "DCE: NOT deleting insn %d, it's a "
-				    "callee-save restore\n", INSN_UID (insn));
-	      continue;
-	    }
-
 	  if (dump_file)
 	    fprintf (dump_file, "DCE: Deleting insn %d\n", INSN_UID (insn));
 
@@ -611,13 +618,27 @@ delete_unmarked_insns (void)
 	  if (CALL_P (insn))
 	    must_clean = true;
 
-	  /* Now delete the insn.  */
-	  delete_insn_and_edges (insn);
+	  if (turn_into_use)
+	    {
+	      /* Don't remove frame related noop moves if they cary
+		 REG_CFA_RESTORE note, while we don't need to emit any code,
+		 we need it to emit the CFI restore note.  */
+	      PATTERN (insn)
+		= gen_rtx_USE (GET_MODE (turn_into_use), turn_into_use);
+	      INSN_CODE (insn) = -1;
+	      df_insn_rescan (insn);
+	    }
+	  else
+	    /* Now delete the insn.  */
+	    delete_insn_and_edges (insn);
 	}
 
   /* Deleted a pure or const call.  */
   if (must_clean)
-    delete_unreachable_blocks ();
+    {
+      delete_unreachable_blocks ();
+      free_dominance_info (CDI_DOMINATORS);
+    }
 }
 
 
diff --git a/gcc/ddg.c b/gcc/ddg.c
index 9ea98d6f40f..68a77f8043e 100644
--- a/gcc/ddg.c
+++ b/gcc/ddg.c
@@ -295,11 +295,14 @@ add_cross_iteration_register_deps (ddg_ptr g, df_ref last_def)
   /* Create inter-loop true dependences and anti dependences.  */
   for (r_use = DF_REF_CHAIN (last_def); r_use != NULL; r_use = r_use->next)
     {
-      rtx_insn *use_insn = DF_REF_INSN (r_use->ref);
-
-      if (BLOCK_FOR_INSN (use_insn) != g->bb)
+      if (DF_REF_BB (r_use->ref) != g->bb)
 	continue;
 
+      gcc_assert (!DF_REF_IS_ARTIFICIAL (r_use->ref)
+		  && DF_REF_INSN_INFO (r_use->ref) != NULL);
+
+      rtx_insn *use_insn = DF_REF_INSN (r_use->ref);
+
       /* ??? Do not handle uses with DF_REF_IN_NOTE notes.  */
       use_node = get_node_of_insn (g, use_insn);
       gcc_assert (use_node);
diff --git a/gcc/doc/extend.texi b/gcc/doc/extend.texi
index 9db9e0e27e9..1ef46799907 100644
--- a/gcc/doc/extend.texi
+++ b/gcc/doc/extend.texi
@@ -1,4 +1,4 @@
-@c Copyright (C) 1988-2017 Free Software Foundation, Inc.
+@c Copyright (C) 1988-2018 Free Software Foundation, Inc.
 
 @c This is part of the GCC manual.
 @c For copying conditions, see the file gcc.texi.
@@ -7710,7 +7710,7 @@ for a C symbol, or to place a C variable in a specific register.
 A basic @code{asm} statement has the following syntax:
 
 @example
-asm @r{[} volatile @r{]} ( @var{AssemblerInstructions} )
+asm @var{asm-qualifiers} ( @var{AssemblerInstructions} )
 @end example
 
 The @code{asm} keyword is a GNU extension.
@@ -7723,6 +7723,10 @@ various @option{-std} options, use @code{__asm__} instead of
 @item volatile
 The optional @code{volatile} qualifier has no effect. 
 All basic @code{asm} blocks are implicitly volatile.
+
+@item inline
+If you use the @code{inline} qualifier, then for inlining purposes the size
+of the asm is taken as the smallest size possible (@pxref{Size of an asm}).
 @end table
 
 @subsubheading Parameters
@@ -7838,17 +7842,19 @@ Extended @code{asm} syntax uses colons (@samp{:}) to delimit
 the operand parameters after the assembler template:
 
 @example
-asm @r{[}volatile@r{]} ( @var{AssemblerTemplate} 
+asm @var{asm-qualifiers} ( @var{AssemblerTemplate} 
                  : @var{OutputOperands} 
                  @r{[} : @var{InputOperands}
                  @r{[} : @var{Clobbers} @r{]} @r{]})
 
-asm @r{[}volatile@r{]} goto ( @var{AssemblerTemplate} 
+asm @var{asm-qualifiers} ( @var{AssemblerTemplate} 
                       : 
                       : @var{InputOperands}
                       : @var{Clobbers}
                       : @var{GotoLabels})
 @end example
+where in the last form, @var{asm-qualifiers} contains @code{goto} (and in the
+first form, not).
 
 The @code{asm} keyword is a GNU extension.
 When writing code that can be compiled with @option{-ansi} and the
@@ -7864,6 +7870,10 @@ values to produce output values. However, your @code{asm} statements may
 also produce side effects. If so, you may need to use the @code{volatile} 
 qualifier to disable certain optimizations. @xref{Volatile}.
 
+@item inline
+If you use the @code{inline} qualifier, then for inlining purposes the size
+of the asm is taken as the smallest size possible (@pxref{Size of an asm}).
+
 @item goto
 This qualifier informs the compiler that the @code{asm} statement may 
 perform a jump to one of the labels listed in the @var{GotoLabels}.
@@ -9146,7 +9156,7 @@ does this by counting the number of instructions in the pattern of the
 @code{asm} and multiplying that by the length of the longest
 instruction supported by that processor.  (When working out the number
 of instructions, it assumes that any occurrence of a newline or of
-whatever statement separator character is supported by the assembler --
+whatever statement separator character is supported by the assembler ---
 typically @samp{;} --- indicates the end of an instruction.)
 
 Normally, GCC's estimate is adequate to ensure that correct
@@ -9157,6 +9167,11 @@ space in the object file than is needed for a single instruction.
 If this happens then the assembler may produce a diagnostic saying that
 a label is unreachable.
 
+@cindex @code{asm inline}
+This size is also used for inlining decisions.  If you use @code{asm inline}
+instead of just @code{asm}, then for inlining purposes the size of the asm
+is taken as the minimum size, ignoring how many instructions GCC thinks it is.
+
 @node Alternate Keywords
 @section Alternate Keywords
 @cindex alternate keywords
@@ -15165,21 +15180,16 @@ or @option{-mpopcntd}):
 @smallexample
 long __builtin_bpermd (long, long);
 int __builtin_divwe (int, int);
-int __builtin_divweo (int, int);
 unsigned int __builtin_divweu (unsigned int, unsigned int);
-unsigned int __builtin_divweuo (unsigned int, unsigned int);
 long __builtin_divde (long, long);
-long __builtin_divdeo (long, long);
 unsigned long __builtin_divdeu (unsigned long, unsigned long);
-unsigned long __builtin_divdeuo (unsigned long, unsigned long);
 unsigned int cdtbcd (unsigned int);
 unsigned int cbcdtd (unsigned int);
 unsigned int addg6s (unsigned int, unsigned int);
 @end smallexample
 
-The @code{__builtin_divde}, @code{__builtin_divdeo},
-@code{__builtin_divdeu}, @code{__builtin_divdeou} functions require a
-64-bit environment support ISA 2.06 or later.
+The @code{__builtin_divde} and @code{__builtin_divdeu} functions
+require a 64-bit environment supporting ISA 2.06 or later.
 
 The following built-in functions are available for the PowerPC family
 of processors, starting with ISA 3.0 or later (@option{-mcpu=power9}):
@@ -15571,7 +15581,30 @@ disabled.  To use them, you must include @code{<altivec.h>} instead.
 
 @item
 GCC allows using a @code{typedef} name as the type specifier for a
-vector type.
+vector type, but only under the following circumstances:
+
+@itemize @bullet
+
+@item
+When using @code{__vector} instead of @code{vector}; for example,
+
+@smallexample
+typedef signed short int16;
+__vector int16 data;
+@end smallexample
+
+@item
+When using @code{vector} in keyword-and-predefine mode; for example,
+
+@smallexample
+typedef signed short int16;
+vector int16 data;
+@end smallexample
+
+Note that keyword-and-predefine mode is enabled by disabling GNU
+extensions (e.g., by using @code{-std=c11}) and including
+@code{<altivec.h>}.
+@end itemize
 
 @item
 For C, overloaded functions are implemented with macros so the following
@@ -15739,6 +15772,8 @@ vector unsigned char vec_vaddubs (vector unsigned char,
 vector float vec_and (vector float, vector float);
 vector float vec_and (vector float, vector bool int);
 vector float vec_and (vector bool int, vector float);
+vector bool long long vec_and (vector bool long long int,
+                               vector bool long long);
 vector bool int vec_and (vector bool int, vector bool int);
 vector signed int vec_and (vector bool int, vector signed int);
 vector signed int vec_and (vector signed int, vector bool int);
@@ -16668,6 +16703,13 @@ vector unsigned char vec_sld (vector unsigned char,
 vector bool char vec_sld (vector bool char,
                           vector bool char,
                           const int);
+vector bool long long int vec_sld (vector bool long long int,
+                                   vector bool long long int, const int);
+vector long long int vec_sld (vector long long int,
+                              vector  long long int, const int);
+vector unsigned long long int vec_sld (vector unsigned long long int,
+                                       vector unsigned long long int,
+                                       const int);
 
 vector signed int vec_sll (vector signed int,
                            vector unsigned int);
@@ -16699,6 +16741,10 @@ vector unsigned short vec_sll (vector unsigned short,
                                vector unsigned short);
 vector unsigned short vec_sll (vector unsigned short,
                                vector unsigned char);
+vector long long int vec_sll (vector long long int,
+                              vector unsigned char);
+vector unsigned long long int vec_sll (vector unsigned long long int,
+                                       vector unsigned char);
 vector bool short vec_sll (vector bool short, vector unsigned int);
 vector bool short vec_sll (vector bool short, vector unsigned short);
 vector bool short vec_sll (vector bool short, vector unsigned char);
@@ -16851,6 +16897,10 @@ vector unsigned short vec_srl (vector unsigned short,
                                vector unsigned short);
 vector unsigned short vec_srl (vector unsigned short,
                                vector unsigned char);
+vector long long int vec_srl (vector long long int,
+                              vector unsigned char);
+vector unsigned long long int vec_srl (vector unsigned long long int,
+                                       vector unsigned char);
 vector bool short vec_srl (vector bool short, vector unsigned int);
 vector bool short vec_srl (vector bool short, vector unsigned short);
 vector bool short vec_srl (vector bool short, vector unsigned char);
@@ -16882,6 +16932,14 @@ vector unsigned short vec_sro (vector unsigned short,
                                vector signed char);
 vector unsigned short vec_sro (vector unsigned short,
                                vector unsigned char);
+vector long long int vec_sro (vector long long int,
+                              vector char);
+vector long long int vec_sro (vector long long int,
+                              vector unsigned char);
+vector unsigned long long int vec_sro (vector unsigned long long int,
+                                       vector char);
+vector unsigned long long int vec_sro (vector unsigned long long int,
+                                       vector unsigned char);
 vector pixel vec_sro (vector pixel, vector signed char);
 vector pixel vec_sro (vector pixel, vector unsigned char);
 vector signed char vec_sro (vector signed char, vector signed char);
@@ -17117,6 +17175,7 @@ vector bool short vec_unpackh (vector bool char);
 vector signed int vec_unpackh (vector signed short);
 vector bool int vec_unpackh (vector bool short);
 vector unsigned int vec_unpackh (vector pixel);
+vector double vec_unpackh (vector float);
 
 vector bool int vec_vupkhsh (vector bool short);
 vector signed int vec_vupkhsh (vector signed short);
@@ -17131,6 +17190,7 @@ vector bool short vec_unpackl (vector bool char);
 vector unsigned int vec_unpackl (vector pixel);
 vector signed int vec_unpackl (vector signed short);
 vector bool int vec_unpackl (vector bool short);
+vector double vec_unpackl (vector float);
 
 vector unsigned int vec_vupklpx (vector pixel);
 
@@ -17490,6 +17550,10 @@ vector double vec_div (vector double, vector double);
 vector long vec_div (vector long, vector long);
 vector unsigned long vec_div (vector unsigned long, vector unsigned long);
 vector double vec_floor (vector double);
+vector signed long long vec_ld (int, const vector signed long long *);
+vector signed long long vec_ld (int, const signed long long *);
+vector unsigned long long vec_ld (int, const vector unsigned long long *);
+vector unsigned long long vec_ld (int, const unsigned long long *);
 vector double vec_ld (int, const vector double *);
 vector double vec_ld (int, const double *);
 vector double vec_ldl (int, const vector double *);
@@ -17562,6 +17626,13 @@ vector signed long vec_splats (signed long);
 vector unsigned long vec_splats (unsigned long);
 vector float vec_sqrt (vector float);
 vector double vec_sqrt (vector double);
+void vec_st (vector signed long long, int, vector signed long long *);
+void vec_st (vector signed long long, int, signed long long *);
+void vec_st (vector unsigned long long, int, vector unsigned long long *);
+void vec_st (vector unsigned long long, int, unsigned long long *);
+void vec_st (vector bool long long, int, vector bool long long *);
+void vec_st (vector bool long long, int, signed long long *);
+void vec_st (vector bool long long, int, unsigned long long *);
 void vec_st (vector double, int, vector double *);
 void vec_st (vector double, int, double *);
 vector double vec_sub (vector double, vector double);
@@ -17879,9 +17950,18 @@ vector int vec_packs (vector long long, vector long long);
 vector unsigned int vec_packs (vector unsigned long long,
                                vector unsigned long long);
 
+test_vsi_packsu_vssi_vssi (vector signed short x,
+
+vector unsigned char vec_packsu (vector signed short, vector signed short )
+vector unsigned char vec_packsu (vector unsigned short, vector unsigned short )
+vector unsigned short int vec_packsu (vector signed int, vector signed int);
+vector unsigned short int vec_packsu (vector unsigned int,
+                                      vector unsigned int);
 vector unsigned int vec_packsu (vector long long, vector long long);
 vector unsigned int vec_packsu (vector unsigned long long,
                                 vector unsigned long long);
+vector unsigned int vec_packsu (vector signed long long,
+                                vector signed long long);
 
 vector long long vec_rl (vector long long,
                          vector unsigned long long);
@@ -18099,9 +18179,24 @@ vector unsigned long long vec_bperm (vector unsigned long long,
                                      vector unsigned char);
 
 vector bool char vec_cmpne (vector bool char, vector bool char);
-vector bool short vec_cmpne (vector bool short, vector bool short);
+vector bool char vec_cmpne (vector signed char, vector signed char);
+vector bool char vec_cmpne (vector unsigned char, vector unsigned char);
 vector bool int vec_cmpne (vector bool int, vector bool int);
+vector bool int vec_cmpne (vector signed int, vector signed int);
+vector bool int vec_cmpne (vector unsigned int, vector unsigned int);
 vector bool long long vec_cmpne (vector bool long long, vector bool long long);
+vector bool long long vec_cmpne (vector signed long long,
+                                 vector signed long long);
+vector bool long long vec_cmpne (vector unsigned long long,
+                                 vector unsigned long long);
+vector bool short vec_cmpne (vector bool short, vector bool short);
+vector bool short vec_cmpne (vector signed short, vector signed short);
+vector bool short vec_cmpne (vector unsigned short, vector unsigned short);
+vector bool long long vec_cmpne (vector double, vector double);
+vector bool int vec_cmpne (vector float, vector float);
+
+vector float vec_extract_fp32_from_shorth (vector unsigned short);
+vector float vec_extract_fp32_from_shortl (vector unsigned short);
 
 vector long long vec_vctz (vector long long);
 vector unsigned long long vec_vctz (vector unsigned long long);
@@ -18124,14 +18219,11 @@ vector unsigned short vec_vctzh (vector unsigned short);
 vector int vec_vctzw (vector int);
 vector unsigned int vec_vctzw (vector int);
 
-long long vec_vextract4b (const vector signed char, const int);
-long long vec_vextract4b (const vector unsigned char, const int);
-
-vector signed char vec_insert4b (vector int, vector signed char, const int);
+long long vec_extract4b (const vector unsigned char, const int);
+vector unsigned char vec_insert4b (vector signed int, vector unsigned char,
+                                   const int);
 vector unsigned char vec_insert4b (vector unsigned int, vector unsigned char,
                                    const int);
-vector signed char vec_insert4b (long long, vector signed char, const int);
-vector unsigned char vec_insert4b (long long, vector unsigned char, const int);
 
 vector int vec_vprtyb (vector int);
 vector unsigned int vec_vprtyb (vector unsigned int);
@@ -18379,20 +18471,33 @@ If the cryptographic instructions are enabled (@option{-mcrypto} or
 @smallexample
 vector unsigned long long __builtin_crypto_vsbox (vector unsigned long long);
 
+vector unsigned char vec_sbox_be (vector unsigned char);
+
 vector unsigned long long __builtin_crypto_vcipher (vector unsigned long long,
                                                     vector unsigned long long);
 
+vector unsigned char vec_cipher_be (vector unsigned char, vector unsigned char);
+
 vector unsigned long long __builtin_crypto_vcipherlast
                                      (vector unsigned long long,
                                       vector unsigned long long);
 
+vector unsigned char vec_cipherlast_be (vector unsigned char,
+                                        vector unsigned char);
+
 vector unsigned long long __builtin_crypto_vncipher (vector unsigned long long,
                                                      vector unsigned long long);
 
+vector unsigned char vec_ncipher_be (vector unsigned char,
+                                     vector unsigned char);
+
 vector unsigned long long __builtin_crypto_vncipherlast
                                      (vector unsigned long long,
                                       vector unsigned long long);
 
+vector unsigned char vec_ncipherlast_be (vector unsigned char,
+                                         vector unsigned char);
+
 vector unsigned char __builtin_crypto_vpermxor (vector unsigned char,
                                                 vector unsigned char,
                                                 vector unsigned char);
diff --git a/gcc/doc/gcov.texi b/gcc/doc/gcov.texi
index 88b8d6d9071..4c232113ca3 100644
--- a/gcc/doc/gcov.texi
+++ b/gcc/doc/gcov.texi
@@ -322,7 +322,7 @@ program source code.  The format is
 Additional block information may succeed each line, when requested by
 command line option.  The @var{execution_count} is @samp{-} for lines
 containing no code.  Unexecuted lines are marked @samp{#####} or
-@samp{====}, depending on whether they are reachable by
+@samp{=====}, depending on whether they are reachable by
 non-exceptional paths or only exceptional paths such as C++ exception
 handlers, respectively. Given @samp{-a} option, unexecuted blocks are
 marked @samp{$$$$$} or @samp{%%%%%}, depending on whether a basic block
@@ -618,6 +618,8 @@ Instrumented applications use a static destructor with priority 99
 to invoke the @code{__gcov_dump} function. Thus @code{__gcov_dump}
 is executed after all user defined static destructors,
 as well as handlers registered with @code{atexit}.
+If an executable loads a dynamic shared object via dlopen functionality,
+@option{-Wl,--dynamic-list-data} is needed to dump all profile data.
 
 @c man end
 
diff --git a/gcc/doc/install.texi2html b/gcc/doc/install.texi2html
index 8a7781ef7cd..44e6f0f8a69 100755
--- a/gcc/doc/install.texi2html
+++ b/gcc/doc/install.texi2html
@@ -52,7 +52,10 @@ for x in index.html specific.html prerequisites.html download.html configure.htm
 do
     define=`echo $x | sed -e 's/\.//g'`
     echo "define = $define"
-    $MAKEINFO --no-number-sections -I $SOURCEDIR -I $SOURCEDIR/include -I $DESTDIR $SOURCEDIR/install.texi --html --no-split -D$define -o$DESTDIR/$x
+    $MAKEINFO --no-number-sections -I $SOURCEDIR -I $SOURCEDIR/include -I $DESTDIR $SOURCEDIR/install.texi --html --no-split -D$define -o$DESTDIR/temp.html
+    # Use sed to work around makeinfo 4.7 brokenness.
+    sed -e 's/_002d/-/g' -e 's/_002a/*/g' $DESTDIR/temp.html > $DESTDIR/$x
+    rm $DESTDIR/temp.html
 done
 
 rm $DESTDIR/gcc-vers.texi
diff --git a/gcc/doc/invoke.texi b/gcc/doc/invoke.texi
index 6f3c344476c..8f279e454b0 100644
--- a/gcc/doc/invoke.texi
+++ b/gcc/doc/invoke.texi
@@ -257,7 +257,7 @@ Objective-C and Objective-C++ Dialects}.
 @xref{Warning Options,,Options to Request or Suppress Warnings}.
 @gccoptlist{-fsyntax-only  -fmax-errors=@var{n}  -Wpedantic @gol
 -pedantic-errors @gol
--w  -Wextra  -Wall  -Waddress  -Waggregate-return  @gol
+-w  -Wextra  -Wall  -Waddress  -Waggregate-return  -Waligned-new @gol
 -Walloc-zero  -Walloc-size-larger-than=@var{n}
 -Walloca  -Walloca-larger-than=@var{n} @gol
 -Wno-aggressive-loop-optimizations  -Warray-bounds  -Warray-bounds=@var{n} @gol
@@ -1025,7 +1025,7 @@ See RS/6000 and PowerPC Options.
 -mfloat-gprs=yes  -mfloat-gprs=no  -mfloat-gprs=single  -mfloat-gprs=double @gol
 -mprototype  -mno-prototype @gol
 -msim  -mmvme  -mads  -myellowknife  -memb  -msdata @gol
--msdata=@var{opt}  -mvxworks  -G @var{num} @gol
+-msdata=@var{opt}  -mreadonly-in-sdata  -mvxworks  -G @var{num} @gol
 -mrecip  -mrecip=@var{opt}  -mno-recip  -mrecip-precision @gol
 -mno-recip-precision @gol
 -mveclibabi=@var{type}  -mfriz  -mno-friz @gol
@@ -1211,7 +1211,7 @@ See RS/6000 and PowerPC Options.
 -mavx256-split-unaligned-load  -mavx256-split-unaligned-store @gol
 -malign-data=@var{type}  -mstack-protector-guard=@var{guard} @gol
 -mmitigate-rop  -mgeneral-regs-only @gol
--mindirect-branch=@var{choice} -mfunction-return==@var{choice} @gol
+-mindirect-branch=@var{choice} -mfunction-return=@var{choice} @gol
 -mindirect-branch-register}
 
 @emph{x86 Windows Options}
@@ -5171,6 +5171,9 @@ precision would exceed @code{SIZE_MAX / 2}.  The option argument @var{n}
 may end in one of the standard suffixes designating a multiple of bytes
 such as @code{kB} and @code{KiB} for kilobyte and kibibyte, respectively,
 @code{MB} and @code{MiB} for megabyte and mebibyte, and so on.
+@option{-Walloc-size-larger-than=}@var{PTRDIFF_MAX} is enabled by default.
+Warnings controlled by the option can be disabled by specifying @var{n}
+of @var{SIZE_MAX} or more.
 @xref{Function Attributes}.
 
 @item -Walloca
@@ -7133,13 +7136,15 @@ results.  This is the default.
 @item -Os
 @opindex Os
 Optimize for size.  @option{-Os} enables all @option{-O2} optimizations that
-do not typically increase code size.  It also performs further
-optimizations designed to reduce code size.
+do not typically increase code size.
 
 @option{-Os} disables the following optimization flags:
 @gccoptlist{-falign-functions  -falign-jumps  -falign-loops @gol
--falign-labels  -freorder-blocks  -freorder-blocks-algorithm=stc @gol
--freorder-blocks-and-partition  -fprefetch-loop-arrays}
+-falign-labels  -fprefetch-loop-arrays}
+
+It also enables @option{-finline-functions}, causes the compiler to tune for
+code size rather than execution speed, and performs further optimizations
+designed to reduce code size.
 
 @item -Ofast
 @opindex Ofast
@@ -7258,7 +7263,7 @@ heuristically decides which functions are simple enough to be worth integrating
 in this way.  This inlining applies to all functions, even those not declared
 inline.
 
-Enabled at level @option{-O2}.
+Enabled at level @option{-O2}, @option{-O3}, @option{-Os}.
 
 @item -findirect-inlining
 @opindex findirect-inlining
@@ -7267,7 +7272,7 @@ time thanks to previous inlining.  This option has any effect only
 when inlining itself is turned on by the @option{-finline-functions}
 or @option{-finline-small-functions} options.
 
-Enabled at level @option{-O2}.
+Enabled at level @option{-O2}, @option{-O3}, @option{-Os}.
 
 @item -finline-functions
 @opindex finline-functions
@@ -7279,7 +7284,8 @@ If all calls to a given function are integrated, and the function is
 declared @code{static}, then the function is normally not output as
 assembler code in its own right.
 
-Enabled at level @option{-O3}.
+Enabled at levels @option{-O3}, @option{-Os}.  Also enabled
+by @option{-fprofile-use} and @option{-fauto-profile}.
 
 @item -finline-functions-called-once
 @opindex finline-functions-called-once
@@ -8132,7 +8138,7 @@ This flag is enabled by default at @option{-O2} and higher and depends on
 
 @item -fisolate-erroneous-paths-attribute
 @opindex fisolate-erroneous-paths-attribute
-Detect paths that trigger erroneous or undefined behavior due a null value
+Detect paths that trigger erroneous or undefined behavior due to a null value
 being used in a way forbidden by a @code{returns_nonnull} or @code{nonnull}
 attribute.  Isolate those paths from the main control flow and turn the
 statement with erroneous or undefined behavior into a trap.  This is not
@@ -8690,6 +8696,7 @@ Some assemblers only support this flag when @var{n} is a power of two;
 in that case, it is rounded up.
 
 If @var{n} is not specified or is zero, use a machine-dependent default.
+The maximum allowed @var{n} option value is 65536.
 
 Enabled at levels @option{-O2}, @option{-O3}.
 
@@ -8715,6 +8722,7 @@ are greater than this value, then their values are used instead.
 
 If @var{n} is not specified or is zero, use a machine-dependent default
 which is very likely to be @samp{1}, meaning no alignment.
+The maximum allowed @var{n} option value is 65536.
 
 Enabled at levels @option{-O2}, @option{-O3}.
 
@@ -8728,6 +8736,7 @@ operations.
 
 @option{-fno-align-loops} and @option{-falign-loops=1} are
 equivalent and mean that loops are not aligned.
+The maximum allowed @var{n} option value is 65536.
 
 If @var{n} is not specified or is zero, use a machine-dependent default.
 
@@ -8745,6 +8754,7 @@ need be executed.
 equivalent and mean that loops are not aligned.
 
 If @var{n} is not specified or is zero, use a machine-dependent default.
+The maximum allowed @var{n} option value is 65536.
 
 Enabled at levels @option{-O2}, @option{-O3}.
 
@@ -11684,9 +11694,9 @@ of these is when the application wishes to throw and catch exceptions
 across different shared libraries.  In that case, each of the libraries
 as well as the application itself should use the shared @file{libgcc}.
 
-Therefore, the G++ and driver automatically adds @option{-shared-libgcc}
- whenever you build a shared library or a main executable, because C++
- programs typically use exceptions, so this is the right thing to do.
+Therefore, the G++ driver automatically adds @option{-shared-libgcc}
+whenever you build a shared library or a main executable, because C++
+programs typically use exceptions, so this is the right thing to do.
 
 If, instead, you use the GCC driver to create shared libraries, you may
 find that they are not always linked with the shared @file{libgcc}.
@@ -11700,8 +11710,7 @@ propagate through such shared libraries, without incurring relocation
 costs at library load time.
 
 However, if a library or main executable is supposed to throw or catch
-exceptions, you must link it using the G++ driver, as appropriate
-for the languages used in the program, or using the option
+exceptions, you must link it using the G++ driver, or using the option
 @option{-shared-libgcc}, such that it is linked with the shared
 @file{libgcc}.
 
@@ -21931,12 +21940,14 @@ Disable Book-E SPE ABI extensions for the current ABI@.
 @item -mabi=ibmlongdouble
 @opindex mabi=ibmlongdouble
 Change the current ABI to use IBM extended-precision long double.
-This is a PowerPC 32-bit SYSV ABI option.
+This is a PowerPC 32-bit SYSV ABI option.  Requires @option{-mlong-double-128}
+to be enabled.
 
 @item -mabi=ieeelongdouble
 @opindex mabi=ieeelongdouble
 Change the current ABI to use IEEE extended-precision long double.
-This is a PowerPC 32-bit Linux ABI option.
+This is a PowerPC 32-bit Linux ABI option.  Requires @option{-mlong-double-128}
+to be enabled.
 
 @item -mabi=elfv1
 @opindex mabi=elfv1
@@ -22070,6 +22081,13 @@ On embedded PowerPC systems, put all initialized global and static data
 in the @code{.data} section, and all uninitialized data in the
 @code{.bss} section.
 
+@item -mreadonly-in-sdata
+@itemx -mreadonly-in-sdata
+@opindex mreadonly-in-sdata
+@opindex mno-readonly-in-sdata
+Put read-only objects in the @code{.sdata} section as well.  This is the
+default.
+
 @item -mblock-move-inline-limit=@var{num}
 @opindex mblock-move-inline-limit
 Inline all block moves (such as calls to @code{memcpy} or structure
@@ -22689,8 +22707,8 @@ Generate code that runs on @var{cpu-type}, which is the name of a
 system representing a certain processor type.  Possible values for
 @var{cpu-type} are @samp{z900}/@samp{arch5}, @samp{z990}/@samp{arch6},
 @samp{z9-109}, @samp{z9-ec}/@samp{arch7}, @samp{z10}/@samp{arch8},
-@samp{z196}/@samp{arch9}, @samp{zEC12}, @samp{z13}/@samp{arch11}, and
-@samp{native}.
+@samp{z196}/@samp{arch9}, @samp{zEC12}, @samp{z13}/@samp{arch11},
+@samp{z14}/@samp{arch12}, and @samp{native}.
 
 The default is @option{-march=z900}.  @samp{g5}/@samp{arch3} and
 @samp{g6} are deprecated and will be removed with future releases.
@@ -25091,8 +25109,8 @@ preferred alignment to @option{-mpreferred-stack-boundary=2}.
 @itemx -mpclmul
 @opindex mpclmul
 @need 200
-@itemx -mclfushopt
-@opindex mclfushopt
+@itemx -mclflushopt
+@opindex mclflushopt
 @need 200
 @itemx -mfsgsbase
 @opindex mfsgsbase
diff --git a/gcc/doc/rtl.texi b/gcc/doc/rtl.texi
index b02e5a16bfe..ebe2a63d370 100644
--- a/gcc/doc/rtl.texi
+++ b/gcc/doc/rtl.texi
@@ -1291,10 +1291,11 @@ point values.  The floating point values are in @code{QFmode},
 @findex CDImode
 @findex CTImode
 @findex COImode
-@item CQImode, CHImode, CSImode, CDImode, CTImode, COImode
+@findex CPSImode
+@item CQImode, CHImode, CSImode, CDImode, CTImode, COImode, CPSImode
 These modes stand for a complex number represented as a pair of integer
 values.  The integer values are in @code{QImode}, @code{HImode},
-@code{SImode}, @code{DImode}, @code{TImode}, and @code{OImode},
+@code{SImode}, @code{DImode}, @code{TImode}, @code{OImode}, and @code{PSImode},
 respectively.
 
 @findex BND32mode
diff --git a/gcc/doc/sourcebuild.texi b/gcc/doc/sourcebuild.texi
index c7bb4b79332..f0e9bb8d35f 100644
--- a/gcc/doc/sourcebuild.texi
+++ b/gcc/doc/sourcebuild.texi
@@ -1273,6 +1273,16 @@ By convention, keywords ending in @code{_nocache} can also include options
 specified for the particular test in an earlier @code{dg-options} or
 @code{dg-add-options} directive.
 
+@subsubsection Endianness
+
+@table @code
+@item be
+Target uses big-endian memory order for multi-byte and multi-word data.
+
+@item le
+Target uses little-endian memory order for multi-byte and multi-word data.
+@end table
+
 @subsubsection Data type sizes
 
 @table @code
diff --git a/gcc/doc/tm.texi b/gcc/doc/tm.texi
index c4f2c893c8e..1bb5a9d9579 100644
--- a/gcc/doc/tm.texi
+++ b/gcc/doc/tm.texi
@@ -10645,8 +10645,12 @@ five otherwise.  This is best for most machines.
 
 @defmac WORD_REGISTER_OPERATIONS
 Define this macro to 1 if operations between registers with integral mode
-smaller than a word are always performed on the entire register.
-Most RISC machines have this property and most CISC machines do not.
+smaller than a word are always performed on the entire register.  To be
+more explicit, if you start with a pair of @code{word_mode} registers with
+known values and you do a subword, for example @code{QImode}, addition on
+the low part of the registers, then the compiler may consider that the
+result has a known value in @code{word_mode} too if the macro is defined
+to 1.  Most RISC machines have this property and most CISC machines do not.
 @end defmac
 
 @deftypefn {Target Hook} {unsigned int} TARGET_MIN_ARITHMETIC_PRECISION (void)
diff --git a/gcc/doc/tm.texi.in b/gcc/doc/tm.texi.in
index 1c471d8da35..d4047142027 100644
--- a/gcc/doc/tm.texi.in
+++ b/gcc/doc/tm.texi.in
@@ -7581,8 +7581,12 @@ is in effect.
 
 @defmac WORD_REGISTER_OPERATIONS
 Define this macro to 1 if operations between registers with integral mode
-smaller than a word are always performed on the entire register.
-Most RISC machines have this property and most CISC machines do not.
+smaller than a word are always performed on the entire register.  To be
+more explicit, if you start with a pair of @code{word_mode} registers with
+known values and you do a subword, for example @code{QImode}, addition on
+the low part of the registers, then the compiler may consider that the
+result has a known value in @code{word_mode} too if the macro is defined
+to 1.  Most RISC machines have this property and most CISC machines do not.
 @end defmac
 
 @hook TARGET_MIN_ARITHMETIC_PRECISION
diff --git a/gcc/dse.c b/gcc/dse.c
index f87dd50024e..f638f38a403 100644
--- a/gcc/dse.c
+++ b/gcc/dse.c
@@ -1342,6 +1342,9 @@ record_store (rtx body, bb_info_t bb_info)
   else
     width = GET_MODE_SIZE (GET_MODE (mem));
 
+  if (width == 0)
+    return 0;
+
   if (group_id >= 0)
     {
       /* In the restrictive case where the base is a constant or the
@@ -1447,7 +1450,12 @@ record_store (rtx body, bb_info_t bb_info)
 	      && offset >= s_info->begin
 	      && offset + width <= s_info->end
 	      && all_positions_needed_p (s_info, offset - s_info->begin,
-					 width))
+					 width)
+	      /* We can only remove the later store if the earlier aliases
+		 at least all accesses the later one.  */
+	      && (MEM_ALIAS_SET (mem) == MEM_ALIAS_SET (s_info->mem)
+		  || alias_set_subset_of (MEM_ALIAS_SET (mem),
+					  MEM_ALIAS_SET (s_info->mem))))
 	    {
 	      if (GET_MODE (mem) == BLKmode)
 		{
diff --git a/gcc/dwarf2asm.c b/gcc/dwarf2asm.c
index 8e3e86f224c..d5d0cfb0e8d 100644
--- a/gcc/dwarf2asm.c
+++ b/gcc/dwarf2asm.c
@@ -33,6 +33,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "dwarf2.h"
 #include "function.h"
 #include "emit-rtl.h"
+#include "fold-const.h"
 
 #ifndef XCOFF_DEBUGGING_INFO
 #define XCOFF_DEBUGGING_INFO 0
@@ -925,7 +926,7 @@ dw2_output_indirect_constant_1 (const char *sym, tree id)
   SET_DECL_ASSEMBLER_NAME (decl, id);
   DECL_ARTIFICIAL (decl) = 1;
   DECL_IGNORED_P (decl) = 1;
-  DECL_INITIAL (decl) = decl;
+  DECL_INITIAL (decl) = build_fold_addr_expr (decl);
   TREE_READONLY (decl) = 1;
   TREE_STATIC (decl) = 1;
 
@@ -938,8 +939,23 @@ dw2_output_indirect_constant_1 (const char *sym, tree id)
     }
 
   sym_ref = gen_rtx_SYMBOL_REF (Pmode, sym);
+  /* Disable ASan for decl because redzones cause ABI breakage between GCC and
+     libstdc++ for `.LDFCM*' variables.  See PR 78651 for details.  */
+  unsigned int save_flag_sanitize = flag_sanitize;
+  flag_sanitize &= ~(SANITIZE_ADDRESS | SANITIZE_USER_ADDRESS
+		     | SANITIZE_KERNEL_ADDRESS);
+  /* And also temporarily disable -fsection-anchors.  These indirect constants
+     are never referenced from code, so it doesn't make any sense to aggregate
+     them in blocks.  */
+  int save_flag_section_anchors = flag_section_anchors;
+  flag_section_anchors = 0;
   assemble_variable (decl, 1, 1, 1);
+  flag_section_anchors = save_flag_section_anchors;
+  flag_sanitize = save_flag_sanitize;
   assemble_integer (sym_ref, POINTER_SIZE_UNITS, POINTER_SIZE, 1);
+  /* The following is a hack recognized by use_blocks_for_decl_p to disable
+     section anchor handling of the decl.  */
+  DECL_INITIAL (decl) = decl;
 
   return 0;
 }
diff --git a/gcc/dwarf2out.c b/gcc/dwarf2out.c
index 43bb121fb21..5223e3b2fb4 100644
--- a/gcc/dwarf2out.c
+++ b/gcc/dwarf2out.c
@@ -297,6 +297,10 @@ static unsigned int rnglist_idx;
 #define FUNC_BEGIN_LABEL	"LFB"
 #endif
 
+#ifndef FUNC_SECOND_SECT_LABEL
+#define FUNC_SECOND_SECT_LABEL	"LFSB"
+#endif
+
 #ifndef FUNC_END_LABEL
 #define FUNC_END_LABEL		"LFE"
 #endif
@@ -1200,21 +1204,24 @@ static void set_cur_line_info_table (section *);
 void
 dwarf2out_switch_text_section (void)
 {
+  char label[MAX_ARTIFICIAL_LABEL_BYTES];
   section *sect;
   dw_fde_ref fde = cfun->fde;
 
   gcc_assert (cfun && fde && fde->dw_fde_second_begin == NULL);
 
+  ASM_GENERATE_INTERNAL_LABEL (label, FUNC_SECOND_SECT_LABEL,
+			       current_function_funcdef_no);
+
+  fde->dw_fde_second_begin = ggc_strdup (label);
   if (!in_cold_section_p)
     {
       fde->dw_fde_end = crtl->subsections.cold_section_end_label;
-      fde->dw_fde_second_begin = crtl->subsections.hot_section_label;
       fde->dw_fde_second_end = crtl->subsections.hot_section_end_label;
     }
   else
     {
       fde->dw_fde_end = crtl->subsections.hot_section_end_label;
-      fde->dw_fde_second_begin = crtl->subsections.cold_section_label;
       fde->dw_fde_second_end = crtl->subsections.cold_section_end_label;
     }
   have_multiple_function_sections = true;
@@ -18749,6 +18756,8 @@ rtl_for_decl_init (tree init, tree type)
 
       if (GET_MODE_CLASS (mode) == MODE_INT && GET_MODE_SIZE (mode) == 1
 	  && domain
+	  && TYPE_MAX_VALUE (domain)
+	  && TREE_CODE (TYPE_MAX_VALUE (domain)) == INTEGER_CST
 	  && integer_zerop (TYPE_MIN_VALUE (domain))
 	  && compare_tree_int (TYPE_MAX_VALUE (domain),
 			       TREE_STRING_LENGTH (init) - 1) == 0
@@ -29720,6 +29729,8 @@ dwarf2out_finish (const char *)
     FOR_EACH_CHILD (die, c, gcc_assert (! c->die_mark));
   }
 #endif
+  for (ctnode = comdat_type_list; ctnode != NULL; ctnode = ctnode->next)
+    resolve_addr (ctnode->root_die);
   resolve_addr (comp_unit_die ());
   move_marked_base_types ();
 
diff --git a/gcc/emit-rtl.c b/gcc/emit-rtl.c
index 0d25d4ec17e..3d47559ec0f 100644
--- a/gcc/emit-rtl.c
+++ b/gcc/emit-rtl.c
@@ -5851,7 +5851,7 @@ init_emit_regs (void)
       attrs = ggc_cleared_alloc<mem_attrs> ();
       attrs->align = BITS_PER_UNIT;
       attrs->addrspace = ADDR_SPACE_GENERIC;
-      if (mode != BLKmode)
+      if (mode != BLKmode && mode != VOIDmode)
 	{
 	  attrs->size_known_p = true;
 	  attrs->size = GET_MODE_SIZE (mode);
diff --git a/gcc/expmed.c b/gcc/expmed.c
index e9f634aa27d..b9f12576b0c 100644
--- a/gcc/expmed.c
+++ b/gcc/expmed.c
@@ -4314,6 +4314,11 @@ expand_divmod (int rem_flag, enum tree_code code, machine_mode mode,
 		HOST_WIDE_INT d = INTVAL (op1);
 		unsigned HOST_WIDE_INT abs_d;
 
+		/* Not prepared to handle division/remainder by
+		   0xffffffffffffffff8000000000000000 etc.  */
+		if (d == HOST_WIDE_INT_MIN && size > HOST_BITS_PER_WIDE_INT)
+		  break;
+
 		/* Since d might be INT_MIN, we have to cast to
 		   unsigned HOST_WIDE_INT before negating to avoid
 		   undefined signed overflow.  */
@@ -4357,9 +4362,7 @@ expand_divmod (int rem_flag, enum tree_code code, machine_mode mode,
 						compute_mode)
 				 != CODE_FOR_nothing)))
 		  ;
-		else if (EXACT_POWER_OF_2_OR_ZERO_P (abs_d)
-			 && (size <= HOST_BITS_PER_WIDE_INT
-			     || abs_d != (unsigned HOST_WIDE_INT) d))
+		else if (EXACT_POWER_OF_2_OR_ZERO_P (abs_d))
 		  {
 		    if (rem_flag)
 		      {
@@ -5886,6 +5889,18 @@ emit_store_flag_force (rtx target, enum rtx_code code, rtx op0, rtx op1,
   if (tem != 0)
     return tem;
 
+  /* If one operand is constant, make it the second one.  Only do this
+     if the other operand is not constant as well.  */
+
+  if (swap_commutative_operands_p (op0, op1))
+    {
+      std::swap (op0, op1);
+      code = swap_condition (code);
+    }
+
+  if (mode == VOIDmode)
+    mode = GET_MODE (op0);
+
   if (!target)
     target = gen_reg_rtx (word_mode);
 
diff --git a/gcc/expr.c b/gcc/expr.c
index bf935c39362..ee545ce071f 100644
--- a/gcc/expr.c
+++ b/gcc/expr.c
@@ -5109,7 +5109,10 @@ expand_assignment (tree to, tree from, bool nontemporal)
 	      && bitpos == 0
 	      && bitsize == mode_bitsize)
 	    result = store_expr (from, to_rtx, false, nontemporal, reversep);
-	  else if (bitsize == mode_bitsize / 2
+	  else if (COMPLEX_MODE_P (GET_MODE (to_rtx))
+		   && (TYPE_MODE (TREE_TYPE (from))
+		       == GET_MODE_INNER (GET_MODE (to_rtx)))
+		   && bitsize == mode_bitsize / 2
 		   && (bitpos == 0 || bitpos == mode_bitsize / 2))
 	    result = store_expr (from, XEXP (to_rtx, bitpos != 0), false,
 				 nontemporal, reversep);
@@ -6893,8 +6896,9 @@ store_field (rtx target, HOST_WIDE_INT bitsize, HOST_WIDE_INT bitpos,
       if (GET_CODE (temp) == PARALLEL)
 	{
 	  HOST_WIDE_INT size = int_size_in_bytes (TREE_TYPE (exp));
-	  machine_mode temp_mode
-	    = smallest_mode_for_size (size * BITS_PER_UNIT, MODE_INT);
+	  machine_mode temp_mode = GET_MODE (temp);
+	  if (temp_mode == BLKmode || temp_mode == VOIDmode)
+	    temp_mode = smallest_mode_for_size (size * BITS_PER_UNIT, MODE_INT);
 	  rtx temp_target = gen_reg_rtx (temp_mode);
 	  emit_group_store (temp_target, temp, TREE_TYPE (exp), size);
 	  temp = temp_target;
@@ -10862,18 +10866,30 @@ expand_expr_real_1 (tree exp, rtx target, machine_mode tmode,
 	tree fndecl = get_callee_fndecl (exp), attr;
 
 	if (fndecl
+	    /* Don't diagnose the error attribute in thunks, those are
+	       artificially created.  */
+	    && !CALL_FROM_THUNK_P (exp)
 	    && (attr = lookup_attribute ("error",
 					 DECL_ATTRIBUTES (fndecl))) != NULL)
-	  error ("%Kcall to %qs declared with attribute error: %s",
-		 exp, identifier_to_locale (lang_hooks.decl_printable_name (fndecl, 1)),
-		 TREE_STRING_POINTER (TREE_VALUE (TREE_VALUE (attr))));
+	  {
+	    const char *ident = lang_hooks.decl_printable_name (fndecl, 1);
+	    error ("%Kcall to %qs declared with attribute error: %s", exp,
+		   identifier_to_locale (ident),
+		   TREE_STRING_POINTER (TREE_VALUE (TREE_VALUE (attr))));
+	  }
 	if (fndecl
+	    /* Don't diagnose the warning attribute in thunks, those are
+	       artificially created.  */
+	    && !CALL_FROM_THUNK_P (exp)
 	    && (attr = lookup_attribute ("warning",
 					 DECL_ATTRIBUTES (fndecl))) != NULL)
-	  warning_at (tree_nonartificial_location (exp),
-		      0, "%Kcall to %qs declared with attribute warning: %s",
-		      exp, identifier_to_locale (lang_hooks.decl_printable_name (fndecl, 1)),
-		      TREE_STRING_POINTER (TREE_VALUE (TREE_VALUE (attr))));
+	  {
+	    const char *ident = lang_hooks.decl_printable_name (fndecl, 1);
+	    warning_at (tree_nonartificial_location (exp), 0,
+			"%Kcall to %qs declared with attribute warning: %s",
+			exp, identifier_to_locale (ident),
+			TREE_STRING_POINTER (TREE_VALUE (TREE_VALUE (attr))));
+	  }
 
 	/* Check for a built-in function.  */
 	if (fndecl && DECL_BUILT_IN (fndecl))
diff --git a/gcc/final.c b/gcc/final.c
index 820162b2d28..c3023285c21 100644
--- a/gcc/final.c
+++ b/gcc/final.c
@@ -906,7 +906,7 @@ shorten_branches (rtx_insn *first)
   char *varying_length;
   rtx body;
   int uid;
-  rtx align_tab[MAX_CODE_ALIGN];
+  rtx align_tab[MAX_CODE_ALIGN + 1];
 
   /* Compute maximum UID and allocate label_align / uid_shuid.  */
   max_uid = get_max_uid ();
@@ -1015,7 +1015,7 @@ shorten_branches (rtx_insn *first)
      alignment of n.  */
   uid_align = XCNEWVEC (rtx, max_uid);
 
-  for (i = MAX_CODE_ALIGN; --i >= 0;)
+  for (i = MAX_CODE_ALIGN + 1; --i >= 0;)
     align_tab[i] = NULL_RTX;
   seq = get_last_insn ();
   for (; seq; seq = PREV_INSN (seq))
@@ -2232,6 +2232,9 @@ final_scan_insn (rtx_insn *insn, FILE *file, int optimize_p ATTRIBUTE_UNUSED,
 	      ASM_OUTPUT_LABEL (asm_out_file,
 				IDENTIFIER_POINTER (cold_function_name));
 #endif
+	      if (dwarf2out_do_frame ()
+	          && cfun->fde->dw_fde_second_begin != NULL)
+		ASM_OUTPUT_LABEL (asm_out_file, cfun->fde->dw_fde_second_begin);
 	    }
 	  break;
 
diff --git a/gcc/fold-const.c b/gcc/fold-const.c
index 8152ccfda53..abe2ee34e7d 100644
--- a/gcc/fold-const.c
+++ b/gcc/fold-const.c
@@ -473,12 +473,15 @@ negate_expr_p (tree t)
     case EXACT_DIV_EXPR:
       if (TYPE_UNSIGNED (type))
 	break;
-      if (negate_expr_p (TREE_OPERAND (t, 0)))
+      /* In general we can't negate A in A / B, because if A is INT_MIN and
+         B is not 1 we change the sign of the result.  */
+      if (TREE_CODE (TREE_OPERAND (t, 0)) == INTEGER_CST
+	  && negate_expr_p (TREE_OPERAND (t, 0)))
 	return true;
       /* In general we can't negate B in A / B, because if A is INT_MIN and
 	 B is 1, we may turn this into INT_MIN / -1 which is undefined
 	 and actually traps on some architectures.  */
-      if (! INTEGRAL_TYPE_P (TREE_TYPE (t))
+      if (! ANY_INTEGRAL_TYPE_P (TREE_TYPE (t))
 	  || TYPE_OVERFLOW_WRAPS (TREE_TYPE (t))
 	  || (TREE_CODE (TREE_OPERAND (t, 1)) == INTEGER_CST
 	      && ! integer_onep (TREE_OPERAND (t, 1))))
@@ -652,14 +655,17 @@ fold_negate_expr_1 (location_t loc, tree t)
     case EXACT_DIV_EXPR:
       if (TYPE_UNSIGNED (type))
 	break;
-      if (negate_expr_p (TREE_OPERAND (t, 0)))
+      /* In general we can't negate A in A / B, because if A is INT_MIN and
+	 B is not 1 we change the sign of the result.  */
+      if (TREE_CODE (TREE_OPERAND (t, 0)) == INTEGER_CST
+	  && negate_expr_p (TREE_OPERAND (t, 0)))
 	return fold_build2_loc (loc, TREE_CODE (t), type,
 				negate_expr (TREE_OPERAND (t, 0)),
 				TREE_OPERAND (t, 1));
       /* In general we can't negate B in A / B, because if A is INT_MIN and
 	 B is 1, we may turn this into INT_MIN / -1 which is undefined
 	 and actually traps on some architectures.  */
-      if ((! INTEGRAL_TYPE_P (TREE_TYPE (t))
+      if ((! ANY_INTEGRAL_TYPE_P (TREE_TYPE (t))
 	   || TYPE_OVERFLOW_WRAPS (TREE_TYPE (t))
 	   || (TREE_CODE (TREE_OPERAND (t, 1)) == INTEGER_CST
 	       && ! integer_onep (TREE_OPERAND (t, 1))))
@@ -5816,12 +5822,13 @@ fold_truth_andor_1 (location_t loc, enum tree_code code, tree truth_type,
     }
 
   /* If the right sides are not constant, do the same for it.  Also,
-     disallow this optimization if a size or signedness mismatch occurs
-     between the left and right sides.  */
+     disallow this optimization if a size, signedness or storage order
+     mismatch occurs between the left and right sides.  */
   if (l_const == 0)
     {
       if (ll_bitsize != lr_bitsize || rl_bitsize != rr_bitsize
 	  || ll_unsignedp != lr_unsignedp || rl_unsignedp != rr_unsignedp
+	  || ll_reversep != lr_reversep
 	  /* Make sure the two fields on the right
 	     correspond to the left without being swapped.  */
 	  || ll_bitpos - rl_bitpos != lr_bitpos - rr_bitpos)
@@ -7199,7 +7206,7 @@ native_encode_vector (const_tree expr, unsigned char *ptr, int len, int off)
 	return 0;
       offset += res;
       if (offset >= len)
-	return offset;
+	return (off == -1 && i < count - 1) ? 0 : offset;
       if (off != -1)
 	off = 0;
     }
@@ -11583,10 +11590,16 @@ fold_ternary_loc (location_t loc, enum tree_code code, tree type,
 	  && integer_pow2p (arg1)
 	  && TREE_CODE (TREE_OPERAND (arg0, 0)) == BIT_AND_EXPR
 	  && operand_equal_p (TREE_OPERAND (TREE_OPERAND (arg0, 0), 1),
-			      arg1, OEP_ONLY_CONST))
+			      arg1, OEP_ONLY_CONST)
+	  /* operand_equal_p compares just value, not precision, so e.g.
+	     arg1 could be 8-bit -128 and be power of two, but BIT_AND_EXPR
+	     second operand 32-bit -128, which is not a power of two (or vice
+	     versa.  */
+	  && integer_pow2p (TREE_OPERAND (TREE_OPERAND (arg0, 0), 1)))
 	return pedantic_non_lvalue_loc (loc,
-				    fold_convert_loc (loc, type,
-						      TREE_OPERAND (arg0, 0)));
+					fold_convert_loc (loc, type,
+							  TREE_OPERAND (arg0,
+									0)));
 
       /* Disable the transformations below for vectors, since
 	 fold_binary_op_with_conditional_arg may undo them immediately,
@@ -14082,6 +14095,7 @@ fold_indirect_ref_1 (location_t loc, tree type, tree op0)
     {
       tree op = TREE_OPERAND (sub, 0);
       tree optype = TREE_TYPE (op);
+
       /* *&CONST_DECL -> to the value of the const decl.  */
       if (TREE_CODE (op) == CONST_DECL)
 	return DECL_INITIAL (op);
@@ -14115,12 +14129,13 @@ fold_indirect_ref_1 (location_t loc, tree type, tree op0)
 	       && type == TREE_TYPE (optype))
 	return fold_build1_loc (loc, REALPART_EXPR, type, op);
       /* *(foo *)&vectorfoo => BIT_FIELD_REF<vectorfoo,...> */
-      else if (TREE_CODE (optype) == VECTOR_TYPE
+      else if (VECTOR_TYPE_P (optype)
 	       && type == TREE_TYPE (optype))
 	{
 	  tree part_width = TYPE_SIZE (type);
 	  tree index = bitsize_int (0);
-	  return fold_build3_loc (loc, BIT_FIELD_REF, type, op, part_width, index);
+	  return fold_build3_loc (loc, BIT_FIELD_REF, type, op, part_width,
+				  index);
 	}
     }
 
@@ -14138,8 +14153,17 @@ fold_indirect_ref_1 (location_t loc, tree type, tree op0)
 	  op00type = TREE_TYPE (op00);
 
 	  /* ((foo*)&vectorfoo)[1] => BIT_FIELD_REF<vectorfoo,...> */
-	  if (TREE_CODE (op00type) == VECTOR_TYPE
-	      && type == TREE_TYPE (op00type))
+	  if (VECTOR_TYPE_P (op00type)
+	      && type == TREE_TYPE (op00type)
+	      /* POINTER_PLUS_EXPR second operand is sizetype, unsigned,
+		 but we want to treat offsets with MSB set as negative.
+		 For the code below negative offsets are invalid and
+		 TYPE_SIZE of the element is something unsigned, so
+		 check whether op01 fits into HOST_WIDE_INT, which
+		 implies it is from 0 to INTTYPE_MAXIMUM (HOST_WIDE_INT), and
+		 then just use unsigned HOST_WIDE_INT because we want to treat
+		 the value as unsigned.  */
+	      && tree_fits_shwi_p (op01))
 	    {
 	      tree part_width = TYPE_SIZE (type);
 	      unsigned HOST_WIDE_INT max_offset
diff --git a/gcc/fortran/ChangeLog b/gcc/fortran/ChangeLog
index 36cd2fe993f..c4b87ed513a 100644
--- a/gcc/fortran/ChangeLog
+++ b/gcc/fortran/ChangeLog
@@ -1,3 +1,893 @@
+2019-05-05  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/90344
+	* frontend-passes.c (create_var): Bring into sync with gcc 8.
+
+2019-04-14  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/87352
+	Backport from trunk
+	* gfortran.h (gfc_component): Add finalized field.
+	* class.c (finalize_component): If the component is already
+	finalized, return early.  Set component->finalized on exit.
+
+2019-04-10  Harald Anlauf  <anlauf@gmx.de>
+
+	Backport from trunk
+	PR fortran/89904
+	* check.c (gfc_check_transfer): Reject procedures as actual
+	arguments for SOURCE and MOLD of TRANSFER intrinsic.
+
+2019-03-31  Harald Anlauf  <anlauf@gmx.de>
+
+	Backport from trunk
+	PR fortran/83515
+	PR fortran/85797
+	* trans-types.c (gfc_typenode_for_spec): Handle conversion for
+	procedure pointers.
+	* target-memory.c (gfc_element_size): Handle size determination
+	for procedure pointers.
+
+2019-03-25  Janus Weil  <janus@gcc.gnu.org>
+
+	PR fortran/71861
+	Backport from trunk
+	* symbol.c (check_conflict): ABSTRACT attribute conflicts with
+	INTRINSIC attribute.
+
+2019-03-23  Thomas Koenig  <tkoeng@gcc.gnu.org>
+
+	PR fortran/68009
+	Backport from trunk
+	* iresolve.c: Include trans.h.
+	(gfc_resolve_fe_runtine_error): Set backend_decl on
+	resolved_sym.
+
+2019-03-17  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/84394
+	Backport from trunk
+	* symbol.c (gfc_add_subroutine): If we are encountering a
+	subrtoutine within a BLOCK DATA and the name starts with an
+	underscore, do not check.
+
+2019-03-16  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/66089
+	Backport from trunk
+	* trans-array.c (gfc_scalar_elemental_arg_saved_as_reference):
+	Return false if a scalar tempoary is needed.
+	(gfc_walk_variable_expr): Fix up class refs.
+
+2019-03-16  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/66695
+	PR fortran/77746
+	PR fortran/79485
+	Backport from trunk
+	* gfortran.h (gfc_symbol): Add bind_c component.
+	(gfc_get_gsymbol): Add argument bind_c.
+	* decl.c (add_global_entry): Add bind_c argument to
+	gfc_get_symbol.
+	* parse.c (parse_block_data): Likewise.
+	(parse_module): Likewise.
+	(add_global_procedure): Likewise.
+	(add_global_program): Likewise.
+	* resolve.c (resolve_common_blocks): Likewise.
+	(resolve_global_procedure): Likewise.
+	(gfc_verify_binding_labels): Likewise.
+	* symbol.c (gfc_get_gsymbol): Add argument bind_c. Set bind_c
+	in gsym.
+	* trans-decl.c (gfc_get_module_backend_decl): Add bind_c argument
+	to gfc_get_symbol.
+	(gfc_get_extern_function_decl): If the sym has a binding label
+	and it cannot be found in the global symbol tabel, it is the wrong
+	one and vice versa.
+
+2019-03-13  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/87673
+	Backport from trunk
+	* match.c (gfc_match_type_spec): Remove call to
+	gfc_resolve_expr for character length.
+
+2019-03-10  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/71544
+	Backport from trunk
+	* trans-types.c (gfc_typenode_for_spec) Set ts->is_c_interop of
+	C_PTR and C_FUNPTR.
+	(create_fn_spec): Mark argument as escaping if ts->is_c_interop is set.
+
+2019-03-10  Thomas Koenig  <tkoenig@gcc.gnu.org>
+	Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/87734
+	Backort from trunk
+	* symbol.c (gfc_add_procedure): Only throw an error if the
+	procedure has not been declared either PUBLIC or PRIVATE.
+	* resolve.c (is_illegal_recursion): Remove an assert().
+
+2019-03-06  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/72714
+	Backport from trunk
+	* resolve.c (resolve_allocate_expr): Add some tests for coarrays.
+
+2019-03-03  Harald Anlauf  <anlauf@gmx.de>
+	    Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/77583
+	* symbol.c (check_conflict): Check for valid procedure name
+	passed to error reporting routine.
+
+2019-03-03  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/87689
+	Backport from trunk
+	* trans-decl.c (gfc_get_extern_function_decl): Add argument
+	actual_args and pass it through to gfc_get_function_type.
+	* trans-expr.c (conv_function_val): Add argument actual_args
+	and pass it on to gfc_get_extern_function_decl.
+	(conv_procedure_call): Pass actual arguments to conv_function_val.
+	* trans-types.c (get_formal_from_actual_arglist): New function.
+	(gfc_get_function_type): Add argument actual_args.  Generate
+	formal args from actual args if necessary.
+	* trans-types.h (gfc_get_function_type): Add optional argument.
+	* trans.h (gfc_get_extern_function_decl): Add optional argument.
+
+2019-02-23  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/88117
+	* resolve.c (deferred_op_assign): Return if the lhs expression
+	has the pointer attribute.
+
+2019-02-23  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/71066
+	Backport from trunk
+	* trans-decl.c (generate_coarray_sym_init):  For an array
+	constructor in a DATA statement of a coarray variable, set the
+	rank to 1 to avoid confusion later on.  If the constructor
+	contains only one value, use that for initiailizig.
+
+2019-02-10  Harald Anlauf  <anlauf@gmx.de>
+
+	Backport from trunk
+	PR fortran/89077
+	* decl.c (add_init_expr_to_sym): Copy length of string initializer
+	to declared symbol.
+
+2019-02-10  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/71723
+	Backport from trunk
+	* expr.c (gfc_check_assign): Add argument is_init_expr.  If we are
+	looking at an init expression, issue error if the target is not a
+	TARGET and we are not looking at a procedure pointer.
+	* gfortran.h (gfc_check_assign): Add optional argument
+	is_init_expr.
+
+2019-02-05  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/67679
+	Backport from trunk
+	* trans-array.c (gfc_array_allocate):  For setting the bounds on
+	the new array, add a condition for a not previously allocated
+	variable.
+
+2019-02-03  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/88393
+	* trans-expr.c (gfc_conv_procedure_call): For derived entities,
+	passed in parentheses to class formals, invert the order of
+	copying allocatable components to taking the _data of the
+	class expression.
+
+2019-02-02  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/88298
+	Backport from trunk
+	* arith.c (gfc_int2int): Do not warn if src->do_not_warn is set.
+	* gfortran.h (gfc_expr): Add flag do_not_warn.
+	* intrinsic.c (gfc_convert_type_warn): Set expr->do_not_warn if
+	no warning is desired.
+
+2019-02-02  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/57048
+	Backport from trunk
+	* interface.c (gfc_compare_types): If a derived type and an
+	integer both have a derived type, and they are identical,
+	this is a C binding type and compares equal.
+
+2019-01-27  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/56386
+	PR fortran/58906
+	PR fortran/77385
+	PR fortran/80260
+	PR fortran/82077
+	* resolve.c (resolve_variable): Fix up expressions with array
+	associate names, where the parser did not detect that this is
+	array and there was no array part_ref in the expression.
+	* trans-expr.c (gfc_find_and_cut_at_last_class_ref): base_expr
+	should be a copy of e and not the initialization expr.
+
+2019-01-15  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/81849
+	* resolve.c (resolve_symbol): Host associated varaibles can appear
+	in the specification statement of a RESULT array.
+
+2019-01-11  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/35031
+	* decl.c (gfc_match_entry): Check for F2018:C1546.  Fix nearby
+	mis-indentation.
+
+2018-12-29  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/82550
+	* trans_decl.c (gfc_get_symbol_decl): Procedure symbols that
+	have the 'used_in_submodule' attribute should be processed by
+	'gfc_get_extern_function_decl'.
+
+2018-12-23  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/77703
+	* resolve.c (get_temp_from_expr): Use the string length of
+	constant character expressions.
+
+2018-12-22  Steven G . Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/85798
+	* decl.c (gfc_match_data): If a component of a derived type entity
+	appears in data statement, check that does not have the allocatable
+	attribute.
+
+2018-12-22  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/85544
+	* frontend-passes.c (optimize_power): Remove.
+	(optimize_op): Remove call to optimize_power.
+	* trans-expr.c (gfc_conv_power_op): Handle cases of 1**integer,
+	(2|4|8|16) ** integer and (-1) ** integer.
+
+2018-12-21  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/88169
+	* module.c (mio_namelist): Remove an error condition/message that
+	is contrary to the Fortran standard.
+
+2018-12-15  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/88138
+	* decl.c (variable_decl): Check that a derived isn't being assigned
+	an incompatible entity in an initialization.
+
+2018-12-11  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/88155
+	* primary.c (gfc_match_structure_constructor):  Set the locus of
+	an expression to avoid a NULL pointer dereference.
+
+2018-12-11  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/88249
+	* gfortran.h: Update prototype for gfc_resolve_filepos().
+	* io.c (gfc_resolve_filepos): Check for UNIT number if ERR= is present.
+	Use passed in locus for error message.
+	* resolve.c (gfc_resolve_code): Pass locus in gfc_resolve_filepos()
+	call.
+
+2018-12-10  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/88269
+	* io.c (io_constraint): Update macro. If locus line buffer is NULL,
+	use gfc_current_locus in error messages.
+	(check_io_constraints): Catch missing IO UNIT in write and read
+	statements.  io_constraint macro is incompatible here.
+
+2018-12-09  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/88205
+	* io.c (gfc_match_open): Move NEWUNIT checks to after STATUS checks.
+
+2018-12-09  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/88206
+	* match.c (gfc_match_type_spec): REAL can be an intrinsic function.
+
+2018-12-09  Fritz Reese  <fritzoreese@gmail.com>
+
+	PR fortran/88228
+	* resolve.c (resolve_operator):  Do not call resolve_function.
+	Break like other cases.
+
+2018-12-06  Release Manager
+
+	* GCC 7.4.0 released.
+
+2018-11-25  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/88073
+	* frontend-passes.c (combine_array_constructor): Do not do
+	anything if in a WHERE statement.
+
+2018-11-24  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from mainline
+	PR fortran/88143
+	* resolve.c (resolve_variable): Check for associate names with
+	NULL target.
+
+2019-11-03  Tobias Burnus  <burnus@net-b.de>
+	Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/87597
+	* expr.c (gfc_simplify_expr): Avoid simplifying
+	the 'array' argument to lbound/ubound/lcobound/
+	ucobound.
+
+2018-10-12  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-07-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/86421
+	* module.c (omp_declare_simd_clauses): Add LINEAR with _REF, _VAL and
+	_UVAL suffixes.
+	(mio_omp_declare_simd): Save and restore ref, val and uval modifiers
+	on linear clauses.  Initialize n->where to gfc_current_locus.
+
+2018-09-13  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from trunk
+	PR fortran/87284
+	* trans-expr.c (gfc_trans_class_init_assign): Access to
+	to array elements of the dynamic type requires that the array
+	reference be added to the class expression and not the _data
+	component, unlike scalar expressions.
+
+2018-09-07  Janus Weil  <janus@gcc.gnu.org>
+
+	Backported from trunk
+	PR fortran/86116
+	* interface.c (compare_type): Remove a CLASS/TYPE check.
+	(compare_type_characteristics): New function that behaves like the old
+	'compare_type'.
+	(gfc_check_dummy_characteristics, gfc_check_result_characteristics):
+	Call 'compare_type_characteristics' instead of 'compare_type'.
+
+2018-07-16  Fritz Reese  <fritzoreese@gmail.com>
+
+	PR fortran/83184
+	Backport from trunk.
+	* decl.c (match_old_style_init): Initialize locus of variable expr when
+	creating a data variable.
+	(match_clist_expr): Verify array is explicit shape/size before
+	attempting to allocate constant array constructor.
+
+2018-07-16  Fritz Reese  <fritzoreese@gmail.com>
+
+	Backport from trunk:
+
+	PR fortran/86417
+	* module.c (mio_component): Set component->loc when loading from module.
+
+	PR fortran/83183
+	PR fortran/86325
+	* expr.c (class_allocatable, class_pointer, comp_allocatable,
+	comp_pointer): New helpers.
+	(component_initializer): Generate EXPR_NULL for allocatable or pointer
+	components. Do not generate initializers for components within BT_CLASS.
+	Do not assign to comp->initializer.
+	(gfc_generate_initializer): Use new helpers; move code to generate
+	EXPR_NULL for class allocatable components into component_initializer().
+
+2018-07-03  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/82969
+	PR fortran/86242
+	* trans-array.c (structure_alloc_comps): Do not explicitly copy
+	procedure pointer components.
+
+2018-06-25  Fritz Reese  <fritzoreese@gmail.com>
+
+	PR fortran/82972
+	PR fortran/83088
+	PR fortran/85851
+	Backport from trunk.
+	* expr.c (component_initializer): Assign init expr to c->initializer.
+	(generate_isocbinding_initializer): New.
+	(gfc_generate_initializer): Call generate_isocbinding_initializer to
+	generate initializers for c_ptr and c_funptr with -finit-derived.
+
+2018-06-25  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/83118
+	Back port from trunk
+	* resolve.c (resolve_ordinary_assign): Force the creation of a
+	vtable for assignment of non-polymorphic expressions to an
+	unlimited polymorphic object.
+	* trans-array.c (gfc_alloc_allocatable_for_assignment): Use the
+	size of the rhs type for such assignments. Set the dtype, _len
+	and vptrs appropriately.
+	* trans-expr.c (gfc_trans_assignment): Force the use of the
+	_copy function for these assignments.
+
+2018-06-22  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-04-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/85313
+	* openmp.c (resolve_omp_do): Remove bogus if (j < i) break;.
+	(resolve_oacc_nested_loops): Likewise.  Formatting fix.
+
+2018-06-13  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/86110
+	* array.c (gfc_resolve_character_array_constructor): Avoid NULL
+	pointer dereference.
+
+2018-06-12  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/44491
+	* expr.c (gfc_check_assign): Select non-NULL locus.
+
+2018-06-09  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/38351
+	* resolve.c (resolve_operator): Provide better error message for
+	derived type entity used in an binary intrinsic numeric operator.
+
+2018-06-09  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/63514
+	* symbol.c (gfc_add_volatile): Enforce F2008:C1282 and F2018:C1588.
+
+2018-06-09  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/78278
+	* data.c (gfc_assign_data_value): Re-arrange code to allow for
+	an error for double initialization of CHARACTER entities.
+
+2018-06-09  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/86059
+	* array.c (match_array_cons_element): NULL() cannot be in an
+	array constructor.
+
+2018-06-09  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/85138
+	PR fortran/85996
+	PR fortran/86051
+	* decl.c (gfc_match_char_spec): Use private namespace in attempt to
+	reduce a charlen to a constant.
+
+2018-06-07  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/86045
+	Backport from trunk.
+	* simplify.c (gfc_simplify_mod): Re-arrange code to test whether
+	'P' is zero and issue an error if it is.
+
+2018-06-07  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/85641
+	Backport from trunk.
+	* frontend-passes.c (is_fe_temp): Add prototype.
+	(realloc_string_callback): Early return for frontend-generated
+	temporary.
+
+2018-06-04  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/85981
+	* resolve.c (resolve_allocate_deallocate): Check errmsg is default
+	character kind.
+
+2018-05-25  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/85543
+	Backport from trunk
+	* resolve.c (update_current_proc_array_outer_dependency): Avoid NULL
+	pointer dereference.
+
+2018-05-25  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/85779
+	Backport from trunk
+	* decl.c (gfc_match_derived_decl): Fix NULL point dereference.
+
+2018-05-25  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/85780
+	Backport from trunk
+	* resolve.c (resolve_fl_procedure): Avoid NULL dereference.
+
+2018-05-25  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/85895
+	Backport from trunk
+	* resolve.c (resolve_sync): Resolve expression before checking for
+	an error.
+
+2018-05-20  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/80657
+	Backport from trunk
+	* resolve.c (flag_fn_result_spec): Use the 'sym' argument to
+	test for self refs to the function result in the character len
+	expression. If a self reference is found, emit an error and
+	return true.
+	(resolve_fntype): Use the function symbol in the calls to the
+	above.
+
+2018-05-20  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/82275
+	Backport from trunk
+	* match.c (gfc_match_type_spec): Go through the array ref and
+	decrement 'rank' for every dimension that is an element.
+
+2018-05-19  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/82923
+	PR fortran/66694
+	PR fortran/82617
+	Backport from trunk
+	* trans-array.c (gfc_alloc_allocatable_for_assignment): Set the
+	charlen backend_decl of the rhs expr to ss->info->string_length
+	so that the value in the current scope is used.
+
+2018-05-16  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/83149
+	Backport from trunk
+	* trans-decl.c (gfc_finish_var_decl): Test sym->ns->proc_name
+	before accessing its components.
+	* trans-types.c (gfc_sym_type): If a character result has null
+	backend_decl, try the procedure symbol..
+
+2018-16-05  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/83898
+	Backport from trunk
+	* trans-stmt.c (trans_associate_var): Do not set cst_array_ctor
+	for characters.
+
+2018-05-16  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/84546
+	Backport from trunk
+	* trans-array.c (structure_alloc_comps): Make sure that the
+	vptr is copied and that the unlimited polymorphic _len is used
+	to compute the size to be allocated.
+	(build_array_ref): Set the 'unlimited' argument false in the
+	call to gfc_get_class_array_ref.
+	* trans-expr.c (gfc_get_class_array_ref): If unlimited, use the
+	unlimited polymorphic _len for the offset to the element.
+	(gfc_copy_class_to_class): Set the new 'unlimited' argument.
+	* trans.h : Add the boolean 'unlimited' to the prototype.
+
+2018-05-12  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/85542
+	Backport from trunk
+	* expr.c (check_inquiry): Avoid NULL pointer dereference.
+
+2018-05-12  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/68846
+	PR fortran/70864
+	Backport from trunk
+	* resolve.c (get_temp_from_expr): The temporary must not have
+	dummy or intent attributes.
+
+2018-05-11  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/70870
+	Backport from trunk
+	* data.c (gfc_assign_data_value): Check that a data object does
+	not also have default initialization.
+
+2018-05-11  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/85521
+	Backport from trunk
+	* array.c (gfc_resolve_character_array_constructor): Substrings
+	with upper bound smaller than lower bound are zero length strings.
+
+2018-05-11  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/85687
+	Backport from trunk
+	* check.c (gfc_check_rank): Check that the argument is a data object.
+
+2018-05-06  Andre Vehreschild  <vehre@gcc.gnu.org>
+
+	PR fortran/85507
+	Backport from trunk.
+	* dependency.c (gfc_dep_resolver): Revert looking at coarray dimension
+	introduced by r259385.
+	* trans-intrinsic.c (conv_caf_send): Always report a dependency for
+	same variables in coarray assignments.
+
+2018-04-28  Andre Vehreschild  <vehre@gcc.gnu.org>
+
+	PR fortran/81773
+	PR fortran/83606
+	Backport from trunk.
+	* dependency.c (gfc_dep_resolver): Coarray indexes are to be ignored
+	during dependency computation.  They define no data dependency.
+	* trans-array.c (conv_array_index_offset): The stride can not be set
+	here, prevent fail.
+	* trans-intrinsic.c (conv_caf_send): Add creation of temporary array
+	for caf_get's result and copying to the array with vectorial
+	indexing.
+
+2018-04-24  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/85520
+	* decl.c (gfc_match_char_spec): Check for negative length and set to 0.
+
+2018-03-28  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/85084
+	Backport from trunk.
+	* frontend-passes.c (gfc_run_passes): Do not run front-end
+	optimizations if a previous error occurred.
+
+2018-03-20  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/85001
+	* interface.c (symbol_rank): Remove bogus null pointer check that
+	crept in when translating a ternary operator into an if-else
+	constructor.
+
+2018-03-19  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/84931
+	Backport from trunk
+	* simplify.c (gfc_convert_constant): Correctly handle iterators
+	for type conversion.
+
+2018-03-19  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/77414
+	* decl.c (get_proc_name):  Check for a subroutine re-defined in
+	the contain portion of a subroutine.  Change language of existing
+	error message to better describe the issue. While here fix whitespace
+	issues.
+
+2018-03-19  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/65453
+	* decl.c (get_proc_name): Catch clash between a procedure statement
+	and a contained subprogram
+
+2018-03-15  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/78741
+	* decl.c (get_proc_name):  Check for clash of entry name with
+	subroutine name.
+
+2018-03-12  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/83939
+	* resolve.c (resolve_fl_procedure): Enforce F2018:C15100.
+
+2018-03-10  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/84734
+	* arith.c (check_result, eval_intrinsic):  If result overflows, pass
+	the expression up the chain instead of a NULL pointer.
+
+2018-03-08  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/64124
+	PR fortran/70409
+	* decl.c (gfc_match_char_spec): Try to reduce a charlen to a constant.
+
+2018-03-06  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/56667
+	* primary.c (match_sym_complex_part): Give the matcher for an implied
+	do-loop a chance to run.
+
+2018-03-04  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/83076
+	* resolve.c (resolve_fl_derived0): Add caf_token fields for
+	allocatable and pointer scalars, when -fcoarray selected.
+	* trans-types.c (gfc_copy_dt_decls_ifequal): Copy the token
+	field as well as the backend_decl.
+	(gfc_get_derived_type): Flag GFC_FCOARRAY_LIB for module
+	derived types that are not vtypes. Components with caf_token
+	attribute are pvoid types. For a component requiring it, find
+	the caf_token field and have the component token field point to
+	its backend_decl.
+
+2018-03-03  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/71085
+	* trans-expr.c (gfc_apply_interface_mapping_to_expr): Do not
+	dereference NULL pointer.
+
+2018-03-03  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/51434
+	* simplify.c (gfc_simplify_transfer): Resolve mold.
+
+2018-03-03  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/80965
+	* resolve.c (build_loc_call): Change symtree name from 'loc' to
+	'_loc'.
+
+2018-03-03  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from trunk.
+	PR fortran/78990
+	* expr.c (gfc_is_class_array_function): Renamed from
+	'gfc_is_alloc_class_array_function' and modified to return true
+	for pointers as well as allocatable results.
+	* gfortran.h : Change of name for prototype of above function.
+	* trans-array.c (gfc_add_loop_ss_code): Force finalization of
+	class array results.
+	(build_class_array_ref): Change assertion into a condition.
+	(build_class_array_ref): Set the se class_vptr for class array
+	function results.
+	(gfc_walk_function_expr): Reference gfc_is_class_array_function
+	as above.
+	* trans-decl.c (get_proc_result): Move it up before
+	gfc_trans_deferred_vars.
+	(gfc_trans_deferred_vars): Nullify explicit return class arrays
+	on entry.
+	* trans-expr.c (gfc_conv_class_to_class): Allow conversion of
+	class array functions that have an se class_vptr and use it
+	for the result vptr.
+	(gfc_conv_subref_array_arg): Rename reference to the above
+	function.
+	(gfc_conv_procedure_call): Ditto. Add the se pre block to the
+	loop pre block before the function is evaluated. Do not
+	finalize class pointer results.
+	(arrayfunc_assign_needs_temporary, gfc_trans_assignment_1) More
+	renamed references.
+	* trans-intrinsic.c (gfc_conv_intrinsic_size): Ditto.
+
+2018-03-03  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-02-16  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/84418
+	* trans-openmp.c (gfc_trans_omp_clauses): For OMP_CLAUSE_LINEAR_REF
+	kind set OMP_CLAUSE_LINEAR_STEP to TYPE_SIZE_UNIT times last_step.
+
+	2018-01-31  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/84116
+	* openmp.c (gfc_match_omp_clauses): If all the linear
+	gfc_match_omp_variable_list calls failed, don't gfc_free_omp_namelist
+	nor set *head = NULL.  Formatting fixes.
+
+2018-02-25  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	ChangeLog for r257972
+	PR fortran/83633
+	* decl.c (variable_decl): Check that an explicit-shape-array with
+	nonconstant bounds is allowed.
+
+2018-02-25  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/78238
+	Backport from trunk
+	* gfortran.h (gfc_integer_4_kind): Define.
+	* resolve.c (resolve_select_type): Make sure that the
+	kind of c->high is gfc_integer_4_kind.
+
+2018-02-24  Steven G. Kargl <kargl@gcc.gnu.org>
+
+	PR fortran/30792
+	* decl.c (gfc_match_data): Check for invalid substring in
+	data-implied-do
+
+2018-02-23  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/84511
+	* trans-io.c (transfer_expr): Deal with C_LOC in transfer statement.
+
+2018-02-23  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/84346
+	* interface.c (compare_actual_formal): Issue error if keyword is
+	used in a statement function.
+
+2018-02-23  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/84506
+	* trans-io.c (set_parameter_value_inquire): Adjust range check of
+	negative unit values for kind=8 units to the kind=4 negative limit.
+
+2018-02-22  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/81116
+	PR fortran/84495
+	* gfortran.dg/realloc_on_assignment_29.f90:  New test.
+
+2018-02-19  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/82007
+	* resolve.c (resolve_transfer): Delete code looking for 'DT'
+	format specifiers in format strings. Set formatted to true if a
+	format string or format label is present.
+	* trans-io.c (get_dtio_proc): Likewise. (transfer_expr): Fix
+	whitespace.
+
+2018-02-17  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/84270
+	* frontend-passes (scalarized_expr):  If the expression
+	is an assumed size array, leave in the last reference
+	and pass AR_SECTION instead of AR_FULL to gfc_resolve
+	in order to avoid an error.
+
+2018-02-13  Alastair McKinstry  <alastair.mckinstry@sceal.ie>
+	    Janne Blomqvist  <jb@gcc.gnu.org>
+
+	* module.c (dump_module): Use lbasename to ensure that module
+	files are reproducible.
+
+2018-02-12  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/68560
+	* trans-intrinsic.c (gfc_conv_intrinsic_shape): New function.
+	(gfc_conv_intrinsic_function): Call it.
+
+2018-02-12  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>
+
+	PR fortran/35299
+	ChangeLog for r257566
+	* resolve.c (resolve_formal_arglist): Update error message.
+
+2018-02-12  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/54223
+	PR fortran/84276
+	* interface.c (compare_actual_formal): Add in_statement_function
+	bool parameter.  Skip check of INTENT attribute for statement
+	functions.  Arguments to a statement function cannot be optional,
+	issue error for missing argument.
+	(gfc_procedure_use, gfc_ppc_use, gfc_arglist_matches_symbol): Use
+	in_statement_function.
+
+2018-02-07  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/82994
+	* match.c (gfc_match_deallocate): Check for NULL pointer.
+
+2018-02-07  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/82049
+	* match.c (gfc_match_type_spec): If the charlen is non-NULL, then
+	try to resolve it.  While here return early if possible.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
diff --git a/gcc/fortran/arith.c b/gcc/fortran/arith.c
index 8fa305c6aee..895d65f53d4 100644
--- a/gcc/fortran/arith.c
+++ b/gcc/fortran/arith.c
@@ -555,10 +555,10 @@ check_result (arith rc, gfc_expr *x, gfc_expr *r, gfc_expr **rp)
       val = ARITH_OK;
     }
 
-  if (val != ARITH_OK)
-    gfc_free_expr (r);
-  else
+  if (val == ARITH_OK || val == ARITH_OVERFLOW)
     *rp = r;
+  else
+    gfc_free_expr (r);
 
   return val;
 }
@@ -1603,9 +1603,13 @@ eval_intrinsic (gfc_intrinsic_op op,
   if (rc != ARITH_OK)
     {
       gfc_error (gfc_arith_error (rc), &op1->where);
+      if (rc == ARITH_OVERFLOW)
+	goto done;
       return NULL;
     }
 
+done:
+
   gfc_free_expr (op1);
   gfc_free_expr (op2);
   return result;
@@ -2046,7 +2050,7 @@ gfc_int2int (gfc_expr *src, int kind)
       gfc_convert_mpz_to_signed (result->value.integer,
 				 gfc_integer_kinds[k].bit_size);
 
-      if (warn_conversion && kind < src->ts.kind)
+      if (warn_conversion && !src->do_not_warn && kind < src->ts.kind)
 	gfc_warning_now (OPT_Wconversion, "Conversion from %qs to %qs at %L",
 			 gfc_typename (&src->ts), gfc_typename (&result->ts),
 			 &src->where);
diff --git a/gcc/fortran/array.c b/gcc/fortran/array.c
index ec0c26656ff..17b3c7d44e8 100644
--- a/gcc/fortran/array.c
+++ b/gcc/fortran/array.c
@@ -1079,6 +1079,15 @@ match_array_cons_element (gfc_constructor_base *result)
   if (m != MATCH_YES)
     return m;
 
+  if (expr->expr_type == EXPR_FUNCTION
+      && expr->ts.type == BT_UNKNOWN
+      && strcmp(expr->symtree->name, "null") == 0)
+   {
+      gfc_error ("NULL() at %C cannot appear in an array constructor");
+      gfc_free_expr (expr);
+      return MATCH_ERROR;
+   }
+
   gfc_constructor_append_expr (result, expr, &gfc_current_locus);
   return MATCH_YES;
 }
@@ -1998,7 +2007,9 @@ got_charlen:
 	  gfc_ref *ref;
 	  for (ref = p->expr->ref; ref; ref = ref->next)
 	    if (ref->type == REF_SUBSTRING
+		&& ref->u.ss.start
 		&& ref->u.ss.start->expr_type == EXPR_CONSTANT
+		&& ref->u.ss.end
 		&& ref->u.ss.end->expr_type == EXPR_CONSTANT)
 	      break;
 
@@ -2021,7 +2032,8 @@ got_charlen:
 	  else
 	    return true;
 
-	  gcc_assert (current_length != -1);
+	  if (current_length < 0)
+	    current_length = 0;
 
 	  if (found_length == -1)
 	    found_length = current_length;
diff --git a/gcc/fortran/check.c b/gcc/fortran/check.c
index 6e62d409e7b..f49fb9e9e09 100644
--- a/gcc/fortran/check.c
+++ b/gcc/fortran/check.c
@@ -3764,8 +3764,11 @@ gfc_check_rank (gfc_expr *a)
 		  ? a->value.function.esym->result->attr.pointer
 		  : a->symtree->n.sym->result->attr.pointer;
 
-  if (a->expr_type == EXPR_OP || a->expr_type == EXPR_NULL
-      || a->expr_type == EXPR_COMPCALL|| a->expr_type == EXPR_PPC
+  if (a->expr_type == EXPR_OP
+      || a->expr_type == EXPR_NULL
+      || a->expr_type == EXPR_COMPCALL
+      || a->expr_type == EXPR_PPC
+      || a->ts.type == BT_PROCEDURE
       || !is_variable)
     {
       gfc_error ("The argument of the RANK intrinsic at %L must be a data "
@@ -5292,6 +5295,26 @@ gfc_check_transfer (gfc_expr *source, gfc_expr *mold, gfc_expr *size)
   size_t source_size;
   size_t result_size;
 
+  /* SOURCE shall be a scalar or array of any type.  */
+  if (source->ts.type == BT_PROCEDURE
+      && source->symtree->n.sym->attr.subroutine == 1)
+    {
+      gfc_error ("%<SOURCE%> argument of %<TRANSFER%> intrinsic at %L "
+                 "must not be a %s", &source->where,
+		 gfc_basic_typename (source->ts.type));
+      return false;
+    }
+
+  /* MOLD shall be a scalar or array of any type.  */
+  if (mold->ts.type == BT_PROCEDURE
+      && mold->symtree->n.sym->attr.subroutine == 1)
+    {
+      gfc_error ("%<MOLD%> argument of %<TRANSFER%> intrinsic at %L "
+                 "must not be a %s", &mold->where,
+		 gfc_basic_typename (mold->ts.type));
+      return false;
+    }
+
   if (mold->ts.type == BT_HOLLERITH)
     {
       gfc_error ("%<MOLD%> argument of %<TRANSFER%> intrinsic at %L must not be"
@@ -5299,6 +5322,8 @@ gfc_check_transfer (gfc_expr *source, gfc_expr *mold, gfc_expr *size)
       return false;
     }
 
+  /* SIZE (optional) shall be an integer scalar.  The corresponding actual
+     argument shall not be an optional dummy argument.  */
   if (size != NULL)
     {
       if (!type_check (size, 2, BT_INTEGER))
diff --git a/gcc/fortran/class.c b/gcc/fortran/class.c
index 2d72e9570da..fdc10627a2a 100644
--- a/gcc/fortran/class.c
+++ b/gcc/fortran/class.c
@@ -899,6 +899,9 @@ finalize_component (gfc_expr *expr, gfc_symbol *derived, gfc_component *comp,
   if (!comp_is_finalizable (comp))
     return;
 
+  if (comp->finalized)
+    return;
+
   e = gfc_copy_expr (expr);
   if (!e->ref)
     e->ref = ref = gfc_get_ref ();
@@ -1026,6 +1029,7 @@ finalize_component (gfc_expr *expr, gfc_symbol *derived, gfc_component *comp,
 			    sub_ns);
       gfc_free_expr (e);
     }
+  comp->finalized = true;
 }
 
 
diff --git a/gcc/fortran/data.c b/gcc/fortran/data.c
index 184e53d480f..5d1d38042f4 100644
--- a/gcc/fortran/data.c
+++ b/gcc/fortran/data.c
@@ -481,6 +481,21 @@ gfc_assign_data_value (gfc_expr *lvalue, gfc_expr *rvalue, mpz_t index,
   mpz_clear (offset);
   gcc_assert (repeat == NULL);
 
+  /* Overwriting an existing initializer is non-standard but usually only
+     provokes a warning from other compilers.  */
+  if (init != NULL && init->where.lb && rvalue->where.lb)
+    {
+      /* Order in which the expressions arrive here depends on whether
+	 they are from data statements or F95 style declarations.
+	 Therefore, check which is the most recent.  */
+      expr = (LOCATION_LINE (init->where.lb->location)
+	      > LOCATION_LINE (rvalue->where.lb->location))
+	   ? init : rvalue;
+      if (gfc_notify_std (GFC_STD_GNU, "re-initialization of %qs at %L",
+			  symbol->name, &expr->where) == false)
+	return false;
+    }
+
   if (ref || last_ts->type == BT_CHARACTER)
     {
       /* An initializer has to be constant.  */
@@ -492,20 +507,13 @@ gfc_assign_data_value (gfc_expr *lvalue, gfc_expr *rvalue, mpz_t index,
     }
   else
     {
-      /* Overwriting an existing initializer is non-standard but usually only
-	 provokes a warning from other compilers.  */
-      if (init != NULL)
+      if (lvalue->ts.type == BT_DERIVED
+	  && gfc_has_default_initializer (lvalue->ts.u.derived))
 	{
-	  /* Order in which the expressions arrive here depends on whether
-	     they are from data statements or F95 style declarations.
-	     Therefore, check which is the most recent.  */
-	  expr = (LOCATION_LINE (init->where.lb->location)
-		  > LOCATION_LINE (rvalue->where.lb->location))
-	       ? init : rvalue;
-	  if (gfc_notify_std (GFC_STD_GNU,
-			      "re-initialization of %qs at %L",
-			      symbol->name, &expr->where) == false)
-	    return false;
+	  gfc_error ("Nonpointer object %qs with default initialization "
+		     "shall not appear in a DATA statement at %L", 
+		     symbol->name, &lvalue->where);
+	  return false;
 	}
 
       expr = gfc_copy_expr (rvalue);
diff --git a/gcc/fortran/decl.c b/gcc/fortran/decl.c
index 4ccaa4c8d1a..a41c5b7ead2 100644
--- a/gcc/fortran/decl.c
+++ b/gcc/fortran/decl.c
@@ -509,6 +509,7 @@ match_old_style_init (const char *name)
   newdata = gfc_get_data ();
   newdata->var = gfc_get_data_variable ();
   newdata->var->expr = gfc_get_variable_expr (st);
+  newdata->var->expr->where = sym->declared_at;
   newdata->where = gfc_current_locus;
 
   /* Match initial value list. This also eats the terminal '/'.  */
@@ -551,6 +552,7 @@ match
 gfc_match_data (void)
 {
   gfc_data *new_data;
+  gfc_expr *e;
   match m;
 
   /* Before parsing the rest of a DATA statement, check F2008:c1206.  */
@@ -573,6 +575,44 @@ gfc_match_data (void)
       if (m != MATCH_YES)
 	goto cleanup;
 
+      if (new_data->var->iter.var
+	  && new_data->var->iter.var->ts.type == BT_INTEGER
+	  && new_data->var->iter.var->symtree->n.sym->attr.implied_index == 1
+	  && new_data->var->list
+	  && new_data->var->list->expr
+	  && new_data->var->list->expr->ts.type == BT_CHARACTER
+	  && new_data->var->list->expr->ref
+	  && new_data->var->list->expr->ref->type == REF_SUBSTRING)
+	{
+	  gfc_error ("Invalid substring in data-implied-do at %L in DATA "
+		     "statement", &new_data->var->list->expr->where);
+	  goto cleanup;
+	}
+
+      /* Check for an entity with an allocatable component, which is not
+	 allowed.  */
+      e = new_data->var->expr;
+      if (e)
+	{
+	  bool invalid;
+
+	  invalid = false;
+	  for (gfc_ref *ref = e->ref; ref; ref = ref->next)
+	    if ((ref->type == REF_COMPONENT
+		 && ref->u.c.component->attr.allocatable)
+		|| (ref->type == REF_ARRAY
+		    && e->symtree->n.sym->attr.pointer != 1
+		    && ref->u.ar.as && ref->u.ar.as->type == AS_DEFERRED))
+	      invalid = true;
+
+	  if (invalid)
+	    {
+	      gfc_error ("Allocatable component or deferred-shaped array "
+			 "near %C in DATA statement");
+	      goto cleanup;
+	    }
+	}
+
       m = top_val_list (new_data);
       if (m != MATCH_YES)
 	goto cleanup;
@@ -620,27 +660,35 @@ match_clist_expr (gfc_expr **result, gfc_typespec *ts, gfc_array_spec *as)
 {
   gfc_constructor_base array_head = NULL;
   gfc_expr *expr = NULL;
-  match m;
+  match m = MATCH_ERROR;
   locus where;
-  mpz_t repeat, size;
+  mpz_t repeat, cons_size, as_size;
   bool scalar;
   int cmp;
 
   gcc_assert (ts);
 
-  mpz_init_set_ui (repeat, 0);
-  mpz_init (size);
-  scalar = !as || !as->rank;
-
   /* We have already matched '/' - now look for a constant list, as with
      top_val_list from decl.c, but append the result to an array.  */
   if (gfc_match ("/") == MATCH_YES)
     {
       gfc_error ("Empty old style initializer list at %C");
-      goto cleanup;
+      return MATCH_ERROR;
     }
 
   where = gfc_current_locus;
+  scalar = !as || !as->rank;
+
+  if (!scalar && !spec_size (as, &as_size))
+    {
+      gfc_error ("Array in initializer list at %L must have an explicit shape",
+		 as->type == AS_EXPLICIT ? &as->upper[0]->where : &where);
+      /* Nothing to cleanup yet.  */
+      return MATCH_ERROR;
+    }
+
+  mpz_init_set_ui (repeat, 0);
+
   for (;;)
     {
       m = match_data_constant (&expr);
@@ -670,7 +718,10 @@ match_clist_expr (gfc_expr **result, gfc_typespec *ts, gfc_array_spec *as)
 
           m = match_data_constant (&expr);
           if (m == MATCH_NO)
-            gfc_error ("Expected data constant after repeat spec at %C");
+	    {
+	      m = MATCH_ERROR;
+	      gfc_error ("Expected data constant after repeat spec at %C");
+	    }
           if (m != MATCH_YES)
             goto cleanup;
         }
@@ -713,6 +764,9 @@ match_clist_expr (gfc_expr **result, gfc_typespec *ts, gfc_array_spec *as)
         goto syntax;
     }
 
+  /* If we break early from here out, we encountered an error.  */
+  m = MATCH_ERROR;
+
   /* Set up expr as an array constructor. */
   if (!scalar)
     {
@@ -723,16 +777,18 @@ match_clist_expr (gfc_expr **result, gfc_typespec *ts, gfc_array_spec *as)
       expr->rank = as->rank;
       expr->shape = gfc_get_shape (expr->rank);
 
-      /* Validate sizes. */
-      gcc_assert (gfc_array_size (expr, &size));
-      gcc_assert (spec_size (as, &repeat));
-      cmp = mpz_cmp (size, repeat);
+      /* Validate sizes.  We built expr ourselves, so cons_size will be
+	 constant (we fail above for non-constant expressions).
+	 We still need to verify that the sizes match.  */
+      gcc_assert (gfc_array_size (expr, &cons_size));
+      cmp = mpz_cmp (cons_size, as_size);
       if (cmp < 0)
-        gfc_error ("Not enough elements in array initializer at %C");
+	gfc_error ("Not enough elements in array initializer at %C");
       else if (cmp > 0)
-        gfc_error ("Too many elements in array initializer at %C");
+	gfc_error ("Too many elements in array initializer at %C");
+      mpz_clear (cons_size);
       if (cmp)
-        goto cleanup;
+	goto cleanup;
     }
 
   /* Make sure scalar types match. */
@@ -744,11 +800,11 @@ match_clist_expr (gfc_expr **result, gfc_typespec *ts, gfc_array_spec *as)
     expr->ts.u.cl->length_from_typespec = 1;
 
   *result = expr;
-  mpz_clear (size);
-  mpz_clear (repeat);
-  return MATCH_YES;
+  m = MATCH_YES;
+  goto done;
 
 syntax:
+  m = MATCH_ERROR;
   gfc_error ("Syntax error in old style initializer list at %C");
 
 cleanup:
@@ -756,9 +812,12 @@ cleanup:
     expr->value.constructor = NULL;
   gfc_free_expr (expr);
   gfc_constructor_free (array_head);
-  mpz_clear (size);
+
+done:
   mpz_clear (repeat);
-  return MATCH_ERROR;
+  if (!scalar)
+    mpz_clear (as_size);
+  return m;
 }
 
 
@@ -1115,14 +1174,12 @@ get_proc_name (const char *name, gfc_symbol **result, bool module_fcn_entry)
   if (sym->attr.proc == PROC_ST_FUNCTION)
     return rc;
 
-  if (sym->attr.module_procedure
-      && sym->attr.if_source == IFSRC_IFBODY)
+  if (sym->attr.module_procedure && sym->attr.if_source == IFSRC_IFBODY)
     {
       /* Create a partially populated interface symbol to carry the
 	 characteristics of the procedure and the result.  */
       sym->tlink = gfc_new_symbol (name, sym->ns);
-      gfc_add_type (sym->tlink, &(sym->ts),
-		    &gfc_current_locus);
+      gfc_add_type (sym->tlink, &(sym->ts), &gfc_current_locus);
       gfc_copy_attr (&sym->tlink->attr, &sym->attr, NULL);
       if (sym->attr.dimension)
 	sym->tlink->as = gfc_copy_array_spec (sym->as);
@@ -1152,11 +1209,22 @@ get_proc_name (const char *name, gfc_symbol **result, bool module_fcn_entry)
 	 accessible names.  */
       if (sym->attr.flavor != 0
 	  && sym->attr.proc != 0
-	  && (sym->attr.subroutine || sym->attr.function)
+	  && (sym->attr.subroutine || sym->attr.function || sym->attr.entry)
 	  && sym->attr.if_source != IFSRC_UNKNOWN)
 	gfc_error_now ("Procedure %qs at %C is already defined at %L",
 		       name, &sym->declared_at);
 
+      if (sym->attr.flavor != 0
+	  && sym->attr.entry && sym->attr.if_source != IFSRC_UNKNOWN)
+	gfc_error_now ("Procedure %qs at %C is already defined at %L",
+		       name, &sym->declared_at);
+
+      if (sym->attr.external && sym->attr.procedure
+	  && gfc_current_state () == COMP_CONTAINS)
+	gfc_error_now ("Contained procedure %qs at %C clashes with "
+			"procedure defined at %L",
+		       name, &sym->declared_at);
+
       /* Trap a procedure with a name the same as interface in the
 	 encompassing scope.  */
       if (sym->attr.generic != 0
@@ -1176,7 +1244,16 @@ get_proc_name (const char *name, gfc_symbol **result, bool module_fcn_entry)
 	  && sym->attr.access == 0
 	  && !module_fcn_entry)
 	gfc_error_now ("Procedure %qs at %C has an explicit interface "
-		       "and must not have attributes declared at %L",
+		       "from a previous declaration",  name);
+    }
+
+    if (sym && !sym->gfc_new
+	&& sym->attr.flavor != FL_UNKNOWN
+	&& sym->attr.referenced == 0 && sym->attr.subroutine == 1
+	&& gfc_state_stack->state == COMP_CONTAINS
+	&& gfc_state_stack->previous->state == COMP_SUBROUTINE)
+    {
+	gfc_error_now ("Procedure %qs at %C is already defined at %L",
 		       name, &sym->declared_at);
     }
 
@@ -1201,10 +1278,10 @@ get_proc_name (const char *name, gfc_symbol **result, bool module_fcn_entry)
   /* See if the procedure should be a module procedure.  */
 
   if (((sym->ns->proc_name != NULL
-		&& sym->ns->proc_name->attr.flavor == FL_MODULE
-		&& sym->attr.proc != PROC_MODULE)
-	    || (module_fcn_entry && sym->attr.proc != PROC_MODULE))
-	&& !gfc_add_procedure (&sym->attr, PROC_MODULE, sym->name, NULL))
+	&& sym->ns->proc_name->attr.flavor == FL_MODULE
+	&& sym->attr.proc != PROC_MODULE)
+       || (module_fcn_entry && sym->attr.proc != PROC_MODULE))
+      && !gfc_add_procedure (&sym->attr, PROC_MODULE, sym->name, NULL))
     rc = 2;
 
   return rc;
@@ -1719,7 +1796,7 @@ add_init_expr_to_sym (const char *name, gfc_expr **initp, locus *var_locus)
 		    }
 		  else if (init->ts.u.cl && init->ts.u.cl->length)
 		    sym->ts.u.cl->length =
-				gfc_copy_expr (sym->value->ts.u.cl->length);
+				gfc_copy_expr (init->ts.u.cl->length);
 		}
 	    }
 	  /* Update initializer character length according symbol.  */
@@ -2183,7 +2260,10 @@ variable_decl (int elem)
   /* At this point, we know for sure if the symbol is PARAMETER and can thus
      determine (and check) whether it can be implied-shape.  If it
      was parsed as assumed-size, change it because PARAMETERs can not
-     be assumed-size.  */
+     be assumed-size.
+
+     An explicit-shape-array cannot appear under several conditions.
+     That check is done here as well.  */
   if (as)
     {
       if (as->type == AS_IMPLIED_SHAPE && current_attr.flavor != FL_PARAMETER)
@@ -2205,6 +2285,50 @@ variable_decl (int elem)
 	  m = MATCH_ERROR;
 	  goto cleanup;
 	}
+
+      /* F2018:C830 (R816) An explicit-shape-spec whose bounds are not
+	 constant expressions shall appear only in a subprogram, derived
+	 type definition, BLOCK construct, or interface body.  */
+      if (as->type == AS_EXPLICIT
+	  && gfc_current_state () != COMP_BLOCK
+	  && gfc_current_state () != COMP_DERIVED
+	  && gfc_current_state () != COMP_FUNCTION
+	  && gfc_current_state () != COMP_INTERFACE
+	  && gfc_current_state () != COMP_SUBROUTINE)
+	{
+	  gfc_expr *e;
+	  bool not_constant = false;
+
+	  for (int i = 0; i < as->rank; i++)
+	    {
+	      e = gfc_copy_expr (as->lower[i]);
+	      gfc_resolve_expr (e);
+	      gfc_simplify_expr (e, 0);
+	      if (e && (e->expr_type != EXPR_CONSTANT))
+		{
+		  not_constant = true;
+		  break;
+		}
+	      gfc_free_expr (e);
+
+	      e = gfc_copy_expr (as->upper[i]);
+	      gfc_resolve_expr (e);
+	      gfc_simplify_expr (e, 0);
+	      if (e && (e->expr_type != EXPR_CONSTANT))
+		{
+		  not_constant = true;
+		  break;
+		}
+	      gfc_free_expr (e);
+	    }
+
+	  if (not_constant)
+	    { 
+	      gfc_error ("Explicit shaped array with nonconstant bounds at %C");
+	      m = MATCH_ERROR;
+	      goto cleanup;
+	    }
+	}
     }
 
   char_len = NULL;
@@ -2445,6 +2569,22 @@ variable_decl (int elem)
       goto cleanup;
     }
 
+  /* Before adding a possible initilizer, do a simple check for compatibility
+     of lhs and rhs types.  Assigning a REAL value to a derive type is not a
+     good thing.  */
+  if (current_ts.type == BT_DERIVED && initializer
+      && (gfc_numeric_ts (&initializer->ts)
+	  || initializer->ts.type == BT_LOGICAL
+	  || initializer->ts.type == BT_CHARACTER))
+    {
+      gfc_error ("Incompatible initialization between a derive type "
+		 "entity and an entity with %qs type at %C",
+		  gfc_typename (&initializer->ts));
+      m = MATCH_ERROR;
+      goto cleanup;
+    }
+
+
   /* Add the initializer.  Note that it is fine if initializer is
      NULL here, because we sometimes also need to check if a
      declaration *must* have an initialization expression.  */
@@ -2918,7 +3058,38 @@ done:
   if (seen_length == 0)
     cl->length = gfc_get_int_expr (gfc_default_integer_kind, NULL, 1);
   else
-    cl->length = len;
+    {
+      /* If gfortran ends up here, then len may be reducible to a constant.
+	 Try to do that here.  If it does not reduce, simply assign len to
+	 charlen.  A complication occurs with user-defined generic functions,
+	 which are not resolved.  Use a private namespace to deal with
+	 generic functions.  */
+
+      if (len && len->expr_type != EXPR_CONSTANT)
+	{
+	  gfc_namespace *old_ns;
+	  gfc_expr *e;
+
+	  old_ns = gfc_current_ns;
+	  gfc_current_ns = gfc_get_namespace (NULL, 0);
+
+	  e = gfc_copy_expr (len);
+	  gfc_reduce_init_expr (e);
+	  if (e->expr_type == EXPR_CONSTANT)
+	    {
+	      gfc_replace_expr (len, e);
+	      if (mpz_cmp_si (len->value.integer, 0) < 0)
+		mpz_set_ui (len->value.integer, 0);
+	    }
+	  else
+	    gfc_free_expr (e);
+
+	  gfc_free_namespace (gfc_current_ns);
+	  gfc_current_ns = old_ns;
+	}
+
+      cl->length = len;
+    }
 
   ts->u.cl = cl;
   ts->kind = kind == 0 ? gfc_default_character_kind : kind;
@@ -6109,7 +6280,7 @@ add_global_entry (const char *name, const char *binding_label, bool sub,
      name is a global identifier.  */
   if (!binding_label || gfc_notification_std (GFC_STD_F2008))
     {
-      s = gfc_get_gsymbol (name);
+      s = gfc_get_gsymbol (name, false);
 
       if (s->defined || (s->type != GSYM_UNKNOWN && s->type != type))
 	{
@@ -6131,7 +6302,7 @@ add_global_entry (const char *name, const char *binding_label, bool sub,
       && (!gfc_notification_std (GFC_STD_F2008)
 	  || strcmp (name, binding_label) != 0))
     {
-      s = gfc_get_gsymbol (binding_label);
+      s = gfc_get_gsymbol (binding_label, true);
 
       if (s->defined || (s->type != GSYM_UNKNOWN && s->type != type))
 	{
@@ -6308,9 +6479,11 @@ gfc_match_entry (void)
 	      gfc_error ("Missing required parentheses before BIND(C) at %C");
 	      return MATCH_ERROR;
 	    }
-	    if (!gfc_add_is_bind_c (&(entry->attr), entry->name,
-				    &(entry->declared_at), 1))
-	      return MATCH_ERROR;
+
+	  if (!gfc_add_is_bind_c (&(entry->attr), entry->name,
+				  &(entry->declared_at), 1))
+	    return MATCH_ERROR;
+	
 	}
 
       if (!gfc_current_ns->parent
@@ -6394,6 +6567,14 @@ gfc_match_entry (void)
       return MATCH_ERROR;
     }
 
+  /* F2018:C1546 An elemental procedure shall not have the BIND attribute.  */
+  if (proc->attr.elemental && entry->attr.is_bind_c)
+    {
+      gfc_error ("ENTRY statement at %L with BIND(C) prohibited in an "
+		 "elemental procedure", &entry->declared_at);
+      return MATCH_ERROR;
+    }
+
   entry->attr.recursive = proc->attr.recursive;
   entry->attr.elemental = proc->attr.elemental;
   entry->attr.pure = proc->attr.pure;
@@ -8935,8 +9116,12 @@ gfc_match_derived_decl (void)
 
   if (!gensym->attr.generic && gensym->ts.type != BT_UNKNOWN)
     {
-      gfc_error ("Derived type name %qs at %C already has a basic type "
-		 "of %s", gensym->name, gfc_typename (&gensym->ts));
+      if (gensym->ts.u.derived)
+	gfc_error ("Derived type name %qs at %C already has a basic type "
+		   "of %s", gensym->name, gfc_typename (&gensym->ts));
+      else
+	gfc_error ("Derived type name %qs at %C already has a basic type",
+		   gensym->name);
       return MATCH_ERROR;
     }
 
diff --git a/gcc/fortran/expr.c b/gcc/fortran/expr.c
index f347c753702..09401a4c339 100644
--- a/gcc/fortran/expr.c
+++ b/gcc/fortran/expr.c
@@ -1823,7 +1823,20 @@ gfc_simplify_expr (gfc_expr *p, int type)
       break;
 
     case EXPR_FUNCTION:
-      for (ap = p->value.function.actual; ap; ap = ap->next)
+      // For array-bound functions, we don't need to optimize
+      // the 'array' argument. In particular, if the argument
+      // is a PARAMETER, simplifying might convert an EXPR_VARIABLE
+      // into an EXPR_ARRAY; the latter has lbound = 1, the former
+      // can have any lbound.
+      ap = p->value.function.actual;
+      if (p->value.function.isym &&
+	  (p->value.function.isym->id == GFC_ISYM_LBOUND
+	   || p->value.function.isym->id == GFC_ISYM_UBOUND
+	   || p->value.function.isym->id == GFC_ISYM_LCOBOUND
+	   || p->value.function.isym->id == GFC_ISYM_UCOBOUND))
+	ap = ap->next;
+
+      for ( ; ap; ap = ap->next)
 	if (!gfc_simplify_expr (ap->expr, type))
 	  return false;
 
@@ -2315,7 +2328,7 @@ check_inquiry (gfc_expr *e, int not_restricted)
 
 	/* Assumed character length will not reduce to a constant expression
 	   with LEN, as required by the standard.  */
-	if (i == 5 && not_restricted
+	if (i == 5 && not_restricted && ap->expr->symtree
 	    && ap->expr->symtree->n.sym->ts.type == BT_CHARACTER
 	    && (ap->expr->symtree->n.sym->ts.u.cl->length == NULL
 		|| ap->expr->symtree->n.sym->ts.deferred))
@@ -3288,6 +3301,8 @@ gfc_check_assign (gfc_expr *lvalue, gfc_expr *rvalue, int conform,
   /* Only DATA Statements come here.  */
   if (!conform)
     {
+      locus *where;
+
       /* Numeric can be converted to any other numeric. And Hollerith can be
 	 converted to any other type.  */
       if ((gfc_numeric_ts (&lvalue->ts) && gfc_numeric_ts (&rvalue->ts))
@@ -3297,8 +3312,9 @@ gfc_check_assign (gfc_expr *lvalue, gfc_expr *rvalue, int conform,
       if (lvalue->ts.type == BT_LOGICAL && rvalue->ts.type == BT_LOGICAL)
 	return true;
 
+      where = lvalue->where.lb ? &lvalue->where : &rvalue->where;
       gfc_error ("Incompatible types in DATA statement at %L; attempted "
-		 "conversion of %s to %s", &lvalue->where,
+		 "conversion of %s to %s", where,
 		 gfc_typename (&rvalue->ts), gfc_typename (&lvalue->ts));
 
       return false;
@@ -3326,7 +3342,7 @@ gfc_check_assign (gfc_expr *lvalue, gfc_expr *rvalue, int conform,
    NULLIFY statement.  */
 
 bool
-gfc_check_pointer_assign (gfc_expr *lvalue, gfc_expr *rvalue)
+gfc_check_pointer_assign (gfc_expr *lvalue, gfc_expr *rvalue, bool is_init_expr)
 {
   symbol_attribute attr, lhs_attr;
   gfc_ref *ref;
@@ -3757,11 +3773,35 @@ gfc_check_pointer_assign (gfc_expr *lvalue, gfc_expr *rvalue)
       return false;
     }
 
-  if (!attr.target && !attr.pointer)
+  if (is_init_expr)
     {
-      gfc_error ("Pointer assignment target is neither TARGET "
-		 "nor POINTER at %L", &rvalue->where);
-      return false;
+      gfc_symbol *sym;
+      bool target;
+
+      gcc_assert (rvalue->symtree);
+      sym = rvalue->symtree->n.sym;
+
+      if (sym->ts.type == BT_CLASS && sym->attr.class_ok)
+	target = CLASS_DATA (sym)->attr.target;
+      else
+	target = sym->attr.target;
+
+      if (!target && !proc_pointer)
+	{
+	  gfc_error ("Pointer assignment target in initialization expression "
+		     "does not have the TARGET attribute at %L",
+		     &rvalue->where);
+	  return false;
+	}
+    }
+  else
+    {
+      if (!attr.target && !attr.pointer)
+	{
+	  gfc_error ("Pointer assignment target is neither TARGET "
+		     "nor POINTER at %L", &rvalue->where);
+	  return false;
+	}
     }
 
   if (is_pure && gfc_impure_variable (rvalue->symtree->n.sym))
@@ -3887,7 +3927,7 @@ gfc_check_assign_symbol (gfc_symbol *sym, gfc_component *comp, gfc_expr *rvalue)
     }
 
   if (pointer || proc_pointer)
-    r = gfc_check_pointer_assign (&lvalue, rvalue);
+    r = gfc_check_pointer_assign (&lvalue, rvalue, true);
   else
     {
       /* If a conversion function, e.g., __convert_i8_i4, was inserted
@@ -4274,21 +4314,60 @@ get_union_initializer (gfc_symbol *union_type, gfc_component **map_p)
   return init;
 }
 
+static bool
+class_allocatable (gfc_component *comp)
+{
+  return comp->ts.type == BT_CLASS && CLASS_DATA (comp)
+    && CLASS_DATA (comp)->attr.allocatable;
+}
+
+static bool
+class_pointer (gfc_component *comp)
+{
+  return comp->ts.type == BT_CLASS && CLASS_DATA (comp)
+    && CLASS_DATA (comp)->attr.pointer;
+}
+
+static bool
+comp_allocatable (gfc_component *comp)
+{
+  return comp->attr.allocatable || class_allocatable (comp);
+}
+
+static bool
+comp_pointer (gfc_component *comp)
+{
+  return comp->attr.pointer
+    || comp->attr.pointer
+    || comp->attr.proc_pointer
+    || comp->attr.class_pointer
+    || class_pointer (comp);
+}
+
 /* Fetch or generate an initializer for the given component.
    Only generate an initializer if generate is true.  */
 
 static gfc_expr *
-component_initializer (gfc_typespec *ts, gfc_component *c, bool generate)
+component_initializer (gfc_component *c, bool generate)
 {
   gfc_expr *init = NULL;
 
+  /* Allocatable components always get EXPR_NULL.
+     Pointer components are only initialized when generating, and only if they
+     do not already have an initializer.  */
+  if (comp_allocatable (c) || (generate && comp_pointer (c) && !c->initializer))
+    {
+      init = gfc_get_null_expr (&c->loc);
+      init->ts = c->ts;
+      return init;
+    }
+
   /* See if we can find the initializer immediately.  */
-  if (c->initializer || !generate
-      || (ts->type == BT_CLASS && !c->attr.allocatable))
+  if (c->initializer || !generate)
     return c->initializer;
 
   /* Recursively handle derived type components.  */
-  if (c->ts.type == BT_DERIVED || c->ts.type == BT_CLASS)
+  else if (c->ts.type == BT_DERIVED || c->ts.type == BT_CLASS)
     init = gfc_generate_initializer (&c->ts, true);
 
   else if (c->ts.type == BT_UNION && c->ts.u.derived->components)
@@ -4347,6 +4426,32 @@ gfc_default_initializer (gfc_typespec *ts)
   return gfc_generate_initializer (ts, false);
 }
 
+/* Generate an initializer expression for an iso_c_binding type
+   such as c_[fun]ptr. The appropriate initializer is c_null_[fun]ptr.  */
+
+static gfc_expr *
+generate_isocbinding_initializer (gfc_symbol *derived)
+{
+  /* The initializers have already been built into the c_null_[fun]ptr symbols
+     from gen_special_c_interop_ptr.  */
+  gfc_symtree *npsym = NULL;
+  if (0 == strcmp (derived->name, "c_ptr"))
+    gfc_find_sym_tree ("c_null_ptr", gfc_current_ns, true, &npsym);
+  else if (0 == strcmp (derived->name, "c_funptr"))
+    gfc_find_sym_tree ("c_null_funptr", gfc_current_ns, true, &npsym);
+  else
+    gfc_internal_error ("generate_isocbinding_initializer(): bad iso_c_binding"
+			" type, expected %<c_ptr%> or %<c_funptr%>");
+  if (npsym)
+    {
+      gfc_expr *init = gfc_copy_expr (npsym->n.sym->value);
+      init->symtree = npsym;
+      init->ts.is_iso_c = true;
+      return init;
+    }
+
+  return NULL;
+}
 
 /* Get or generate an expression for a default initializer of a derived type.
    If -finit-derived is specified, generate default initialization expressions
@@ -4357,8 +4462,12 @@ gfc_generate_initializer (gfc_typespec *ts, bool generate)
 {
   gfc_expr *init, *tmp;
   gfc_component *comp;
+
   generate = flag_init_derived && generate;
 
+  if (ts->u.derived->ts.is_iso_c && generate)
+    return generate_isocbinding_initializer (ts->u.derived);
+
   /* See if we have a default initializer in this, but not in nested
      types (otherwise we could use gfc_has_default_initializer()).
      We don't need to check if we are going to generate them.  */
@@ -4366,9 +4475,7 @@ gfc_generate_initializer (gfc_typespec *ts, bool generate)
   if (!generate)
     {
       for (; comp; comp = comp->next)
-        if (comp->initializer || comp->attr.allocatable
-            || (comp->ts.type == BT_CLASS && CLASS_DATA (comp)
-                && CLASS_DATA (comp)->attr.allocatable))
+	if (comp->initializer || comp_allocatable (comp))
           break;
     }
 
@@ -4384,7 +4491,7 @@ gfc_generate_initializer (gfc_typespec *ts, bool generate)
       gfc_constructor *ctor = gfc_constructor_get();
 
       /* Fetch or generate an initializer for the component.  */
-      tmp = component_initializer (ts, comp, generate);
+      tmp = component_initializer (comp, generate);
       if (tmp)
 	{
 	  /* Save the component ref for STRUCTUREs and UNIONs.  */
@@ -4394,8 +4501,7 @@ gfc_generate_initializer (gfc_typespec *ts, bool generate)
 
           /* If the initializer was not generated, we need a copy.  */
           ctor->expr = comp->initializer ? gfc_copy_expr (tmp) : tmp;
-	  if ((comp->ts.type != tmp->ts.type
-	       || comp->ts.kind != tmp->ts.kind)
+	  if ((comp->ts.type != tmp->ts.type || comp->ts.kind != tmp->ts.kind)
 	      && !comp->attr.pointer && !comp->attr.proc_pointer)
 	    {
 	      bool val;
@@ -4405,15 +4511,6 @@ gfc_generate_initializer (gfc_typespec *ts, bool generate)
 	    }
 	}
 
-      if (comp->attr.allocatable
-	  || (comp->ts.type == BT_CLASS && CLASS_DATA (comp)->attr.allocatable))
-	{
-	  ctor->expr = gfc_get_expr ();
-	  ctor->expr->expr_type = EXPR_NULL;
-	  ctor->expr->where = init->where;
-	  ctor->expr->ts = comp->ts;
-	}
-
       gfc_constructor_append (&init->value.constructor, ctor);
     }
 
@@ -4762,14 +4859,15 @@ gfc_is_alloc_class_scalar_function (gfc_expr *expr)
 /* Determine if an expression is a function with an allocatable class array
    result.  */
 bool
-gfc_is_alloc_class_array_function (gfc_expr *expr)
+gfc_is_class_array_function (gfc_expr *expr)
 {
   if (expr->expr_type == EXPR_FUNCTION
       && expr->value.function.esym
       && expr->value.function.esym->result
       && expr->value.function.esym->result->ts.type == BT_CLASS
       && CLASS_DATA (expr->value.function.esym->result)->attr.dimension
-      && CLASS_DATA (expr->value.function.esym->result)->attr.allocatable)
+      && (CLASS_DATA (expr->value.function.esym->result)->attr.allocatable
+	  || CLASS_DATA (expr->value.function.esym->result)->attr.pointer))
     return true;
 
   return false;
diff --git a/gcc/fortran/frontend-passes.c b/gcc/fortran/frontend-passes.c
index 082e2353790..83c43bb8979 100644
--- a/gcc/fortran/frontend-passes.c
+++ b/gcc/fortran/frontend-passes.c
@@ -48,6 +48,8 @@ static gfc_code * create_do_loop (gfc_expr *, gfc_expr *, gfc_expr *,
 				  locus *, gfc_namespace *,
 				  char *vname=NULL);
 
+static bool is_fe_temp (gfc_expr *e);
+
 #ifdef CHECKING_P
 static void check_locus (gfc_namespace *);
 #endif
@@ -135,6 +137,10 @@ gfc_run_passes (gfc_namespace *ns)
   check_locus (ns);
 #endif
 
+  gfc_get_errors (&w, &e);
+  if (e > 0)
+   return;
+
   if (flag_frontend_optimize)
     {
       optimize_namespace (ns);
@@ -145,10 +151,6 @@ gfc_run_passes (gfc_namespace *ns)
       expr_array.release ();
     }
 
-  gfc_get_errors (&w, &e);
-  if (e > 0)
-   return;
-
   if (flag_realloc_lhs)
     realloc_strings (ns);
 }
@@ -231,22 +233,29 @@ realloc_string_callback (gfc_code **c, int *walk_subtrees ATTRIBUTE_UNUSED,
       || !expr1->ts.deferred)
     return 0;
 
-  expr2 = gfc_discard_nops (co->expr2);
-  if (expr2->expr_type != EXPR_VARIABLE)
+  if (is_fe_temp (expr1))
     return 0;
 
-  found_substr = false;
-  for (ref = expr2->ref; ref; ref = ref->next)
+  expr2 = gfc_discard_nops (co->expr2);
+
+  if (expr2->expr_type == EXPR_VARIABLE)
     {
-      if (ref->type == REF_SUBSTRING)
+      found_substr = false;
+      for (ref = expr2->ref; ref; ref = ref->next)
 	{
-	  found_substr = true;
-	  break;
+	  if (ref->type == REF_SUBSTRING)
+	    {
+	      found_substr = true;
+	      break;
+	    }
 	}
+      if (!found_substr)
+	return 0;
     }
-  if (!found_substr)
+  else if (expr2->expr_type != EXPR_OP
+	   || expr2->value.op.op != INTRINSIC_CONCAT)
     return 0;
-
+  
   if (!gfc_check_dependency (expr1, expr2, true))
     return 0;
 
@@ -619,7 +628,8 @@ constant_string_length (gfc_expr *e)
 
   /* Return length of char symbol, if constant.  */
 
-  if (e->symtree->n.sym->ts.u.cl && e->symtree->n.sym->ts.u.cl->length
+  if (e->symtree && e->symtree->n.sym->ts.u.cl
+      && e->symtree->n.sym->ts.u.cl->length
       && e->symtree->n.sym->ts.u.cl->length->expr_type == EXPR_CONSTANT)
     return gfc_copy_expr (e->symtree->n.sym->ts.u.cl->length);
 
@@ -691,6 +701,11 @@ create_var (gfc_expr * e, const char *vname)
   if (e->expr_type == EXPR_CONSTANT || is_fe_temp (e))
     return gfc_copy_expr (e);
 
+  /* Creation of an array of unknown size requires realloc on assignment.
+     If that is not possible, just return NULL.  */
+  if (flag_realloc_lhs == 0 && e->rank > 0 && e->shape == NULL)
+    return NULL;
+
   ns = insert_block ();
 
   if (vname)
@@ -738,7 +753,7 @@ create_var (gfc_expr * e, const char *vname)
     }
 
   deferred = 0;
-  if (e->ts.type == BT_CHARACTER && e->rank == 0)
+  if (e->ts.type == BT_CHARACTER)
     {
       gfc_expr *length;
 
@@ -749,6 +764,8 @@ create_var (gfc_expr * e, const char *vname)
       else
 	{
 	  symbol->attr.allocatable = 1;
+	  symbol->ts.u.cl->length = NULL;
+	  symbol->ts.deferred = 1;
 	  deferred = 1;
 	}
     }
@@ -761,7 +778,7 @@ create_var (gfc_expr * e, const char *vname)
 
   result = gfc_get_expr ();
   result->expr_type = EXPR_VARIABLE;
-  result->ts = e->ts;
+  result->ts = symbol->ts;
   result->ts.deferred = deferred;
   result->rank = e->rank;
   result->shape = gfc_copy_shape (e->shape, e->rank);
@@ -1348,6 +1365,10 @@ combine_array_constructor (gfc_expr *e)
   if (iterator_level > 0)
     return false;
 
+  /* WHERE also doesn't work.  */
+  if (in_where > 0)
+    return false;
+
   op1 = e->value.op.op1;
   op2 = e->value.op.op2;
 
@@ -1408,84 +1429,6 @@ combine_array_constructor (gfc_expr *e)
   return true;
 }
 
-/* Change (-1)**k into 1-ishift(iand(k,1),1) and
- 2**k into ishift(1,k) */
-
-static bool
-optimize_power (gfc_expr *e)
-{
-  gfc_expr *op1, *op2;
-  gfc_expr *iand, *ishft;
-
-  if (e->ts.type != BT_INTEGER)
-    return false;
-
-  op1 = e->value.op.op1;
-
-  if (op1 == NULL || op1->expr_type != EXPR_CONSTANT)
-    return false;
-
-  if (mpz_cmp_si (op1->value.integer, -1L) == 0)
-    {
-      gfc_free_expr (op1);
-
-      op2 = e->value.op.op2;
-
-      if (op2 == NULL)
-	return false;
-
-      iand = gfc_build_intrinsic_call (current_ns, GFC_ISYM_IAND,
-				       "_internal_iand", e->where, 2, op2,
-				       gfc_get_int_expr (e->ts.kind,
-							 &e->where, 1));
-
-      ishft = gfc_build_intrinsic_call (current_ns, GFC_ISYM_ISHFT,
-					"_internal_ishft", e->where, 2, iand,
-					gfc_get_int_expr (e->ts.kind,
-							  &e->where, 1));
-
-      e->value.op.op = INTRINSIC_MINUS;
-      e->value.op.op1 = gfc_get_int_expr (e->ts.kind, &e->where, 1);
-      e->value.op.op2 = ishft;
-      return true;
-    }
-  else if (mpz_cmp_si (op1->value.integer, 2L) == 0)
-    {
-      gfc_free_expr (op1);
-
-      op2 = e->value.op.op2;
-      if (op2 == NULL)
-	return false;
-
-      ishft = gfc_build_intrinsic_call (current_ns, GFC_ISYM_ISHFT,
-					"_internal_ishft", e->where, 2,
-					gfc_get_int_expr (e->ts.kind,
-							  &e->where, 1),
-					op2);
-      *e = *ishft;
-      return true;
-    }
-
-  else if (mpz_cmp_si (op1->value.integer, 1L) == 0)
-    {
-      op2 = e->value.op.op2;
-      if (op2 == NULL)
-	return false;
-
-      gfc_free_expr (op1);
-      gfc_free_expr (op2);
-
-      e->expr_type = EXPR_CONSTANT;
-      e->value.op.op1 = NULL;
-      e->value.op.op2 = NULL;
-      mpz_init_set_si (e->value.integer, 1);
-      /* Typespec and location are still OK.  */
-      return true;
-    }
-
-  return false;
-}
-
 /* Recursive optimization of operators.  */
 
 static bool
@@ -1546,9 +1489,6 @@ optimize_op (gfc_expr *e)
     case INTRINSIC_DIVIDE:
       return combine_array_constructor (e) || changed;
 
-    case INTRINSIC_POWER:
-      return optimize_power (e);
-
     default:
       break;
     }
@@ -2750,10 +2690,26 @@ scalarized_expr (gfc_expr *e_in, gfc_expr **index, int count_index)
 			 is the lbound of a full ref.  */
 		      int j;
 		      gfc_array_ref *ar;
+		      int to;
 
 		      ar = &ref->u.ar;
-		      ar->type = AR_FULL;
-		      for (j = 0; j < ar->dimen; j++)
+
+		      /* For assumed size, we need to keep around the final
+			 reference in order not to get an error on resolution
+			 below, and we cannot use AR_FULL.  */
+			 
+		      if (ar->as->type == AS_ASSUMED_SIZE)
+			{
+			  ar->type = AR_SECTION;
+			  to = ar->dimen - 1;
+			}
+		      else
+			{
+			  to = ar->dimen;
+			  ar->type = AR_FULL;
+			}
+
+		      for (j = 0; j < to; j++)
 			{
 			  gfc_free_expr (ar->start[j]);
 			  ar->start[j] = NULL;
diff --git a/gcc/fortran/gfortran.h b/gcc/fortran/gfortran.h
index 293655078a4..47b98bbd5ae 100644
--- a/gcc/fortran/gfortran.h
+++ b/gcc/fortran/gfortran.h
@@ -863,7 +863,7 @@ typedef struct
   unsigned alloc_comp:1, pointer_comp:1, proc_pointer_comp:1,
 	   private_comp:1, zero_comp:1, coarray_comp:1, lock_comp:1,
 	   event_comp:1, defined_assign_comp:1, unlimited_polymorphic:1,
-	   has_dtio_procs:1;
+	   has_dtio_procs:1, caf_token:1;
 
   /* This is a temporary selector for SELECT TYPE or an associate
      variable for SELECT_TYPE or ASSOCIATE.  */
@@ -1058,6 +1058,7 @@ typedef struct gfc_component
   struct gfc_typebound_proc *tb;
   /* When allocatable/pointer and in a coarray the associated token.  */
   tree caf_token;
+  bool finalized;
 }
 gfc_component;
 
@@ -1854,6 +1855,7 @@ typedef struct gfc_gsymbol
   enum gfc_symbol_type type;
 
   int defined, used;
+  bool bind_c;
   locus where;
   gfc_namespace *ns;
 }
@@ -2106,6 +2108,9 @@ typedef struct gfc_expr
   /* Will require finalization after use.  */
   unsigned int must_finalize : 1;
 
+  /* Set this if no warning should be given somewhere in a lower level.  */
+
+  unsigned int do_not_warn : 1;
   /* If an expression comes from a Hollerith constant or compile-time
      evaluation of a transfer statement, it may have a prescribed target-
      memory representation, and these cannot always be backformed from
@@ -2856,6 +2861,8 @@ extern int gfc_charlen_int_kind;
 extern int gfc_numeric_storage_size;
 extern int gfc_character_storage_size;
 
+#define gfc_integer_4_kind 4
+
 /* symbol.c */
 void gfc_clear_new_implicit (void);
 bool gfc_add_new_implicit_range (int, int);
@@ -2986,7 +2993,7 @@ void gfc_enforce_clean_symbol_state (void);
 void gfc_free_dt_list (void);
 
 
-gfc_gsymbol *gfc_get_gsymbol (const char *);
+gfc_gsymbol *gfc_get_gsymbol (const char *, bool bind_c);
 gfc_gsymbol *gfc_find_gsymbol (gfc_gsymbol *, const char *);
 
 gfc_typebound_proc* gfc_get_typebound_proc (gfc_typebound_proc*);
@@ -3122,7 +3129,7 @@ int gfc_kind_max (gfc_expr *, gfc_expr *);
 
 bool gfc_check_conformance (gfc_expr *, gfc_expr *, const char *, ...) ATTRIBUTE_PRINTF_3;
 bool gfc_check_assign (gfc_expr *, gfc_expr *, int, bool c = true);
-bool gfc_check_pointer_assign (gfc_expr *, gfc_expr *);
+bool gfc_check_pointer_assign (gfc_expr *, gfc_expr *, bool is_init_expr = false);
 bool gfc_check_assign_symbol (gfc_symbol *, gfc_component *, gfc_expr *);
 
 gfc_expr *gfc_build_default_init_expr (gfc_typespec *, locus *);
@@ -3145,7 +3152,7 @@ bool gfc_expr_check_typed (gfc_expr*, gfc_namespace*, bool);
 gfc_component * gfc_get_proc_ptr_comp (gfc_expr *);
 bool gfc_is_proc_ptr_comp (gfc_expr *);
 bool gfc_is_alloc_class_scalar_function (gfc_expr *);
-bool gfc_is_alloc_class_array_function (gfc_expr *);
+bool gfc_is_class_array_function (gfc_expr *);
 
 bool gfc_ref_this_image (gfc_ref *ref);
 bool gfc_is_coindexed (gfc_expr *);
@@ -3267,7 +3274,7 @@ bool gfc_resolve_open (gfc_open *);
 void gfc_free_close (gfc_close *);
 bool gfc_resolve_close (gfc_close *);
 void gfc_free_filepos (gfc_filepos *);
-bool gfc_resolve_filepos (gfc_filepos *);
+bool gfc_resolve_filepos (gfc_filepos *, locus *);
 void gfc_free_inquire (gfc_inquire *);
 bool gfc_resolve_inquire (gfc_inquire *);
 void gfc_free_dt (gfc_dt *);
diff --git a/gcc/fortran/interface.c b/gcc/fortran/interface.c
index 2e5732a8810..5625a2e6ab6 100644
--- a/gcc/fortran/interface.c
+++ b/gcc/fortran/interface.c
@@ -691,6 +691,15 @@ gfc_compare_types (gfc_typespec *ts1, gfc_typespec *ts2)
   if (ts1->type == BT_VOID || ts2->type == BT_VOID)
     return true;
 
+  /* Special case for our C interop types.  There should be a better
+     way of doing this...  */
+
+  if (((ts1->type == BT_INTEGER && ts2->type == BT_DERIVED)
+       || (ts1->type == BT_DERIVED && ts2->type == BT_INTEGER))
+      && ts1->u.derived && ts2->u.derived
+      && ts1->u.derived == ts2->u.derived)
+    return true;
+
   /* The _data component is not always present, therefore check for its
      presence before assuming, that its derived->attr is available.
      When the _data component is not present, then nevertheless the
@@ -734,13 +743,20 @@ compare_type (gfc_symbol *s1, gfc_symbol *s2)
   if (s2->attr.ext_attr & (1 << EXT_ATTR_NO_ARG_CHECK))
     return true;
 
+  return gfc_compare_types (&s1->ts, &s2->ts) || s2->ts.type == BT_ASSUMED;
+}
+
+
+static bool
+compare_type_characteristics (gfc_symbol *s1, gfc_symbol *s2)
+{
   /* TYPE and CLASS of the same declared type are type compatible,
      but have different characteristics.  */
   if ((s1->ts.type == BT_CLASS && s2->ts.type == BT_DERIVED)
       || (s1->ts.type == BT_DERIVED && s2->ts.type == BT_CLASS))
     return false;
 
-  return gfc_compare_types (&s1->ts, &s2->ts) || s2->ts.type == BT_ASSUMED;
+  return compare_type (s1, s2);
 }
 
 
@@ -1263,7 +1279,7 @@ symbol_rank (gfc_symbol *sym)
 {
   gfc_array_spec *as = NULL;
 
-  if (sym->ts.type == BT_CLASS && CLASS_DATA (sym) && CLASS_DATA (sym)->as)
+  if (sym->ts.type == BT_CLASS && CLASS_DATA (sym))
     as = CLASS_DATA (sym)->as;
   else
     as = sym->as;
@@ -1286,7 +1302,8 @@ gfc_check_dummy_characteristics (gfc_symbol *s1, gfc_symbol *s2,
   /* Check type and rank.  */
   if (type_must_agree)
     {
-      if (!compare_type (s1, s2) || !compare_type (s2, s1))
+      if (!compare_type_characteristics (s1, s2)
+	  || !compare_type_characteristics (s2, s1))
 	{
 	  snprintf (errmsg, err_len, "Type mismatch in argument '%s' (%s/%s)",
 		    s1->name, gfc_typename (&s1->ts), gfc_typename (&s2->ts));
@@ -1505,7 +1522,7 @@ gfc_check_result_characteristics (gfc_symbol *s1, gfc_symbol *s2,
     return true;
 
   /* Check type and rank.  */
-  if (!compare_type (r1, r2))
+  if (!compare_type_characteristics (r1, r2))
     {
       snprintf (errmsg, err_len, "Type mismatch in function result (%s/%s)",
 		gfc_typename (&r1->ts), gfc_typename (&r2->ts));
@@ -2791,7 +2808,8 @@ is_procptr_result (gfc_expr *expr)
 
 static bool
 compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,
-	 	       int ranks_must_agree, int is_elemental, locus *where)
+	 	       int ranks_must_agree, int is_elemental,
+		       bool in_statement_function, locus *where)
 {
   gfc_actual_arglist **new_arg, *a, *actual;
   gfc_formal_arglist *f;
@@ -2820,6 +2838,13 @@ compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,
 
   for (a = actual; a; a = a->next, f = f->next)
     {
+      if (a->name != NULL && in_statement_function)
+	{
+	  gfc_error ("Keyword argument %qs at %L is invalid in "
+		     "a statement function", a->name, &a->expr->where);
+	  return false;
+	}
+
       /* Look for keywords but ignore g77 extensions like %VAL.  */
       if (a->name != NULL && a->name[0] != '%')
 	{
@@ -3143,8 +3168,9 @@ compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,
 	}
 
       /* Check intent = OUT/INOUT for definable actual argument.  */
-      if ((f->sym->attr.intent == INTENT_OUT
-	  || f->sym->attr.intent == INTENT_INOUT))
+      if (!in_statement_function
+	  && (f->sym->attr.intent == INTENT_OUT
+	      || f->sym->attr.intent == INTENT_INOUT))
 	{
 	  const char* context = (where
 				 ? _("actual argument to INTENT = OUT/INOUT")
@@ -3249,7 +3275,8 @@ compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,
 		       "at %L", where);
 	  return false;
 	}
-      if (!f->sym->attr.optional)
+      if (!f->sym->attr.optional
+	  || (in_statement_function && f->sym->attr.optional))
 	{
 	  if (where)
 	    gfc_error ("Missing actual argument for argument %qs at %L",
@@ -3535,6 +3562,7 @@ check_intents (gfc_formal_arglist *f, gfc_actual_arglist *a)
 bool
 gfc_procedure_use (gfc_symbol *sym, gfc_actual_arglist **ap, locus *where)
 {
+  gfc_actual_arglist *a;
   gfc_formal_arglist *dummy_args;
 
   /* Warn about calls with an implicit interface.  Special case
@@ -3561,8 +3589,6 @@ gfc_procedure_use (gfc_symbol *sym, gfc_actual_arglist **ap, locus *where)
 
   if (sym->attr.if_source == IFSRC_UNKNOWN)
     {
-      gfc_actual_arglist *a;
-
       if (sym->attr.pointer)
 	{
 	  gfc_error ("The pointer object %qs at %L must have an explicit "
@@ -3654,9 +3680,12 @@ gfc_procedure_use (gfc_symbol *sym, gfc_actual_arglist **ap, locus *where)
 
   dummy_args = gfc_sym_get_dummy_args (sym);
 
-  if (!compare_actual_formal (ap, dummy_args, 0, sym->attr.elemental, where))
+  /* For a statement function, check that types and type parameters of actual
+     arguments and dummy arguments match.  */
+  if (!compare_actual_formal (ap, dummy_args, 0, sym->attr.elemental,
+			      sym->attr.proc == PROC_ST_FUNCTION, where))
     return false;
-
+ 
   if (!check_intents (dummy_args, *ap))
     return false;
 
@@ -3703,7 +3732,7 @@ gfc_ppc_use (gfc_component *comp, gfc_actual_arglist **ap, locus *where)
     }
 
   if (!compare_actual_formal (ap, comp->ts.interface->formal, 0,
-			      comp->attr.elemental, where))
+			      comp->attr.elemental, false, where))
     return;
 
   check_intents (comp->ts.interface->formal, *ap);
@@ -3728,7 +3757,7 @@ gfc_arglist_matches_symbol (gfc_actual_arglist** args, gfc_symbol* sym)
   dummy_args = gfc_sym_get_dummy_args (sym);
 
   r = !sym->attr.elemental;
-  if (compare_actual_formal (args, dummy_args, r, !r, NULL))
+  if (compare_actual_formal (args, dummy_args, r, !r, false, NULL))
     {
       check_intents (dummy_args, *args);
       if (warn_aliasing)
diff --git a/gcc/fortran/intrinsic.c b/gcc/fortran/intrinsic.c
index 2f60fe8c877..8eb815c9a5b 100644
--- a/gcc/fortran/intrinsic.c
+++ b/gcc/fortran/intrinsic.c
@@ -4919,6 +4919,8 @@ gfc_convert_type_warn (gfc_expr *expr, gfc_typespec *ts, int eflag, int wflag)
   if (ts->type == BT_UNKNOWN)
     goto bad;
 
+  expr->do_not_warn = ! wflag;
+
   /* NULL and zero size arrays get their type here.  */
   if (expr->expr_type == EXPR_NULL
       || (expr->expr_type == EXPR_ARRAY && expr->value.constructor == NULL))
diff --git a/gcc/fortran/io.c b/gcc/fortran/io.c
index b2fa741d03f..90f4baafd74 100644
--- a/gcc/fortran/io.c
+++ b/gcc/fortran/io.c
@@ -2090,33 +2090,6 @@ gfc_match_open (void)
 
   warn = (open->err || open->iostat) ? true : false;
 
-  /* Checks on NEWUNIT specifier.  */
-  if (open->newunit)
-    {
-      if (open->unit)
-	{
-	  gfc_error ("UNIT specifier not allowed with NEWUNIT at %C");
-	  goto cleanup;
-	}
-
-      if (!open->file && open->status)
-        {
-	  if (open->status->expr_type == EXPR_CONSTANT
-	     && gfc_wide_strncasecmp (open->status->value.character.string,
-				       "scratch", 7) != 0)
-	   {
-	     gfc_error ("NEWUNIT specifier must have FILE= "
-			"or STATUS='scratch' at %C");
-	     goto cleanup;
-	   }
-	}
-    }
-  else if (!open->unit)
-    {
-      gfc_error ("OPEN statement at %C must have UNIT or NEWUNIT specified");
-      goto cleanup;
-    }
-
   /* Checks on the ACCESS specifier.  */
   if (open->access && open->access->expr_type == EXPR_CONSTANT)
     {
@@ -2441,6 +2414,33 @@ gfc_match_open (void)
 	}
     }
 
+  /* Checks on NEWUNIT specifier.  */
+  if (open->newunit)
+    {
+      if (open->unit)
+	{
+	  gfc_error ("UNIT specifier not allowed with NEWUNIT at %C");
+	  goto cleanup;
+	}
+
+      if (!open->file && open->status)
+        {
+	  if (open->status->expr_type == EXPR_CONSTANT
+	     && gfc_wide_strncasecmp (open->status->value.character.string,
+				       "scratch", 7) != 0)
+	   {
+	     gfc_error ("NEWUNIT specifier must have FILE= "
+			"or STATUS='scratch' at %C");
+	     goto cleanup;
+	   }
+	}
+    }
+  else if (!open->unit)
+    {
+      gfc_error ("OPEN statement at %C must have UNIT or NEWUNIT specified");
+      goto cleanup;
+    }
+
   /* Things that are not allowed for unformatted I/O.  */
   if (open->form && open->form->expr_type == EXPR_CONSTANT
       && (open->delim || open->decimal || open->encoding || open->round
@@ -2774,22 +2774,21 @@ cleanup:
 
 
 bool
-gfc_resolve_filepos (gfc_filepos *fp)
+gfc_resolve_filepos (gfc_filepos *fp, locus *where)
 {
   RESOLVE_TAG (&tag_unit, fp->unit);
   RESOLVE_TAG (&tag_iostat, fp->iostat);
   RESOLVE_TAG (&tag_iomsg, fp->iomsg);
-  if (!gfc_reference_st_label (fp->err, ST_LABEL_TARGET))
-    return false;
 
-  if (!fp->unit && (fp->iostat || fp->iomsg))
+  if (!fp->unit && (fp->iostat || fp->iomsg || fp->err))
     {
-      locus where;
-      where = fp->iostat ? fp->iostat->where : fp->iomsg->where;
-      gfc_error ("UNIT number missing in statement at %L", &where);
+      gfc_error ("UNIT number missing in statement at %L", where);
       return false;
     }
 
+  if (!gfc_reference_st_label (fp->err, ST_LABEL_TARGET))
+    return false;
+
   if (fp->unit->expr_type == EXPR_CONSTANT
       && fp->unit->ts.type == BT_INTEGER
       && mpz_sgn (fp->unit->value.integer) < 0)
@@ -3617,10 +3616,13 @@ static match
 check_io_constraints (io_kind k, gfc_dt *dt, gfc_code *io_code,
 		      locus *spec_end)
 {
-#define io_constraint(condition,msg,arg)\
+#define io_constraint(condition, msg, arg)\
 if (condition) \
   {\
-    gfc_error(msg,arg);\
+    if ((arg)->lb != NULL)\
+      gfc_error ((msg), (arg));\
+    else\
+      gfc_error ((msg), &gfc_current_locus);\
     m = MATCH_ERROR;\
   }
 
@@ -3680,11 +3682,14 @@ if (condition) \
   if (expr && expr->ts.type != BT_CHARACTER)
     {
 
-      io_constraint (gfc_pure (NULL) && (k == M_READ || k == M_WRITE),
-		     "IO UNIT in %s statement at %C must be "
+      if (gfc_pure (NULL) && (k == M_READ || k == M_WRITE))
+	{
+	  gfc_error ("IO UNIT in %s statement at %C must be "
 		     "an internal file in a PURE procedure",
 		     io_kind_name (k));
-
+	  return MATCH_ERROR;
+	}
+	  
       if (k == M_READ || k == M_WRITE)
 	gfc_unset_implicit_pure (NULL);
     }
diff --git a/gcc/fortran/iresolve.c b/gcc/fortran/iresolve.c
index b784ac339e9..a5fcbda46aa 100644
--- a/gcc/fortran/iresolve.c
+++ b/gcc/fortran/iresolve.c
@@ -35,6 +35,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "intrinsic.h"
 #include "constructor.h"
 #include "arith.h"
+#include "trans.h"
 
 /* Given printf-like arguments, return a stable version of the result string. 
 
@@ -2286,6 +2287,10 @@ gfc_resolve_fe_runtime_error (gfc_code *c)
     a->name = "%VAL";
 
   c->resolved_sym = gfc_get_intrinsic_sub_symbol (name);
+  /* We set the backend_decl here because runtime_error is a
+     variadic function and we would use the wrong calling
+     convention otherwise.  */
+  c->resolved_sym->backend_decl = gfor_fndecl_runtime_error;
 }
 
 void
diff --git a/gcc/fortran/match.c b/gcc/fortran/match.c
index 78fd6a4ba11..0200366d4ed 100644
--- a/gcc/fortran/match.c
+++ b/gcc/fortran/match.c
@@ -2001,12 +2001,17 @@ gfc_match_type_spec (gfc_typespec *ts)
 {
   match m;
   locus old_locus;
-  char name[GFC_MAX_SYMBOL_LEN + 1];
+  char c, name[GFC_MAX_SYMBOL_LEN + 1];
 
   gfc_clear_ts (ts);
   gfc_gobble_whitespace ();
   old_locus = gfc_current_locus;
 
+  /* If c isn't [a-z], then return immediately.  */
+  c = gfc_peek_ascii_char ();
+  if (!ISALPHA(c))
+    return MATCH_NO;
+
   if (match_derived_type_spec (ts) == MATCH_YES)
     {
       /* Enforce F03:C401.  */
@@ -2056,7 +2061,7 @@ gfc_match_type_spec (gfc_typespec *ts)
      or list item in a type-list of an OpenMP reduction clause.  Need to
      differentiate REAL([KIND]=scalar-int-initialization-expr) from
      REAL(A,[KIND]) and REAL(KIND,A).  Logically, when this code was
-     written the use of LOGICAL as a type-spec or intrinsic subprogram 
+     written the use of LOGICAL as a type-spec or intrinsic subprogram
      was overlooked.  */
 
   m = gfc_match (" %n", name);
@@ -2146,6 +2151,9 @@ found:
 	      return MATCH_NO;
 	    }
 
+	  if (e->expr_type != EXPR_CONSTANT)
+	    goto ohno;
+
 	  gfc_next_char (); /* Burn the ')'. */
 	  ts->kind = (int) mpz_get_si (e->value.integer);
 	  if (gfc_validate_kind (ts->type, ts->kind , true) == -1)
@@ -2160,6 +2168,8 @@ found:
 	}
     }
 
+ohno:
+
   /* If a type is not matched, simply return MATCH_NO.  */
   gfc_current_locus = old_locus;
   return MATCH_NO;
@@ -4404,8 +4414,8 @@ gfc_match_deallocate (void)
 	   && (tail->expr->ref->type == REF_COMPONENT
 	       || tail->expr->ref->type == REF_ARRAY));
       if (sym && sym->ts.type == BT_CLASS)
-	b2 = !(CLASS_DATA (sym)->attr.allocatable
-	       || CLASS_DATA (sym)->attr.class_pointer);
+	b2 = !(CLASS_DATA (sym) && (CLASS_DATA (sym)->attr.allocatable
+	       || CLASS_DATA (sym)->attr.class_pointer));
       else
 	b2 = sym && !(sym->attr.allocatable || sym->attr.pointer
 		      || sym->attr.proc_pointer);
@@ -5707,6 +5717,7 @@ copy_ts_from_selector_to_associate (gfc_expr *associate, gfc_expr *selector)
 {
   gfc_ref *ref;
   gfc_symbol *assoc_sym;
+  int rank = 0;
 
   assoc_sym = associate->symtree->n.sym;
 
@@ -5743,14 +5754,28 @@ copy_ts_from_selector_to_associate (gfc_expr *associate, gfc_expr *selector)
 	selector->rank = ref->u.ar.dimen;
       else
 	selector->rank = 0;
+
+      rank = selector->rank;
     }
 
-  if (selector->rank)
+  if (rank)
     {
-      assoc_sym->attr.dimension = 1;
-      assoc_sym->as = gfc_get_array_spec ();
-      assoc_sym->as->rank = selector->rank;
-      assoc_sym->as->type = AS_DEFERRED;
+      for (int i = 0; i < ref->u.ar.dimen + ref->u.ar.codimen; i++)
+	if (ref->u.ar.dimen_type[i] == DIMEN_ELEMENT
+	    || (ref->u.ar.dimen_type[i] == DIMEN_UNKNOWN
+		&& ref->u.ar.end[i] == NULL
+		&& ref->u.ar.stride[i] == NULL))
+	  rank--;
+
+      if (rank)
+	{
+	  assoc_sym->attr.dimension = 1;
+	  assoc_sym->as = gfc_get_array_spec ();
+	  assoc_sym->as->rank = rank;
+	  assoc_sym->as->type = AS_DEFERRED;
+	}
+      else
+	assoc_sym->as = NULL;
     }
   else
     assoc_sym->as = NULL;
diff --git a/gcc/fortran/module.c b/gcc/fortran/module.c
index e8cba1455aa..ab29639784b 100644
--- a/gcc/fortran/module.c
+++ b/gcc/fortran/module.c
@@ -2791,6 +2791,8 @@ mio_component (gfc_component *c, int vtype)
   if (c->attr.proc_pointer)
     mio_typebound_proc (&c->tb);
 
+  c->loc = gfc_current_locus;
+
   mio_rparen ();
 }
 
@@ -3630,7 +3632,6 @@ static void
 mio_namelist (gfc_symbol *sym)
 {
   gfc_namelist *n, *m;
-  const char *check_name;
 
   mio_lparen ();
 
@@ -3641,17 +3642,6 @@ mio_namelist (gfc_symbol *sym)
     }
   else
     {
-      /* This departure from the standard is flagged as an error.
-	 It does, in fact, work correctly. TODO: Allow it
-	 conditionally?  */
-      if (sym->attr.flavor == FL_NAMELIST)
-	{
-	  check_name = find_use_name (sym->name, false);
-	  if (check_name && strcmp (check_name, sym->name) != 0)
-	    gfc_error ("Namelist %s cannot be renamed by USE "
-		       "association to %s", sym->name, check_name);
-	}
-
       m = NULL;
       while (peek_atom () != ATOM_RPAREN)
 	{
@@ -4016,6 +4006,9 @@ static const mstring omp_declare_simd_clauses[] =
     minit ("UNIFORM", 3),
     minit ("LINEAR", 4),
     minit ("ALIGNED", 5),
+    minit ("LINEAR_REF", 33),
+    minit ("LINEAR_VAL", 34),
+    minit ("LINEAR_UVAL", 35),
     minit (NULL, -1)
 };
 
@@ -4058,7 +4051,10 @@ mio_omp_declare_simd (gfc_namespace *ns, gfc_omp_declare_simd **odsp)
 	    }
 	  for (n = ods->clauses->lists[OMP_LIST_LINEAR]; n; n = n->next)
 	    {
-	      mio_name (4, omp_declare_simd_clauses);
+	      if (n->u.linear_op == OMP_LINEAR_DEFAULT)
+		mio_name (4, omp_declare_simd_clauses);
+	      else
+		mio_name (32 + n->u.linear_op, omp_declare_simd_clauses);
 	      mio_symbol_ref (&n->sym);
 	      mio_expr (&n->expr);
 	    }
@@ -4099,11 +4095,20 @@ mio_omp_declare_simd (gfc_namespace *ns, gfc_omp_declare_simd **odsp)
 	    case 4:
 	    case 5:
 	      *ptrs[t - 3] = n = gfc_get_omp_namelist ();
+	    finish_namelist:
+	      n->where = gfc_current_locus;
 	      ptrs[t - 3] = &n->next;
 	      mio_symbol_ref (&n->sym);
 	      if (t != 3)
 		mio_expr (&n->expr);
 	      break;
+	    case 33:
+	    case 34:
+	    case 35:
+	      *ptrs[1] = n = gfc_get_omp_namelist ();
+	      n->u.linear_op = (enum gfc_omp_linear_op) (t - 32);
+	      t = 4;
+	      goto finish_namelist;
 	    }
 	}
     }
@@ -6063,8 +6068,10 @@ dump_module (const char *name, int dump_flag)
     gfc_fatal_error ("Can't open module file %qs for writing at %C: %s",
 		     filename_tmp, xstrerror (errno));
 
+  /* Use lbasename to ensure module files are reproducible regardless
+     of the build path (see the reproducible builds project).  */
   gzprintf (module_fp, "GFORTRAN module version '%s' created from %s\n",
-	    MOD_VERSION, gfc_source_file);
+	    MOD_VERSION, lbasename (gfc_source_file));
 
   /* Write the module itself.  */
   iomode = IO_OUTPUT;
diff --git a/gcc/fortran/openmp.c b/gcc/fortran/openmp.c
index 7b88d6fbeba..8f7c622bbed 100644
--- a/gcc/fortran/openmp.c
+++ b/gcc/fortran/openmp.c
@@ -1312,23 +1312,21 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, const omp_mask mask,
 	      else if (gfc_match_omp_variable_list (" val (",
 						    &c->lists[OMP_LIST_LINEAR],
 						    false, NULL, &head)
-		  == MATCH_YES)
+		       == MATCH_YES)
 		linear_op = OMP_LINEAR_VAL;
 	      else if (gfc_match_omp_variable_list (" uval (",
 						    &c->lists[OMP_LIST_LINEAR],
 						    false, NULL, &head)
-		  == MATCH_YES)
+		       == MATCH_YES)
 		linear_op = OMP_LINEAR_UVAL;
 	      else if (gfc_match_omp_variable_list ("",
 						    &c->lists[OMP_LIST_LINEAR],
 						    false, &end_colon, &head)
-		  == MATCH_YES)
+		       == MATCH_YES)
 		linear_op = OMP_LINEAR_DEFAULT;
 	      else
 		{
-		  gfc_free_omp_namelist (*head);
 		  gfc_current_locus = old_loc;
-		  *head = NULL;
 		  break;
 		}
 	      if (linear_op != OMP_LINEAR_DEFAULT)
@@ -5577,8 +5575,6 @@ resolve_omp_do (gfc_code *code)
 			     "iteration space at %L", name, &do_code->loc);
 		  break;
 		}
-	      if (j < i)
-		break;
 	      do_code2 = do_code2->block->next;
 	    }
 	}
@@ -5742,12 +5738,10 @@ resolve_oacc_nested_loops (gfc_code *code, gfc_code* do_code, int collapse,
 		  || gfc_find_sym_in_expr (ivar, do_code->ext.iterator->end)
 		  || gfc_find_sym_in_expr (ivar, do_code->ext.iterator->step))
 		{
-		  gfc_error ("!$ACC LOOP %s loops don't form rectangular iteration space at %L",
-			     clause, &do_code->loc);
+		  gfc_error ("!$ACC LOOP %s loops don't form rectangular "
+			     "iteration space at %L", clause, &do_code->loc);
 		  break;
 		}
-	      if (j < i)
-		break;
 	      do_code2 = do_code2->block->next;
 	    }
 	}
diff --git a/gcc/fortran/parse.c b/gcc/fortran/parse.c
index 3aedb1d93bf..d41736934a0 100644
--- a/gcc/fortran/parse.c
+++ b/gcc/fortran/parse.c
@@ -5780,7 +5780,7 @@ parse_block_data (void)
     }
   else
     {
-      s = gfc_get_gsymbol (gfc_new_block->name);
+      s = gfc_get_gsymbol (gfc_new_block->name, false);
       if (s->defined
 	  || (s->type != GSYM_UNKNOWN && s->type != GSYM_BLOCK_DATA))
        gfc_global_used (s, &gfc_new_block->declared_at);
@@ -5862,7 +5862,7 @@ parse_module (void)
   gfc_gsymbol *s;
   bool error;
 
-  s = gfc_get_gsymbol (gfc_new_block->name);
+  s = gfc_get_gsymbol (gfc_new_block->name, false);
   if (s->defined || (s->type != GSYM_UNKNOWN && s->type != GSYM_MODULE))
     gfc_global_used (s, &gfc_new_block->declared_at);
   else
@@ -5926,7 +5926,7 @@ add_global_procedure (bool sub)
      name is a global identifier.  */
   if (!gfc_new_block->binding_label || gfc_notification_std (GFC_STD_F2008))
     {
-      s = gfc_get_gsymbol (gfc_new_block->name);
+      s = gfc_get_gsymbol (gfc_new_block->name, false);
 
       if (s->defined
 	  || (s->type != GSYM_UNKNOWN
@@ -5951,7 +5951,7 @@ add_global_procedure (bool sub)
       && (!gfc_notification_std (GFC_STD_F2008)
           || strcmp (gfc_new_block->name, gfc_new_block->binding_label) != 0))
     {
-      s = gfc_get_gsymbol (gfc_new_block->binding_label);
+      s = gfc_get_gsymbol (gfc_new_block->binding_label, true);
 
       if (s->defined
 	  || (s->type != GSYM_UNKNOWN
@@ -5983,7 +5983,7 @@ add_global_program (void)
 
   if (gfc_new_block == NULL)
     return;
-  s = gfc_get_gsymbol (gfc_new_block->name);
+  s = gfc_get_gsymbol (gfc_new_block->name, false);
 
   if (s->defined || (s->type != GSYM_UNKNOWN && s->type != GSYM_PROGRAM))
     gfc_global_used (s, &gfc_new_block->declared_at);
diff --git a/gcc/fortran/primary.c b/gcc/fortran/primary.c
index b97b4a1ca59..7dc05881bf7 100644
--- a/gcc/fortran/primary.c
+++ b/gcc/fortran/primary.c
@@ -1247,8 +1247,22 @@ match_sym_complex_part (gfc_expr **result)
 
   if (sym->attr.flavor != FL_PARAMETER)
     {
-      gfc_error ("Expected PARAMETER symbol in complex constant at %C");
-      return MATCH_ERROR;
+      /* Give the matcher for implied do-loops a chance to run.  This yields
+	 a much saner error message for "write(*,*) (i, i=1, 6" where the 
+	 right parenthesis is missing.  */
+      char c;
+      gfc_gobble_whitespace ();
+      c = gfc_peek_ascii_char ();
+      if (c == '=' || c == ',')
+	{
+	  m = MATCH_NO;
+	}
+      else
+	{
+	  gfc_error ("Expected PARAMETER symbol in complex constant at %C");
+	  m = MATCH_ERROR;
+	}
+      return m;
     }
 
   if (!sym->value)
@@ -2966,6 +2980,7 @@ gfc_match_structure_constructor (gfc_symbol *sym, gfc_expr **result)
   e = gfc_get_expr ();
   e->symtree = symtree;
   e->expr_type = EXPR_FUNCTION;
+  e->where = gfc_current_locus;
 
   gcc_assert (gfc_fl_struct (sym->attr.flavor)
 	      && symtree->n.sym->attr.flavor == FL_PROCEDURE);
diff --git a/gcc/fortran/resolve.c b/gcc/fortran/resolve.c
index 8e7babfe9e9..6948394dcd4 100644
--- a/gcc/fortran/resolve.c
+++ b/gcc/fortran/resolve.c
@@ -512,8 +512,11 @@ resolve_formal_arglist (gfc_symbol *proc)
 	{
 	  if (sym->as != NULL)
 	    {
-	      gfc_error ("Argument %qs of statement function at %L must "
-			 "be scalar", sym->name, &sym->declared_at);
+	      /* F03:C1263 (R1238) The function-name and each dummy-arg-name
+		 shall be specified, explicitly or implicitly, to be scalar.  */
+	      gfc_error ("Argument '%s' of statement function '%s' at %L "
+			 "must be scalar", sym->name, proc->name,
+			 &proc->declared_at);
 	      continue;
 	    }
 
@@ -1042,7 +1045,7 @@ resolve_common_blocks (gfc_symtree *common_root)
 	}
       if (!gsym)
 	{
-	  gsym = gfc_get_gsymbol (common_root->n.common->name);
+	  gsym = gfc_get_gsymbol (common_root->n.common->name, false);
 	  gsym->type = GSYM_COMMON;
 	  gsym->where = common_root->n.common->where;
 	  gsym->defined = 1;
@@ -1064,7 +1067,7 @@ resolve_common_blocks (gfc_symtree *common_root)
 	}
       if (!gsym)
 	{
-	  gsym = gfc_get_gsymbol (common_root->n.common->binding_label);
+	  gsym = gfc_get_gsymbol (common_root->n.common->binding_label, true);
 	  gsym->type = GSYM_COMMON;
 	  gsym->where = common_root->n.common->where;
 	  gsym->defined = 1;
@@ -1573,8 +1576,6 @@ is_illegal_recursion (gfc_symbol* sym, gfc_namespace* context)
       || gfc_fl_struct (sym->attr.flavor))
     return false;
 
-  gcc_assert (sym->attr.flavor == FL_PROCEDURE);
-
   /* If we've got an ENTRY, find real procedure.  */
   if (sym->attr.entry && sym->ns->entries)
     proc_sym = sym->ns->entries->sym;
@@ -2376,7 +2377,8 @@ resolve_global_procedure (gfc_symbol *sym, locus *where,
 
   type = sub ? GSYM_SUBROUTINE : GSYM_FUNCTION;
 
-  gsym = gfc_get_gsymbol (sym->binding_label ? sym->binding_label : sym->name);
+  gsym = gfc_get_gsymbol (sym->binding_label ? sym->binding_label : sym->name,
+			  sym->binding_label != NULL);
 
   if ((gsym->type != GSYM_UNKNOWN && gsym->type != type))
     gfc_global_used (gsym, where);
@@ -2903,8 +2905,8 @@ update_current_proc_array_outer_dependency (gfc_symbol *sym)
 
   /* If SYM has references to outer arrays, so has the procedure calling
      SYM.  If SYM is a procedure pointer, we can assume the worst.  */
-  if (sym->attr.array_outer_dependency
-      || sym->attr.proc_pointer)
+  if ((sym->attr.array_outer_dependency || sym->attr.proc_pointer)
+      && gfc_current_ns->proc_name)
     gfc_current_ns->proc_name->attr.array_outer_dependency = 1;
 }
 
@@ -3682,7 +3684,13 @@ resolve_operator (gfc_expr *e)
 	  break;
 	}
 
-      sprintf (msg,
+      if (op1->ts.type == BT_DERIVED || op2->ts.type == BT_DERIVED)
+	sprintf (msg,
+	       _("Unexpected derived-type entities in binary intrinsic "
+		 "numeric operator %%<%s%%> at %%L"),
+	       gfc_op2string (e->value.op.op));
+      else
+      	sprintf (msg,
 	       _("Operands of binary numeric operator %%<%s%%> at %%L are %s/%s"),
 	       gfc_op2string (e->value.op.op), gfc_typename (&op1->ts),
 	       gfc_typename (&op2->ts));
@@ -3728,7 +3736,7 @@ resolve_operator (gfc_expr *e)
 	  if (op2->ts.type != e->ts.type || op2->ts.kind != e->ts.kind)
 	    gfc_convert_type (op2, &e->ts, 1);
 	  e = logical_to_bitwise (e);
-	  return resolve_function (e);
+	  break;
 	}
 
       sprintf (msg, _("Operands of logical operator %%<%s%%> at %%L are %s/%s"),
@@ -3744,7 +3752,7 @@ resolve_operator (gfc_expr *e)
 	  e->ts.type = BT_INTEGER;
 	  e->ts.kind = op1->ts.kind;
 	  e = logical_to_bitwise (e);
-	  return resolve_function (e);
+	  break;
 	}
 
       if (op1->ts.type == BT_LOGICAL)
@@ -5123,7 +5131,7 @@ resolve_variable (gfc_expr *e)
      the ts' type of the component refs is still array valued, which
      can't be translated that way.  */
   if (sym->assoc && e->rank == 0 && e->ref && sym->ts.type == BT_CLASS
-      && sym->assoc->target->ts.type == BT_CLASS
+      && sym->assoc->target && sym->assoc->target->ts.type == BT_CLASS
       && CLASS_DATA (sym->assoc->target)->as)
     {
       gfc_ref *ref = e->ref;
@@ -5152,6 +5160,23 @@ resolve_variable (gfc_expr *e)
 	gfc_fix_class_refs (e);
       if (!sym->attr.dimension && e->ref && e->ref->type == REF_ARRAY)
 	return false;
+       else if (sym->attr.dimension && (!e->ref || e->ref->type != REF_ARRAY))
+	  {
+	    /* This can happen because the parser did not detect that the
+	       associate name is an array and the expression had no array
+	       part_ref.  */
+	    gfc_ref *ref = gfc_get_ref ();
+	    ref->type = REF_ARRAY;
+	    ref->u.ar = *gfc_get_array_ref();
+	    ref->u.ar.type = AR_FULL;
+	    if (sym->as)
+	      {
+		ref->u.ar.as = sym->as;
+		ref->u.ar.dimen = sym->as->rank;
+	      }
+	    ref->next = e->ref;
+	    e->ref = ref;
+	  }
     }
 
   if (sym->ts.type == BT_DERIVED && sym->ts.u.derived->attr.generic)
@@ -7405,13 +7430,54 @@ resolve_allocate_expr (gfc_expr *e, gfc_code *code, bool *array_alloc_wo_spec)
 
   if (codimension)
     for (i = ar->dimen; i < ar->dimen + ar->codimen; i++)
-      if (ar->dimen_type[i] == DIMEN_THIS_IMAGE)
-	{
-	  gfc_error ("Coarray specification required in ALLOCATE statement "
-		     "at %L", &e->where);
-	  goto failure;
-	}
+      {
+	switch (ar->dimen_type[i])
+	  {
+	  case DIMEN_THIS_IMAGE:
+	    gfc_error ("Coarray specification required in ALLOCATE statement "
+		       "at %L", &e->where);
+	    goto failure;
 
+	  case  DIMEN_RANGE:
+	    if (ar->start[i] == 0 || ar->end[i] == 0)
+	      {
+		/* If ar->stride[i] is NULL, we issued a previous error.  */
+		if (ar->stride[i] == NULL)
+		  gfc_error ("Bad array specification in ALLOCATE statement "
+			     "at %L", &e->where);
+		goto failure;
+	      }
+	    else if (gfc_dep_compare_expr (ar->start[i], ar->end[i]) == 1)
+	      {
+		gfc_error ("Upper cobound is less than lower cobound at %L",
+			   &ar->start[i]->where);
+		goto failure;
+	      }
+	    break;
+
+	  case DIMEN_ELEMENT:
+	    if (ar->start[i]->expr_type == EXPR_CONSTANT)
+	      {
+		gcc_assert (ar->start[i]->ts.type == BT_INTEGER);
+		if (mpz_cmp_si (ar->start[i]->value.integer, 1) < 0)
+		  {
+		    gfc_error ("Upper cobound is less than lower cobound "
+			       " of 1 at %L", &ar->start[i]->where);
+		    goto failure;
+		  }
+	      }
+	    break;
+
+	  case DIMEN_STAR:
+	    break;
+
+	  default:
+	    gfc_error ("Bad array specification in ALLOCATE statement at %L",
+		       &e->where);
+	    goto failure;
+
+	  }
+      }
   for (i = 0; i < ar->dimen; i++)
     {
       if (ar->type == AR_ELEMENT || ar->type == AR_FULL)
@@ -7551,12 +7617,17 @@ resolve_allocate_deallocate (gfc_code *code, const char *fcn)
       gfc_check_vardef_context (errmsg, false, false, false,
 				_("ERRMSG variable"));
 
+      /* F18:R928  alloc-opt             is ERRMSG = errmsg-variable
+	 F18:R930  errmsg-variable       is scalar-default-char-variable
+	 F18:R906  default-char-variable is variable
+	 F18:C906  default-char-variable shall be default character.  */
       if ((errmsg->ts.type != BT_CHARACTER
 	   && !(errmsg->ref
 		&& (errmsg->ref->type == REF_ARRAY
 		    || errmsg->ref->type == REF_COMPONENT)))
-	  || errmsg->rank > 0 )
-	gfc_error ("Errmsg-variable at %L must be a scalar CHARACTER "
+	  || errmsg->rank > 0
+	  || errmsg->ts.kind != gfc_default_character_kind)
+	gfc_error ("ERRMSG variable at %L shall be a scalar default CHARACTER "
 		   "variable", &errmsg->where);
 
       for (p = code->ext.alloc.list; p; p = p->next)
@@ -8495,7 +8566,7 @@ build_loc_call (gfc_expr *sym_expr)
   gfc_expr *loc_call;
   loc_call = gfc_get_expr ();
   loc_call->expr_type = EXPR_FUNCTION;
-  gfc_get_sym_tree ("loc", gfc_current_ns, &loc_call->symtree, false);
+  gfc_get_sym_tree ("_loc", gfc_current_ns, &loc_call->symtree, false);
   loc_call->symtree->n.sym->attr.flavor = FL_PROCEDURE;
   loc_call->symtree->n.sym->attr.intrinsic = 1;
   loc_call->symtree->n.sym->result = loc_call->symtree->n.sym;
@@ -8548,6 +8619,9 @@ resolve_select_type (gfc_code *code, gfc_namespace *old_ns)
 	code->expr1->symtree->n.sym->ts = code->expr2->ts;
       selector_type = CLASS_DATA (code->expr2)->ts.u.derived;
 
+      if (code->expr2->rank && CLASS_DATA (code->expr1)->as)
+	CLASS_DATA (code->expr1)->as->rank = code->expr2->rank;
+
       /* F2008: C803 The selector expression must not be coindexed.  */
       if (gfc_is_coindexed (code->expr2))
 	{
@@ -8742,7 +8816,7 @@ resolve_select_type (gfc_code *code, gfc_namespace *old_ns)
 	    {
 	      vtab = gfc_find_derived_vtab (c->ts.u.derived);
 	      gcc_assert (vtab);
-	      c->high = gfc_get_int_expr (gfc_default_integer_kind, NULL,
+	      c->high = gfc_get_int_expr (gfc_integer_4_kind, NULL,
 					  c->ts.u.derived->hash_value);
 	    }
 	  else
@@ -8751,6 +8825,13 @@ resolve_select_type (gfc_code *code, gfc_namespace *old_ns)
 	      gcc_assert (vtab && CLASS_DATA (vtab)->initializer);
 	      e = CLASS_DATA (vtab)->initializer;
 	      c->high = gfc_copy_expr (e);
+	      if (c->high->ts.kind != gfc_integer_4_kind)
+		{
+		  gfc_typespec ts;
+		  ts.kind = gfc_integer_4_kind;
+		  ts.type = BT_INTEGER;
+		  gfc_convert_type_warn (c->high, &ts, 2, 0);
+		}
 	    }
 
 	  e = gfc_lval_expr_from_sym (vtab);
@@ -8996,19 +9077,9 @@ resolve_transfer (gfc_code *code)
       else
 	derived = ts->u.derived->components->ts.u.derived;
 
-      if (dt->format_expr)
-	{
-	  char *fmt;
-	  fmt = gfc_widechar_to_char (dt->format_expr->value.character.string,
-				      -1);
-	  if (strtok (fmt, "DT") != NULL)
-	    formatted = true;
-	}
-      else if (dt->format_label == &format_asterisk)
-	{
-	  /* List directed io must call the formatted DTIO procedure.  */
-	  formatted = true;
-	}
+      /* Determine when to use the formatted DTIO procedure.  */
+      if (dt && (dt->format_expr || dt->format_label))
+	formatted = true;
 
       write = dt->dt_io_kind->value.iokind == M_WRITE
 	      || dt->dt_io_kind->value.iokind == M_PRINT;
@@ -9296,6 +9367,7 @@ resolve_sync (gfc_code *code)
     }
 
   /* Check STAT.  */
+  gfc_resolve_expr (code->expr2);
   if (code->expr2
       && (code->expr2->ts.type != BT_INTEGER || code->expr2->rank != 0
 	  || code->expr2->expr_type != EXPR_VARIABLE))
@@ -9303,6 +9375,7 @@ resolve_sync (gfc_code *code)
 	       &code->expr2->where);
 
   /* Check ERRMSG.  */
+  gfc_resolve_expr (code->expr3);
   if (code->expr3
       && (code->expr3->ts.type != BT_CHARACTER || code->expr3->rank != 0
 	  || code->expr3->expr_type != EXPR_VARIABLE))
@@ -10135,6 +10208,11 @@ resolve_ordinary_assign (gfc_code *code, gfc_namespace *ns)
       && rhs->expr_type != EXPR_ARRAY)
     gfc_add_data_component (rhs);
 
+  /* Make sure there is a vtable and, in particular, a _copy for the
+     rhs type.  */
+  if (UNLIMITED_POLY (lhs) && lhs->rank && rhs->ts.type != BT_CLASS)
+    gfc_find_vtab (&rhs->ts);
+
   bool caf_convert_to_send = flag_coarray == GFC_FCOARRAY_LIB
       && (lhs_coindexed
 	  || (code->expr2->expr_type == EXPR_FUNCTION
@@ -10243,6 +10321,11 @@ get_temp_from_expr (gfc_expr *e, gfc_namespace *ns)
   gfc_get_sym_tree (name, ns, &tmp, false);
   gfc_add_type (tmp->n.sym, &e->ts, NULL);
 
+  if (e->expr_type == EXPR_CONSTANT && e->ts.type == BT_CHARACTER)
+    tmp->n.sym->ts.u.cl->length = gfc_get_int_expr (gfc_charlen_int_kind,
+						    NULL,
+						    e->value.character.length);
+
   as = NULL;
   ref = NULL;
   aref = NULL;
@@ -10273,6 +10356,8 @@ get_temp_from_expr (gfc_expr *e, gfc_namespace *ns)
   tmp->n.sym->attr.function = 0;
   tmp->n.sym->attr.result = 0;
   tmp->n.sym->attr.flavor = FL_VARIABLE;
+  tmp->n.sym->attr.dummy = 0;
+  tmp->n.sym->attr.intent = INTENT_UNKNOWN;
 
   if (as)
     {
@@ -10731,6 +10816,9 @@ deferred_op_assign (gfc_code **code, gfc_namespace *ns)
   if (!gfc_check_dependency ((*code)->expr1, (*code)->expr2, 1))
     return false;
 
+  if (gfc_expr_attr ((*code)->expr1).pointer)
+    return false;
+
   tmp_expr = get_temp_from_expr ((*code)->expr1, ns);
   tmp_expr->where = (*code)->loc;
 
@@ -11140,7 +11228,7 @@ start:
 	case EXEC_ENDFILE:
 	case EXEC_REWIND:
 	case EXEC_FLUSH:
-	  if (!gfc_resolve_filepos (code->ext.filepos))
+	  if (!gfc_resolve_filepos (code->ext.filepos, &code->loc))
 	    break;
 
 	  resolve_branch (code->ext.filepos->err, code);
@@ -11362,7 +11450,7 @@ gfc_verify_binding_labels (gfc_symbol *sym)
 	  && (gsym->type == GSYM_FUNCTION || gsym->type == GSYM_SUBROUTINE)))
     {
       if (!gsym)
-	gsym = gfc_get_gsymbol (sym->binding_label);
+	gsym = gfc_get_gsymbol (sym->binding_label, true);
       gsym->where = sym->declared_at;
       gsym->sym_name = sym->name;
       gsym->binding_label = sym->binding_label;
@@ -12225,6 +12313,19 @@ resolve_fl_procedure (gfc_symbol *sym, int mp_flag)
 	}
     }
 
+  /* F2018, C15100: "The result of an elemental function shall be scalar,
+     and shall not have the POINTER or ALLOCATABLE attribute."  The scalar
+     pointer is tested and caught elsewhere.  */
+  if (sym->attr.elemental && sym->result
+      && (sym->result->attr.allocatable || sym->result->attr.pointer))
+    {
+      gfc_error ("Function result variable %qs at %L of elemental "
+		 "function %qs shall not have an ALLOCATABLE or POINTER "
+		 "attribute", sym->result->name,
+		 &sym->result->declared_at, sym->name);
+      return false;
+    }
+
   if (sym->attr.is_bind_c && sym->attr.is_c_interop != 1)
     {
       gfc_formal_arglist *curr_arg;
@@ -12250,7 +12351,7 @@ resolve_fl_procedure (gfc_symbol *sym, int mp_flag)
       while (curr_arg != NULL)
         {
           /* Skip implicitly typed dummy args here.  */
-	  if (curr_arg->sym->attr.implicit_type == 0)
+	  if (curr_arg->sym && curr_arg->sym->attr.implicit_type == 0)
 	    if (!gfc_verify_c_interop_param (curr_arg->sym))
 	      /* If something is found to fail, record the fact so we
 		 can mark the symbol for the procedure as not being
@@ -13799,6 +13900,31 @@ resolve_fl_derived0 (gfc_symbol *sym)
   if (!success)
     return false;
 
+  /* Now add the caf token field, where needed.  */
+  if (flag_coarray != GFC_FCOARRAY_NONE
+      && !sym->attr.is_class && !sym->attr.vtype)
+    {
+      for (c = sym->components; c; c = c->next)
+	if (!c->attr.dimension && !c->attr.codimension
+	    && (c->attr.allocatable || c->attr.pointer))
+	  {
+	    char name[GFC_MAX_SYMBOL_LEN+9];
+	    gfc_component *token;
+	    sprintf (name, "_caf_%s", c->name);
+	    token = gfc_find_component (sym, name, true, true, NULL);
+	    if (token == NULL)
+	      {
+		if (!gfc_add_component (sym, name, &token))
+		  return false;
+		token->ts.type = BT_VOID;
+		token->ts.kind = gfc_default_integer_kind;
+		token->attr.access = ACCESS_PRIVATE;
+		token->attr.artificial = 1;
+		token->attr.caf_token = 1;
+	      }
+	  }
+    }
+
   check_defined_assignments (sym);
 
   if (!sym->attr.defined_assign_comp && super_type)
@@ -14793,7 +14919,7 @@ resolve_symbol (gfc_symbol *sym)
   /* Set the formal_arg_flag so that check_conflict will not throw
      an error for host associated variables in the specification
      expression for an array_valued function.  */
-  if (sym->attr.function && sym->as)
+  if ((sym->attr.function || sym->attr.result) && sym->as)
     formal_arg_flag = true;
 
   saved_specification_expr = specification_expr;
@@ -15827,7 +15953,7 @@ resolve_equivalence (gfc_equiv *eq)
 
 static bool
 flag_fn_result_spec (gfc_expr *expr,
-                     gfc_symbol *sym ATTRIBUTE_UNUSED,
+                     gfc_symbol *sym,
                      int *f ATTRIBUTE_UNUSED)
 {
   gfc_namespace *ns;
@@ -15840,6 +15966,13 @@ flag_fn_result_spec (gfc_expr *expr,
 	if (!ns->parent)
 	  break;
 
+      if (sym == s)
+	{
+	  gfc_error ("Self reference in character length expression "
+		     "for %qs at %L", sym->name, &expr->where);
+	  return true;
+	}
+
       if (!s->fn_result_spec
 	  && s->attr.flavor == FL_PARAMETER)
 	{
@@ -15922,7 +16055,7 @@ resolve_fntype (gfc_namespace *ns)
       }
 
   if (sym->ts.type == BT_CHARACTER)
-    gfc_traverse_expr (sym->ts.u.cl->length, NULL, flag_fn_result_spec, 0);
+    gfc_traverse_expr (sym->ts.u.cl->length, sym, flag_fn_result_spec, 0);
 }
 
 
diff --git a/gcc/fortran/simplify.c b/gcc/fortran/simplify.c
index d12ae5f4aab..6cfa2283336 100644
--- a/gcc/fortran/simplify.c
+++ b/gcc/fortran/simplify.c
@@ -25,6 +25,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "gfortran.h"
 #include "arith.h"
 #include "intrinsic.h"
+#include "match.h"
 #include "target-memory.h"
 #include "constructor.h"
 #include "version.h"	/* For version_string.  */
@@ -4641,43 +4642,48 @@ gfc_simplify_mod (gfc_expr *a, gfc_expr *p)
   gfc_expr *result;
   int kind;
 
-  if (a->expr_type != EXPR_CONSTANT || p->expr_type != EXPR_CONSTANT)
+  /* First check p.  */
+  if (p->expr_type != EXPR_CONSTANT)
     return NULL;
 
-  kind = a->ts.kind > p->ts.kind ? a->ts.kind : p->ts.kind;
-  result = gfc_get_constant_expr (a->ts.type, kind, &a->where);
-
-  switch (a->ts.type)
+  /* p shall not be 0.  */
+  switch (p->ts.type)
     {
       case BT_INTEGER:
 	if (mpz_cmp_ui (p->value.integer, 0) == 0)
 	  {
-	    /* Result is processor-dependent.  */
-	    gfc_error ("Second argument MOD at %L is zero", &a->where);
-	    gfc_free_expr (result);
+	    gfc_error ("Argument %qs of MOD at %L shall not be zero",
+			"P", &p->where);
 	    return &gfc_bad_expr;
 	  }
-	mpz_tdiv_r (result->value.integer, a->value.integer, p->value.integer);
 	break;
-
       case BT_REAL:
 	if (mpfr_cmp_ui (p->value.real, 0) == 0)
 	  {
-	    /* Result is processor-dependent.  */
-	    gfc_error ("Second argument of MOD at %L is zero", &p->where);
-	    gfc_free_expr (result);
+	    gfc_error ("Argument %qs of MOD at %L shall not be zero",
+			"P", &p->where);
 	    return &gfc_bad_expr;
 	  }
-
-	gfc_set_model_kind (kind);
-	mpfr_fmod (result->value.real, a->value.real, p->value.real,
-		   GFC_RND_MODE);
 	break;
-
       default:
 	gfc_internal_error ("gfc_simplify_mod(): Bad arguments");
     }
 
+  if (a->expr_type != EXPR_CONSTANT)
+    return NULL;
+
+  kind = a->ts.kind > p->ts.kind ? a->ts.kind : p->ts.kind;
+  result = gfc_get_constant_expr (a->ts.type, kind, &a->where);
+
+  if (a->ts.type == BT_INTEGER)
+    mpz_tdiv_r (result->value.integer, a->value.integer, p->value.integer);
+  else
+    {
+      gfc_set_model_kind (kind);
+      mpfr_fmod (result->value.real, a->value.real, p->value.real,
+		 GFC_RND_MODE);
+    }
+
   return range_check (result, "MOD");
 }
 
@@ -6579,10 +6585,12 @@ gfc_simplify_transfer (gfc_expr *source, gfc_expr *mold, gfc_expr *size)
   unsigned char *buffer;
   size_t result_length;
 
+  if (!gfc_is_constant_expr (source) || !gfc_is_constant_expr (size))
+    return NULL;
 
-  if (!gfc_is_constant_expr (source)
-	|| (gfc_init_expr_flag && !gfc_is_constant_expr (mold))
-	|| !gfc_is_constant_expr (size))
+  if (!gfc_resolve_expr (mold))
+    return NULL;
+  if (gfc_init_expr_flag && !gfc_is_constant_expr (mold))
     return NULL;
 
   if (!gfc_calculate_transfer_sizes (source, mold, size, &source_size, 
@@ -7172,26 +7180,32 @@ gfc_convert_constant (gfc_expr *e, bt type, int kind)
 	{
 	  gfc_expr *tmp;
 	  if (c->iterator == NULL)
-	    tmp = f (c->expr, kind);
+	    {
+	      tmp = f (c->expr, kind);
+	      if (tmp == NULL)
+		{
+		  gfc_free_expr (result);
+		  return NULL;
+		}
+
+	      gfc_constructor_append_expr (&result->value.constructor,
+					   tmp, &c->where);
+	    }
 	  else
 	    {
+	      gfc_constructor *n;
 	      g = gfc_convert_constant (c->expr, type, kind);
-	      if (g == &gfc_bad_expr)
+	      if (g == NULL || g == &gfc_bad_expr)
 	        {
 		  gfc_free_expr (result);
 		  return g;
 		}
-	      tmp = g;
-	    }
-
-	  if (tmp == NULL)
-	    {
-	      gfc_free_expr (result);
-	      return NULL;
+	      n = gfc_constructor_get ();
+	      n->expr = g;
+	      n->iterator = gfc_copy_iterator (c->iterator);
+	      n->where = c->where;
+	      gfc_constructor_append (&result->value.constructor, n);
 	    }
-
-	  gfc_constructor_append_expr (&result->value.constructor,
-				       tmp, &c->where);
 	}
 
       break;
diff --git a/gcc/fortran/symbol.c b/gcc/fortran/symbol.c
index ec43e635bf3..44e15d039f4 100644
--- a/gcc/fortran/symbol.c
+++ b/gcc/fortran/symbol.c
@@ -477,7 +477,7 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)
   /* The copying of procedure dummy arguments for module procedures in
      a submodule occur whilst the current state is COMP_CONTAINS. It
      is necessary, therefore, to let this through.  */
-  if (attr->dummy
+  if (name && attr->dummy
       && (attr->function || attr->subroutine)
       && gfc_current_state () == COMP_CONTAINS
       && !(gfc_new_block && gfc_new_block->abr_modproc_decl))
@@ -509,6 +509,7 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)
 
   conf (external, intrinsic);
   conf (entry, intrinsic);
+  conf (abstract, intrinsic);
 
   if ((attr->if_source == IFSRC_DECL && !attr->procedure) || attr->contained)
     conf (external, subroutine);
@@ -1259,6 +1260,20 @@ gfc_add_volatile (symbol_attribute *attr, const char *name, locus *where)
 			 where))
       return false;
 
+  /* F2008:  C1282 A designator of a variable with the VOLATILE attribute
+     shall not appear in a pure subprogram.
+
+     F2018: C1588 A local variable of a pure subprogram, or of a BLOCK
+     construct within a pure subprogram, shall not have the SAVE or
+     VOLATILE attribute.  */
+  if (gfc_pure (NULL))
+    {
+      gfc_error ("VOLATILE attribute at %L cannot be specified in a "
+		 "PURE procedure", where);
+      return false;
+    }
+
+
   attr->volatile_ = 1;
   attr->volatile_ns = gfc_current_ns;
   return check_conflict (attr, name, where);
@@ -1581,7 +1596,15 @@ gfc_add_subroutine (symbol_attribute *attr, const char *name, locus *where)
     return false;
 
   attr->subroutine = 1;
-  return check_conflict (attr, name, where);
+
+  /* If we are looking at a BLOCK DATA statement and we encounter a
+     name with a leading underscore (which must be
+     compiler-generated), do not check. See PR 84394.  */
+
+  if (name && *name != '_' && gfc_current_state () != COMP_BLOCK_DATA)
+    return check_conflict (attr, name, where);
+  else
+    return true;
 }
 
 
@@ -1697,7 +1720,8 @@ gfc_add_procedure (symbol_attribute *attr, procedure_type t,
   if (where == NULL)
     where = &gfc_current_locus;
 
-  if (attr->proc != PROC_UNKNOWN && !attr->module_procedure)
+  if (attr->proc != PROC_UNKNOWN && !attr->module_procedure
+      && attr->access == ACCESS_UNKNOWN)
     {
       if (attr->proc == PROC_ST_FUNCTION && t == PROC_INTERNAL
 	  && !gfc_notification_std (GFC_STD_F2008))
@@ -4159,7 +4183,7 @@ gsym_compare (void *_s1, void *_s2)
 /* Get a global symbol, creating it if it doesn't exist.  */
 
 gfc_gsymbol *
-gfc_get_gsymbol (const char *name)
+gfc_get_gsymbol (const char *name, bool bind_c)
 {
   gfc_gsymbol *s;
 
@@ -4170,6 +4194,7 @@ gfc_get_gsymbol (const char *name)
   s = XCNEW (gfc_gsymbol);
   s->type = GSYM_UNKNOWN;
   s->name = gfc_get_string ("%s", name);
+  s->bind_c = bind_c;
 
   gfc_insert_bbt (&gfc_gsym_root, s, gsym_compare);
 
diff --git a/gcc/fortran/target-memory.c b/gcc/fortran/target-memory.c
index d239cf114e1..f4890aa06c4 100644
--- a/gcc/fortran/target-memory.c
+++ b/gcc/fortran/target-memory.c
@@ -111,6 +111,7 @@ gfc_element_size (gfc_expr *e)
     case BT_CLASS:
     case BT_VOID:
     case BT_ASSUMED:
+    case BT_PROCEDURE:
       {
 	/* Determine type size without clobbering the typespec for ISO C
 	   binding types.  */
diff --git a/gcc/fortran/trans-array.c b/gcc/fortran/trans-array.c
index 96fe8d431a3..668b4591739 100644
--- a/gcc/fortran/trans-array.c
+++ b/gcc/fortran/trans-array.c
@@ -2498,6 +2498,9 @@ gfc_scalar_elemental_arg_saved_as_reference (gfc_ss_info * ss_info)
   if (ss_info->type != GFC_SS_REFERENCE)
     return false;
 
+  if (ss_info->data.scalar.needs_temporary)
+    return false;
+
   /* If the actual argument can be absent (in other words, it can
      be a NULL reference), don't try to evaluate it; pass instead
      the reference directly.  */
@@ -2652,6 +2655,8 @@ gfc_add_loop_ss_code (gfc_loopinfo * loop, gfc_ss * ss, bool subscript,
 	  gfc_init_se (&se, NULL);
 	  se.loop = loop;
 	  se.ss = ss;
+	  if (gfc_is_class_array_function (expr))
+	    expr->must_finalize = 1;
 	  gfc_conv_expr (&se, expr);
 	  gfc_add_block_to_block (&outer_loop->pre, &se.pre);
 	  gfc_add_block_to_block (&outer_loop->post, &se.post);
@@ -3071,7 +3076,7 @@ conv_array_index_offset (gfc_se * se, gfc_ss * ss, int dim, int i,
     }
 
   /* Multiply by the stride.  */
-  if (!integer_onep (stride))
+  if (stride != NULL && !integer_onep (stride))
     index = fold_build2_loc (input_location, MULT_EXPR, gfc_array_index_type,
 			     index, stride);
 
@@ -3102,7 +3107,7 @@ build_class_array_ref (gfc_se *se, tree base, tree index)
     {
       if (expr == NULL
 	  || (expr->ts.type != BT_CLASS
-	      && !gfc_is_alloc_class_array_function (expr)
+	      && !gfc_is_class_array_function (expr)
 	      && !gfc_is_class_array_ref (expr, NULL)))
 	return false;
 
@@ -3132,12 +3137,12 @@ build_class_array_ref (gfc_se *se, tree base, tree index)
     }
 
   if (class_ref == NULL && expr && expr->symtree->n.sym->attr.function
-      && expr->symtree->n.sym == expr->symtree->n.sym->result)
+      && expr->symtree->n.sym == expr->symtree->n.sym->result
+      && expr->symtree->n.sym->backend_decl == current_function_decl)
     {
-      gcc_assert (expr->symtree->n.sym->backend_decl == current_function_decl);
       decl = gfc_get_fake_result_decl (expr->symtree->n.sym, 0);
     }
-  else if (expr && gfc_is_alloc_class_array_function (expr))
+  else if (expr && gfc_is_class_array_function (expr))
     {
       size = NULL_TREE;
       decl = NULL_TREE;
@@ -3160,6 +3165,8 @@ build_class_array_ref (gfc_se *se, tree base, tree index)
 
       if (decl == NULL_TREE)
 	return false;
+
+      se->class_vptr = gfc_evaluate_now (gfc_class_vptr_get (decl), &se->pre);
     }
   else if (class_ref == NULL)
     {
@@ -3334,7 +3341,10 @@ build_array_ref (tree desc, tree offset, tree decl, tree vptr)
     {
       type = gfc_get_element_type (type);
       tmp = TREE_OPERAND (cdecl, 0);
-      tmp = gfc_get_class_array_ref (offset, tmp, NULL_TREE);
+      /* Note that the fourth argument in this call has been set false.
+	 should any character dynamic types come this way, the 'len'
+	 field of the unlimited object will not be used.  */
+      tmp = gfc_get_class_array_ref (offset, tmp, NULL_TREE, false);
       tmp = fold_convert (build_pointer_type (type), tmp);
       tmp = build_fold_indirect_ref_loc (input_location, tmp);
       return tmp;
@@ -5475,6 +5485,7 @@ gfc_array_allocate (gfc_se * se, gfc_expr * expr, tree status, tree errmsg,
   tree var_overflow = NULL_TREE;
   tree cond;
   tree set_descriptor;
+  tree not_prev_allocated = NULL_TREE;
   stmtblock_t set_descriptor_block;
   stmtblock_t elseblock;
   gfc_expr **lower;
@@ -5612,8 +5623,6 @@ gfc_array_allocate (gfc_se * se, gfc_expr * expr, tree status, tree errmsg,
 	}
     }
 
-  gfc_start_block (&elseblock);
-
   /* Allocate memory to store the data.  */
   if (POINTER_TYPE_P (TREE_TYPE (se->expr)))
     se->expr = build_fold_indirect_ref_loc (input_location, se->expr);
@@ -5629,6 +5638,19 @@ gfc_array_allocate (gfc_se * se, gfc_expr * expr, tree status, tree errmsg,
     pointer = gfc_conv_descriptor_data_get (se->expr);
   STRIP_NOPS (pointer);
 
+  if (allocatable)
+    {
+      not_prev_allocated = gfc_create_var (logical_type_node,
+					   "not_prev_allocated");
+      tmp = fold_build2_loc (input_location, EQ_EXPR,
+			     logical_type_node, pointer,
+			     build_int_cst (TREE_TYPE (pointer), 0));
+
+      gfc_add_modify (&se->pre, not_prev_allocated, tmp);
+    }
+
+  gfc_start_block (&elseblock);
+
   /* The allocatable variant takes the old pointer as first argument.  */
   if (allocatable)
     gfc_allocate_allocatable (&elseblock, pointer, size, token,
@@ -5665,6 +5687,11 @@ gfc_array_allocate (gfc_se * se, gfc_expr * expr, tree status, tree errmsg,
       cond = fold_build2_loc (input_location, EQ_EXPR,
 			  logical_type_node, status,
 			  build_int_cst (TREE_TYPE (status), 0));
+
+      if (not_prev_allocated != NULL_TREE)
+	cond = fold_build2_loc (input_location, TRUTH_OR_EXPR,
+				logical_type_node, cond, not_prev_allocated);
+
       gfc_add_expr_to_block (&se->pre,
 		 fold_build3_loc (input_location, COND_EXPR, void_type_node,
 				  cond,
@@ -7125,7 +7152,11 @@ gfc_conv_expr_descriptor (gfc_se *se, gfc_expr *expr)
       else
 	{
 	  /* Otherwise make a new one.  */
-	  parmtype = gfc_get_element_type (TREE_TYPE (desc));
+	  if (expr->ts.type == BT_CHARACTER && expr->ts.deferred)
+	    parmtype = gfc_typenode_for_spec (&expr->ts);
+	  else
+	    parmtype = gfc_get_element_type (TREE_TYPE (desc));
+
 	  parmtype = gfc_get_array_type_bounds (parmtype, loop.dimen, codim,
 						loop.from, loop.to, 0,
 						GFC_ARRAY_UNKNOWN, false);
@@ -8598,7 +8629,7 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,
 	  break;
 
 	case COPY_ALLOC_COMP:
-	  if (c->attr.pointer)
+	  if (c->attr.pointer || c->attr.proc_pointer)
 	    continue;
 
 	  /* We need source and destination components.  */
@@ -8642,6 +8673,31 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,
 
 	      gfc_init_block (&tmpblock);
 
+	      gfc_add_modify (&tmpblock, gfc_class_vptr_get (dcmp),
+			      gfc_class_vptr_get (comp));
+
+	      /* Copy the unlimited '_len' field. If it is greater than zero
+		 (ie. a character(_len)), multiply it by size and use this
+		 for the malloc call.  */
+	      if (UNLIMITED_POLY (c))
+		{
+		  tree ctmp;
+		  gfc_add_modify (&tmpblock, gfc_class_len_get (dcmp),
+				  gfc_class_len_get (comp));
+
+		  size = gfc_evaluate_now (size, &tmpblock);
+		  tmp = gfc_class_len_get (comp);
+		  ctmp = fold_build2_loc (input_location, MULT_EXPR,
+					  size_type_node, size,
+					  fold_convert (size_type_node, tmp));
+		  tmp = fold_build2_loc (input_location, GT_EXPR,
+					 logical_type_node, tmp,
+					 build_zero_cst (TREE_TYPE (tmp)));
+		  size = fold_build3_loc (input_location, COND_EXPR,
+					  size_type_node, tmp, ctmp, size);
+		  size = gfc_evaluate_now (size, &tmpblock);
+		}
+
 	      /* Coarray component have to have the same allocation status and
 		 shape/type-parameter/effective-type on the LHS and RHS of an
 		 intrinsic assignment. Hence, we did not deallocated them - and
@@ -9096,6 +9152,12 @@ gfc_alloc_allocatable_for_assignment (gfc_loopinfo *loop,
   if (expr2 && rss == gfc_ss_terminator)
     return NULL_TREE;
 
+  /* Ensure that the string length from the current scope is used.  */
+  if (expr2->ts.type == BT_CHARACTER
+      && expr2->expr_type == EXPR_FUNCTION
+      && !expr2->value.function.isym)
+    expr2->ts.u.cl->backend_decl = rss->info->string_length;
+
   gfc_start_block (&fblock);
 
   /* Since the lhs is allocatable, this must be a descriptor type.
@@ -9340,6 +9402,8 @@ gfc_alloc_allocatable_for_assignment (gfc_loopinfo *loop,
 			     gfc_array_index_type, tmp,
 			     expr1->ts.u.cl->backend_decl);
     }
+  else if (UNLIMITED_POLY (expr1) && expr2->ts.type != BT_CLASS)
+    tmp = TYPE_SIZE_UNIT (gfc_typenode_for_spec (&expr2->ts));
   else
     tmp = TYPE_SIZE_UNIT (gfc_typenode_for_spec (&expr1->ts));
   tmp = fold_convert (gfc_array_index_type, tmp);
@@ -9366,6 +9430,28 @@ gfc_alloc_allocatable_for_assignment (gfc_loopinfo *loop,
       gfc_add_modify (&fblock, tmp,
 		      gfc_get_dtype_rank_type (expr1->rank,type));
     }
+  else if (UNLIMITED_POLY (expr1) && expr2->ts.type != BT_CLASS)
+    {
+      tree type;
+      tmp = gfc_conv_descriptor_dtype (desc);
+      type = gfc_typenode_for_spec (&expr2->ts);
+      gfc_add_modify (&fblock, tmp,
+		      gfc_get_dtype_rank_type (expr2->rank,type));
+      /* Set the _len field as well...  */
+      tmp = gfc_class_len_get (TREE_OPERAND (desc, 0));
+      if (expr2->ts.type == BT_CHARACTER)
+	gfc_add_modify (&fblock, tmp,
+			fold_convert (TREE_TYPE (tmp),
+				      TYPE_SIZE_UNIT (type)));
+      else
+	gfc_add_modify (&fblock, tmp,
+			build_int_cst (TREE_TYPE (tmp), 0));
+      /* ...and the vptr.  */
+      tmp = gfc_class_vptr_get (TREE_OPERAND (desc, 0));
+      tmp2 = gfc_get_symbol_decl (gfc_find_vtab (&expr2->ts));
+      tmp2 = gfc_build_addr_expr (TREE_TYPE (tmp), tmp2);
+      gfc_add_modify (&fblock, tmp, tmp2);
+    }
   else if (coarray && GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (desc)))
     {
       gfc_add_modify (&fblock, gfc_conv_descriptor_dtype (desc),
@@ -9471,10 +9557,11 @@ gfc_alloc_allocatable_for_assignment (gfc_loopinfo *loop,
 
 
   /* We already set the dtype in the case of deferred character
-     length arrays.  */
+     length arrays and unlimited polymorphic arrays.  */
   if (!(GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (desc))
 	&& ((expr1->ts.type == BT_CHARACTER && expr1->ts.deferred)
-	    || coarray)))
+	    || coarray))
+      && !UNLIMITED_POLY (expr1))
     {
       tmp = gfc_conv_descriptor_dtype (desc);
       gfc_add_modify (&alloc_block, tmp, gfc_get_dtype (TREE_TYPE (desc)));
@@ -9688,6 +9775,8 @@ gfc_walk_variable_expr (gfc_ss * ss, gfc_expr * expr)
 {
   gfc_ref *ref;
 
+  gfc_fix_class_refs (expr);
+
   for (ref = expr->ref; ref; ref = ref->next)
     if (ref->type == REF_ARRAY && ref->u.ar.type != AR_ELEMENT)
       break;
@@ -10007,7 +10096,7 @@ gfc_walk_function_expr (gfc_ss * ss, gfc_expr * expr)
   if (!sym)
     sym = expr->symtree->n.sym;
 
-  if (gfc_is_alloc_class_array_function (expr))
+  if (gfc_is_class_array_function (expr))
     return gfc_get_array_ss (ss, expr,
 			     CLASS_DATA (expr->value.function.esym->result)->as->rank,
 			     GFC_SS_FUNCTION);
diff --git a/gcc/fortran/trans-decl.c b/gcc/fortran/trans-decl.c
index 5f2f76b7cbe..e403936dff0 100644
--- a/gcc/fortran/trans-decl.c
+++ b/gcc/fortran/trans-decl.c
@@ -603,10 +603,12 @@ gfc_finish_var_decl (tree decl, gfc_symbol * sym)
      function scope.  */
   if (current_function_decl != NULL_TREE)
     {
-      if (sym->ns->proc_name->backend_decl == current_function_decl
-	  || sym->result == sym)
+      if (sym->ns->proc_name
+	  && (sym->ns->proc_name->backend_decl == current_function_decl
+	      || sym->result == sym))
 	gfc_add_decl_to_function (decl);
-      else if (sym->ns->proc_name->attr.flavor == FL_LABEL)
+      else if (sym->ns->proc_name
+	       && sym->ns->proc_name->attr.flavor == FL_LABEL)
 	/* This is a BLOCK construct.  */
 	add_decl_as_local (decl);
       else
@@ -698,7 +700,8 @@ gfc_finish_var_decl (tree decl, gfc_symbol * sym)
     }
 
   /* Keep variables larger than max-stack-var-size off stack.  */
-  if (!sym->ns->proc_name->attr.recursive && !sym->attr.automatic
+  if (!(sym->ns->proc_name && sym->ns->proc_name->attr.recursive)
+      && !sym->attr.automatic
       && INTEGER_CST_P (DECL_SIZE_UNIT (decl))
       && !gfc_can_put_var_on_stack (DECL_SIZE_UNIT (decl))
 	 /* Put variable length auto array pointers always into stack.  */
@@ -828,7 +831,7 @@ gfc_get_module_backend_decl (gfc_symbol *sym)
 	{
 	  if (!gsym)
 	    {
-	      gsym = gfc_get_gsymbol (sym->module);
+	      gsym = gfc_get_gsymbol (sym->module, false);
 	      gsym->type = GSYM_MODULE;
 	      gsym->ns = gfc_get_namespace (NULL, 0);
 	    }
@@ -1652,7 +1655,9 @@ gfc_get_symbol_decl (gfc_symbol * sym)
     {
       /* Catch functions. Only used for actual parameters,
 	 procedure pointers and procptr initialization targets.  */
-      if (sym->attr.use_assoc || sym->attr.intrinsic
+      if (sym->attr.use_assoc
+	  || sym->attr.used_in_submodule
+	  || sym->attr.intrinsic
 	  || sym->attr.if_source != IFSRC_DECL)
 	{
 	  decl = gfc_get_extern_function_decl (sym);
@@ -1931,7 +1936,7 @@ get_proc_pointer_decl (gfc_symbol *sym)
 /* Get a basic decl for an external function.  */
 
 tree
-gfc_get_extern_function_decl (gfc_symbol * sym)
+gfc_get_extern_function_decl (gfc_symbol * sym, gfc_actual_arglist *actual_args)
 {
   tree type;
   tree fndecl;
@@ -1956,9 +1961,22 @@ gfc_get_extern_function_decl (gfc_symbol * sym)
     return get_proc_pointer_decl (sym);
 
   /* See if this is an external procedure from the same file.  If so,
-     return the backend_decl.  */
-  gsym =  gfc_find_gsymbol (gfc_gsym_root, sym->binding_label
-					   ? sym->binding_label : sym->name);
+     return the backend_decl.  If we are looking at a BIND(C)
+     procedure and the symbol is not BIND(C), or vice versa, we
+     haven't found the right procedure.  */
+
+  if (sym->binding_label)
+    {
+      gsym = gfc_find_gsymbol (gfc_gsym_root, sym->binding_label);
+      if (gsym && !gsym->bind_c)
+	gsym = NULL;
+    }
+  else
+    {
+      gsym = gfc_find_gsymbol (gfc_gsym_root, sym->name);
+      if (gsym && gsym->bind_c)
+	gsym = NULL;
+    }
 
   if (gsym && !gsym->defined)
     gsym = NULL;
@@ -2104,7 +2122,7 @@ module_sym:
       mangled_name = gfc_sym_mangled_function_id (sym);
     }
 
-  type = gfc_get_function_type (sym);
+  type = gfc_get_function_type (sym, actual_args);
   fndecl = build_decl (input_location,
 		       FUNCTION_DECL, name, type);
 
@@ -4142,6 +4160,24 @@ gfc_null_and_pass_deferred_len (gfc_symbol *sym, stmtblock_t *init,
   return tmp;
 }
 
+
+/* Get the result expression for a procedure.  */
+
+static tree
+get_proc_result (gfc_symbol* sym)
+{
+  if (sym->attr.subroutine || sym == sym->result)
+    {
+      if (current_fake_result_decl != NULL)
+	return TREE_VALUE (current_fake_result_decl);
+
+      return NULL_TREE;
+    }
+
+  return sym->result->backend_decl;
+}
+
+
 /* Generate function entry and exit code, and add it to the function body.
    This includes:
     Allocation and initialization of array variables.
@@ -4251,6 +4287,21 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, gfc_wrapped_block * block)
       else
 	gcc_assert (flag_f2c && proc_sym->ts.type == BT_COMPLEX);
     }
+  else if (proc_sym == proc_sym->result && IS_CLASS_ARRAY (proc_sym))
+    {
+      /* Nullify explicit return class arrays on entry.  */
+      tree type;
+      tmp = get_proc_result (proc_sym);
+	if (tmp && GFC_CLASS_TYPE_P (TREE_TYPE (tmp)))
+	  {
+	    gfc_start_block (&init);
+	    tmp = gfc_class_data_get (tmp);
+	    type = TREE_TYPE (gfc_conv_descriptor_data_get (tmp));
+	    gfc_conv_descriptor_data_set (&init, tmp, build_int_cst (type, 0));
+	    gfc_add_init_cleanup (block, gfc_finish_block (&init), NULL_TREE);
+	  }
+    }
+
 
   /* Initialize the INTENT(OUT) derived type dummy arguments.  This
      should be done here so that the offsets and lbounds of arrays
@@ -5184,6 +5235,33 @@ generate_coarray_sym_init (gfc_symbol *sym)
   /* Handle "static" initializer.  */
   if (sym->value)
     {
+      if (sym->value->expr_type == EXPR_ARRAY)
+	{
+	  gfc_constructor *c, *cnext;
+
+	  /* Test if the array has more than one element.  */
+	  c = gfc_constructor_first (sym->value->value.constructor);
+	  gcc_assert (c);  /* Empty constructor should not happen here.  */
+	  cnext = gfc_constructor_next (c);
+
+	  if (cnext)
+	    {
+	      /* An EXPR_ARRAY with a rank > 1 here has to come from a
+		 DATA statement.  Set its rank here as not to confuse
+		 the following steps.   */
+	      sym->value->rank = 1;
+	    }
+	  else
+	    {
+	      /* There is only a single value in the constructor, use
+		 it directly for the assignment.  */
+	      gfc_expr *new_expr;
+	      new_expr = gfc_copy_expr (c->expr);
+	      gfc_free_expr (sym->value);
+	      sym->value = new_expr;
+	    }
+	}
+
       sym->attr.pointer = 1;
       tmp = gfc_trans_assignment (gfc_lval_expr_from_sym (sym), sym->value,
 				  true, false);
@@ -5981,23 +6059,6 @@ create_main_function (tree fndecl)
 }
 
 
-/* Get the result expression for a procedure.  */
-
-static tree
-get_proc_result (gfc_symbol* sym)
-{
-  if (sym->attr.subroutine || sym == sym->result)
-    {
-      if (current_fake_result_decl != NULL)
-	return TREE_VALUE (current_fake_result_decl);
-
-      return NULL_TREE;
-    }
-
-  return sym->result->backend_decl;
-}
-
-
 /* Generate an appropriate return-statement for a procedure.  */
 
 tree
diff --git a/gcc/fortran/trans-expr.c b/gcc/fortran/trans-expr.c
index b022704e7fd..1bcc43c5546 100644
--- a/gcc/fortran/trans-expr.c
+++ b/gcc/fortran/trans-expr.c
@@ -391,7 +391,7 @@ gfc_find_and_cut_at_last_class_ref (gfc_expr *e)
       e->ref = NULL;
     }
 
-  base_expr = gfc_expr_to_initialize (e);
+  base_expr = gfc_copy_expr (e);
 
   /* Restore the original tail expression.  */
   if (class_ref)
@@ -960,6 +960,7 @@ gfc_conv_class_to_class (gfc_se *parmse, gfc_expr *e, gfc_typespec class_ts,
     }
 
   if ((ref == NULL || class_ref == ref)
+      && !(gfc_is_class_array_function (e) && parmse->class_vptr != NULL_TREE)
       && (!class_ts.u.derived->components->as
 	  || class_ts.u.derived->components->as->rank != -1))
     return;
@@ -1030,8 +1031,11 @@ gfc_conv_class_to_class (gfc_se *parmse, gfc_expr *e, gfc_typespec class_ts,
      First we have to find the corresponding class reference.  */
 
   tmp = NULL_TREE;
-  if (class_ref == NULL
-	&& e->symtree && e->symtree->n.sym->ts.type == BT_CLASS)
+  if (gfc_is_class_array_function (e)
+      && parmse->class_vptr != NULL_TREE)
+    tmp = parmse->class_vptr;
+  else if (class_ref == NULL
+	   && e->symtree && e->symtree->n.sym->ts.type == BT_CLASS)
     {
       tmp = e->symtree->n.sym->backend_decl;
 
@@ -1063,7 +1067,11 @@ gfc_conv_class_to_class (gfc_se *parmse, gfc_expr *e, gfc_typespec class_ts,
   if (TREE_CODE (TREE_TYPE (tmp)) == REFERENCE_TYPE)
     tmp = build_fold_indirect_ref_loc (input_location, tmp);
 
-  vptr = gfc_class_vptr_get (tmp);
+  if (!(gfc_is_class_array_function (e) && parmse->class_vptr))
+    vptr = gfc_class_vptr_get (tmp);
+  else
+    vptr = tmp;
+
   gfc_add_modify (&block, ctree,
 		  fold_convert (TREE_TYPE (ctree), vptr));
 
@@ -1148,15 +1156,32 @@ gfc_conv_class_to_class (gfc_se *parmse, gfc_expr *e, gfc_typespec class_ts,
    of the referenced element.  */
 
 tree
-gfc_get_class_array_ref (tree index, tree class_decl, tree data_comp)
+gfc_get_class_array_ref (tree index, tree class_decl, tree data_comp,
+			 bool unlimited)
 {
-  tree data = data_comp != NULL_TREE ? data_comp :
-				       gfc_class_data_get (class_decl);
-  tree size = gfc_class_vtab_size_get (class_decl);
-  tree offset = fold_build2_loc (input_location, MULT_EXPR,
-				 gfc_array_index_type,
-				 index, size);
-  tree ptr;
+  tree data, size, tmp, ctmp, offset, ptr;
+
+  data = data_comp != NULL_TREE ? data_comp :
+				  gfc_class_data_get (class_decl);
+  size = gfc_class_vtab_size_get (class_decl);
+
+  if (unlimited)
+    {
+      tmp = fold_convert (gfc_array_index_type,
+			  gfc_class_len_get (class_decl));
+      ctmp = fold_build2_loc (input_location, MULT_EXPR,
+			      gfc_array_index_type, size, tmp);
+      tmp = fold_build2_loc (input_location, GT_EXPR,
+			     logical_type_node, tmp,
+			     build_zero_cst (TREE_TYPE (tmp)));
+      size = fold_build3_loc (input_location, COND_EXPR,
+			      gfc_array_index_type, tmp, ctmp, size);
+    }
+
+  offset = fold_build2_loc (input_location, MULT_EXPR,
+			    gfc_array_index_type,
+			    index, size);
+
   data = gfc_conv_descriptor_data_get (data);
   ptr = fold_convert (pvoid_type_node, data);
   ptr = fold_build_pointer_plus_loc (input_location, ptr, offset);
@@ -1258,14 +1283,15 @@ gfc_copy_class_to_class (tree from, tree to, tree nelems, bool unlimited)
 
       if (is_from_desc)
 	{
-	  from_ref = gfc_get_class_array_ref (index, from, from_data);
+	  from_ref = gfc_get_class_array_ref (index, from, from_data,
+					      unlimited);
 	  vec_safe_push (args, from_ref);
 	}
       else
         vec_safe_push (args, from_data);
 
       if (is_to_class)
-	to_ref = gfc_get_class_array_ref (index, to, to_data);
+	to_ref = gfc_get_class_array_ref (index, to, to_data, unlimited);
       else
 	{
 	  tmp = gfc_conv_array_data (to);
@@ -1450,7 +1476,6 @@ gfc_trans_class_init_assign (gfc_code *code)
   gfc_start_block (&block);
 
   lhs = gfc_copy_expr (code->expr1);
-  gfc_add_data_component (lhs);
 
   rhs = gfc_copy_expr (code->expr1);
   gfc_add_vptr_component (rhs);
@@ -1468,11 +1493,15 @@ gfc_trans_class_init_assign (gfc_code *code)
     {
       gfc_array_spec *tmparr = gfc_get_array_spec ();
       *tmparr = *CLASS_DATA (code->expr1)->as;
+      /* Adding the array ref to the class expression results in correct
+	 indexing to the dynamic type.  */
       gfc_add_full_array_ref (lhs, tmparr);
       tmp = gfc_trans_class_array_init_assign (rhs, lhs, code->expr1);
     }
   else
     {
+      /* Scalar initialization needs the _data component.  */
+      gfc_add_data_component (lhs);
       sz = gfc_copy_expr (code->expr1);
       gfc_add_vptr_component (sz);
       gfc_add_size_component (sz);
@@ -2958,6 +2987,83 @@ gfc_conv_power_op (gfc_se * se, gfc_expr * expr)
     if (gfc_conv_cst_int_power (se, lse.expr, rse.expr))
       return;
 
+  if (INTEGER_CST_P (lse.expr)
+      && TREE_CODE (TREE_TYPE (rse.expr)) == INTEGER_TYPE)
+    {
+      wide_int wlhs = lse.expr;
+      HOST_WIDE_INT v;
+      v = wlhs.to_shwi ();
+      if (v == 1)
+	{
+	  /* 1**something is always 1.  */
+	  se->expr = build_int_cst (TREE_TYPE (lse.expr), 1);
+	  return;
+	}
+      else if (v == 2 || v == 4 || v == 8 || v == 16)
+	{
+	  /* 2**n = 1<<n, 4**n = 1<<(n+n), 8**n = 1 <<(3*n), 16**n =
+	   1<<(4*n), but we have to make sure to return zero if the
+	   number of bits is too large. */
+	  tree lshift;
+	  tree type;
+	  tree shift;
+	  tree ge;
+	  tree cond;
+	  tree num_bits;
+	  tree cond2;
+
+	  type = TREE_TYPE (lse.expr);
+
+	  if (v == 2)
+	    shift = rse.expr;
+	  else if (v == 4)
+	    shift = fold_build2_loc (input_location, PLUS_EXPR,
+				     TREE_TYPE (rse.expr),
+				       rse.expr, rse.expr);
+	  else if (v == 8)
+	    shift = fold_build2_loc (input_location, MULT_EXPR,
+				     TREE_TYPE (rse.expr),
+				     build_int_cst (TREE_TYPE (rse.expr), 3),
+				     rse.expr);
+	  else if (v == 16)
+	    shift = fold_build2_loc (input_location, MULT_EXPR,
+				     TREE_TYPE (rse.expr),
+				     build_int_cst (TREE_TYPE (rse.expr), 4),
+				     rse.expr);
+	  else
+	    gcc_unreachable ();
+
+	  lshift = fold_build2_loc (input_location, LSHIFT_EXPR, type,
+				    build_int_cst (type, 1), shift);
+	  ge = fold_build2_loc (input_location, GE_EXPR, logical_type_node,
+				rse.expr, build_int_cst (type, 0));
+	  cond = fold_build3_loc (input_location, COND_EXPR, type, ge, lshift,
+				 build_int_cst (type, 0));
+	  num_bits = build_int_cst (TREE_TYPE (rse.expr), TYPE_PRECISION (type));
+	  cond2 = fold_build2_loc (input_location, GE_EXPR, logical_type_node,
+				   rse.expr, num_bits);
+	  se->expr = fold_build3_loc (input_location, COND_EXPR, type, cond2,
+				      build_int_cst (type, 0), cond);
+	  return;
+	}
+      else if (v == -1)
+	{
+	  /* (-1)**n is 1 - ((n & 1) << 1) */
+	  tree type;
+	  tree tmp;
+
+	  type = TREE_TYPE (lse.expr);
+	  tmp = fold_build2_loc (input_location, BIT_AND_EXPR, type,
+				 rse.expr, build_int_cst (type, 1));
+	  tmp = fold_build2_loc (input_location, LSHIFT_EXPR, type,
+				 tmp, build_int_cst (type, 1));
+	  tmp = fold_build2_loc (input_location, MINUS_EXPR, type,
+				 build_int_cst (type, 1), tmp);
+	  se->expr = tmp;
+	  return;
+	}
+    }
+
   gfc_int4_type_node = gfc_get_int_type (4);
 
   /* In case of integer operands with kinds 1 or 2, we call the integer kind 4
@@ -3693,7 +3799,8 @@ conv_base_obj_fcn_val (gfc_se * se, tree base_object, gfc_expr * expr)
 
 
 static void
-conv_function_val (gfc_se * se, gfc_symbol * sym, gfc_expr * expr)
+conv_function_val (gfc_se * se, gfc_symbol * sym, gfc_expr * expr,
+		   gfc_actual_arglist *actual_args)
 {
   tree tmp;
 
@@ -3711,7 +3818,7 @@ conv_function_val (gfc_se * se, gfc_symbol * sym, gfc_expr * expr)
   else
     {
       if (!sym->backend_decl)
-	sym->backend_decl = gfc_get_extern_function_decl (sym);
+	sym->backend_decl = gfc_get_extern_function_decl (sym, actual_args);
 
       TREE_USED (sym->backend_decl) = 1;
 
@@ -4307,6 +4414,8 @@ gfc_apply_interface_mapping_to_expr (gfc_interface_mapping * mapping,
 
       if (expr->value.function.esym == NULL
 	    && expr->value.function.isym != NULL
+	    && expr->value.function.actual
+	    && expr->value.function.actual->expr
 	    && expr->value.function.actual->expr->symtree
 	    && gfc_map_intrinsic_function (expr, mapping))
 	break;
@@ -4435,7 +4544,7 @@ gfc_conv_subref_array_arg (gfc_se * parmse, gfc_expr * expr, int g77,
   /* Reset the offset for the function call since the loop
      is zero based on the data pointer.  Note that the temp
      comes first in the loop chain since it is added second.  */
-  if (gfc_is_alloc_class_array_function (expr))
+  if (gfc_is_class_array_function (expr))
     {
       tmp = loop.ss->loop_chain->info->data.array.descriptor;
       gfc_conv_descriptor_offset_set (&loop.pre, tmp,
@@ -4484,7 +4593,7 @@ gfc_conv_subref_array_arg (gfc_se * parmse, gfc_expr * expr, int g77,
   dimen = rse.ss->dimen;
 
   /* Skip the write-out loop for this case.  */
-  if (gfc_is_alloc_class_array_function (expr))
+  if (gfc_is_class_array_function (expr))
     goto class_array_fcn;
 
   /* Calculate the bounds of the scalarization.  */
@@ -4778,7 +4887,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,
 	      gcc_assert ((!comp && gfc_return_by_reference (sym)
 			   && sym->result->attr.dimension)
 			  || (comp && comp->attr.dimension)
-			  || gfc_is_alloc_class_array_function (expr));
+			  || gfc_is_class_array_function (expr));
 	      gcc_assert (se->loop != NULL);
 	      /* Access the previously obtained result.  */
 	      gfc_conv_tmp_array_ref (se);
@@ -5461,7 +5570,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,
 				fsym ? fsym->attr.intent : INTENT_INOUT,
 				fsym && fsym->attr.pointer);
 
-	      else if (gfc_is_alloc_class_array_function (e)
+	      else if (gfc_is_class_array_function (e)
 			 && fsym && fsym->ts.type == BT_DERIVED)
 		/* See previous comment.  For function actual argument,
 		   the write out is not needed so the intent is set as
@@ -5604,6 +5713,16 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,
 	      break;
 	    }
 
+	  if (e->ts.type == BT_DERIVED && fsym && fsym->ts.type == BT_CLASS)
+	    {
+	      /* The derived type is passed to gfc_deallocate_alloc_comp.
+		 Therefore, class actuals can be handled correctly but derived
+		 types passed to class formals need the _data component.  */
+	      tmp = gfc_class_data_get (tmp);
+	      if (!CLASS_DATA (fsym)->attr.dimension)
+		tmp = build_fold_indirect_ref_loc (input_location, tmp);
+	    }
+
 	  if (e->expr_type == EXPR_OP
 		&& e->value.op.op == INTRINSIC_PARENTHESES
 		&& e->value.op.op1->expr_type == EXPR_VARIABLE)
@@ -5615,16 +5734,6 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,
 	      gfc_add_expr_to_block (&se->post, local_tmp);
 	    }
 
-	  if (e->ts.type == BT_DERIVED && fsym && fsym->ts.type == BT_CLASS)
-	    {
-	      /* The derived type is passed to gfc_deallocate_alloc_comp.
-		 Therefore, class actuals can handled correctly but derived
-		 types passed to class formals need the _data component.  */
-	      tmp = gfc_class_data_get (tmp);
-	      if (!CLASS_DATA (fsym)->attr.dimension)
-		tmp = build_fold_indirect_ref_loc (input_location, tmp);
-	    }
-
 	  tmp = gfc_deallocate_alloc_comp (e->ts.u.derived, tmp, parm_rank);
 
 	  gfc_prepend_expr_to_block (&post, tmp);
@@ -6130,7 +6239,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,
 
   /* Generate the actual call.  */
   if (base_object == NULL_TREE)
-    conv_function_val (se, sym, expr);
+    conv_function_val (se, sym, expr, args);
   else
     conv_base_obj_fcn_val (se, base_object, expr);
 
@@ -6302,7 +6411,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,
 	 call the finalization function of the temporary. Note that the
 	 nullification of allocatable components needed by the result
 	 is done in gfc_trans_assignment_1.  */
-      if (expr && ((gfc_is_alloc_class_array_function (expr)
+      if (expr && ((gfc_is_class_array_function (expr)
 		    && se->ss && se->ss->loop)
 		   || gfc_is_alloc_class_scalar_function (expr))
 	  && se->expr && GFC_CLASS_TYPE_P (TREE_TYPE (se->expr))
@@ -6313,6 +6422,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,
 	  int n;
 	  if (se->ss && se->ss->loop)
 	    {
+	      gfc_add_block_to_block (&se->ss->loop->pre, &se->pre);
 	      se->expr = gfc_evaluate_now (se->expr, &se->ss->loop->pre);
 	      tmp = gfc_class_data_get (se->expr);
 	      info->descriptor = tmp;
@@ -6335,6 +6445,11 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,
 			CLASS_DATA (expr->value.function.esym->result)->attr);
 	    }
 
+	  if ((gfc_is_class_array_function (expr)
+	       || gfc_is_alloc_class_scalar_function (expr))
+	      && CLASS_DATA (expr->value.function.esym->result)->attr.pointer)
+	    goto no_finalization;
+
 	  final_fndecl = gfc_class_vtab_final_get (se->expr);
 	  is_final = fold_build2_loc (input_location, NE_EXPR,
 				      logical_type_node,
@@ -6365,6 +6480,8 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,
 	      tmp = gfc_call_free (tmp);
 	      gfc_add_expr_to_block (&se->post, tmp);
 	    }
+
+no_finalization:
 	  expr->must_finalize = 0;
 	}
 
@@ -8835,7 +8952,7 @@ gfc_trans_scalar_assign (gfc_se * lse, gfc_se * rse, gfc_typespec ts,
 	  gfc_add_expr_to_block (&block, tmp);
 	}
     }
-  else if (gfc_bt_struct (ts.type) || ts.type == BT_CLASS)
+  else if (gfc_bt_struct (ts.type) || ts.type == BT_CLASS || ts.type == BT_COMPLEX)
     {
       gfc_add_block_to_block (&block, &lse->pre);
       gfc_add_block_to_block (&block, &rse->pre);
@@ -8871,7 +8988,7 @@ arrayfunc_assign_needs_temporary (gfc_expr * expr1, gfc_expr * expr2)
   gfc_symbol *sym = expr1->symtree->n.sym;
 
   /* Play it safe with class functions assigned to a derived type.  */
-  if (gfc_is_alloc_class_array_function (expr2)
+  if (gfc_is_class_array_function (expr2)
       && expr1->ts.type == BT_DERIVED)
     return true;
 
@@ -9878,7 +9995,7 @@ gfc_trans_assignment_1 (gfc_expr * expr1, gfc_expr * expr2, bool init_flag,
   rss = NULL;
 
   if ((expr1->ts.type == BT_DERIVED)
-      && (gfc_is_alloc_class_array_function (expr2)
+      && (gfc_is_class_array_function (expr2)
 	  || gfc_is_alloc_class_scalar_function (expr2)))
     expr2->must_finalize = 1;
 
@@ -10085,7 +10202,7 @@ gfc_trans_assignment_1 (gfc_expr * expr1, gfc_expr * expr2, bool init_flag,
      a scalar to array assignment, this is done in gfc_trans_scalar_assign
      as part of the deep copy.  */
   if (!scalar_to_array && expr1->ts.type == BT_DERIVED
-		       && (gfc_is_alloc_class_array_function (expr2)
+		       && (gfc_is_class_array_function (expr2)
 			   || gfc_is_alloc_class_scalar_function (expr2)))
     {
       tmp = rse.expr;
@@ -10294,6 +10411,10 @@ gfc_trans_assignment (gfc_expr * expr1, gfc_expr * expr2, bool init_flag,
 	return tmp;
     }
 
+  if (UNLIMITED_POLY (expr1) && expr1->rank
+      && expr2->ts.type != BT_CLASS)
+    use_vptr_copy = true;
+
   /* Fallback to the scalarizer to generate explicit loops.  */
   return gfc_trans_assignment_1 (expr1, expr2, init_flag, dealloc,
 				 use_vptr_copy, may_alias);
diff --git a/gcc/fortran/trans-intrinsic.c b/gcc/fortran/trans-intrinsic.c
index 1ca00c132f2..18cae832c64 100644
--- a/gcc/fortran/trans-intrinsic.c
+++ b/gcc/fortran/trans-intrinsic.c
@@ -1860,7 +1860,7 @@ conv_caf_send (gfc_code *code) {
 
   lhs_expr = code->ext.actual->expr;
   rhs_expr = code->ext.actual->next->expr;
-  may_require_tmp = gfc_check_dependency (lhs_expr, rhs_expr, false) == 0
+  may_require_tmp = gfc_check_dependency (lhs_expr, rhs_expr, true) == 0
 		    ? boolean_false_node : boolean_true_node;
   gfc_init_block (&block);
 
@@ -1906,34 +1906,124 @@ conv_caf_send (gfc_code *code) {
     }
   else
     {
-      /* If has_vector, pass descriptor for whole array and the
-         vector bounds separately.  */
-      gfc_array_ref *ar, ar2;
-      bool has_vector = false;
+      bool has_vector = gfc_has_vector_subscript (lhs_expr);
 
-      if (gfc_is_coindexed (lhs_expr) && gfc_has_vector_subscript (lhs_expr))
+      if (gfc_is_coindexed (lhs_expr) || !has_vector)
 	{
-          has_vector = true;
-          ar = gfc_find_array_ref (lhs_expr);
-	  ar2 = *ar;
-	  memset (ar, '\0', sizeof (*ar));
-	  ar->as = ar2.as;
-	  ar->type = AR_FULL;
+	  /* If has_vector, pass descriptor for whole array and the
+	     vector bounds separately.  */
+	  gfc_array_ref *ar, ar2;
+	  bool has_tmp_lhs_array = false;
+	  if (has_vector)
+	    {
+	      has_tmp_lhs_array = true;
+	      ar = gfc_find_array_ref (lhs_expr);
+	      ar2 = *ar;
+	      memset (ar, '\0', sizeof (*ar));
+	      ar->as = ar2.as;
+	      ar->type = AR_FULL;
+	    }
+	  lhs_se.want_pointer = 1;
+	  gfc_conv_expr_descriptor (&lhs_se, lhs_expr);
+	  /* Using gfc_conv_expr_descriptor, we only get the descriptor, but
+	     that has the wrong type if component references are done.  */
+	  lhs_type = gfc_typenode_for_spec (&lhs_expr->ts);
+	  tmp = build_fold_indirect_ref_loc (input_location, lhs_se.expr);
+	  gfc_add_modify (&lhs_se.pre, gfc_conv_descriptor_dtype (tmp),
+			  gfc_get_dtype_rank_type (has_vector ? ar2.dimen
+							      : lhs_expr->rank,
+						   lhs_type));
+	  if (has_tmp_lhs_array)
+	    {
+	      vec = conv_caf_vector_subscript (&block, lhs_se.expr, &ar2);
+	      *ar = ar2;
+	    }
 	}
-      lhs_se.want_pointer = 1;
-      gfc_conv_expr_descriptor (&lhs_se, lhs_expr);
-      /* Using gfc_conv_expr_descriptor, we only get the descriptor, but that
-         has the wrong type if component references are done.  */
-      lhs_type = gfc_typenode_for_spec (&lhs_expr->ts);
-      tmp = build_fold_indirect_ref_loc (input_location, lhs_se.expr);
-      gfc_add_modify (&lhs_se.pre, gfc_conv_descriptor_dtype (tmp),
-                      gfc_get_dtype_rank_type (has_vector ? ar2.dimen
-							  : lhs_expr->rank,
-		      lhs_type));
-      if (has_vector)
+      else
 	{
-	  vec = conv_caf_vector_subscript (&block, lhs_se.expr, &ar2);
-	  *ar = ar2;
+	  /* Special casing for arr1 ([...]) = arr2[...], i.e. caf_get to
+	     indexed array expression.  This is rewritten to:
+
+	     tmp_array = arr2[...]
+	     arr1 ([...]) = tmp_array
+
+	     because using the standard gfc_conv_expr (lhs_expr) did the
+	     assignment with lhs and rhs exchanged.  */
+
+	  gfc_ss *lss_for_tmparray, *lss_real;
+	  gfc_loopinfo loop;
+	  gfc_se se;
+	  stmtblock_t body;
+	  tree tmparr_desc, src;
+	  tree index = gfc_index_zero_node;
+	  tree stride = gfc_index_zero_node;
+	  int n;
+
+	  /* Walk both sides of the assignment, once to get the shape of the
+	     temporary array to create right.  */
+	  lss_for_tmparray = gfc_walk_expr (lhs_expr);
+	  /* And a second time to be able to create an assignment of the
+	     temporary to the lhs_expr.  gfc_trans_create_temp_array replaces
+	     the tree in the descriptor with the one for the temporary
+	     array.  */
+	  lss_real = gfc_walk_expr (lhs_expr);
+	  gfc_init_loopinfo (&loop);
+	  gfc_add_ss_to_loop (&loop, lss_for_tmparray);
+	  gfc_add_ss_to_loop (&loop, lss_real);
+	  gfc_conv_ss_startstride (&loop);
+	  gfc_conv_loop_setup (&loop, &lhs_expr->where);
+	  lhs_type = gfc_typenode_for_spec (&lhs_expr->ts);
+	  gfc_trans_create_temp_array (&lhs_se.pre, &lhs_se.post,
+				       lss_for_tmparray, lhs_type, NULL_TREE,
+				       false, true, false,
+				       &lhs_expr->where);
+	  tmparr_desc = lss_for_tmparray->info->data.array.descriptor;
+	  gfc_start_scalarized_body (&loop, &body);
+	  gfc_init_se (&se, NULL);
+	  gfc_copy_loopinfo_to_se (&se, &loop);
+	  se.ss = lss_real;
+	  gfc_conv_expr (&se, lhs_expr);
+	  gfc_add_block_to_block (&body, &se.pre);
+
+	  /* Walk over all indexes of the loop.  */
+	  for (n = loop.dimen - 1; n > 0; --n)
+	    {
+	      tmp = loop.loopvar[n];
+	      tmp = fold_build2_loc (input_location, MINUS_EXPR,
+				     gfc_array_index_type, tmp, loop.from[n]);
+	      tmp = fold_build2_loc (input_location, PLUS_EXPR,
+				     gfc_array_index_type, tmp, index);
+
+	      stride = fold_build2_loc (input_location, MINUS_EXPR,
+					gfc_array_index_type,
+					loop.to[n - 1], loop.from[n - 1]);
+	      stride = fold_build2_loc (input_location, PLUS_EXPR,
+					gfc_array_index_type,
+					stride, gfc_index_one_node);
+
+	      index = fold_build2_loc (input_location, MULT_EXPR,
+				       gfc_array_index_type, tmp, stride);
+	    }
+
+	  index = fold_build2_loc (input_location, MINUS_EXPR,
+				   gfc_array_index_type,
+				   index, loop.from[0]);
+
+	  index = fold_build2_loc (input_location, PLUS_EXPR,
+				   gfc_array_index_type,
+				   loop.loopvar[0], index);
+
+	  src = build_fold_indirect_ref (gfc_conv_array_data (tmparr_desc));
+	  src = gfc_build_array_ref (src, index, NULL);
+	  /* Now create the assignment of lhs_expr = tmp_array.  */
+	  gfc_add_modify (&body, se.expr, src);
+	  gfc_add_block_to_block (&body, &se.post);
+	  lhs_se.expr = gfc_build_addr_expr (NULL_TREE, tmparr_desc);
+	  gfc_trans_scalarizing_loops (&loop, &body);
+	  gfc_add_block_to_block (&loop.pre, &loop.post);
+	  gfc_add_expr_to_block (&lhs_se.post, gfc_finish_block (&loop.pre));
+	  gfc_free_ss (lss_for_tmparray);
+	  gfc_free_ss (lss_real);
 	}
     }
 
@@ -5477,6 +5567,22 @@ gfc_conv_intrinsic_ibits (gfc_se * se, gfc_expr * expr)
   se->expr = fold_build2_loc (input_location, BIT_AND_EXPR, type, tmp, mask);
 }
 
+static void
+gfc_conv_intrinsic_shape (gfc_se *se, gfc_expr *expr)
+{
+  gfc_actual_arglist *s, *k;
+  gfc_expr *e;
+
+  /* Remove the KIND argument, if present. */
+  s = expr->value.function.actual;
+  k = s->next;
+  e = k->expr;
+  gfc_free_expr (e);
+  k->expr = NULL;
+
+  gfc_conv_intrinsic_funcall (se, expr);
+}
+
 static void
 gfc_conv_intrinsic_shift (gfc_se * se, gfc_expr * expr, bool right_shift,
 			  bool arithmetic)
@@ -6601,7 +6707,7 @@ gfc_conv_intrinsic_size (gfc_se * se, gfc_expr * expr)
     gfc_add_class_array_ref (actual->expr);
 
   argse.data_not_needed = 1;
-  if (gfc_is_alloc_class_array_function (actual->expr))
+  if (gfc_is_class_array_function (actual->expr))
     {
       /* For functions that return a class array conv_expr_descriptor is not
 	 able to get the descriptor right.  Therefore this special case.  */
@@ -8589,6 +8695,10 @@ gfc_conv_intrinsic_function (gfc_se * se, gfc_expr * expr)
 	      conv_generic_with_optional_char_arg (se, expr, 1, 3);
 	      break;
 
+	    case GFC_ISYM_SHAPE:
+	      gfc_conv_intrinsic_shape (se, expr);
+	      break;
+
 	    default:
 	      gfc_conv_intrinsic_funcall (se, expr);
 	      break;
diff --git a/gcc/fortran/trans-io.c b/gcc/fortran/trans-io.c
index af8ee02494d..ecdecd50f36 100644
--- a/gcc/fortran/trans-io.c
+++ b/gcc/fortran/trans-io.c
@@ -639,12 +639,12 @@ set_parameter_value_inquire (stmtblock_t *block, tree var,
       /* Don't evaluate the UNIT number multiple times.  */
       se.expr = gfc_evaluate_now (se.expr, &se.pre);
 
-      /* UNIT numbers should be greater than zero.  */
+      /* UNIT numbers should be greater than the min.  */
       i = gfc_validate_kind (BT_INTEGER, 4, false);
+      val = gfc_conv_mpz_to_tree (gfc_integer_kinds[i].pedantic_min_int, 4);
       cond1 = build2_loc (input_location, LT_EXPR, logical_type_node,
 			  se.expr,
-			  fold_convert (TREE_TYPE (se.expr),
-			  integer_zero_node));
+			  fold_convert (TREE_TYPE (se.expr), val));
       /* UNIT numbers should be less than the max.  */
       val = gfc_conv_mpz_to_tree (gfc_integer_kinds[i].huge, 4);
       cond2 = build2_loc (input_location, GT_EXPR, logical_type_node,
@@ -2214,25 +2214,9 @@ get_dtio_proc (gfc_typespec * ts, gfc_code * code, gfc_symbol **dtio_sub)
   bool formatted = false;
   gfc_dt *dt = code->ext.dt;
 
-  if (dt)
-    {
-      char *fmt = NULL;
-
-      if (dt->format_label == &format_asterisk)
-	{
-	  /* List directed io must call the formatted DTIO procedure.  */
-	  formatted = true;
-	}
-      else if (dt->format_expr)
-	fmt = gfc_widechar_to_char (dt->format_expr->value.character.string,
-				      -1);
-      else if (dt->format_label)
-	fmt = gfc_widechar_to_char (dt->format_label->format->value.character.string,
-				      -1);
-      if (fmt && strtok (fmt, "DT") != NULL)
-	formatted = true;
-
-    }
+  /* Determine when to use the formatted DTIO procedure.  */
+  if (dt && (dt->format_expr || dt->format_label))
+    formatted = true;
 
   if (ts->type == BT_CLASS)
     derived = ts->u.derived->components->ts.u.derived;
@@ -2293,6 +2277,16 @@ transfer_expr (gfc_se * se, gfc_typespec * ts, tree addr_expr,
       ts->kind = gfc_index_integer_kind;
     }
 
+  /* gfortran reaches here for "print *, c_loc(xxx)".  */
+  if (ts->type == BT_VOID
+      && code->expr1 && code->expr1->ts.type == BT_VOID
+      && code->expr1->symtree
+      && strcmp (code->expr1->symtree->name, "c_loc") == 0)
+    {
+      ts->type = BT_INTEGER;
+      ts->kind = gfc_index_integer_kind;
+    }
+
   kind = ts->kind;
   function = NULL;
   arg2 = NULL;
@@ -2442,8 +2436,7 @@ transfer_expr (gfc_se * se, gfc_typespec * ts, tree addr_expr,
 	    {
 	      /* Recurse into the elements of the derived type.  */
 	      expr = gfc_evaluate_now (addr_expr, &se->pre);
-	      expr = build_fold_indirect_ref_loc (input_location,
-				      expr);
+	      expr = build_fold_indirect_ref_loc (input_location, expr);
 
 	      /* Make sure that the derived type has been built.  An external
 		 function, if only referenced in an io statement, requires this
diff --git a/gcc/fortran/trans-openmp.c b/gcc/fortran/trans-openmp.c
index 4cef0b2be6e..e9a3b46e6e3 100644
--- a/gcc/fortran/trans-openmp.c
+++ b/gcc/fortran/trans-openmp.c
@@ -1949,9 +1949,32 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,
 			  }
 			else
 			  {
-			    tree type = gfc_typenode_for_spec (&n->sym->ts);
-			    OMP_CLAUSE_LINEAR_STEP (node)
-			      = fold_convert (type, last_step);
+			    if (kind == OMP_CLAUSE_LINEAR_REF)
+			      {
+				tree type;
+				if (n->sym->attr.flavor == FL_PROCEDURE)
+				  {
+				    type = gfc_get_function_type (n->sym);
+				    type = build_pointer_type (type);
+				  }
+				else
+				  type = gfc_sym_type (n->sym);
+				if (POINTER_TYPE_P (type))
+				  type = TREE_TYPE (type);
+				/* Otherwise to be determined what exactly
+				   should be done.  */
+				tree t = fold_convert (sizetype, last_step);
+				t = size_binop (MULT_EXPR, t,
+						TYPE_SIZE_UNIT (type));
+				OMP_CLAUSE_LINEAR_STEP (node) = t;
+			      }
+			    else
+			      {
+				tree type
+				  = gfc_typenode_for_spec (&n->sym->ts);
+				OMP_CLAUSE_LINEAR_STEP (node)
+				  = fold_convert (type, last_step);
+			      }
 			  }
 			if (n->sym->attr.dimension || n->sym->attr.allocatable)
 			  OMP_CLAUSE_LINEAR_ARRAY (node) = 1;
diff --git a/gcc/fortran/trans-stmt.c b/gcc/fortran/trans-stmt.c
index 79ec6c2e13b..ac90c97e544 100644
--- a/gcc/fortran/trans-stmt.c
+++ b/gcc/fortran/trans-stmt.c
@@ -1566,7 +1566,8 @@ trans_associate_var (gfc_symbol *sym, gfc_wrapped_block *block)
 
       desc = sym->backend_decl;
       cst_array_ctor = e->expr_type == EXPR_ARRAY
-	      && gfc_constant_array_constructor_p (e->value.constructor);
+	      && gfc_constant_array_constructor_p (e->value.constructor)
+	      && e->ts.type != BT_CHARACTER;
 
       /* If association is to an expression, evaluate it and create temporary.
 	 Otherwise, get descriptor of target for pointer assignment.  */
diff --git a/gcc/fortran/trans-types.c b/gcc/fortran/trans-types.c
index 8c2c8a69cac..a010cf85d30 100644
--- a/gcc/fortran/trans-types.c
+++ b/gcc/fortran/trans-types.c
@@ -1139,7 +1139,8 @@ gfc_typenode_for_spec (gfc_typespec * spec, int codim)
         {
           spec->type = BT_INTEGER;
           spec->kind = gfc_index_integer_kind;
-          spec->f90_type = BT_VOID;
+	  spec->f90_type = BT_VOID;
+	  spec->is_c_interop = 1;  /* Mark as escaping later.  */
         }
       break;
     case BT_VOID:
@@ -1156,6 +1157,9 @@ gfc_typenode_for_spec (gfc_typespec * spec, int codim)
 	    basetype = pfunc_type_node;
 	}
        break;
+    case BT_PROCEDURE:
+      basetype = pfunc_type_node;
+      break;
     default:
       gcc_unreachable ();
     }
@@ -1804,7 +1808,7 @@ gfc_get_array_descriptor_base (int dimen, int codimen, bool restricted)
       TREE_NO_WARNING (decl) = 1;
     }
 
-  if (flag_coarray == GFC_FCOARRAY_LIB && codimen)
+  if (flag_coarray == GFC_FCOARRAY_LIB)
     {
       decl = gfc_add_field_to_struct_1 (fat_type,
 					get_identifier ("token"),
@@ -2168,6 +2172,14 @@ gfc_sym_type (gfc_symbol * sym)
   if (sym->backend_decl && !sym->attr.function)
     return TREE_TYPE (sym->backend_decl);
 
+  if (sym->attr.result
+      && sym->ts.type == BT_CHARACTER
+      && sym->ts.u.cl->backend_decl == NULL_TREE
+      && sym->ns->proc_name
+      && sym->ns->proc_name->ts.u.cl
+      && sym->ns->proc_name->ts.u.cl->backend_decl != NULL_TREE)
+    sym->ts.u.cl->backend_decl = sym->ns->proc_name->ts.u.cl->backend_decl;
+
   if (sym->ts.type == BT_CHARACTER
       && ((sym->attr.function && sym->attr.is_bind_c)
 	  || (sym->attr.result
@@ -2334,6 +2346,7 @@ gfc_copy_dt_decls_ifequal (gfc_symbol *from, gfc_symbol *to,
   for (; to_cm; to_cm = to_cm->next, from_cm = from_cm->next)
     {
       to_cm->backend_decl = from_cm->backend_decl;
+      to_cm->caf_token = from_cm->caf_token;
       if (from_cm->ts.type == BT_UNION)
         gfc_get_union_type (to_cm->ts.u.derived);
       else if (from_cm->ts.type == BT_DERIVED
@@ -2444,6 +2457,10 @@ gfc_get_derived_type (gfc_symbol * derived, int codimen)
   gfc_dt_list *dt;
   gfc_namespace *ns;
   tree tmp;
+  bool coarray_flag;
+
+  coarray_flag = flag_coarray == GFC_FCOARRAY_LIB
+		 && derived->module && !derived->attr.vtype;
 
   if (derived->attr.unlimited_polymorphic
       || (flag_coarray == GFC_FCOARRAY_LIB
@@ -2636,7 +2653,9 @@ gfc_get_derived_type (gfc_symbol * derived, int codimen)
 	  field_type = build_pointer_type (tmp);
 	}
       else if (c->ts.type == BT_DERIVED || c->ts.type == BT_CLASS)
-        field_type = c->ts.u.derived->backend_decl;
+	field_type = c->ts.u.derived->backend_decl;
+      else if (c->attr.caf_token)
+	field_type = pvoid_type_node;
       else
 	{
 	  if (c->ts.type == BT_CHARACTER && !c->ts.deferred)
@@ -2715,19 +2734,6 @@ gfc_get_derived_type (gfc_symbol * derived, int codimen)
       gcc_assert (field);
       if (!c->backend_decl)
 	c->backend_decl = field;
-
-      /* Do not add a caf_token field for classes' data components.  */
-      if (codimen && !c->attr.dimension && !c->attr.codimension
-	  && (c->attr.allocatable || c->attr.pointer)
-	  && c->caf_token == NULL_TREE && strcmp ("_data", c->name) != 0)
-	{
-	  char caf_name[GFC_MAX_SYMBOL_LEN];
-	  snprintf (caf_name, GFC_MAX_SYMBOL_LEN, "_caf_%s", c->name);
-	  c->caf_token = gfc_add_field_to_struct (typenode,
-						  get_identifier (caf_name),
-						  pvoid_type_node, &chain);
-	  TREE_NO_WARNING (c->caf_token) = 1;
-	}
     }
 
   /* Now lay out the derived type, including the fields.  */
@@ -2753,6 +2759,24 @@ gfc_get_derived_type (gfc_symbol * derived, int codimen)
 
 copy_derived_types:
 
+  for (c = derived->components; c; c = c->next)
+    {
+      /* Do not add a caf_token field for class container components.  */
+      if ((codimen || coarray_flag)
+	  && !c->attr.dimension && !c->attr.codimension
+	  && (c->attr.allocatable || c->attr.pointer)
+	  && !derived->attr.is_class)
+	{
+	  char caf_name[GFC_MAX_SYMBOL_LEN];
+	  gfc_component *token;
+	  snprintf (caf_name, GFC_MAX_SYMBOL_LEN, "_caf_%s", c->name);
+	  token = gfc_find_component (derived, caf_name, true, true, NULL);
+	  gcc_assert (token);
+	  c->caf_token = token->backend_decl;
+	  TREE_NO_WARNING (c->caf_token) = 1;
+	}
+    }
+
   for (dt = gfc_derived_types; dt; dt = dt->next)
     gfc_copy_dt_decls_ifequal (derived, dt->derived, false);
 
@@ -2864,7 +2888,8 @@ create_fn_spec (gfc_symbol *sym, tree fntype)
 		    || f->sym->ts.u.derived->attr.pointer_comp))
 	    || (f->sym->ts.type == BT_CLASS
 		&& (CLASS_DATA (f->sym)->ts.u.derived->attr.proc_pointer_comp
-		    || CLASS_DATA (f->sym)->ts.u.derived->attr.pointer_comp)))
+		    || CLASS_DATA (f->sym)->ts.u.derived->attr.pointer_comp))
+	    || (f->sym->ts.type == BT_INTEGER && f->sym->ts.is_c_interop))
 	  spec[spec_len++] = '.';
 	else if (f->sym->attr.intent == INTENT_IN)
 	  spec[spec_len++] = 'r';
@@ -2877,9 +2902,57 @@ create_fn_spec (gfc_symbol *sym, tree fntype)
   return build_type_attribute_variant (fntype, tmp);
 }
 
+/* Helper function - if we do not find an interface for a procedure,
+   construct it from the actual arglist.  Luckily, this can only
+   happen for call by reference, so the information we actually need
+   to provide (and which would be impossible to guess from the call
+   itself) is not actually needed.  */
+
+static void
+get_formal_from_actual_arglist (gfc_symbol *sym, gfc_actual_arglist *actual_args)
+{
+  gfc_actual_arglist *a;
+  gfc_formal_arglist **f;
+  gfc_symbol *s;
+  char name[GFC_MAX_SYMBOL_LEN + 1];
+  static int var_num;
+
+  f = &sym->formal;
+  for (a = actual_args; a != NULL; a = a->next)
+    {
+      (*f) = gfc_get_formal_arglist ();
+      if (a->expr)
+	{
+	  snprintf (name, GFC_MAX_SYMBOL_LEN, "_formal_%d", var_num ++);
+	  gfc_get_symbol (name, NULL, &s);
+	  if (a->expr->ts.type == BT_PROCEDURE)
+	    {
+	      s->attr.flavor = FL_PROCEDURE;
+	    }
+	  else
+	    {
+	      s->ts = a->expr->ts;
+	      s->attr.flavor = FL_VARIABLE;
+	      if (a->expr->rank > 0)
+		{
+		  s->attr.dimension = 1;
+		  s->as = gfc_get_array_spec ();
+		  s->as->type = AS_ASSUMED_SIZE;
+		}
+	    }
+	  s->attr.dummy = 1;
+	  s->attr.intent = INTENT_UNKNOWN;
+	  (*f)->sym = s;
+	}
+      else  /* If a->expr is NULL, this is an alternate rerturn.  */
+	(*f)->sym = NULL;
+
+      f = &((*f)->next);
+    }
+}
 
 tree
-gfc_get_function_type (gfc_symbol * sym)
+gfc_get_function_type (gfc_symbol * sym, gfc_actual_arglist *actual_args)
 {
   tree type;
   vec<tree, va_gc> *typelist = NULL;
@@ -2937,6 +3010,10 @@ gfc_get_function_type (gfc_symbol * sym)
 	    vec_safe_push (typelist, build_pointer_type(gfc_charlen_type_node));
 	}
     }
+  if (sym->backend_decl == error_mark_node && actual_args != NULL
+      && sym->formal == NULL && (sym->attr.proc == PROC_EXTERNAL
+				 || sym->attr.proc == PROC_UNKNOWN))
+    get_formal_from_actual_arglist (sym, actual_args);
 
   /* Build the argument types for the function.  */
   for (f = gfc_sym_get_dummy_args (sym); f; f = f->next)
diff --git a/gcc/fortran/trans-types.h b/gcc/fortran/trans-types.h
index 6dba78e3671..3df9d540c15 100644
--- a/gcc/fortran/trans-types.h
+++ b/gcc/fortran/trans-types.h
@@ -87,7 +87,7 @@ tree gfc_sym_type (gfc_symbol *);
 tree gfc_typenode_for_spec (gfc_typespec *, int c = 0);
 int gfc_copy_dt_decls_ifequal (gfc_symbol *, gfc_symbol *, bool);
 
-tree gfc_get_function_type (gfc_symbol *);
+tree gfc_get_function_type (gfc_symbol *, gfc_actual_arglist *args = NULL);
 
 tree gfc_type_for_size (unsigned, int);
 tree gfc_type_for_mode (machine_mode, int);
diff --git a/gcc/fortran/trans.h b/gcc/fortran/trans.h
index d02f3470eeb..f3e5b948743 100644
--- a/gcc/fortran/trans.h
+++ b/gcc/fortran/trans.h
@@ -431,7 +431,7 @@ tree gfc_vptr_deallocate_get (tree);
 void gfc_reset_vptr (stmtblock_t *, gfc_expr *);
 void gfc_reset_len (stmtblock_t *, gfc_expr *);
 tree gfc_get_vptr_from_expr (tree);
-tree gfc_get_class_array_ref (tree, tree, tree);
+tree gfc_get_class_array_ref (tree, tree, tree, bool);
 tree gfc_copy_class_to_class (tree, tree, tree, bool);
 bool gfc_add_finalizer_call (stmtblock_t *, gfc_expr *);
 bool gfc_add_comp_finalizer_call (stmtblock_t *, tree, gfc_component *, bool);
@@ -578,7 +578,8 @@ void gfc_merge_block_scope (stmtblock_t * block);
 tree gfc_get_label_decl (gfc_st_label *);
 
 /* Return the decl for an external function.  */
-tree gfc_get_extern_function_decl (gfc_symbol *);
+tree gfc_get_extern_function_decl (gfc_symbol *,
+				   gfc_actual_arglist *args = NULL);
 
 /* Return the decl for a function.  */
 tree gfc_get_function_decl (gfc_symbol *);
diff --git a/gcc/function.c b/gcc/function.c
index 21eb586a8f7..7df51f29fd8 100644
--- a/gcc/function.c
+++ b/gcc/function.c
@@ -6576,8 +6576,9 @@ match_asm_constraints_1 (rtx_insn *insn, rtx *p_sets, int noutputs)
       /* Only do the transformation for pseudos.  */
       if (! REG_P (output)
 	  || rtx_equal_p (output, input)
-	  || (GET_MODE (input) != VOIDmode
-	      && GET_MODE (input) != GET_MODE (output)))
+	  || !(REG_P (input) || SUBREG_P (input)
+	       || MEM_P (input) || CONSTANT_P (input))
+	  || !general_operand (input, GET_MODE (output)))
 	continue;
 
       /* We can't do anything if the output is also used as input,
@@ -6603,7 +6604,7 @@ match_asm_constraints_1 (rtx_insn *insn, rtx *p_sets, int noutputs)
       output_matched[match] = true;
 
       start_sequence ();
-      emit_move_insn (output, input);
+      emit_move_insn (output, copy_rtx (input));
       insns = get_insns ();
       end_sequence ();
       emit_insn_before (insns, insn);
diff --git a/gcc/gcc.c b/gcc/gcc.c
index c48178f1aa3..eced0d53aae 100644
--- a/gcc/gcc.c
+++ b/gcc/gcc.c
@@ -677,7 +677,7 @@ proper position among the other output files.  */
 
 #ifndef LIBASAN_SPEC
 #define STATIC_LIBASAN_LIBS \
-  " %{static-libasan:%:include(libsanitizer.spec)%(link_libasan)}"
+  " %{static-libasan|static:%:include(libsanitizer.spec)%(link_libasan)}"
 #ifdef LIBASAN_EARLY_SPEC
 #define LIBASAN_SPEC STATIC_LIBASAN_LIBS
 #elif defined(HAVE_LD_STATIC_DYNAMIC)
@@ -695,7 +695,7 @@ proper position among the other output files.  */
 
 #ifndef LIBTSAN_SPEC
 #define STATIC_LIBTSAN_LIBS \
-  " %{static-libtsan:%:include(libsanitizer.spec)%(link_libtsan)}"
+  " %{static-libtsan|static:%:include(libsanitizer.spec)%(link_libtsan)}"
 #ifdef LIBTSAN_EARLY_SPEC
 #define LIBTSAN_SPEC STATIC_LIBTSAN_LIBS
 #elif defined(HAVE_LD_STATIC_DYNAMIC)
@@ -713,7 +713,7 @@ proper position among the other output files.  */
 
 #ifndef LIBLSAN_SPEC
 #define STATIC_LIBLSAN_LIBS \
-  " %{static-liblsan:%:include(libsanitizer.spec)%(link_liblsan)}"
+  " %{static-liblsan|static:%:include(libsanitizer.spec)%(link_liblsan)}"
 #ifdef LIBLSAN_EARLY_SPEC
 #define LIBLSAN_SPEC STATIC_LIBLSAN_LIBS
 #elif defined(HAVE_LD_STATIC_DYNAMIC)
@@ -731,7 +731,7 @@ proper position among the other output files.  */
 
 #ifndef LIBUBSAN_SPEC
 #define STATIC_LIBUBSAN_LIBS \
-  " %{static-libubsan:%:include(libsanitizer.spec)%(link_libubsan)}"
+  " %{static-libubsan|static:%:include(libsanitizer.spec)%(link_libubsan)}"
 #ifdef HAVE_LD_STATIC_DYNAMIC
 #define LIBUBSAN_SPEC "%{static-libubsan:" LD_STATIC_OPTION \
 		     "} -lubsan %{static-libubsan:" LD_DYNAMIC_OPTION "}" \
@@ -6970,8 +6970,8 @@ try_generate_repro (const char **argv)
 
     /* In final attempt we append compiler options and preprocesssed code to last
        generated .out file with configuration and backtrace.  */
-    char **output = &temp_stdout_files[RETRY_ICE_ATTEMPTS - 1];
-    do_report_bug (new_argv, nargs, stderr_commented, output);
+    char **err = &temp_stderr_files[RETRY_ICE_ATTEMPTS - 1];
+    do_report_bug (new_argv, nargs, stderr_commented, err);
   }
 
 out:
diff --git a/gcc/gcse.c b/gcc/gcse.c
index 38b95772857..3eace228e49 100644
--- a/gcc/gcse.c
+++ b/gcc/gcse.c
@@ -1963,14 +1963,11 @@ pre_expr_reaches_here_p (basic_block occr_bb, struct gcse_expr *expr, basic_bloc
   return rval;
 }
 
-/* Generate RTL to copy an EXPR to its `reaching_reg' and return it.  */
+/* Generate RTL to copy an EXP to REG and return it.  */
 
-static rtx_insn *
-process_insert_insn (struct gcse_expr *expr)
+rtx_insn *
+prepare_copy_insn (rtx reg, rtx exp)
 {
-  rtx reg = expr->reaching_reg;
-  /* Copy the expression to make sure we don't have any sharing issues.  */
-  rtx exp = copy_rtx (expr->expr);
   rtx_insn *pat;
 
   start_sequence ();
@@ -1996,6 +1993,18 @@ process_insert_insn (struct gcse_expr *expr)
   return pat;
 }
 
+/* Generate RTL to copy an EXPR to its `reaching_reg' and return it.  */
+
+static rtx_insn *
+process_insert_insn (struct gcse_expr *expr)
+{
+  rtx reg = expr->reaching_reg;
+  /* Copy the expression to make sure we don't have any sharing issues.  */
+  rtx exp = copy_rtx (expr->expr);
+
+  return prepare_copy_insn (reg, exp);
+}
+
 /* Add EXPR to the end of basic block BB.
 
    This is used by both the PRE and code hoisting.  */
diff --git a/gcc/genmatch.c b/gcc/genmatch.c
index 5621aa05b59..3527e499cbf 100644
--- a/gcc/genmatch.c
+++ b/gcc/genmatch.c
@@ -2054,7 +2054,11 @@ capture_info::walk_match (operand *o, unsigned toplevel_arg,
       if (c->what
 	  && (e = dyn_cast <expr *> (c->what)))
 	{
-	  info[where].expr_p = true;
+	  /* Zero-operand expression captures like ADDR_EXPR@0 are
+	     similar as predicates -- if they are not mentioned in
+	     the result we have to force them to have no side-effects.  */
+	  if (e->ops.length () != 0)
+	    info[where].expr_p = true;
 	  info[where].force_single_use |= e->force_single_use;
 	}
     }
diff --git a/gcc/genmodes.c b/gcc/genmodes.c
index e56c08b4d30..2af6556d8ac 100644
--- a/gcc/genmodes.c
+++ b/gcc/genmodes.c
@@ -116,6 +116,7 @@ complex_class (enum mode_class c)
   switch (c)
     {
     case MODE_INT: return MODE_COMPLEX_INT;
+    case MODE_PARTIAL_INT: return MODE_COMPLEX_INT;
     case MODE_FLOAT: return MODE_COMPLEX_FLOAT;
     default:
       error ("no complex class for class %s", mode_class_names[c]);
diff --git a/gcc/gimple-match-head.c b/gcc/gimple-match-head.c
index e7e9839a4b8..5a0d33174fb 100644
--- a/gcc/gimple-match-head.c
+++ b/gcc/gimple-match-head.c
@@ -99,17 +99,34 @@ gimple_resimplify1 (gimple_seq *seq,
 	}
     }
 
+  /* Limit recursion, there are cases like PR80887 and others, for
+     example when value-numbering presents us with unfolded expressions
+     that we are really not prepared to handle without eventual
+     oscillation like ((_50 + 0) + 8) where _50 gets mapped to _50
+     itself as available expression.  */
+  static unsigned depth;
+  if (depth > 10)
+    {
+      if (dump_file && (dump_flags & TDF_DETAILS))
+	fprintf (dump_file, "Aborting expression simplification due to "
+		 "deep recursion\n");
+      return false;
+    }
+
+  ++depth;
   code_helper res_code2;
   tree res_ops2[3] = {};
   if (gimple_simplify (&res_code2, res_ops2, seq, valueize,
 		       *res_code, type, res_ops[0]))
     {
+      --depth;
       *res_code = res_code2;
       res_ops[0] = res_ops2[0];
       res_ops[1] = res_ops2[1];
       res_ops[2] = res_ops2[2];
       return true;
     }
+  --depth;
 
   return false;
 }
@@ -159,17 +176,30 @@ gimple_resimplify2 (gimple_seq *seq,
       canonicalized = true;
     }
 
+  /* Limit recursion, see gimple_resimplify1.  */
+  static unsigned depth;
+  if (depth > 10)
+    {
+      if (dump_file && (dump_flags & TDF_DETAILS))
+	fprintf (dump_file, "Aborting expression simplification due to "
+		 "deep recursion\n");
+      return false;
+    }
+
+  ++depth;
   code_helper res_code2;
   tree res_ops2[3] = {};
   if (gimple_simplify (&res_code2, res_ops2, seq, valueize,
 		       *res_code, type, res_ops[0], res_ops[1]))
     {
+      --depth;
       *res_code = res_code2;
       res_ops[0] = res_ops2[0];
       res_ops[1] = res_ops2[1];
       res_ops[2] = res_ops2[2];
       return true;
     }
+  --depth;
 
   return canonicalized;
 }
@@ -218,18 +248,31 @@ gimple_resimplify3 (gimple_seq *seq,
       canonicalized = true;
     }
 
+  /* Limit recursion, see gimple_resimplify1.  */
+  static unsigned depth;
+  if (depth > 10)
+    {
+      if (dump_file && (dump_flags & TDF_DETAILS))
+	fprintf (dump_file, "Aborting expression simplification due to "
+		 "deep recursion\n");
+      return false;
+    }
+
+  ++depth;
   code_helper res_code2;
   tree res_ops2[3] = {};
   if (gimple_simplify (&res_code2, res_ops2, seq, valueize,
 		       *res_code, type,
 		       res_ops[0], res_ops[1], res_ops[2]))
     {
+      --depth;
       *res_code = res_code2;
       res_ops[0] = res_ops2[0];
       res_ops[1] = res_ops2[1];
       res_ops[2] = res_ops2[2];
       return true;
     }
+  --depth;
 
   return canonicalized;
 }
diff --git a/gcc/gimple-pretty-print.c b/gcc/gimple-pretty-print.c
index 49cc80c57d7..79e9c8ce15d 100644
--- a/gcc/gimple-pretty-print.c
+++ b/gcc/gimple-pretty-print.c
@@ -1989,6 +1989,8 @@ dump_gimple_asm (pretty_printer *buffer, gasm *gs, int spc, int flags)
       pp_string (buffer, "__asm__");
       if (gimple_asm_volatile_p (gs))
 	pp_string (buffer, " __volatile__");
+      if (gimple_asm_inline_p (gs))
+	pp_string (buffer, " __inline__");
       if (gimple_asm_nlabels (gs))
 	pp_string (buffer, " goto");
       pp_string (buffer, "(\"");
diff --git a/gcc/gimple-ssa-backprop.c b/gcc/gimple-ssa-backprop.c
index 3acf3d604ea..fa4ef45e555 100644
--- a/gcc/gimple-ssa-backprop.c
+++ b/gcc/gimple-ssa-backprop.c
@@ -260,6 +260,11 @@ private:
      post-order walk.  */
   auto_sbitmap m_visited_blocks;
 
+  /* A bitmap of phis that we have finished processing in the initial
+     post-order walk, excluding those from blocks mentioned in
+     M_VISITED_BLOCKS.  */
+  auto_bitmap m_visited_phis;
+
   /* A worklist of SSA names whose definitions need to be reconsidered.  */
   auto_vec <tree, 64> m_worklist;
 
@@ -500,8 +505,11 @@ backprop::intersect_uses (tree var, usage_info *info)
     {
       if (is_gimple_debug (stmt))
 	continue;
-      if (is_a <gphi *> (stmt)
-	  && !bitmap_bit_p (m_visited_blocks, gimple_bb (stmt)->index))
+      gphi *phi = dyn_cast <gphi *> (stmt);
+      if (phi
+	  && !bitmap_bit_p (m_visited_blocks, gimple_bb (phi)->index)
+	  && !bitmap_bit_p (m_visited_phis,
+			    SSA_NAME_VERSION (gimple_phi_result (phi))))
 	{
 	  /* Skip unprocessed phis.  */
 	  if (dump_file && (dump_flags & TDF_DETAILS))
@@ -509,7 +517,7 @@ backprop::intersect_uses (tree var, usage_info *info)
 	      fprintf (dump_file, "[BACKEDGE] ");
 	      print_generic_expr (dump_file, var, 0);
 	      fprintf (dump_file, " in ");
-	      print_gimple_stmt (dump_file, stmt, 0, TDF_SLIM);
+	      print_gimple_stmt (dump_file, phi, 0, TDF_SLIM);
 	    }
 	}
       else
@@ -633,7 +641,12 @@ backprop::process_block (basic_block bb)
     }
   for (gphi_iterator gpi = gsi_start_phis (bb); !gsi_end_p (gpi);
        gsi_next (&gpi))
-    process_var (gimple_phi_result (gpi.phi ()));
+    {
+      tree result = gimple_phi_result (gpi.phi ());
+      process_var (result);
+      bitmap_set_bit (m_visited_phis, SSA_NAME_VERSION (result));
+    }
+  bitmap_clear (m_visited_phis);
 }
 
 /* Delete the definition of VAR, which has no uses.  */
diff --git a/gcc/gimple-ssa-store-merging.c b/gcc/gimple-ssa-store-merging.c
index 17a95a50b1f..bb04245ea1f 100644
--- a/gcc/gimple-ssa-store-merging.c
+++ b/gcc/gimple-ssa-store-merging.c
@@ -812,12 +812,14 @@ pass_store_merging::terminate_all_aliasing_chains (imm_store_chain_info
 	{
 	  struct store_immediate_info *info;
 	  unsigned int i;
+	  tree store_lhs
+	    = gimple_store_p (stmt) ? gimple_get_lhs (stmt) : NULL_TREE;
 	  FOR_EACH_VEC_ELT ((*chain_info)->m_store_info, i, info)
 	    {
-	      if (ref_maybe_used_by_stmt_p (stmt,
-					    gimple_assign_lhs (info->stmt))
-		  || stmt_may_clobber_ref_p (stmt,
-					     gimple_assign_lhs (info->stmt)))
+	      tree lhs = gimple_assign_lhs (info->stmt);
+	      if (ref_maybe_used_by_stmt_p (stmt, lhs)
+		  || stmt_may_clobber_ref_p (stmt, lhs)
+		  || (store_lhs && refs_output_dependent_p (store_lhs, lhs)))
 		{
 		  if (dump_file && (dump_flags & TDF_DETAILS))
 		    {
diff --git a/gcc/gimple-ssa-strength-reduction.c b/gcc/gimple-ssa-strength-reduction.c
index 2c67d97b28f..08bba54fc01 100644
--- a/gcc/gimple-ssa-strength-reduction.c
+++ b/gcc/gimple-ssa-strength-reduction.c
@@ -55,6 +55,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "params.h"
 #include "tree-ssa-address.h"
 #include "tree-affine.h"
+#include "tree-eh.h"
 #include "builtins.h"
 
 /* Information about a strength reduction candidate.  Each statement
@@ -265,6 +266,10 @@ struct slsr_cand_d
      of a statement.  */
   cand_idx next_interp;
 
+  /* Index of the first candidate record in a chain for the same
+     statement.  */
+  cand_idx first_interp;
+
   /* Index of the basis statement S0, if any, in the candidate vector.  */
   cand_idx basis;
 
@@ -642,6 +647,7 @@ alloc_cand_and_find_basis (enum cand_kind kind, gimple *gs, tree base,
   c->kind = kind;
   c->cand_num = cand_vec.length () + 1;
   c->next_interp = 0;
+  c->first_interp = c->cand_num;
   c->dependent = 0;
   c->sibling = 0;
   c->def_phi = kind == CAND_MULT ? find_phi_def (base) : 0;
@@ -1212,8 +1218,9 @@ slsr_process_mul (gimple *gs, tree rhs1, tree rhs2, bool speed)
 	 is the stride and RHS2 is the base expression.  */
       c2 = create_mul_ssa_cand (gs, rhs2, rhs1, speed);
       c->next_interp = c2->cand_num;
+      c2->first_interp = c->cand_num;
     }
-  else
+  else if (TREE_CODE (rhs2) == INTEGER_CST && !integer_zerop (rhs2))
     {
       /* Record an interpretation for the multiply-immediate.  */
       c = create_mul_imm_cand (gs, rhs1, rhs2, speed);
@@ -1449,7 +1456,10 @@ slsr_process_add (gimple *gs, tree rhs1, tree rhs2, bool speed)
 	{
 	  c2 = create_add_ssa_cand (gs, rhs2, rhs1, false, speed);
 	  if (c)
-	    c->next_interp = c2->cand_num;
+	    {
+	      c->next_interp = c2->cand_num;
+	      c2->first_interp = c->cand_num;
+	    }
 	  else
 	    add_cand_for_stmt (gs, c2);
 	}
@@ -1572,6 +1582,8 @@ slsr_process_cast (gimple *gs, tree rhs1, bool speed)
 
   if (base_cand && base_cand->kind != CAND_PHI)
     {
+      slsr_cand_t first_cand = NULL;
+
       while (base_cand)
 	{
 	  /* Propagate all data from the base candidate except the type,
@@ -1586,6 +1598,12 @@ slsr_process_cast (gimple *gs, tree rhs1, bool speed)
 					 base_cand->index, base_cand->stride,
 					 ctype, base_cand->stride_type,
 					 savings);
+	  if (!first_cand)
+	    first_cand = c;
+
+	  if (first_cand != c)
+	    c->first_interp = first_cand->cand_num;
+
 	  if (base_cand->next_interp)
 	    base_cand = lookup_cand (base_cand->next_interp);
 	  else
@@ -1608,6 +1626,7 @@ slsr_process_cast (gimple *gs, tree rhs1, bool speed)
       c2 = alloc_cand_and_find_basis (CAND_MULT, gs, rhs1, 0,
 				      integer_one_node, ctype, sizetype, 0);
       c->next_interp = c2->cand_num;
+      c2->first_interp = c->cand_num;
     }
 
   /* Add the first (or only) interpretation to the statement-candidate
@@ -1632,6 +1651,8 @@ slsr_process_copy (gimple *gs, tree rhs1, bool speed)
 
   if (base_cand && base_cand->kind != CAND_PHI)
     {
+      slsr_cand_t first_cand = NULL;
+
       while (base_cand)
 	{
 	  /* Propagate all data from the base candidate.  */
@@ -1644,6 +1665,12 @@ slsr_process_copy (gimple *gs, tree rhs1, bool speed)
 					 base_cand->index, base_cand->stride,
 					 base_cand->cand_type,
 					 base_cand->stride_type, savings);
+	  if (!first_cand)
+	    first_cand = c;
+
+	  if (first_cand != c)
+	    c->first_interp = first_cand->cand_num;
+
 	  if (base_cand->next_interp)
 	    base_cand = lookup_cand (base_cand->next_interp);
 	  else
@@ -1668,6 +1695,7 @@ slsr_process_copy (gimple *gs, tree rhs1, bool speed)
 				      integer_one_node, TREE_TYPE (rhs1),
 				      sizetype, 0);
       c->next_interp = c2->cand_num;
+      c2->first_interp = c->cand_num;
     }
 
   /* Add the first (or only) interpretation to the statement-candidate
@@ -1699,6 +1727,9 @@ find_candidates_dom_walker::before_dom_children (basic_block bb)
     {
       gimple *gs = gsi_stmt (gsi);
 
+      if (stmt_could_throw_p (gs))
+	continue;
+
       if (gimple_vuse (gs) && gimple_assign_single_p (gs))
 	slsr_process_ref (gs);
 
@@ -1835,8 +1866,9 @@ dump_candidate (slsr_cand_t c)
   print_generic_expr (dump_file, c->cand_type, 0);
   fprintf (dump_file, "\n     basis: %d  dependent: %d  sibling: %d\n",
 	   c->basis, c->dependent, c->sibling);
-  fprintf (dump_file, "     next-interp: %d  dead-savings: %d\n",
-	   c->next_interp, c->dead_savings);
+  fprintf (dump_file,
+	   "     next-interp: %d  first-interp: %d  dead-savings: %d\n",
+	   c->next_interp, c->first_interp, c->dead_savings);
   if (c->def_phi)
     fprintf (dump_file, "     phi:  %d\n", c->def_phi);
   fputs ("\n", dump_file);
@@ -2094,14 +2126,13 @@ replace_mult_candidate (slsr_cand_t c, tree basis_name, widest_int bump)
       tree lhs = gimple_assign_lhs (c->cand_stmt);
       gassign *copy_stmt = gimple_build_assign (lhs, basis_name);
       gimple_stmt_iterator gsi = gsi_for_stmt (c->cand_stmt);
-      slsr_cand_t cc = c;
+      slsr_cand_t cc = lookup_cand (c->first_interp);
       gimple_set_location (copy_stmt, gimple_location (c->cand_stmt));
       gsi_replace (&gsi, copy_stmt, false);
-      c->cand_stmt = copy_stmt;
-      while (cc->next_interp)
+      while (cc)
 	{
-	  cc = lookup_cand (cc->next_interp);
 	  cc->cand_stmt = copy_stmt;
+	  cc = cc->next_interp ? lookup_cand (cc->next_interp) : NULL;
 	}
       if (dump_file && (dump_flags & TDF_DETAILS))
 	stmt_to_print = copy_stmt;
@@ -2128,15 +2159,14 @@ replace_mult_candidate (slsr_cand_t c, tree basis_name, widest_int bump)
       else
 	{
 	  gimple_stmt_iterator gsi = gsi_for_stmt (c->cand_stmt);
-	  slsr_cand_t cc = c;
+	  slsr_cand_t cc = lookup_cand (c->first_interp);
 	  gimple_assign_set_rhs_with_ops (&gsi, code,
 					  basis_name, bump_tree);
 	  update_stmt (gsi_stmt (gsi));
-	  c->cand_stmt = gsi_stmt (gsi);
-	  while (cc->next_interp)
+	  while (cc)
 	    {
-	      cc = lookup_cand (cc->next_interp);
 	      cc->cand_stmt = gsi_stmt (gsi);
+	      cc = cc->next_interp ? lookup_cand (cc->next_interp) : NULL;
 	    }
 	  if (dump_file && (dump_flags & TDF_DETAILS))
 	    stmt_to_print = gsi_stmt (gsi);
@@ -2636,17 +2666,23 @@ record_phi_increments (slsr_cand_t basis, gimple *phi)
   for (i = 0; i < gimple_phi_num_args (phi); i++)
     {
       tree arg = gimple_phi_arg_def (phi, i);
+      gimple *arg_def = SSA_NAME_DEF_STMT (arg);
 
-      if (!operand_equal_p (arg, phi_cand->base_expr, 0))
+      if (gimple_code (arg_def) == GIMPLE_PHI)
+	record_phi_increments (basis, arg_def);
+      else
 	{
-	  gimple *arg_def = SSA_NAME_DEF_STMT (arg);
+	  widest_int diff;
 
-	  if (gimple_code (arg_def) == GIMPLE_PHI)
-	    record_phi_increments (basis, arg_def);
+	  if (operand_equal_p (arg, phi_cand->base_expr, 0))
+	    {
+	      diff = -basis->index;
+	      record_increment (phi_cand, diff, PHI_ADJUST);
+	    }
 	  else
 	    {
 	      slsr_cand_t arg_cand = base_cand_from_table (arg);
-	      widest_int diff = arg_cand->index - basis->index;
+	      diff = arg_cand->index - basis->index;
 	      record_increment (arg_cand, diff, PHI_ADJUST);
 	    }
 	}
@@ -2708,28 +2744,42 @@ phi_incr_cost (slsr_cand_t c, const widest_int &incr, gimple *phi,
   for (i = 0; i < gimple_phi_num_args (phi); i++)
     {
       tree arg = gimple_phi_arg_def (phi, i);
+      gimple *arg_def = SSA_NAME_DEF_STMT (arg);
 
-      if (!operand_equal_p (arg, phi_cand->base_expr, 0))
+      if (gimple_code (arg_def) == GIMPLE_PHI)
 	{
-	  gimple *arg_def = SSA_NAME_DEF_STMT (arg);
-      
-	  if (gimple_code (arg_def) == GIMPLE_PHI)
+	  int feeding_savings = 0;
+	  cost += phi_incr_cost (c, incr, arg_def, &feeding_savings);
+	  if (has_single_use (gimple_phi_result (arg_def)))
+	    *savings += feeding_savings;
+	}
+      else
+	{
+	  widest_int diff;
+	  slsr_cand_t arg_cand;
+
+	  /* When the PHI argument is just a pass-through to the base
+	     expression of the hidden basis, the difference is zero minus
+	     the index of the basis.  There is no potential savings by
+	     eliminating a statement in this case.  */
+	  if (operand_equal_p (arg, phi_cand->base_expr, 0))
 	    {
-	      int feeding_savings = 0;
-	      cost += phi_incr_cost (c, incr, arg_def, &feeding_savings);
-	      if (has_single_use (gimple_phi_result (arg_def)))
-		*savings += feeding_savings;
+	      arg_cand = (slsr_cand_t) NULL;
+	      diff = -basis->index;
 	    }
 	  else
 	    {
-	      slsr_cand_t arg_cand = base_cand_from_table (arg);
-	      widest_int diff = arg_cand->index - basis->index;
-
-	      if (incr == diff)
+	      arg_cand = base_cand_from_table (arg);
+	      diff = arg_cand->index - basis->index;
+	    }
+	  
+	  if (incr == diff)
+	    {
+	      tree basis_lhs = gimple_assign_lhs (basis->cand_stmt);
+	      cost += add_cost (true, TYPE_MODE (TREE_TYPE (basis_lhs)));
+	      if (arg_cand)
 		{
-		  tree basis_lhs = gimple_assign_lhs (basis->cand_stmt);
 		  tree lhs = gimple_assign_lhs (arg_cand->cand_stmt);
-		  cost += add_cost (true, TYPE_MODE (TREE_TYPE (basis_lhs)));
 		  if (has_single_use (lhs))
 		    *savings += stmt_cost (arg_cand->cand_stmt, true);
 		}
@@ -3046,23 +3096,26 @@ ncd_with_phi (slsr_cand_t c, const widest_int &incr, gphi *phi,
   for (i = 0; i < gimple_phi_num_args (phi); i++)
     {
       tree arg = gimple_phi_arg_def (phi, i);
+      gimple *arg_def = SSA_NAME_DEF_STMT (arg);
 
-      if (!operand_equal_p (arg, phi_cand->base_expr, 0))
+      if (gimple_code (arg_def) == GIMPLE_PHI)
+	ncd = ncd_with_phi (c, incr, as_a <gphi *> (arg_def), ncd, where);
+      else 
 	{
-	  gimple *arg_def = SSA_NAME_DEF_STMT (arg);
+	  widest_int diff;
 
-	  if (gimple_code (arg_def) == GIMPLE_PHI)
-	    ncd = ncd_with_phi (c, incr, as_a <gphi *> (arg_def), ncd,
-				where);
-	  else 
+	  if (operand_equal_p (arg, phi_cand->base_expr, 0))
+	    diff = -basis->index;
+	  else
 	    {
 	      slsr_cand_t arg_cand = base_cand_from_table (arg);
-	      widest_int diff = arg_cand->index - basis->index;
-	      basic_block pred = gimple_phi_arg_edge (phi, i)->src;
-
-	      if ((incr == diff) || (!address_arithmetic_p && incr == -diff))
-		ncd = ncd_for_two_cands (ncd, pred, *where, NULL, where);
+	      diff = arg_cand->index - basis->index;
 	    }
+	  
+	  basic_block pred = gimple_phi_arg_edge (phi, i)->src;
+	  
+	  if ((incr == diff) || (!address_arithmetic_p && incr == -diff))
+	    ncd = ncd_for_two_cands (ncd, pred, *where, NULL, where);
 	}
     }
 
@@ -3328,49 +3381,52 @@ all_phi_incrs_profitable (slsr_cand_t c, gphi *phi)
 	return false;
 
       tree arg = gimple_phi_arg_def (phi, i);
+      gimple *arg_def = SSA_NAME_DEF_STMT (arg);
 
-      if (!operand_equal_p (arg, phi_cand->base_expr, 0))
+      if (gimple_code (arg_def) == GIMPLE_PHI)
 	{
-	  gimple *arg_def = SSA_NAME_DEF_STMT (arg);
+	  if (!all_phi_incrs_profitable (c, as_a <gphi *> (arg_def)))
+	    return false;
+	}
+      else
+	{
+	  int j;
+	  widest_int increment;
 
-	  if (gimple_code (arg_def) == GIMPLE_PHI)
-	    {
-	      if (!all_phi_incrs_profitable (c, as_a <gphi *> (arg_def)))
-		return false;
-	    }
+	  if (operand_equal_p (arg, phi_cand->base_expr, 0))
+	    increment = -basis->index;
 	  else
 	    {
-	      int j;
 	      slsr_cand_t arg_cand = base_cand_from_table (arg);
-	      widest_int increment = arg_cand->index - basis->index;
+	      increment = arg_cand->index - basis->index;
+	    }
 
-	      if (!address_arithmetic_p && wi::neg_p (increment))
-		increment = -increment;
+	  if (!address_arithmetic_p && wi::neg_p (increment))
+	    increment = -increment;
 
-	      j = incr_vec_index (increment);
+	  j = incr_vec_index (increment);
 
-	      if (dump_file && (dump_flags & TDF_DETAILS))
-		{
-		  fprintf (dump_file, "  Conditional candidate %d, phi: ",
-			   c->cand_num);
-		  print_gimple_stmt (dump_file, phi, 0, 0);
-		  fputs ("    increment: ", dump_file);
-		  print_decs (increment, dump_file);
-		  if (j < 0)
-		    fprintf (dump_file,
-			     "\n  Not replaced; incr_vec overflow.\n");
-		  else {
-		    fprintf (dump_file, "\n    cost: %d\n", incr_vec[j].cost);
-		    if (profitable_increment_p (j))
-		      fputs ("  Replacing...\n", dump_file);
-		    else
-		      fputs ("  Not replaced.\n", dump_file);
-		  }
-		}
-
-	      if (j < 0 || !profitable_increment_p (j))
-		return false;
+	  if (dump_file && (dump_flags & TDF_DETAILS))
+	    {
+	      fprintf (dump_file, "  Conditional candidate %d, phi: ",
+		       c->cand_num);
+	      print_gimple_stmt (dump_file, phi, 0, 0);
+	      fputs ("    increment: ", dump_file);
+	      print_decs (increment, dump_file);
+	      if (j < 0)
+		fprintf (dump_file,
+			 "\n  Not replaced; incr_vec overflow.\n");
+	      else {
+		fprintf (dump_file, "\n    cost: %d\n", incr_vec[j].cost);
+		if (profitable_increment_p (j))
+		  fputs ("  Replacing...\n", dump_file);
+		else
+		  fputs ("  Not replaced.\n", dump_file);
+	      }
 	    }
+
+	  if (j < 0 || !profitable_increment_p (j))
+	    return false;
 	}
     }
 
@@ -3422,14 +3478,13 @@ replace_rhs_if_not_dup (enum tree_code new_code, tree new_rhs1, tree new_rhs2,
 	      || !operand_equal_p (new_rhs2, old_rhs1, 0))))
     {
       gimple_stmt_iterator gsi = gsi_for_stmt (c->cand_stmt);
-      slsr_cand_t cc = c;
+      slsr_cand_t cc = lookup_cand (c->first_interp);
       gimple_assign_set_rhs_with_ops (&gsi, new_code, new_rhs1, new_rhs2);
       update_stmt (gsi_stmt (gsi));
-      c->cand_stmt = gsi_stmt (gsi);
-      while (cc->next_interp)
+      while (cc)
 	{
-	  cc = lookup_cand (cc->next_interp);
 	  cc->cand_stmt = gsi_stmt (gsi);
+	  cc = cc->next_interp ? lookup_cand (cc->next_interp) : NULL;
 	}
 
       if (dump_file && (dump_flags & TDF_DETAILS))
@@ -3462,6 +3517,11 @@ replace_one_candidate (slsr_cand_t c, unsigned i, tree basis_name)
   orig_rhs2 = gimple_assign_rhs2 (c->cand_stmt);
   cand_incr = cand_increment (c);
 
+  /* If orig_rhs2 is NULL, we have already replaced this in situ with
+     a copy statement under another interpretation.  */
+  if (!orig_rhs2)
+    return;
+
   if (dump_file && (dump_flags & TDF_DETAILS))
     {
       fputs ("Replacing: ", dump_file);
@@ -3534,14 +3594,13 @@ replace_one_candidate (slsr_cand_t c, unsigned i, tree basis_name)
 	  || !operand_equal_p (rhs2, orig_rhs2, 0))
 	{
 	  gimple_stmt_iterator gsi = gsi_for_stmt (c->cand_stmt);
-	  slsr_cand_t cc = c;
+	  slsr_cand_t cc = lookup_cand (c->first_interp);
 	  gimple_assign_set_rhs_with_ops (&gsi, MINUS_EXPR, basis_name, rhs2);
 	  update_stmt (gsi_stmt (gsi));
-          c->cand_stmt = gsi_stmt (gsi);
-	  while (cc->next_interp)
+	  while (cc)
 	    {
-	      cc = lookup_cand (cc->next_interp);
 	      cc->cand_stmt = gsi_stmt (gsi);
+	      cc = cc->next_interp ? lookup_cand (cc->next_interp) : NULL;
 	    }
 
 	  if (dump_file && (dump_flags & TDF_DETAILS))
@@ -3561,14 +3620,13 @@ replace_one_candidate (slsr_cand_t c, unsigned i, tree basis_name)
 	{
 	  gassign *copy_stmt = gimple_build_assign (lhs, basis_name);
 	  gimple_stmt_iterator gsi = gsi_for_stmt (c->cand_stmt);
-	  slsr_cand_t cc = c;
+	  slsr_cand_t cc = lookup_cand (c->first_interp);
 	  gimple_set_location (copy_stmt, gimple_location (c->cand_stmt));
 	  gsi_replace (&gsi, copy_stmt, false);
-	  c->cand_stmt = copy_stmt;
-	  while (cc->next_interp)
+	  while (cc)
 	    {
-	      cc = lookup_cand (cc->next_interp);
 	      cc->cand_stmt = copy_stmt;
+	      cc = cc->next_interp ? lookup_cand (cc->next_interp) : NULL;
 	    }
 
 	  if (dump_file && (dump_flags & TDF_DETAILS))
@@ -3578,14 +3636,13 @@ replace_one_candidate (slsr_cand_t c, unsigned i, tree basis_name)
 	{
 	  gimple_stmt_iterator gsi = gsi_for_stmt (c->cand_stmt);
 	  gassign *cast_stmt = gimple_build_assign (lhs, NOP_EXPR, basis_name);
-	  slsr_cand_t cc = c;
+	  slsr_cand_t cc = lookup_cand (c->first_interp);
 	  gimple_set_location (cast_stmt, gimple_location (c->cand_stmt));
 	  gsi_replace (&gsi, cast_stmt, false);
-	  c->cand_stmt = cast_stmt;
-	  while (cc->next_interp)
+	  while (cc)
 	    {
-	      cc = lookup_cand (cc->next_interp);
 	      cc->cand_stmt = cast_stmt;
+	      cc = cc->next_interp ? lookup_cand (cc->next_interp) : NULL;
 	    }
 
 	  if (dump_file && (dump_flags & TDF_DETAILS))
diff --git a/gcc/gimple.h b/gcc/gimple.h
index 460011c87f1..7e9e0bd38a3 100644
--- a/gcc/gimple.h
+++ b/gcc/gimple.h
@@ -136,6 +136,7 @@ enum gimple_rhs_class
 enum gf_mask {
     GF_ASM_INPUT		= 1 << 0,
     GF_ASM_VOLATILE		= 1 << 1,
+    GF_ASM_INLINE		= 1 << 2,
     GF_CALL_FROM_THUNK		= 1 << 0,
     GF_CALL_RETURN_SLOT_OPT	= 1 << 1,
     GF_CALL_TAILCALL		= 1 << 2,
@@ -3909,7 +3910,7 @@ gimple_asm_string (const gasm *asm_stmt)
 }
 
 
-/* Return true ASM_STMT ASM_STMT is an asm statement marked volatile.  */
+/* Return true if ASM_STMT is marked volatile.  */
 
 static inline bool
 gimple_asm_volatile_p (const gasm *asm_stmt)
@@ -3918,7 +3919,7 @@ gimple_asm_volatile_p (const gasm *asm_stmt)
 }
 
 
-/* If VOLATLE_P is true, mark asm statement ASM_STMT as volatile.  */
+/* If VOLATILE_P is true, mark asm statement ASM_STMT as volatile.  */
 
 static inline void
 gimple_asm_set_volatile (gasm *asm_stmt, bool volatile_p)
@@ -3930,6 +3931,27 @@ gimple_asm_set_volatile (gasm *asm_stmt, bool volatile_p)
 }
 
 
+/* Return true if ASM_STMT is marked inline.  */
+
+static inline bool
+gimple_asm_inline_p (const gasm *asm_stmt)
+{
+  return (asm_stmt->subcode & GF_ASM_INLINE) != 0;
+}
+
+
+/* If INLINE_P is true, mark asm statement ASM_STMT as inline.  */
+
+static inline void
+gimple_asm_set_inline (gasm *asm_stmt, bool inline_p)
+{
+  if (inline_p)
+    asm_stmt->subcode |= GF_ASM_INLINE;
+  else
+    asm_stmt->subcode &= ~GF_ASM_INLINE;
+}
+
+
 /* If INPUT_P is true, mark asm ASM_STMT as an ASM_INPUT.  */
 
 static inline void
diff --git a/gcc/gimplify.c b/gcc/gimplify.c
index 5264a4f3d40..818f0abd2f9 100644
--- a/gcc/gimplify.c
+++ b/gcc/gimplify.c
@@ -1125,10 +1125,6 @@ static void
 asan_poison_variable (tree decl, bool poison, gimple_stmt_iterator *it,
 		      bool before)
 {
-  /* When within an OMP context, do not emit ASAN_MARK internal fns.  */
-  if (gimplify_omp_ctxp)
-    return;
-
   tree unit_size = DECL_SIZE_UNIT (decl);
   tree base = build_fold_addr_expr (decl);
 
@@ -1640,7 +1636,8 @@ gimplify_decl_expr (tree *stmt_p, gimple_seq *seq_p)
 	  && TREE_ADDRESSABLE (decl)
 	  && !TREE_STATIC (decl)
 	  && !DECL_HAS_VALUE_EXPR_P (decl)
-	  && dbg_cnt (asan_use_after_scope))
+	  && dbg_cnt (asan_use_after_scope)
+	  && !gimplify_omp_ctxp)
 	{
 	  asan_poisoned_variables->add (decl);
 	  asan_poison_variable (decl, false, seq_p);
@@ -4684,7 +4681,7 @@ gimplify_init_constructor (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,
 	     objects.  Initializers for such objects must explicitly set
 	     every field that needs to be set.  */
 	  cleared = false;
-	else if (!complete_p && !CONSTRUCTOR_NO_CLEARING (ctor))
+	else if (!complete_p)
 	  /* If the constructor isn't complete, clear the whole object
 	     beforehand, unless CONSTRUCTOR_NO_CLEARING is set on it.
 
@@ -4693,7 +4690,7 @@ gimplify_init_constructor (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,
 	     we'd need to *find* the elements that are not present, and that
 	     requires trickery to avoid quadratic compile-time behavior in
 	     large cases or excessive memory use in small cases.  */
-	  cleared = true;
+	  cleared = !CONSTRUCTOR_NO_CLEARING (ctor);
 	else if (num_ctor_elements - num_nonzero_elements
 		 > CLEAR_RATIO (optimize_function_for_speed_p (cfun))
 		 && num_nonzero_elements < num_ctor_elements / 4)
@@ -5776,8 +5773,11 @@ gimplify_save_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p)
 	}
       else
 	/* The temporary may not be an SSA name as later abnormal and EH
-	   control flow may invalidate use/def domination.  */
-	val = get_initialized_tmp_var (val, pre_p, post_p, false);
+	   control flow may invalidate use/def domination.  When in SSA
+	   form then assume there are no such issues and SAVE_EXPRs only
+	   appear via GENERIC foldings.  */
+	val = get_initialized_tmp_var (val, pre_p, post_p,
+				       gimple_in_ssa_p (cfun));
 
       TREE_OPERAND (*expr_p, 0) = val;
       SAVE_EXPR_RESOLVED_P (*expr_p) = 1;
@@ -6206,6 +6206,7 @@ gimplify_asm_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p)
 
       gimple_asm_set_volatile (stmt, ASM_VOLATILE_P (expr) || noutputs == 0);
       gimple_asm_set_input (stmt, ASM_INPUT_P (expr));
+      gimple_asm_set_inline (stmt, ASM_INLINE_P (expr));
 
       gimplify_seq_add_stmt (pre_p, stmt);
     }
@@ -6458,7 +6459,8 @@ gimplify_target_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p)
 	      clobber = build2 (MODIFY_EXPR, TREE_TYPE (temp), temp, clobber);
 	      gimple_push_cleanup (temp, clobber, false, pre_p, true);
 	    }
-	  if (asan_poisoned_variables && dbg_cnt (asan_use_after_scope))
+	  if (asan_poisoned_variables && dbg_cnt (asan_use_after_scope)
+	      && !gimplify_omp_ctxp)
 	    {
 	      tree asan_cleanup = build_asan_poison_call_expr (temp);
 	      if (asan_cleanup)
@@ -9546,9 +9548,26 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)
 	  t = TREE_VEC_ELT (OMP_FOR_INIT (for_stmt), i);
 	  if (!is_gimple_constant (TREE_OPERAND (t, 1)))
 	    {
+	      tree type = TREE_TYPE (TREE_OPERAND (t, 0));
 	      TREE_OPERAND (t, 1)
 		= get_initialized_tmp_var (TREE_OPERAND (t, 1),
-					   pre_p, NULL, false);
+					   gimple_seq_empty_p (for_pre_body)
+					   ? pre_p : &for_pre_body, NULL,
+					   false);
+	      /* Reference to pointer conversion is considered useless,
+		 but is significant for firstprivate clause.  Force it
+		 here.  */
+	      if (TREE_CODE (type) == POINTER_TYPE
+		  && (TREE_CODE (TREE_TYPE (TREE_OPERAND (t, 1)))
+		      == REFERENCE_TYPE))
+		{
+		  tree v = create_tmp_var (TYPE_MAIN_VARIANT (type));
+		  tree m = build2 (INIT_EXPR, TREE_TYPE (v), v,
+				   TREE_OPERAND (t, 1));
+		  gimplify_and_add (m, gimple_seq_empty_p (for_pre_body)
+				       ? pre_p : &for_pre_body);
+		  TREE_OPERAND (t, 1) = v;
+		}
 	      tree c = build_omp_clause (input_location,
 					 OMP_CLAUSE_FIRSTPRIVATE);
 	      OMP_CLAUSE_DECL (c) = TREE_OPERAND (t, 1);
@@ -9560,11 +9579,26 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)
 	  t = TREE_VEC_ELT (OMP_FOR_COND (for_stmt), i);
 	  if (!is_gimple_constant (TREE_OPERAND (t, 1)))
 	    {
+	      tree type = TREE_TYPE (TREE_OPERAND (t, 0));
 	      TREE_OPERAND (t, 1)
 		= get_initialized_tmp_var (TREE_OPERAND (t, 1),
 					   gimple_seq_empty_p (for_pre_body)
 					   ? pre_p : &for_pre_body, NULL,
 					   false);
+	      /* Reference to pointer conversion is considered useless,
+		 but is significant for firstprivate clause.  Force it
+		 here.  */
+	      if (TREE_CODE (type) == POINTER_TYPE
+		  && (TREE_CODE (TREE_TYPE (TREE_OPERAND (t, 1)))
+		      == REFERENCE_TYPE))
+		{
+		  tree v = create_tmp_var (TYPE_MAIN_VARIANT (type));
+		  tree m = build2 (INIT_EXPR, TREE_TYPE (v), v,
+				   TREE_OPERAND (t, 1));
+		  gimplify_and_add (m, gimple_seq_empty_p (for_pre_body)
+				       ? pre_p : &for_pre_body);
+		  TREE_OPERAND (t, 1) = v;
+		}
 	      tree c = build_omp_clause (input_location,
 					 OMP_CLAUSE_FIRSTPRIVATE);
 	      OMP_CLAUSE_DECL (c) = TREE_OPERAND (t, 1);
diff --git a/gcc/go/ChangeLog b/gcc/go/ChangeLog
index 2d6cdbea429..f014302cbc5 100644
--- a/gcc/go/ChangeLog
+++ b/gcc/go/ChangeLog
@@ -1,3 +1,7 @@
+2018-12-06  Release Manager
+
+	* GCC 7.4.0 released.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
diff --git a/gcc/go/gofrontend/expressions.cc b/gcc/go/gofrontend/expressions.cc
index fee3203714f..1f43c4af16f 100644
--- a/gcc/go/gofrontend/expressions.cc
+++ b/gcc/go/gofrontend/expressions.cc
@@ -8065,7 +8065,7 @@ Builtin_call_expression::do_numeric_constant_value(Numeric_constant* nc) const
       if (arg_type->is_error())
 	return false;
       if (arg_type->is_abstract())
-	return false;
+	arg_type = arg_type->make_non_abstract_type();
       if (this->seen_)
         return false;
 
diff --git a/gcc/graphite.h b/gcc/graphite.h
index d22c4f2693f..e69edf2ae15 100644
--- a/gcc/graphite.h
+++ b/gcc/graphite.h
@@ -37,6 +37,8 @@ along with GCC; see the file COPYING3.  If not see
 #include <isl/schedule.h>
 #include <isl/ast_build.h>
 #include <isl/schedule_node.h>
+#include <isl/id.h>
+#include <isl/space.h>
 
 typedef struct poly_dr *poly_dr_p;
 
diff --git a/gcc/hsa-gen.c b/gcc/hsa-gen.c
index 7b69d64ac97..e2256990a90 100644
--- a/gcc/hsa-gen.c
+++ b/gcc/hsa-gen.c
@@ -917,9 +917,13 @@ get_symbol_for_decl (tree decl)
 	  else if (lookup_attribute ("hsa_group_segment",
 				     DECL_ATTRIBUTES (decl)))
 	    segment = BRIG_SEGMENT_GROUP;
-	  else if (TREE_STATIC (decl)
-		   || lookup_attribute ("hsa_global_segment",
-					DECL_ATTRIBUTES (decl)))
+	  else if (TREE_STATIC (decl))
+	    {
+	      segment = BRIG_SEGMENT_GLOBAL;
+	      allocation = BRIG_ALLOCATION_PROGRAM;
+	    }
+	  else if (lookup_attribute ("hsa_global_segment",
+				     DECL_ATTRIBUTES (decl)))
 	    segment = BRIG_SEGMENT_GLOBAL;
 	  else
 	    segment = BRIG_SEGMENT_PRIVATE;
diff --git a/gcc/input.c b/gcc/input.c
index 80718100d0c..6412d70f4e2 100644
--- a/gcc/input.c
+++ b/gcc/input.c
@@ -3480,6 +3480,34 @@ for_each_line_table_case (void (*testcase) (const line_table_case &))
   ASSERT_EQ (num_cases_tested, 2 * 12);
 }
 
+/* Verify that when presented with a consecutive pair of locations with
+   a very large line offset, we don't attempt to consolidate them into
+   a single ordinary linemap where the line offsets within the line map
+   would lead to overflow (PR lto/88147).  */
+
+static void
+test_line_offset_overflow ()
+{
+  line_table_test ltt (line_table_case (5, 0));
+
+  linemap_add (line_table, LC_ENTER, false, "foo.c", 0);
+  linemap_line_start (line_table, 1, 100);
+  location_t loc_a = linemap_line_start (line_table, 2578, 255);
+  assert_loceq ("foo.c", 2578, 0, loc_a);
+
+  const line_map_ordinary *ordmap_a = LINEMAPS_LAST_ORDINARY_MAP (line_table);
+  ASSERT_EQ (ordmap_a->m_column_and_range_bits, 13);
+  ASSERT_EQ (ordmap_a->m_range_bits, 5);
+
+  location_t loc_b = linemap_line_start (line_table, 404198, 512);
+  assert_loceq ("foo.c", 404198, 0, loc_b);
+
+  /* We should have started a new linemap, rather than attempting to store
+     a very large line offset.  */
+  const line_map_ordinary *ordmap_b = LINEMAPS_LAST_ORDINARY_MAP (line_table);
+  ASSERT_NE (ordmap_a, ordmap_b);
+}
+
 /* Run all of the selftests within this file.  */
 
 void
@@ -3518,6 +3546,8 @@ input_c_tests ()
   for_each_line_table_case (test_lexer_char_constants);
 
   test_reading_source_line ();
+
+  test_line_offset_overflow ();
 }
 
 } // namespace selftest
diff --git a/gcc/ipa-cp.c b/gcc/ipa-cp.c
index 716c8cc3a1f..56a95754c7f 100644
--- a/gcc/ipa-cp.c
+++ b/gcc/ipa-cp.c
@@ -621,6 +621,24 @@ determine_versionability (struct cgraph_node *node,
       reason = "calls comdat-local function";
     }
 
+  /* Functions calling BUILT_IN_VA_ARG_PACK and BUILT_IN_VA_ARG_PACK_LEN
+     works only when inlined.  Cloning them may still lead to better code
+     becuase ipa-cp will not give up on cloning further.  If the function is
+     external this however leads to wrong code becuase we may end up producing
+     offline copy of the function.  */
+  if (DECL_EXTERNAL (node->decl))
+    for (cgraph_edge *edge = node->callees; !reason && edge;
+	 edge = edge->next_callee)
+      if (DECL_BUILT_IN (edge->callee->decl)
+	  && DECL_BUILT_IN_CLASS (edge->callee->decl) == BUILT_IN_NORMAL)
+        {
+	  if (DECL_FUNCTION_CODE (edge->callee->decl) == BUILT_IN_VA_ARG_PACK)
+	    reason = "external function which calls va_arg_pack";
+	  if (DECL_FUNCTION_CODE (edge->callee->decl)
+	      == BUILT_IN_VA_ARG_PACK_LEN)
+	    reason = "external function which calls va_arg_pack_len";
+        }
+
   if (reason && dump_file && !node->alias && !node->thunk.thunk_p)
     fprintf (dump_file, "Function %s/%i is not versionable, reason: %s.\n",
 	     node->name (), node->order, reason);
@@ -792,7 +810,7 @@ build_toporder_info (struct ipa_topo_info *topo)
   topo->stack = XCNEWVEC (struct cgraph_node *, symtab->cgraph_count);
 
   gcc_checking_assert (topo->stack_top == 0);
-  topo->nnodes = ipa_reduced_postorder (topo->order, true, true, NULL);
+  topo->nnodes = ipa_reduced_postorder (topo->order, true, NULL);
 }
 
 /* Free information about strongly connected components and the arrays in
@@ -2801,11 +2819,18 @@ perform_estimation_of_a_value (cgraph_node *node, vec<tree> known_csts,
   estimate_ipcp_clone_size_and_time (node, known_csts, known_contexts,
 				     known_aggs_ptrs, &size, &time,
 				     &hints);
-  time_benefit = base_time - time
-    + devirtualization_time_bonus (node, known_csts, known_contexts,
-				   known_aggs_ptrs)
-    + hint_time_bonus (hints)
-    + removable_params_cost + est_move_cost;
+
+  /* Extern inline functions have no cloning local time benefits because they
+     will be inlined anyway.  The only reason to clone them is if it enables
+     optimization in any of the functions they call.  */
+  if (DECL_EXTERNAL (node->decl) && DECL_DECLARED_INLINE_P (node->decl))
+    time_benefit = 0;
+  else
+    time_benefit = base_time - time
+      + devirtualization_time_bonus (node, known_csts, known_contexts,
+				     known_aggs_ptrs)
+      + hint_time_bonus (hints)
+      + removable_params_cost + est_move_cost;
 
   gcc_checking_assert (size >=0);
   /* The inliner-heuristics based estimates may think that in certain
@@ -4009,7 +4034,9 @@ intersect_with_plats (struct ipcp_param_lattices *plats,
 	  if (aglat->offset - offset == item->offset)
 	    {
 	      gcc_checking_assert (item->value);
-	      if (values_equal_for_ipcp_p (item->value, aglat->values->value))
+	      if (aglat->is_single_const ()
+		  && values_equal_for_ipcp_p (item->value,
+					      aglat->values->value))
 		found = true;
 	      break;
 	    }
diff --git a/gcc/ipa-devirt.c b/gcc/ipa-devirt.c
index 0d214170c24..c1b7aa3bea6 100644
--- a/gcc/ipa-devirt.c
+++ b/gcc/ipa-devirt.c
@@ -1577,8 +1577,15 @@ odr_types_equivalent_p (tree t1, tree t2, bool warn, bool *warned,
 				 "in another translation unit"));
 		    return false;
 		  }
-		gcc_assert (DECL_NONADDRESSABLE_P (f1)
-			    == DECL_NONADDRESSABLE_P (f2));
+		if (DECL_BIT_FIELD (f1) != DECL_BIT_FIELD (f2))
+		  {
+		    warn_odr (t1, t2, f1, f2, warn, warned,
+			      G_("one field is bitfield while other is not"));
+		    return false;
+		  }
+		else
+		  gcc_assert (DECL_NONADDRESSABLE_P (f1)
+			      == DECL_NONADDRESSABLE_P (f2));
 	      }
 
 	    /* If one aggregate has more fields than the other, they
diff --git a/gcc/ipa-icf-gimple.c b/gcc/ipa-icf-gimple.c
index b40dd8653b4..9a1ca00392d 100644
--- a/gcc/ipa-icf-gimple.c
+++ b/gcc/ipa-icf-gimple.c
@@ -994,6 +994,9 @@ func_checker::compare_gimple_asm (const gasm *g1, const gasm *g2)
   if (gimple_asm_input_p (g1) != gimple_asm_input_p (g2))
     return false;
 
+  if (gimple_asm_inline_p (g1) != gimple_asm_inline_p (g2))
+    return false;
+
   if (gimple_asm_ninputs (g1) != gimple_asm_ninputs (g2))
     return false;
 
diff --git a/gcc/ipa-icf.c b/gcc/ipa-icf.c
index 95fad30e83a..c8ca9566cb7 100644
--- a/gcc/ipa-icf.c
+++ b/gcc/ipa-icf.c
@@ -2132,23 +2132,6 @@ sem_variable::get_hash (void)
   return m_hash;
 }
 
-/* Set all points-to UIDs of aliases pointing to node N as UID.  */
-
-static void
-set_alias_uids (symtab_node *n, int uid)
-{
-  ipa_ref *ref;
-  FOR_EACH_ALIAS (n, ref)
-    {
-      if (dump_file)
-	fprintf (dump_file, "  Setting points-to UID of [%s] as %d\n",
-		 xstrdup_for_dump (ref->referring->asm_name ()), uid);
-
-      SET_DECL_PT_UID (ref->referring->decl, uid);
-      set_alias_uids (ref->referring, uid);
-    }
-}
-
 /* Merges instance with an ALIAS_ITEM, where alias, thunk or redirection can
    be applied.  */
 
@@ -2275,7 +2258,6 @@ sem_variable::merge (sem_item *alias_item)
       if (dump_file)
 	fprintf (dump_file, "Unified; Variable alias has been created.\n");
 
-      set_alias_uids (original, DECL_UID (original->decl));
       return true;
     }
 }
@@ -2295,7 +2277,7 @@ unsigned int sem_item_optimizer::class_id = 0;
 
 sem_item_optimizer::sem_item_optimizer ()
 : worklist (0), m_classes (0), m_classes_count (0), m_cgraph_node_hooks (NULL),
-  m_varpool_node_hooks (NULL)
+  m_varpool_node_hooks (NULL), m_merged_variables ()
 {
   m_items.create (0);
   bitmap_obstack_initialize (&m_bmstack);
@@ -2320,6 +2302,7 @@ sem_item_optimizer::~sem_item_optimizer ()
   m_items.release ();
 
   bitmap_obstack_release (&m_bmstack);
+  m_merged_variables.release ();
 }
 
 /* Write IPA ICF summary for symbols.  */
@@ -3571,13 +3554,103 @@ sem_item_optimizer::merge_classes (unsigned int prev_class_count)
 	      }
 
 	    if (dbg_cnt (merged_ipa_icf))
-	      merged_p |= source->merge (alias);
+	      {
+		bool merged = source->merge (alias);
+		merged_p |= merged;
+
+		if (merged && alias->type == VAR)
+		  {
+		    symtab_pair p = symtab_pair (source->node, alias->node);
+		    m_merged_variables.safe_push (p);
+		  }
+	      }
 	  }
       }
 
+  if (!m_merged_variables.is_empty ())
+    fixup_points_to_sets ();
+
   return merged_p;
 }
 
+/* Fixup points to set PT.  */
+
+void
+sem_item_optimizer::fixup_pt_set (struct pt_solution *pt)
+{
+  if (pt->vars == NULL)
+    return;
+
+  unsigned i;
+  symtab_pair *item;
+  FOR_EACH_VEC_ELT (m_merged_variables, i, item)
+    if (bitmap_bit_p (pt->vars, DECL_UID (item->second->decl)))
+      bitmap_set_bit (pt->vars, DECL_UID (item->first->decl));
+}
+
+/* Set all points-to UIDs of aliases pointing to node N as UID.  */
+
+static void
+set_alias_uids (symtab_node *n, int uid)
+{
+  ipa_ref *ref;
+  FOR_EACH_ALIAS (n, ref)
+    {
+      if (dump_file)
+	fprintf (dump_file, "  Setting points-to UID of [%s] as %d\n",
+		 xstrdup_for_dump (ref->referring->asm_name ()), uid);
+
+      SET_DECL_PT_UID (ref->referring->decl, uid);
+      set_alias_uids (ref->referring, uid);
+    }
+}
+
+/* Fixup points to analysis info.  */
+
+void
+sem_item_optimizer::fixup_points_to_sets (void)
+{
+  /* TODO: remove in GCC 9 and trigger PTA re-creation after IPA passes.  */
+  cgraph_node *cnode;
+
+  FOR_EACH_DEFINED_FUNCTION (cnode)
+    {
+      tree name;
+      unsigned i;
+      function *fn = DECL_STRUCT_FUNCTION (cnode->decl);
+      if (!gimple_in_ssa_p (fn))
+	continue;
+
+      FOR_EACH_SSA_NAME (i, name, fn)
+	if (POINTER_TYPE_P (TREE_TYPE (name))
+	    && SSA_NAME_PTR_INFO (name))
+	  fixup_pt_set (&SSA_NAME_PTR_INFO (name)->pt);
+      fixup_pt_set (&fn->gimple_df->escaped);
+
+       /* The above get's us to 99% I guess, at least catching the
+	  address compares.  Below also gets us aliasing correct
+	  but as said we're giving leeway to the situation with
+	  readonly vars anyway, so ... */
+       basic_block bb;
+       FOR_EACH_BB_FN (bb, fn)
+	for (gimple_stmt_iterator gsi = gsi_start_bb (bb); !gsi_end_p (gsi);
+	     gsi_next (&gsi))
+	  {
+	    gcall *call = dyn_cast<gcall *> (gsi_stmt (gsi));
+	    if (call)
+	      {
+		fixup_pt_set (gimple_call_use_set (call));
+		fixup_pt_set (gimple_call_clobber_set (call));
+	      }
+	  }
+    }
+
+  unsigned i;
+  symtab_pair *item;
+  FOR_EACH_VEC_ELT (m_merged_variables, i, item)
+    set_alias_uids (item->first, DECL_UID (item->first->decl));
+}
+
 /* Dump function prints all class members to a FILE with an INDENT.  */
 
 void
diff --git a/gcc/ipa-icf.h b/gcc/ipa-icf.h
index c57224c1517..2101747bfd6 100644
--- a/gcc/ipa-icf.h
+++ b/gcc/ipa-icf.h
@@ -141,6 +141,8 @@ public:
   unsigned int index;
 };
 
+typedef std::pair<symtab_node *, symtab_node *> symtab_pair;
+
 /* Semantic item is a base class that encapsulates all shared functionality
    for both semantic function and variable items.  */
 class sem_item
@@ -563,6 +565,12 @@ private:
      processed.  */
   bool merge_classes (unsigned int prev_class_count);
 
+  /* Fixup points to analysis info.  */
+  void fixup_points_to_sets (void);
+
+  /* Fixup points to set PT.  */
+  void fixup_pt_set (struct pt_solution *pt);
+
   /* Adds a newly created congruence class CLS to worklist.  */
   void worklist_push (congruence_class *cls);
 
@@ -632,6 +640,10 @@ private:
 
   /* Bitmap stack.  */
   bitmap_obstack m_bmstack;
+
+  /* Vector of merged variables.  Needed for fixup of points-to-analysis
+     info.  */
+  vec <symtab_pair> m_merged_variables;
 }; // class sem_item_optimizer
 
 } // ipa_icf namespace
diff --git a/gcc/ipa-inline.c b/gcc/ipa-inline.c
index 0dfdd551577..b520c6393f4 100644
--- a/gcc/ipa-inline.c
+++ b/gcc/ipa-inline.c
@@ -1745,7 +1745,7 @@ inline_small_functions (void)
      metrics.  */
 
   max_count = 0;
-  ipa_reduced_postorder (order, true, true, NULL);
+  ipa_reduced_postorder (order, true, NULL);
   free (order);
 
   FOR_EACH_DEFINED_FUNCTION (node)
@@ -1773,7 +1773,7 @@ inline_small_functions (void)
 		struct cgraph_node *n2;
 		int id = dfs->scc_no + 1;
 		for (n2 = node; n2;
-		     n2 = ((struct ipa_dfs_info *) node->aux)->next_cycle)
+		     n2 = ((struct ipa_dfs_info *) n2->aux)->next_cycle)
 		  {
 		    struct inline_summary *info2 = inline_summaries->get (n2);
 		    if (info2->scc_no)
diff --git a/gcc/ipa-prop.c b/gcc/ipa-prop.c
index 9cc19cec204..ec78eae7a67 100644
--- a/gcc/ipa-prop.c
+++ b/gcc/ipa-prop.c
@@ -111,12 +111,13 @@ struct ipa_vr_ggc_hash_traits : public ggc_cache_remove <value_range *>
   typedef value_range *compare_type;
   static hashval_t
   hash (const value_range *p)
-  {
-    gcc_checking_assert (!p->equiv);
-    hashval_t t = (hashval_t) p->type;
-    t = iterative_hash_expr (p->min, t);
-    return iterative_hash_expr (p->max, t);
-  }
+    {
+      gcc_checking_assert (!p->equiv);
+      inchash::hash hstate (p->type);
+      hstate.add_ptr (p->min);
+      hstate.add_ptr (p->max);
+      return hstate.end ();
+    }
   static bool
   equal (const value_range *a, const value_range *b)
     {
@@ -1576,7 +1577,8 @@ determine_locally_known_aggregate_parts (gcall *call, tree arg,
       if (TREE_CODE (arg) == SSA_NAME)
 	{
 	  tree type_size;
-          if (!tree_fits_uhwi_p (TYPE_SIZE (TREE_TYPE (arg_type))))
+          if (!tree_fits_uhwi_p (TYPE_SIZE (TREE_TYPE (arg_type)))
+	      || !POINTER_TYPE_P (TREE_TYPE (arg)))
             return;
 	  check_ref = true;
 	  arg_base = arg;
@@ -4352,8 +4354,7 @@ ipa_modify_call_arguments (struct cgraph_edge *cs, gcall *stmt,
 
 	  gcc_checking_assert (adj->offset % BITS_PER_UNIT == 0);
 	  base = gimple_call_arg (stmt, adj->base_index);
-	  loc = DECL_P (base) ? DECL_SOURCE_LOCATION (base)
-			      : EXPR_LOCATION (base);
+	  loc = gimple_location (stmt);
 
 	  if (TREE_CODE (base) != ADDR_EXPR
 	      && POINTER_TYPE_P (TREE_TYPE (base)))
@@ -4445,6 +4446,7 @@ ipa_modify_call_arguments (struct cgraph_edge *cs, gcall *stmt,
 		  else
 		    expr = create_tmp_reg (TREE_TYPE (expr));
 		  gimple_assign_set_lhs (tem, expr);
+		  gimple_set_location (tem, loc);
 		  gsi_insert_before (&gsi, tem, GSI_SAME_STMT);
 		}
 	    }
diff --git a/gcc/ipa-pure-const.c b/gcc/ipa-pure-const.c
index e457166ea39..5a11919dd5c 100644
--- a/gcc/ipa-pure-const.c
+++ b/gcc/ipa-pure-const.c
@@ -1233,7 +1233,7 @@ propagate_pure_const (void)
   bool remove_p = false;
   bool has_cdtor;
 
-  order_pos = ipa_reduced_postorder (order, true, false,
+  order_pos = ipa_reduced_postorder (order, true,
 				     ignore_edge_for_pure_const);
   if (dump_file)
     {
@@ -1566,7 +1566,7 @@ propagate_nothrow (void)
   int i;
   struct ipa_dfs_info * w_info;
 
-  order_pos = ipa_reduced_postorder (order, true, false,
+  order_pos = ipa_reduced_postorder (order, true,
 				     ignore_edge_for_nothrow);
   if (dump_file)
     {
diff --git a/gcc/ipa-reference.c b/gcc/ipa-reference.c
index f47d0cc51e1..ccbfa078deb 100644
--- a/gcc/ipa-reference.c
+++ b/gcc/ipa-reference.c
@@ -730,7 +730,7 @@ propagate (void)
      the global information.  All the nodes within a cycle will have
      the same info so we collapse cycles first.  Then we can do the
      propagation in one pass from the leaves to the roots.  */
-  order_pos = ipa_reduced_postorder (order, true, true, ignore_edge_p);
+  order_pos = ipa_reduced_postorder (order, true, ignore_edge_p);
   if (dump_file)
     ipa_print_order (dump_file, "reduced", order, order_pos);
 
diff --git a/gcc/ipa-utils.c b/gcc/ipa-utils.c
index 959e31a68e6..3fb02150904 100644
--- a/gcc/ipa-utils.c
+++ b/gcc/ipa-utils.c
@@ -63,7 +63,6 @@ struct searchc_env {
   int order_pos;
   splay_tree nodes_marked_new;
   bool reduce;
-  bool allow_overwritable;
   int count;
 };
 
@@ -105,7 +104,7 @@ searchc (struct searchc_env* env, struct cgraph_node *v,
 
       if (w->aux
 	  && (avail > AVAIL_INTERPOSABLE
-	      || (env->allow_overwritable && avail == AVAIL_INTERPOSABLE)))
+	      || avail == AVAIL_INTERPOSABLE))
 	{
 	  w_info = (struct ipa_dfs_info *) w->aux;
 	  if (w_info->new_node)
@@ -162,7 +161,7 @@ searchc (struct searchc_env* env, struct cgraph_node *v,
 
 int
 ipa_reduced_postorder (struct cgraph_node **order,
-		       bool reduce, bool allow_overwritable,
+		       bool reduce,
 		       bool (*ignore_edge) (struct cgraph_edge *))
 {
   struct cgraph_node *node;
@@ -175,15 +174,13 @@ ipa_reduced_postorder (struct cgraph_node **order,
   env.nodes_marked_new = splay_tree_new (splay_tree_compare_ints, 0, 0);
   env.count = 1;
   env.reduce = reduce;
-  env.allow_overwritable = allow_overwritable;
 
   FOR_EACH_DEFINED_FUNCTION (node)
     {
       enum availability avail = node->get_availability ();
 
       if (avail > AVAIL_INTERPOSABLE
-	  || (allow_overwritable
-	      && (avail == AVAIL_INTERPOSABLE)))
+	  || avail == AVAIL_INTERPOSABLE)
 	{
 	  /* Reuse the info if it is already there.  */
 	  struct ipa_dfs_info *info = (struct ipa_dfs_info *) node->aux;
@@ -404,6 +401,8 @@ ipa_merge_profiles (struct cgraph_node *dst,
 
   if (!dst->count)
     return;
+  if (!src->count || src->alias)
+    return;
   if (symtab->dump_file)
     {
       fprintf (symtab->dump_file, "Merging profiles of %s/%i to %s/%i\n",
diff --git a/gcc/ipa-utils.h b/gcc/ipa-utils.h
index e992f65948b..f8a25a6786f 100644
--- a/gcc/ipa-utils.h
+++ b/gcc/ipa-utils.h
@@ -36,7 +36,7 @@ struct ipa_dfs_info {
 
 /* In ipa-utils.c  */
 void ipa_print_order (FILE*, const char *, struct cgraph_node**, int);
-int ipa_reduced_postorder (struct cgraph_node **, bool, bool,
+int ipa_reduced_postorder (struct cgraph_node **, bool,
 			  bool (*ignore_edge) (struct cgraph_edge *));
 void ipa_free_postorder_info (void);
 vec<cgraph_node *> ipa_get_nodes_in_cycle (struct cgraph_node *);
diff --git a/gcc/jit/ChangeLog b/gcc/jit/ChangeLog
index e77a00f6139..00016616a6a 100644
--- a/gcc/jit/ChangeLog
+++ b/gcc/jit/ChangeLog
@@ -1,3 +1,7 @@
+2018-12-06  Release Manager
+
+	* GCC 7.4.0 released.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
diff --git a/gcc/loop-unroll.c b/gcc/loop-unroll.c
index 3d48a8fb7bc..21959f716b1 100644
--- a/gcc/loop-unroll.c
+++ b/gcc/loop-unroll.c
@@ -477,7 +477,7 @@ unroll_loop_constant_iterations (struct loop *loop)
 
   exit_mod = niter % (max_unroll + 1);
 
-  auto_sbitmap wont_exit (max_unroll + 1);
+  auto_sbitmap wont_exit (max_unroll + 2);
   bitmap_ones (wont_exit);
 
   auto_vec<edge> remove_edges;
diff --git a/gcc/lower-subreg.c b/gcc/lower-subreg.c
index a4dcec51bb5..b1e2e287e15 100644
--- a/gcc/lower-subreg.c
+++ b/gcc/lower-subreg.c
@@ -490,7 +490,16 @@ find_decomposable_subregs (rtx *loc, enum classify_move_insn *pcmi)
 	     were the same number and size of pieces.  Hopefully this
 	     doesn't happen much.  */
 
-	  if (outer_words == 1 && inner_words > 1)
+	  if (outer_words == 1
+	      && inner_words > 1
+	      /* Don't allow to decompose floating point subregs of
+		 multi-word pseudos if the floating point mode does
+		 not have word size, because otherwise we'd generate
+		 a subreg with that floating mode from a different
+		 sized integral pseudo which is not allowed by
+		 validate_subreg.  */
+	      && (!FLOAT_MODE_P (GET_MODE (x))
+		  || outer_size == UNITS_PER_WORD))
 	    {
 	      bitmap_set_bit (decomposable_context, regno);
 	      iter.skip_subrtxes ();
diff --git a/gcc/lra-constraints.c b/gcc/lra-constraints.c
index db67677bf0b..9b011fd70a5 100644
--- a/gcc/lra-constraints.c
+++ b/gcc/lra-constraints.c
@@ -3724,7 +3724,13 @@ curr_insn_transform (bool check_only_p)
 
   curr_insn_set = single_set (curr_insn);
   if (curr_insn_set != NULL_RTX && simple_move_p ())
-    return false;
+    {
+      /* We assume that the corresponding insn alternative has no
+	 earlier clobbers.  If it is not the case, don't define move
+	 cost equal to 2 for the corresponding register classes.  */
+      lra_set_used_insn_alternative (curr_insn, LRA_NON_CLOBBERED_ALT);
+      return false;
+    }
 
   no_input_reloads_p = no_output_reloads_p = false;
   goal_alt_number = -1;
@@ -3832,7 +3838,7 @@ curr_insn_transform (bool check_only_p)
   if (change_p)
     /* If we've changed the instruction then any alternative that
        we chose previously may no longer be valid.  */
-    lra_set_used_insn_alternative (curr_insn, -1);
+    lra_set_used_insn_alternative (curr_insn, LRA_UNKNOWN_ALT);
 
   if (! check_only_p && curr_insn_set != NULL_RTX
       && check_and_process_move (&change_p, &sec_mem_p))
@@ -3840,7 +3846,7 @@ curr_insn_transform (bool check_only_p)
 
  try_swapped:
 
-  reused_alternative_num = check_only_p ? -1 : curr_id->used_insn_alternative;
+  reused_alternative_num = check_only_p ? LRA_UNKNOWN_ALT : curr_id->used_insn_alternative;
   if (lra_dump_file != NULL && reused_alternative_num >= 0)
     fprintf (lra_dump_file, "Reusing alternative %d for insn #%u\n",
 	     reused_alternative_num, INSN_UID (curr_insn));
@@ -6708,7 +6714,7 @@ remove_inheritance_pseudos (bitmap remove_pseudos)
 			}
 		      lra_push_insn_and_update_insn_regno_info (curr_insn);
 		      lra_set_used_insn_alternative_by_uid
-			(INSN_UID (curr_insn), -1);
+			(INSN_UID (curr_insn), LRA_UNKNOWN_ALT);
 		      done_p = true;
 		      if (lra_dump_file != NULL)
 			{
@@ -6747,7 +6753,7 @@ remove_inheritance_pseudos (bitmap remove_pseudos)
 		     constraints pass.  */
 		  lra_push_insn_and_update_insn_regno_info (curr_insn);
 		  lra_set_used_insn_alternative_by_uid
-		    (INSN_UID (curr_insn), -1);
+		    (INSN_UID (curr_insn), LRA_UNKNOWN_ALT);
 		}
 	      else if (restored_regs_p)
 		/* The instruction has been restored to the form that
diff --git a/gcc/lra-eliminations.c b/gcc/lra-eliminations.c
index 695f99ad317..993da861cf9 100644
--- a/gcc/lra-eliminations.c
+++ b/gcc/lra-eliminations.c
@@ -1178,7 +1178,7 @@ spill_pseudos (HARD_REG_SET set)
     if (bitmap_bit_p (&to_process, INSN_UID (insn)))
       {
 	lra_push_insn (insn);
-	lra_set_used_insn_alternative (insn, -1);
+	lra_set_used_insn_alternative (insn, LRA_UNKNOWN_ALT);
       }
   bitmap_clear (&to_process);
 }
@@ -1409,7 +1409,7 @@ process_insn_for_elimination (rtx_insn *insn, bool final_p, bool first_p)
 	}
       lra_update_insn_regno_info (insn);
       lra_push_insn (insn);
-      lra_set_used_insn_alternative (insn, -1);
+      lra_set_used_insn_alternative (insn, LRA_UNKNOWN_ALT);
     }
 }
 
diff --git a/gcc/lra-int.h b/gcc/lra-int.h
index 405071708b1..59b08ec73ef 100644
--- a/gcc/lra-int.h
+++ b/gcc/lra-int.h
@@ -202,15 +202,20 @@ struct lra_static_insn_data
   const struct operand_alternative *operand_alternative;
 };
 
+/* Negative insn alternative numbers used for special cases.  */
+#define LRA_UNKNOWN_ALT -1
+#define LRA_NON_CLOBBERED_ALT -2
+
 /* LRA internal info about an insn (LRA internal insn
    representation).  */
 struct lra_insn_recog_data
 {
   /* The insn code.  */
   int icode;
-  /* The alternative should be used for the insn, -1 if invalid, or we
-     should try to use any alternative, or the insn is a debug
-     insn.  */
+  /* The alternative should be used for the insn, LRA_UNKNOWN_ALT if
+     unknown, or we should assume any alternative, or the insn is a
+     debug insn.  LRA_NON_CLOBBERED_ALT means ignoring any earlier
+     clobbers for the insn.  */
   int used_insn_alternative;
   /* SP offset before the insn relative to one at the func start.  */
   HOST_WIDE_INT sp_offset;
diff --git a/gcc/lra-lives.c b/gcc/lra-lives.c
index 5d4015b5ab9..bb8ab25d4ef 100644
--- a/gcc/lra-lives.c
+++ b/gcc/lra-lives.c
@@ -593,7 +593,9 @@ static inline bool
 reg_early_clobber_p (const struct lra_insn_reg *reg, int n_alt)
 {
   return (reg->early_clobber
-	  && (n_alt < 0 || TEST_BIT (reg->early_clobber_alts, n_alt)));
+	  && (n_alt == LRA_UNKNOWN_ALT
+	      || (n_alt != LRA_NON_CLOBBERED_ALT
+		  && TEST_BIT (reg->early_clobber_alts, n_alt))));
 }
 
 /* Process insns of the basic block BB to update pseudo live ranges,
diff --git a/gcc/lra-spills.c b/gcc/lra-spills.c
index 492fc182cf0..73f293a08f7 100644
--- a/gcc/lra-spills.c
+++ b/gcc/lra-spills.c
@@ -503,7 +503,7 @@ spill_pseudos (void)
 			 INSN_UID (insn));
 	      lra_push_insn (insn);
 	      if (lra_reg_spill_p || targetm.different_addr_displacement_p ())
-		lra_set_used_insn_alternative (insn, -1);
+		lra_set_used_insn_alternative (insn, LRA_UNKNOWN_ALT);
 	    }
 	  else if (CALL_P (insn)
 		   /* Presence of any pseudo in CALL_INSN_FUNCTION_USAGE
diff --git a/gcc/lra.c b/gcc/lra.c
index 1230b25e7e1..995aafc7d9f 100644
--- a/gcc/lra.c
+++ b/gcc/lra.c
@@ -946,7 +946,7 @@ lra_set_insn_recog_data (rtx_insn *insn)
   data = XNEW (struct lra_insn_recog_data);
   lra_insn_recog_data[uid] = data;
   data->insn = insn;
-  data->used_insn_alternative = -1;
+  data->used_insn_alternative = LRA_UNKNOWN_ALT;
   data->icode = icode;
   data->regs = NULL;
   if (DEBUG_INSN_P (insn))
@@ -1187,7 +1187,7 @@ lra_update_insn_recog_data (rtx_insn *insn)
       return data;
     }
   insn_static_data = data->insn_static_data;
-  data->used_insn_alternative = -1;
+  data->used_insn_alternative = LRA_UNKNOWN_ALT;
   if (DEBUG_INSN_P (insn))
     return data;
   if (data->icode < 0)
@@ -1670,10 +1670,12 @@ lra_rtx_hash (rtx x)
 
     case SCRATCH:
     case CONST_DOUBLE:
-    case CONST_INT:
     case CONST_VECTOR:
       return val;
 
+    case CONST_INT:
+      return val + UINTVAL (x);
+
     default:
       break;
     }
diff --git a/gcc/lto-streamer-out.c b/gcc/lto-streamer-out.c
index b96b9df63b7..89313727068 100644
--- a/gcc/lto-streamer-out.c
+++ b/gcc/lto-streamer-out.c
@@ -2524,13 +2524,10 @@ write_symbol (struct streamer_tree_cache_d *cache,
   const char *comdat;
   unsigned char c;
 
-  /* None of the following kinds of symbols are needed in the
-     symbol table.  */
-  if (!TREE_PUBLIC (t)
-      || is_builtin_fn (t)
-      || DECL_ABSTRACT_P (t)
-      || (VAR_P (t) && DECL_HARD_REGISTER (t)))
-    return;
+  gcc_checking_assert (TREE_PUBLIC (t)
+		       && !is_builtin_fn (t)
+		       && !DECL_ABSTRACT_P (t)
+		       && (!VAR_P (t) || !DECL_HARD_REGISTER (t)));
 
   gcc_assert (VAR_OR_FUNCTION_DECL_P (t));
 
@@ -2618,45 +2615,6 @@ write_symbol (struct streamer_tree_cache_d *cache,
   lto_write_data (&slot_num, 4);
 }
 
-/* Return true if NODE should appear in the plugin symbol table.  */
-
-bool
-output_symbol_p (symtab_node *node)
-{
-  struct cgraph_node *cnode;
-  if (!node->real_symbol_p ())
-    return false;
-  /* We keep external functions in symtab for sake of inlining
-     and devirtualization.  We do not want to see them in symbol table as
-     references unless they are really used.  */
-  cnode = dyn_cast <cgraph_node *> (node);
-  if (cnode && (!node->definition || DECL_EXTERNAL (cnode->decl))
-      && cnode->callers)
-    return true;
-
- /* Ignore all references from external vars initializers - they are not really
-    part of the compilation unit until they are used by folding.  Some symbols,
-    like references to external construction vtables can not be referred to at all.
-    We decide this at can_refer_decl_in_current_unit_p.  */
- if (!node->definition || DECL_EXTERNAL (node->decl))
-    {
-      int i;
-      struct ipa_ref *ref;
-      for (i = 0; node->iterate_referring (i, ref); i++)
-	{
-	  if (ref->use == IPA_REF_ALIAS)
-	    continue;
-          if (is_a <cgraph_node *> (ref->referring))
-	    return true;
-	  if (!DECL_EXTERNAL (ref->referring->decl))
-	    return true;
-	}
-      return false;
-    }
-  return true;
-}
-
-
 /* Write an IL symbol table to OB.
    SET and VSET are cgraph/varpool node sets we are outputting.  */
 
@@ -2681,7 +2639,7 @@ produce_symtab (struct output_block *ob)
     {
       symtab_node *node = lsei_node (lsei);
 
-      if (!output_symbol_p (node) || DECL_EXTERNAL (node->decl))
+      if (DECL_EXTERNAL (node->decl) || !node->output_to_lto_symbol_table_p ())
 	continue;
       write_symbol (cache, node->decl, &seen, false);
     }
@@ -2690,7 +2648,7 @@ produce_symtab (struct output_block *ob)
     {
       symtab_node *node = lsei_node (lsei);
 
-      if (!output_symbol_p (node) || !DECL_EXTERNAL (node->decl))
+      if (!DECL_EXTERNAL (node->decl) || !node->output_to_lto_symbol_table_p ())
 	continue;
       write_symbol (cache, node->decl, &seen, false);
     }
diff --git a/gcc/lto-wrapper.c b/gcc/lto-wrapper.c
index 2c81176913e..5e5caa85408 100644
--- a/gcc/lto-wrapper.c
+++ b/gcc/lto-wrapper.c
@@ -1403,7 +1403,9 @@ cont:
 	  struct pex_obj *pex;
 	  char jobs[32];
 
-	  fprintf (mstream, "all:");
+	  fprintf (mstream,
+		   ".PHONY: all\n"
+		   "all:");
 	  for (i = 0; i < nr; ++i)
 	    fprintf (mstream, " \\\n\t%s", output_names[i]);
 	  fprintf (mstream, "\n");
diff --git a/gcc/lto/ChangeLog b/gcc/lto/ChangeLog
index 251156789d3..fa3b356cacb 100644
--- a/gcc/lto/ChangeLog
+++ b/gcc/lto/ChangeLog
@@ -1,3 +1,106 @@
+2018-12-06  Release Manager
+
+	* GCC 7.4.0 released.
+
+2018-04-24  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-04-19  Martin Liska  <mliska@suse.cz>
+
+	* lto-symtab.c (lto_symtab_resolve_symbols): Do not bail out
+	for multiple PREVAILING_DEF_IRONLY for common symbols.
+
+2018-04-24  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-04-10  Martin Liska  <mliska@suse.cz>
+
+	PR lto/85248
+	* lto-symtab.c (lto_symtab_merge_p): Do not check for
+	TREE_VALUES of error attributes.
+
+2018-04-24  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-04-10  Richard Biener  <rguenther@suse.de>
+		    Martin Liska  <mliska@suse.cz>
+
+	PR lto/85248
+	* lto-symtab.c (lto_symtab_merge_p): Handle noreturn attribute.
+
+2018-03-06  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-01-23  Martin Liska  <mliska@suse.cz>
+
+	PR lto/81440
+	* lto-symtab.c (lto_symtab_merge): Handle and do not warn about
+	trailing arrays at the end of a struct.
+
+2018-03-06  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-02-08  Jan Hubicka  <hubicka@ucw.cz>
+
+	* lto-partition.c (lto_balanced_map): Watch overflow.
+
+2018-03-06  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-02-08  Jan Hubicka  <hubicka@ucw.cz>
+
+	PR ipa/81360
+	* lto.c (unify_scc): Register prevailing trees, not trees to be freed.
+	(read_cgraph_and_symbols): Use
+	symtab_node::output_to_lto_symbol_table_p.
+
+2018-03-06  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-01-30  Jan Hubicka  <hubicka@ucw.cz>
+
+	* lto.c (register_resolution): Remove forgotten sanity check.
+
+2018-03-06  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-01-30  Jan Hubicka  <hubicka@ucw.cz>
+
+	PR lto/81004
+	* lto.c: Include builtins.h
+	(register_resolution): Merge resolutions in case trees was
+	merged across units.
+	(lto_maybe_register_decl): Break out from ...
+	(lto_read_decls): ... here.
+	(unify_scc): Also register decls here.
+	(read_cgraph_and_symbols): Sanity check that all resolutions was
+	read.
+
+2018-03-06  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-02-02  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR lto/83954
+	* lto-symtab.c (warn_type_compatibility_p): Do not recurse into the
+	component type of array types with non-aliased component.
+
+2018-03-06  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-01-30  Jan Hubicka  <hubicka@ucw.cz>
+
+	PR lto/83954
+	* lto-symtab.c (warn_type_compatibility_p): Silence false positive
+	for type match warning on arrays of pointers.
+
+2018-03-06  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2017-10-13  Jan Hubicka  <hubicka@ucw.cz>
+
+	* lto-lang.c (lto_post_options): Clean shlib flag when not doing PIC.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
diff --git a/gcc/lto/lto-lang.c b/gcc/lto/lto-lang.c
index ca8945e53bb..fdd6ae08a1c 100644
--- a/gcc/lto/lto-lang.c
+++ b/gcc/lto/lto-lang.c
@@ -840,11 +840,13 @@ lto_post_options (const char **pfilename ATTRIBUTE_UNUSED)
          flag_pie is 2.  */
       flag_pie = MAX (flag_pie, flag_pic);
       flag_pic = flag_pie;
+      flag_shlib = 0;
       break;
 
     case LTO_LINKER_OUTPUT_EXEC: /* Normal executable */
       flag_pic = 0;
       flag_pie = 0;
+      flag_shlib = 0;
       break;
 
     case LTO_LINKER_OUTPUT_UNKNOWN:
diff --git a/gcc/lto/lto-partition.c b/gcc/lto/lto-partition.c
index e27d0d1690c..a624dfa8847 100644
--- a/gcc/lto/lto-partition.c
+++ b/gcc/lto/lto-partition.c
@@ -756,7 +756,8 @@ lto_balanced_map (int n_lto_partitions, int max_partition_size)
 	  if (npartitions < n_lto_partitions)
 	    partition_size = total_size / (n_lto_partitions - npartitions);
 	  else
-	    partition_size = INT_MAX;
+	    /* Watch for overflow.  */
+	    partition_size = INT_MAX / 16;
 
 	  if (partition_size < PARAM_VALUE (MIN_PARTITION_SIZE))
 	    partition_size = PARAM_VALUE (MIN_PARTITION_SIZE);
diff --git a/gcc/lto/lto-symtab.c b/gcc/lto/lto-symtab.c
index f61b1f80133..65eb2b58c72 100644
--- a/gcc/lto/lto-symtab.c
+++ b/gcc/lto/lto-symtab.c
@@ -283,11 +283,25 @@ warn_type_compatibility_p (tree prevailing_type, tree type,
       alias_set_type set1 = get_alias_set (type);
       alias_set_type set2 = get_alias_set (prevailing_type);
 
-      if (set1 && set2 && set1 != set2 
-          && (!POINTER_TYPE_P (type) || !POINTER_TYPE_P (prevailing_type)
+      if (set1 && set2 && set1 != set2)
+	{
+          tree t1 = type, t2 = prevailing_type;
+
+	  /* Alias sets of arrays with aliased components are the same as alias
+	     sets of the inner types.  */
+	  while (TREE_CODE (t1) == ARRAY_TYPE
+		 && !TYPE_NONALIASED_COMPONENT (t1)
+		 && TREE_CODE (t2) == ARRAY_TYPE
+		 && !TYPE_NONALIASED_COMPONENT (t2))
+	    {
+	      t1 = TREE_TYPE (t1);
+	      t2 = TREE_TYPE (t2);
+	    }
+          if ((!POINTER_TYPE_P (t1) || !POINTER_TYPE_P (t2))
 	      || (set1 != TYPE_ALIAS_SET (ptr_type_node)
-		  && set2 != TYPE_ALIAS_SET (ptr_type_node))))
-        lev |= 5;
+		  && set2 != TYPE_ALIAS_SET (ptr_type_node)))
+             lev |= 5;
+	}
     }
 
   return lev;
@@ -351,18 +365,31 @@ lto_symtab_merge (symtab_node *prevailing, symtab_node *entry)
     return false;
 
   if (DECL_SIZE (decl) && DECL_SIZE (prevailing_decl)
-      && !tree_int_cst_equal (DECL_SIZE (decl), DECL_SIZE (prevailing_decl))
+      && !tree_int_cst_equal (DECL_SIZE (decl), DECL_SIZE (prevailing_decl)))
+      {
+	if (!DECL_COMMON (decl) && !DECL_EXTERNAL (decl))
+	  return false;
+
+	tree type = TREE_TYPE (decl);
+
+	/* For record type, check for array at the end of the structure.  */
+	if (TREE_CODE (type) == RECORD_TYPE)
+	  {
+	    tree field = TYPE_FIELDS (type);
+	    while (DECL_CHAIN (field) != NULL_TREE)
+	      field = DECL_CHAIN (field);
+
+	    return TREE_CODE (TREE_TYPE (field)) == ARRAY_TYPE;
+	  }
       /* As a special case do not warn about merging
 	 int a[];
 	 and
 	 int a[]={1,2,3};
 	 here the first declaration is COMMON
 	 and sizeof(a) == sizeof (int).  */
-      && ((!DECL_COMMON (decl) && !DECL_EXTERNAL (decl))
-	  || TREE_CODE (TREE_TYPE (decl)) != ARRAY_TYPE
-	  || TYPE_SIZE (TREE_TYPE (decl))
-	     != TYPE_SIZE (TREE_TYPE (TREE_TYPE (decl)))))
-    return false;
+	else if (TREE_CODE (type) == ARRAY_TYPE)
+	  return (TYPE_SIZE (decl) == TYPE_SIZE (TREE_TYPE (type)));
+      }
 
   return true;
 }
@@ -438,9 +465,14 @@ lto_symtab_resolve_symbols (symtab_node *first)
   /* If the chain is already resolved there is nothing else to do.  */
   if (prevailing)
     {
-      /* Assert it's the only one.  */
+      /* Assert it's the only one.
+	 GCC should silence multiple PREVAILING_DEF_IRONLY defs error
+	 on COMMON symbols since it isn't error.
+	 See: https://sourceware.org/bugzilla/show_bug.cgi?id=23079.  */
       for (e = prevailing->next_sharing_asm_name; e; e = e->next_sharing_asm_name)
 	if (lto_symtab_symbol_p (e)
+	    && !DECL_COMMON (prevailing->decl)
+	    && !DECL_COMMON (e->decl)
 	    && (e->resolution == LDPR_PREVAILING_DEF_IRONLY
 		|| e->resolution == LDPR_PREVAILING_DEF_IRONLY_EXP
 		|| e->resolution == LDPR_PREVAILING_DEF))
@@ -544,6 +576,9 @@ lto_symtab_merge_p (tree prevailing, tree decl)
 	  return false;
 	}
     }
+
+  /* FIXME: after MPX is removed, use flags_from_decl_or_type
+     function instead.  PR lto/85248.  */
   if (DECL_ATTRIBUTES (prevailing) != DECL_ATTRIBUTES (decl))
     {
       tree prev_attr = lookup_attribute ("error", DECL_ATTRIBUTES (prevailing));
@@ -571,6 +606,16 @@ lto_symtab_merge_p (tree prevailing, tree decl)
 		     "warning attribute mismatch\n");
 	  return false;
 	}
+
+      prev_attr = lookup_attribute ("noreturn", DECL_ATTRIBUTES (prevailing));
+      attr = lookup_attribute ("noreturn", DECL_ATTRIBUTES (decl));
+      if ((prev_attr == NULL) != (attr == NULL))
+	{
+          if (symtab->dump_file)
+	    fprintf (symtab->dump_file, "Not merging decls; "
+		     "noreturn attribute mismatch\n");
+	  return false;
+	}
     }
   return true;
 }
diff --git a/gcc/lto/lto.c b/gcc/lto/lto.c
index a7d5e450ea0..8a82f923b6e 100644
--- a/gcc/lto/lto.c
+++ b/gcc/lto/lto.c
@@ -53,6 +53,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "lto-symtab.h"
 #include "stringpool.h"
 #include "fold-const.h"
+#include "builtins.h"
 
 
 /* Number of parallel tasks to run, -1 if we want to use GNU Make jobserver.  */
@@ -829,12 +830,19 @@ static void
 register_resolution (struct lto_file_decl_data *file_data, tree decl,
 		     enum ld_plugin_symbol_resolution resolution)
 {
+  bool existed;
   if (resolution == LDPR_UNKNOWN)
     return;
   if (!file_data->resolution_map)
     file_data->resolution_map
       = new hash_map<tree, ld_plugin_symbol_resolution>;
-  file_data->resolution_map->put (decl, resolution);
+  ld_plugin_symbol_resolution_t &res
+     = file_data->resolution_map->get_or_insert (decl, &existed);
+  if (!existed
+      || resolution == LDPR_PREVAILING_DEF_IRONLY
+      || resolution == LDPR_PREVAILING_DEF
+      || resolution == LDPR_PREVAILING_DEF_IRONLY_EXP)
+    res = resolution;
 }
 
 /* Register DECL with the global symbol table and change its
@@ -877,6 +885,18 @@ lto_register_function_decl_in_symtab (struct data_in *data_in, tree decl,
 			 decl, get_resolution (data_in, ix));
 }
 
+/* Check if T is a decl and needs register its resolution info.  */
+
+static void
+lto_maybe_register_decl (struct data_in *data_in, tree t, unsigned ix)
+{
+  if (TREE_CODE (t) == VAR_DECL)
+    lto_register_var_decl_in_symtab (data_in, t, ix);
+  else if (TREE_CODE (t) == FUNCTION_DECL
+	   && !DECL_BUILT_IN (t))
+    lto_register_function_decl_in_symtab (data_in, t, ix);
+}
+
 
 /* For the type T re-materialize it in the type variant list and
    the pointer/reference-to chains.  */
@@ -1607,7 +1627,10 @@ unify_scc (struct data_in *data_in, unsigned from,
 	  /* Fixup the streamer cache with the prevailing nodes according
 	     to the tree node mapping computed by compare_tree_sccs.  */
 	  if (len == 1)
-	    streamer_tree_cache_replace_tree (cache, pscc->entries[0], from);
+	    {
+	      lto_maybe_register_decl (data_in, pscc->entries[0], from);
+	      streamer_tree_cache_replace_tree (cache, pscc->entries[0], from);
+	    }
 	  else
 	    {
 	      tree *map2 = XALLOCAVEC (tree, 2 * len);
@@ -1619,8 +1642,12 @@ unify_scc (struct data_in *data_in, unsigned from,
 	      qsort (map2, len, 2 * sizeof (tree), cmp_tree);
 	      qsort (map, len, 2 * sizeof (tree), cmp_tree);
 	      for (unsigned i = 0; i < len; ++i)
-		streamer_tree_cache_replace_tree (cache, map[2*i],
-						  (uintptr_t)map2[2*i]);
+		{
+		  lto_maybe_register_decl (data_in, map[2*i],
+					   (uintptr_t)map2[2*i]);
+		  streamer_tree_cache_replace_tree (cache, map[2*i],
+						    (uintptr_t)map2[2*i]);
+		}
 	    }
 
 	  /* Free the tree nodes from the read SCC.  */
@@ -1759,13 +1786,7 @@ lto_read_decls (struct lto_file_decl_data *decl_data, const void *data,
 		}
 	      if (!flag_ltrans)
 		{
-		  /* Register variables and functions with the
-		     symbol table.  */
-		  if (TREE_CODE (t) == VAR_DECL)
-		    lto_register_var_decl_in_symtab (data_in, t, from + i);
-		  else if (TREE_CODE (t) == FUNCTION_DECL
-			   && !DECL_BUILT_IN (t))
-		    lto_register_function_decl_in_symtab (data_in, t, from + i);
+		  lto_maybe_register_decl (data_in, t, from + i);
 		  /* Scan the tree for references to global functions or
 		     variables and record those for later fixup.  */
 		  if (mentions_vars_p (t))
@@ -2858,13 +2879,25 @@ read_cgraph_and_symbols (unsigned nfiles, const char **fnames)
 
   /* Store resolutions into the symbol table.  */
 
-  ld_plugin_symbol_resolution_t *res;
   FOR_EACH_SYMBOL (snode)
-    if (snode->real_symbol_p ()
-	&& snode->lto_file_data
-	&& snode->lto_file_data->resolution_map
-	&& (res = snode->lto_file_data->resolution_map->get (snode->decl)))
-      snode->resolution = *res;
+    if (snode->externally_visible && snode->real_symbol_p ()
+	&& snode->lto_file_data && snode->lto_file_data->resolution_map
+	&& !is_builtin_fn (snode->decl)
+	&& !(VAR_P (snode->decl) && DECL_HARD_REGISTER (snode->decl)))
+      {
+	ld_plugin_symbol_resolution_t *res;
+
+	res = snode->lto_file_data->resolution_map->get (snode->decl);
+	if (!res || *res == LDPR_UNKNOWN)
+	  {
+	    if (snode->output_to_lto_symbol_table_p ())
+	      fatal_error (input_location, "missing resolution data for %s",
+		           IDENTIFIER_POINTER
+			     (DECL_ASSEMBLER_NAME (snode->decl)));
+	  }
+	else
+          snode->resolution = *res;
+      }
   for (i = 0; all_file_decl_data[i]; i++)
     if (all_file_decl_data[i]->resolution_map)
       {
diff --git a/gcc/machmode.def b/gcc/machmode.def
index afe685195ef..6c844889b7f 100644
--- a/gcc/machmode.def
+++ b/gcc/machmode.def
@@ -243,6 +243,7 @@ UACCUM_MODE (UTA, 16, 64, 64); /* 64.64 */
 
 /* Complex modes.  */
 COMPLEX_MODES (INT);
+COMPLEX_MODES (PARTIAL_INT);
 COMPLEX_MODES (FLOAT);
 
 /* Decimal floating point modes.  */
diff --git a/gcc/match.pd b/gcc/match.pd
index 100e188ea2c..e405d9e84e9 100644
--- a/gcc/match.pd
+++ b/gcc/match.pd
@@ -2789,15 +2789,17 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)
 (simplify
  (cond
   (ne (bit_and @0 integer_pow2p@1) integer_zerop)
-  integer_pow2p@2 integer_zerop)
- (with {
-    int shift = wi::exact_log2 (@2) - wi::exact_log2 (@1);
-  }
-  (if (shift > 0)
-   (bit_and
-    (lshift (convert @0) { build_int_cst (integer_type_node, shift); }) @2)
-   (bit_and
-    (convert (rshift @0 { build_int_cst (integer_type_node, -shift); })) @2))))
+  INTEGER_CST@2 integer_zerop)
+ (if (integer_pow2p (@2))
+  (with {
+     int shift = wi::exact_log2 (@2) - wi::exact_log2 (@1);
+   }
+   (if (shift > 0)
+    (bit_and
+     (lshift (convert @0) { build_int_cst (integer_type_node, shift); }) @2)
+    (bit_and
+     (convert (rshift @0 { build_int_cst (integer_type_node, -shift); }))
+     @2)))))
 
 /* If we have (A & C) != 0 where C is the sign bit of A, convert
    this into A < 0.  Similarly for (A & C) == 0 into A >= 0.  */
@@ -2818,8 +2820,9 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)
 (simplify
  (cond
   (lt @0 integer_zerop)
-  integer_pow2p@1 integer_zerop)
- (if (!TYPE_UNSIGNED (TREE_TYPE (@0)))
+  INTEGER_CST@1 integer_zerop)
+ (if (integer_pow2p (@1)
+      && !TYPE_UNSIGNED (TREE_TYPE (@0)))
   (with {
     int shift = element_precision (@0) - wi::exact_log2 (@1) - 1;
    }
@@ -2926,10 +2929,13 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)
 (for cmp (ne eq)
  (simplify
   (cmp (convert @0) INTEGER_CST@1)
-  (if ((POINTER_TYPE_P (TREE_TYPE (@0)) && !FUNC_OR_METHOD_TYPE_P (TREE_TYPE (TREE_TYPE (@0)))
-	&& INTEGRAL_TYPE_P (TREE_TYPE (@1)))
-      || (INTEGRAL_TYPE_P (TREE_TYPE (@0)) && POINTER_TYPE_P (TREE_TYPE (@1))
-	  && !FUNC_OR_METHOD_TYPE_P (TREE_TYPE (TREE_TYPE (@1)))))
+  (if (((POINTER_TYPE_P (TREE_TYPE (@0))
+	 && !FUNC_OR_METHOD_TYPE_P (TREE_TYPE (TREE_TYPE (@0)))
+	 && INTEGRAL_TYPE_P (TREE_TYPE (@1)))
+	|| (INTEGRAL_TYPE_P (TREE_TYPE (@0))
+	    && POINTER_TYPE_P (TREE_TYPE (@1))
+	    && !FUNC_OR_METHOD_TYPE_P (TREE_TYPE (TREE_TYPE (@1)))))
+       && TYPE_PRECISION (TREE_TYPE (@0)) == TYPE_PRECISION (TREE_TYPE (@1)))
    (cmp @0 (convert @1)))))
 
 /* Non-equality compare simplifications from fold_binary  */
diff --git a/gcc/objc/ChangeLog b/gcc/objc/ChangeLog
index 62e7c9f97d8..b9a5e0790c9 100644
--- a/gcc/objc/ChangeLog
+++ b/gcc/objc/ChangeLog
@@ -1,3 +1,7 @@
+2018-12-06  Release Manager
+
+	* GCC 7.4.0 released.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
diff --git a/gcc/objcp/ChangeLog b/gcc/objcp/ChangeLog
index babdf8c10da..b77e32d421f 100644
--- a/gcc/objcp/ChangeLog
+++ b/gcc/objcp/ChangeLog
@@ -1,3 +1,7 @@
+2018-12-06  Release Manager
+
+	* GCC 7.4.0 released.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
diff --git a/gcc/omp-expand.c b/gcc/omp-expand.c
index a1e668d99d2..549a5db000a 100644
--- a/gcc/omp-expand.c
+++ b/gcc/omp-expand.c
@@ -5628,6 +5628,14 @@ expand_oacc_for (struct omp_region *region, struct omp_for_data *fd)
 
 	  split->flags ^= EDGE_FALLTHRU | EDGE_TRUE_VALUE;
 
+	  /* Add a dummy exit for the tiled block when cont_bb is missing.  */
+	  if (cont_bb == NULL)
+	    {
+	      edge e = make_edge (body_bb, exit_bb, EDGE_FALSE_VALUE);
+	      e->probability = PROB_EVEN;
+	      split->probability = PROB_EVEN;
+	    }
+
 	  /* Initialize the user's loop vars.  */
 	  gsi = gsi_start_bb (elem_body_bb);
 	  expand_oacc_collapse_vars (fd, true, &gsi, counts, e_offset);
diff --git a/gcc/omp-low.c b/gcc/omp-low.c
index 2d1ba3f52c3..2fda4480570 100644
--- a/gcc/omp-low.c
+++ b/gcc/omp-low.c
@@ -1197,13 +1197,16 @@ scan_sharing_clauses (tree clauses, omp_context *ctx,
 	  /* Global variables with "omp declare target" attribute
 	     don't need to be copied, the receiver side will use them
 	     directly.  However, global variables with "omp declare target link"
-	     attribute need to be copied.  */
+	     attribute need to be copied.  Or when ALWAYS modifier is used.  */
 	  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_MAP
 	      && DECL_P (decl)
 	      && ((OMP_CLAUSE_MAP_KIND (c) != GOMP_MAP_FIRSTPRIVATE_POINTER
 		   && (OMP_CLAUSE_MAP_KIND (c)
 		       != GOMP_MAP_FIRSTPRIVATE_REFERENCE))
 		  || TREE_CODE (TREE_TYPE (decl)) == ARRAY_TYPE)
+	      && OMP_CLAUSE_MAP_KIND (c) != GOMP_MAP_ALWAYS_TO
+	      && OMP_CLAUSE_MAP_KIND (c) != GOMP_MAP_ALWAYS_FROM
+	      && OMP_CLAUSE_MAP_KIND (c) != GOMP_MAP_ALWAYS_TOFROM
 	      && is_global_var (maybe_lookup_decl_in_outer_ctx (decl, ctx))
 	      && varpool_node::get_create (decl)->offloadable
 	      && !lookup_attribute ("omp declare target link",
@@ -3261,6 +3264,43 @@ scan_omp (gimple_seq *body_p, omp_context *ctx)
 
 /* Re-gimplification and code generation routines.  */
 
+/* Remove omp_member_access_dummy_var variables from gimple_bind_vars
+   of BIND if in a method.  */
+
+static void
+maybe_remove_omp_member_access_dummy_vars (gbind *bind)
+{
+  if (DECL_ARGUMENTS (current_function_decl)
+      && DECL_ARTIFICIAL (DECL_ARGUMENTS (current_function_decl))
+      && (TREE_CODE (TREE_TYPE (DECL_ARGUMENTS (current_function_decl)))
+	  == POINTER_TYPE))
+    {
+      tree vars = gimple_bind_vars (bind);
+      for (tree *pvar = &vars; *pvar; )
+	if (omp_member_access_dummy_var (*pvar))
+	  *pvar = DECL_CHAIN (*pvar);
+	else
+	  pvar = &DECL_CHAIN (*pvar);
+      gimple_bind_set_vars (bind, vars);
+    }
+}
+
+/* Remove omp_member_access_dummy_var variables from BLOCK_VARS of
+   block and its subblocks.  */
+
+static void
+remove_member_access_dummy_vars (tree block)
+{
+  for (tree *pvar = &BLOCK_VARS (block); *pvar; )
+    if (omp_member_access_dummy_var (*pvar))
+      *pvar = DECL_CHAIN (*pvar);
+    else
+      pvar = &DECL_CHAIN (*pvar);
+
+  for (block = BLOCK_SUBBLOCKS (block); block; block = BLOCK_CHAIN (block))
+    remove_member_access_dummy_vars (block);
+}
+
 /* If a context was created for STMT when it was scanned, return it.  */
 
 static omp_context *
@@ -7002,6 +7042,7 @@ lower_omp_for (gimple_stmt_iterator *gsi_p, omp_context *ctx)
   pop_gimplify_context (new_stmt);
 
   gimple_bind_append_vars (new_stmt, ctx->block_vars);
+  maybe_remove_omp_member_access_dummy_vars (new_stmt);
   BLOCK_VARS (block) = gimple_bind_vars (new_stmt);
   if (BLOCK_VARS (block))
     TREE_USED (block) = 1;
@@ -7100,6 +7141,7 @@ create_task_copyfn (gomp_task *task_stmt, omp_context *ctx)
   splay_tree_node n;
   struct omp_taskcopy_context tcctx;
   location_t loc = gimple_location (task_stmt);
+  size_t looptempno = 0;
 
   child_fn = gimple_omp_task_copy_fn (task_stmt);
   child_cfun = DECL_STRUCT_FUNCTION (child_fn);
@@ -7213,6 +7255,15 @@ create_task_copyfn (gomp_task *task_stmt, omp_context *ctx)
 	t = build2 (MODIFY_EXPR, TREE_TYPE (dst), dst, src);
 	append_to_statement_list (t, &list);
 	break;
+      case OMP_CLAUSE__LOOPTEMP_:
+	/* Fields for first two _looptemp_ clauses are initialized by
+	   GOMP_taskloop*, the rest are handled like firstprivate.  */
+        if (looptempno < 2)
+	  {
+	    looptempno++;
+	    break;
+	  }
+	/* FALLTHRU */
       case OMP_CLAUSE_FIRSTPRIVATE:
 	decl = OMP_CLAUSE_DECL (c);
 	if (is_variable_sized (decl))
@@ -7238,7 +7289,10 @@ create_task_copyfn (gomp_task *task_stmt, omp_context *ctx)
 	  src = decl;
 	dst = build_simple_mem_ref_loc (loc, arg);
 	dst = omp_build_component_ref (dst, f);
-	t = lang_hooks.decls.omp_clause_copy_ctor (c, dst, src);
+	if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE__LOOPTEMP_)
+	  t = build2 (MODIFY_EXPR, TREE_TYPE (dst), dst, src);
+	else
+	  t = lang_hooks.decls.omp_clause_copy_ctor (c, dst, src);
 	append_to_statement_list (t, &list);
 	break;
       case OMP_CLAUSE_PRIVATE:
@@ -7452,6 +7506,7 @@ lower_omp_taskreg (gimple_stmt_iterator *gsi_p, omp_context *ctx)
   /* Declare all the variables created by mapping and the variables
      declared in the scope of the parallel body.  */
   record_vars_into (ctx->block_vars, child_fn);
+  maybe_remove_omp_member_access_dummy_vars (par_bind);
   record_vars_into (gimple_bind_vars (par_bind), child_fn);
 
   if (ctx->record_type)
@@ -7820,6 +7875,7 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)
       /* Declare all the variables created by mapping and the variables
 	 declared in the scope of the target body.  */
       record_vars_into (ctx->block_vars, child_fn);
+      maybe_remove_omp_member_access_dummy_vars (tgt_bind);
       record_vars_into (gimple_bind_vars (tgt_bind), child_fn);
     }
 
@@ -8811,6 +8867,7 @@ lower_omp_1 (gimple_stmt_iterator *gsi_p, omp_context *ctx)
       break;
     case GIMPLE_BIND:
       lower_omp (gimple_bind_body_ptr (as_a <gbind *> (stmt)), ctx);
+      maybe_remove_omp_member_access_dummy_vars (as_a <gbind *> (stmt));
       break;
     case GIMPLE_OMP_PARALLEL:
     case GIMPLE_OMP_TASK:
@@ -9015,6 +9072,16 @@ execute_lower_omp (void)
       all_contexts = NULL;
     }
   BITMAP_FREE (task_shared_vars);
+
+  /* If current function is a method, remove artificial dummy VAR_DECL created
+     for non-static data member privatization, they aren't needed for
+     debuginfo nor anything else, have been already replaced everywhere in the
+     IL and cause problems with LTO.  */
+  if (DECL_ARGUMENTS (current_function_decl)
+      && DECL_ARTIFICIAL (DECL_ARGUMENTS (current_function_decl))
+      && (TREE_CODE (TREE_TYPE (DECL_ARGUMENTS (current_function_decl)))
+	  == POINTER_TYPE))
+    remove_member_access_dummy_vars (DECL_INITIAL (current_function_decl));
   return 0;
 }
 
diff --git a/gcc/optabs.c b/gcc/optabs.c
index 714fac76f3c..9591adaae0c 100644
--- a/gcc/optabs.c
+++ b/gcc/optabs.c
@@ -4294,9 +4294,10 @@ emit_conditional_move (rtx target, enum rtx_code code, rtx op0, rtx op1,
 	  save_pending_stack_adjust (&save);
 	  last = get_last_insn ();
 	  do_pending_stack_adjust ();
+	  machine_mode cmpmode = cmode;
 	  prepare_cmp_insn (XEXP (comparison, 0), XEXP (comparison, 1),
 			    GET_CODE (comparison), NULL_RTX, unsignedp,
-			    OPTAB_WIDEN, &comparison, &cmode);
+			    OPTAB_WIDEN, &comparison, &cmpmode);
 	  if (comparison)
 	    {
 	      struct expand_operand ops[4];
diff --git a/gcc/opts.c b/gcc/opts.c
index f03b57aa343..b98a0ca73a8 100644
--- a/gcc/opts.c
+++ b/gcc/opts.c
@@ -654,7 +654,16 @@ default_options_optimization (struct gcc_options *opts,
   /* For -O1 only do loop invariant motion for very small loops.  */
   maybe_set_param_value
     (PARAM_LOOP_INVARIANT_MAX_BBS_IN_LOOP,
-     opt2 ? default_param_value (PARAM_LOOP_INVARIANT_MAX_BBS_IN_LOOP) : 1000,
+     opt2 ? default_param_value (PARAM_LOOP_INVARIANT_MAX_BBS_IN_LOOP)
+     : default_param_value (PARAM_LOOP_INVARIANT_MAX_BBS_IN_LOOP) / 10,
+     opts->x_param_values, opts_set->x_param_values);
+
+  /* For -O1 reduce the maximum number of active local stores for RTL DSE
+     since this can consume huge amounts of memory (PR89115).  */
+  maybe_set_param_value
+    (PARAM_MAX_DSE_ACTIVE_LOCAL_STORES,
+     opt2 ? default_param_value (PARAM_MAX_DSE_ACTIVE_LOCAL_STORES)
+     : default_param_value (PARAM_MAX_DSE_ACTIVE_LOCAL_STORES) / 10,
      opts->x_param_values, opts_set->x_param_values);
 
   /* At -Ofast, allow store motion to introduce potential race conditions.  */
@@ -1014,6 +1023,26 @@ finish_options (struct gcc_options *opts, struct gcc_options *opts_set,
   if ((opts->x_flag_sanitize & SANITIZE_KERNEL_ADDRESS) && opts->x_flag_tm)
     sorry ("transactional memory is not supported with "
 	   "%<-fsanitize=kernel-address%>");
+
+  /* Comes from final.c -- no real reason to change it.  */
+#define MAX_CODE_ALIGN 16
+#define MAX_CODE_ALIGN_VALUE (1 << MAX_CODE_ALIGN)
+
+  if (opts->x_align_loops > MAX_CODE_ALIGN_VALUE)
+    error_at (loc, "-falign-loops=%d is not between 0 and %d",
+	      opts->x_align_loops, MAX_CODE_ALIGN_VALUE);
+
+  if (opts->x_align_jumps > MAX_CODE_ALIGN_VALUE)
+    error_at (loc, "-falign-jumps=%d is not between 0 and %d",
+	      opts->x_align_jumps, MAX_CODE_ALIGN_VALUE);
+
+  if (opts->x_align_functions > MAX_CODE_ALIGN_VALUE)
+    error_at (loc, "-falign-functions=%d is not between 0 and %d",
+	      opts->x_align_functions, MAX_CODE_ALIGN_VALUE);
+
+  if (opts->x_align_labels > MAX_CODE_ALIGN_VALUE)
+    error_at (loc, "-falign-labels=%d is not between 0 and %d",
+	      opts->x_align_labels, MAX_CODE_ALIGN_VALUE);
 }
 
 #define LEFT_COLUMN	27
diff --git a/gcc/params.def b/gcc/params.def
index 6b07518a34b..9c83b0af3ef 100644
--- a/gcc/params.def
+++ b/gcc/params.def
@@ -344,11 +344,11 @@ DEFPARAM(PARAM_MAX_UNSWITCH_LEVEL,
 	"The maximum number of unswitchings in a single loop.",
 	3, 0, 0)
 
-/* The maximum number of insns in loop header duplicated by he copy loop
+/* The maximum number of insns in loop header duplicated by the copy loop
    headers pass.  */
 DEFPARAM(PARAM_MAX_LOOP_HEADER_INSNS,
 	"max-loop-header-insns",
-	"The maximum number of insns in loop header duplicated by he copy loop headers pass.",
+	"The maximum number of insns in loop header duplicated by the copy loop headers pass.",
 	20, 0, 0)
 
 /* The maximum number of iterations of a loop the brute force algorithm
diff --git a/gcc/po/ChangeLog b/gcc/po/ChangeLog
index b8ed7deef96..233c5fd9005 100644
--- a/gcc/po/ChangeLog
+++ b/gcc/po/ChangeLog
@@ -1,3 +1,7 @@
+2018-12-06  Release Manager
+
+	* GCC 7.4.0 released.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
diff --git a/gcc/postreload.c b/gcc/postreload.c
index e721f2f867d..d60875a257b 100644
--- a/gcc/postreload.c
+++ b/gcc/postreload.c
@@ -1160,11 +1160,13 @@ reload_combine_recognize_pattern (rtx_insn *insn)
 	     value in PREV, the constant loading instruction.  */
 	  validate_change (prev, &SET_DEST (prev_set), index_reg, 1);
 	  if (reg_state[regno].offset != const0_rtx)
-	    validate_change (prev,
-			     &SET_SRC (prev_set),
-			     GEN_INT (INTVAL (SET_SRC (prev_set))
-				      + INTVAL (reg_state[regno].offset)),
-			     1);
+	    {
+	      HOST_WIDE_INT c
+		= trunc_int_for_mode (UINTVAL (SET_SRC (prev_set))
+				      + UINTVAL (reg_state[regno].offset),
+				      GET_MODE (index_reg));
+	      validate_change (prev, &SET_SRC (prev_set), GEN_INT (c), 1);
+	    }
 
 	  /* Now for every use of REG that we have recorded, replace REG
 	     with REG_SUM.  */
diff --git a/gcc/regcprop.c b/gcc/regcprop.c
index 367d85a7e24..cf7ab901614 100644
--- a/gcc/regcprop.c
+++ b/gcc/regcprop.c
@@ -854,6 +854,12 @@ copyprop_hardreg_forward_1 (basic_block bb, struct value_data *vd)
 		  && reg_overlap_mentioned_p (XEXP (link, 0), SET_SRC (set)))
 		set = NULL;
 	    }
+
+	  /* We need to keep CFI info correct, and the same on all paths,
+	     so we cannot normally replace the registers REG_CFA_REGISTER
+	     refers to.  Bail.  */
+	  if (REG_NOTE_KIND (link) == REG_CFA_REGISTER)
+	    goto did_replacement;
 	}
 
       /* Special-case plain move instructions, since we may well
diff --git a/gcc/regrename.c b/gcc/regrename.c
index 58036644fc6..7f2408a94df 100644
--- a/gcc/regrename.c
+++ b/gcc/regrename.c
@@ -1656,7 +1656,8 @@ build_def_use (basic_block bb)
 	     (6) For any non-earlyclobber write we find in an operand, make
 	         a new chain or mark the hard register as live.
 	     (7) For any REG_UNUSED, close any chains we just opened.
-	     (8) For any REG_CFA_RESTORE, kill any chain containing it.
+	     (8) For any REG_CFA_RESTORE or REG_CFA_REGISTER, kill any chain
+	         containing its dest.
 
 	     We cannot deal with situations where we track a reg in one mode
 	     and see a reference in another mode; these will cause the chain
@@ -1871,10 +1872,20 @@ build_def_use (basic_block bb)
 	      }
 
 	  /* Step 8: Kill the chains involving register restores.  Those
-	     should restore _that_ register.  */
+	     should restore _that_ register.  Similar for REG_CFA_REGISTER.  */
 	  for (note = REG_NOTES (insn); note; note = XEXP (note, 1))
-	    if (REG_NOTE_KIND (note) == REG_CFA_RESTORE)
-	      scan_rtx (insn, &XEXP (note, 0), NO_REGS, mark_all_read, OP_IN);
+	    if (REG_NOTE_KIND (note) == REG_CFA_RESTORE
+		|| REG_NOTE_KIND (note) == REG_CFA_REGISTER)
+	      {
+		rtx *x = &XEXP (note, 0);
+		if (!*x)
+		  x = &PATTERN (insn);
+		if (GET_CODE (*x) == PARALLEL)
+		  x = &XVECEXP (*x, 0, 0);
+		if (GET_CODE (*x) == SET)
+		  x = &SET_DEST (*x);
+		scan_rtx (insn, x, NO_REGS, mark_all_read, OP_IN);
+	      }
 	}
       else if (DEBUG_INSN_P (insn)
 	       && !VAR_LOC_UNKNOWN_P (INSN_VAR_LOCATION_LOC (insn)))
diff --git a/gcc/reorg.c b/gcc/reorg.c
index 19bb65bcfb1..c8568c77222 100644
--- a/gcc/reorg.c
+++ b/gcc/reorg.c
@@ -1035,7 +1035,8 @@ check_annul_list_true_false (int annul_true_p,
 
 static void
 steal_delay_list_from_target (rtx_insn *insn, rtx condition, rtx_sequence *seq,
-			      vec<rtx_insn *> *delay_list, resources *sets,
+			      vec<rtx_insn *> *delay_list,
+			      struct resources *sets,
 			      struct resources *needed,
 			      struct resources *other_needed,
 			      int slots_to_fill, int *pslots_filled,
@@ -1048,7 +1049,7 @@ steal_delay_list_from_target (rtx_insn *insn, rtx condition, rtx_sequence *seq,
   int used_annul = 0;
   int i;
   struct resources cc_set;
-  bool *redundant;
+  rtx_insn **redundant;
 
   /* We can't do anything if there are more delay slots in SEQ than we
      can handle, or if we don't know that it will be a taken branch.
@@ -1087,7 +1088,7 @@ steal_delay_list_from_target (rtx_insn *insn, rtx condition, rtx_sequence *seq,
   if (! targetm.can_follow_jump (insn, seq->insn (0)))
     return;
 
-  redundant = XALLOCAVEC (bool, XVECLEN (seq, 0));
+  redundant = XALLOCAVEC (rtx_insn *, XVECLEN (seq, 0));
   for (i = 1; i < seq->len (); i++)
     {
       rtx_insn *trial = seq->insn (i);
@@ -1151,7 +1152,10 @@ steal_delay_list_from_target (rtx_insn *insn, rtx condition, rtx_sequence *seq,
      we therefore decided not to copy.  */
   for (i = 1; i < seq->len (); i++)
     if (redundant[i])
-      update_block (seq->insn (i), insn);
+      {
+	fix_reg_dead_note (redundant[i], insn);
+	update_block (seq->insn (i), insn);
+      }
 
   /* Show the place to which we will be branching.  */
   *pnew_thread = first_active_target_insn (JUMP_LABEL (seq->insn (0)));
@@ -1198,6 +1202,7 @@ steal_delay_list_from_fallthrough (rtx_insn *insn, rtx condition,
   for (i = 1; i < seq->len (); i++)
     {
       rtx_insn *trial = seq->insn (i);
+      rtx_insn *prior_insn;
 
       /* If TRIAL sets CC0, stealing it will move it too far from the use
 	 of CC0.  */
@@ -1209,8 +1214,9 @@ steal_delay_list_from_fallthrough (rtx_insn *insn, rtx condition,
 	break;
 
       /* If this insn was already done, we don't need it.  */
-      if (redundant_insn (trial, insn, *delay_list))
+      if ((prior_insn = redundant_insn (trial, insn, *delay_list)))
 	{
+	  fix_reg_dead_note (prior_insn, insn);
 	  update_block (trial, insn);
 	  delete_from_delay_slot (trial);
 	  continue;
@@ -1790,15 +1796,14 @@ fix_reg_dead_note (rtx_insn *start_insn, rtx stop_insn)
       }
 }
 
-/* Delete any REG_UNUSED notes that exist on INSN but not on REDUNDANT_INSN.
+/* Delete any REG_UNUSED notes that exist on INSN but not on OTHER_INSN.
 
    This handles the case of udivmodXi4 instructions which optimize their
-   output depending on whether any REG_UNUSED notes are present.
-   we must make sure that INSN calculates as many results as REDUNDANT_INSN
-   does.  */
+   output depending on whether any REG_UNUSED notes are present.  We must
+   make sure that INSN calculates as many results as OTHER_INSN does.  */
 
 static void
-update_reg_unused_notes (rtx_insn *insn, rtx redundant_insn)
+update_reg_unused_notes (rtx_insn *insn, rtx other_insn)
 {
   rtx link, next;
 
@@ -1810,8 +1815,7 @@ update_reg_unused_notes (rtx_insn *insn, rtx redundant_insn)
 	  || !REG_P (XEXP (link, 0)))
 	continue;
 
-      if (! find_regno_note (redundant_insn, REG_UNUSED,
-			     REGNO (XEXP (link, 0))))
+      if (!find_regno_note (other_insn, REG_UNUSED, REGNO (XEXP (link, 0))))
 	remove_note (insn, link);
     }
 }
@@ -2324,9 +2328,8 @@ follow_jumps (rtx label, rtx_insn *jump, bool *crossing)
    taken and THREAD_IF_TRUE is set.  This is used for the branch at the
    end of a loop back up to the top.
 
-   OWN_THREAD and OWN_OPPOSITE_THREAD are true if we are the only user of the
-   thread.  I.e., it is the fallthrough code of our jump or the target of the
-   jump when we are the only jump going there.
+   OWN_THREAD is true if we are the only user of the thread, i.e. it is
+   the target of the jump when we are the only jump going there.
 
    If OWN_THREAD is false, it must be the "true" thread of a jump.  In that
    case, we can only take insns from the head of the thread for our delay
@@ -3117,7 +3120,7 @@ relax_delay_slots (rtx_insn *first)
   /* Look at every JUMP_INSN and see if we can improve it.  */
   for (insn = first; insn; insn = next)
     {
-      rtx_insn *other;
+      rtx_insn *other, *prior_insn;
       bool crossing;
 
       next = next_active_insn (insn);
@@ -3223,8 +3226,9 @@ relax_delay_slots (rtx_insn *first)
       /* See if the first insn in the delay slot is redundant with some
 	 previous insn.  Remove it from the delay slot if so; then set up
 	 to reprocess this insn.  */
-      if (redundant_insn (pat->insn (1), delay_insn, vNULL))
+      if ((prior_insn = redundant_insn (pat->insn (1), delay_insn, vNULL)))
 	{
+	  fix_reg_dead_note (prior_insn, insn);
 	  update_block (pat->insn (1), insn);
 	  delete_from_delay_slot (pat->insn (1));
 	  next = prev_active_insn (next);
diff --git a/gcc/rtl.h b/gcc/rtl.h
index 93330425c00..e6eeea55bdf 100644
--- a/gcc/rtl.h
+++ b/gcc/rtl.h
@@ -3666,6 +3666,9 @@ extern void init_lower_subreg (void);
 /* In gcse.c */
 extern bool can_copy_p (machine_mode);
 extern bool can_assign_to_reg_without_clobbers_p (rtx, machine_mode);
+extern rtx_insn *prepare_copy_insn (rtx, rtx);
+
+/* In cprop.c */
 extern rtx fis_get_condition (rtx_insn *);
 
 /* In ira.c */
@@ -3832,6 +3835,25 @@ load_extend_op (machine_mode mode)
   return UNKNOWN;
 }
 
+/* Return true if X is an operation that always operates on the full
+   registers for WORD_REGISTER_OPERATIONS architectures.  */
+
+inline bool
+word_register_operation_p (const_rtx x)
+{
+  switch (GET_CODE (x))
+    {
+    case ROTATE:
+    case ROTATERT:
+    case SIGN_EXTRACT:
+    case ZERO_EXTRACT:
+      return false;
+    
+    default:
+      return true;
+    }
+}
+    
 /* gtype-desc.c.  */
 extern void gt_ggc_mx (rtx &);
 extern void gt_pch_nx (rtx &);
diff --git a/gcc/rtlanal.c b/gcc/rtlanal.c
index 772a6a993bb..5642c0d6fcf 100644
--- a/gcc/rtlanal.c
+++ b/gcc/rtlanal.c
@@ -357,10 +357,10 @@ get_initial_register_offset (int from, int to)
   if (to == from)
     return 0;
 
-  /* It is not safe to call INITIAL_ELIMINATION_OFFSET
-     before the reload pass.  We need to give at least
-     an estimation for the resulting frame size.  */
-  if (! reload_completed)
+  /* It is not safe to call INITIAL_ELIMINATION_OFFSET before the epilogue
+     is completed, but we need to give at least an estimate for the stack
+     pointer based on the frame size.  */
+  if (!epilogue_completed)
     {
       offset1 = crtl->outgoing_args_size + get_frame_size ();
 #if !STACK_GROWS_DOWNWARD
@@ -4339,14 +4339,14 @@ nonzero_bits1 (const_rtx x, machine_mode mode, const_rtx known_x,
      might be nonzero in its own mode, taking into account the fact that, on
      CISC machines, accessing an object in a wider mode generally causes the
      high-order bits to become undefined, so they are not known to be zero.
-     We extend this reasoning to RISC machines for rotate operations since the
-     semantics of the operations in the larger mode is not well defined.  */
+     We extend this reasoning to RISC machines for operations that might not
+     operate on the full registers.  */
   if (GET_MODE (x) != VOIDmode
       && GET_MODE (x) != mode
       && GET_MODE_PRECISION (GET_MODE (x)) <= BITS_PER_WORD
       && GET_MODE_PRECISION (GET_MODE (x)) <= HOST_BITS_PER_WIDE_INT
       && GET_MODE_PRECISION (mode) > GET_MODE_PRECISION (GET_MODE (x))
-      && (!WORD_REGISTER_OPERATIONS || code == ROTATE))
+      && !(WORD_REGISTER_OPERATIONS && word_register_operation_p (x)))
     {
       nonzero &= cached_nonzero_bits (x, GET_MODE (x),
 				      known_x, known_mode, known_ret);
@@ -4623,13 +4623,16 @@ nonzero_bits1 (const_rtx x, machine_mode mode, const_rtx known_x,
 	  nonzero &= cached_nonzero_bits (SUBREG_REG (x), mode,
 					  known_x, known_mode, known_ret);
 
-          /* On many CISC machines, accessing an object in a wider mode
+          /* On a typical CISC machine, accessing an object in a wider mode
 	     causes the high-order bits to become undefined.  So they are
-	     not known to be zero.  */
+	     not known to be zero.
+
+	     On a typical RISC machine, we only have to worry about the way
+	     loads are extended.  Otherwise, if we get a reload for the inner
+	     part, it may be loaded from the stack, and then we may lose all
+	     the zero bits that existed before the store to the stack.  */
 	  rtx_code extend_op;
 	  if ((!WORD_REGISTER_OPERATIONS
-	       /* If this is a typical RISC machine, we only have to worry
-		  about the way loads are extended.  */
 	       || ((extend_op = load_extend_op (inner_mode)) == SIGN_EXTEND
 		   ? val_signbit_known_set_p (inner_mode, nonzero)
 		   : extend_op != ZERO_EXTEND)
@@ -4872,10 +4875,9 @@ num_sign_bit_copies1 (const_rtx x, machine_mode mode, const_rtx known_x,
     {
       /* If this machine does not do all register operations on the entire
 	 register and MODE is wider than the mode of X, we can say nothing
-	 at all about the high-order bits.  We extend this reasoning to every
-	 machine for rotate operations since the semantics of the operations
-	 in the larger mode is not well defined.  */
-      if (!WORD_REGISTER_OPERATIONS || code == ROTATE || code == ROTATERT)
+	 at all about the high-order bits.  We extend this reasoning to RISC
+	 machines for operations that might not operate on full registers.  */
+      if (!(WORD_REGISTER_OPERATIONS && word_register_operation_p (x)))
 	return 1;
 
       /* Likewise on machines that do, if the mode of the object is smaller
@@ -4965,10 +4967,10 @@ num_sign_bit_copies1 (const_rtx x, machine_mode mode, const_rtx known_x,
 
       /* For paradoxical SUBREGs on machines where all register operations
 	 affect the entire register, just look inside.  Note that we are
-	 passing MODE to the recursive call, so the number of sign bit copies
-	 will remain relative to that mode, not the inner mode.  */
+	 passing MODE to the recursive call, so the number of sign bit
+	 copies will remain relative to that mode, not the inner mode.
 
-      /* This works only if loads sign extend.  Otherwise, if we get a
+         This works only if loads sign extend.  Otherwise, if we get a
 	 reload for the inner part, it may be loaded from the stack, and
 	 then we lose all sign bit copies that existed before the store
 	 to the stack.  */
diff --git a/gcc/sched-deps.c b/gcc/sched-deps.c
index b2393bf28fb..d54c69eaa98 100644
--- a/gcc/sched-deps.c
+++ b/gcc/sched-deps.c
@@ -2851,9 +2851,11 @@ sched_macro_fuse_insns (rtx_insn *insn)
     {
       rtx insn_set = single_set (insn);
 
+      if (!insn_set)
+	return;
+
       prev = prev_nonnote_nondebug_insn (insn);
       if (!prev
-          || !insn_set
           || !single_set (prev))
         return;
 
@@ -2920,6 +2922,8 @@ sched_analyze_insn (struct deps_desc *deps, rtx x, rtx_insn *insn)
 	= alloc_INSN_LIST (insn, deps->sched_before_next_jump);
 
       /* Make sure epilogue insn is scheduled after preceding jumps.  */
+      add_dependence_list (insn, deps->last_pending_memory_flush, 1,
+			   REG_DEP_ANTI, true);
       add_dependence_list (insn, deps->pending_jump_insns, 1, REG_DEP_ANTI,
 			   true);
     }
diff --git a/gcc/shrink-wrap.c b/gcc/shrink-wrap.c
index 35eb85ba63c..083eebc257c 100644
--- a/gcc/shrink-wrap.c
+++ b/gcc/shrink-wrap.c
@@ -157,7 +157,7 @@ move_insn_for_shrink_wrap (basic_block bb, rtx_insn *insn,
 			   struct dead_debug_local *debug)
 {
   rtx set, src, dest;
-  bitmap live_out, live_in, bb_uses, bb_defs;
+  bitmap live_out, live_in, bb_uses = NULL, bb_defs = NULL;
   unsigned int i, dregno, end_dregno;
   unsigned int sregno = FIRST_PSEUDO_REGISTER;
   unsigned int end_sregno = FIRST_PSEUDO_REGISTER;
@@ -330,8 +330,11 @@ move_insn_for_shrink_wrap (basic_block bb, rtx_insn *insn,
       /* Check whether BB uses DEST or clobbers DEST.  We need to add
 	 INSN to BB if so.  Either way, DEST is no longer live on entry,
 	 except for any part that overlaps SRC (next loop).  */
-      bb_uses = &DF_LR_BB_INFO (bb)->use;
-      bb_defs = &DF_LR_BB_INFO (bb)->def;
+      if (!*split_p)
+	{
+	  bb_uses = &DF_LR_BB_INFO (bb)->use;
+	  bb_defs = &DF_LR_BB_INFO (bb)->def;
+	}
       if (df_live)
 	{
 	  for (i = dregno; i < end_dregno; i++)
@@ -1374,6 +1377,8 @@ spread_components (sbitmap components)
       bitmap_clear_bit (seen, bb->index);
     }
 
+  todo.release ();
+
   /* Finally, mark everything not not needed both forwards and backwards.  */
 
   FOR_EACH_BB_FN (bb, cfun)
diff --git a/gcc/simplify-rtx.c b/gcc/simplify-rtx.c
index 02ebe389d40..5a9a38728b5 100644
--- a/gcc/simplify-rtx.c
+++ b/gcc/simplify-rtx.c
@@ -3299,7 +3299,8 @@ simplify_binary_operation_1 (enum rtx_code code, machine_mode mode,
       if (CONST_INT_P (trueop1)
 	  && exact_log2 (UINTVAL (trueop1)) > 0)
 	return simplify_gen_binary (AND, mode, op0,
-				    gen_int_mode (INTVAL (op1) - 1, mode));
+				    gen_int_mode (UINTVAL (trueop1) - 1,
+						  mode));
       break;
 
     case MOD:
diff --git a/gcc/stor-layout.c b/gcc/stor-layout.c
index 10e9a324940..cfe876c1dc1 100644
--- a/gcc/stor-layout.c
+++ b/gcc/stor-layout.c
@@ -1526,6 +1526,30 @@ place_field (record_layout_info rli, tree field)
 	= size_binop (PLUS_EXPR, rli->offset, DECL_SIZE_UNIT (field));
       rli->bitpos = bitsize_zero_node;
       rli->offset_align = MIN (rli->offset_align, desired_align);
+
+      if (!multiple_of_p (bitsizetype, DECL_SIZE (field),
+			  bitsize_int (rli->offset_align)))
+	{
+	  tree type = strip_array_types (TREE_TYPE (field));
+	  /* The above adjusts offset_align just based on the start of the
+	     field.  The field might not have a size that is a multiple of
+	     that offset_align though.  If the field is an array of fixed
+	     sized elements, assume there can be any multiple of those
+	     sizes.  If it is a variable length aggregate or array of
+	     variable length aggregates, assume worst that the end is
+	     just BITS_PER_UNIT aligned.  */
+	  if (TREE_CODE (TYPE_SIZE (type)) == INTEGER_CST)
+	    {
+	      if (TREE_INT_CST_LOW (TYPE_SIZE (type)))
+		{
+		  unsigned HOST_WIDE_INT sz
+		    = least_bit_hwi (TREE_INT_CST_LOW (TYPE_SIZE (type)));
+		  rli->offset_align = MIN (rli->offset_align, sz);
+		}
+	    }
+	  else
+	    rli->offset_align = MIN (rli->offset_align, BITS_PER_UNIT);
+	}
     }
   else if (targetm.ms_bitfield_layout_p (rli->t))
     {
diff --git a/gcc/store-motion.c b/gcc/store-motion.c
index 927de1b1a91..8c7e0df975f 100644
--- a/gcc/store-motion.c
+++ b/gcc/store-motion.c
@@ -907,8 +907,7 @@ replace_store_insn (rtx reg, rtx_insn *del, basic_block bb,
   rtx_insn *insn;
   rtx mem, note, set;
 
-  mem = smexpr->pattern;
-  insn = gen_move_insn (reg, SET_SRC (single_set (del)));
+  insn = prepare_copy_insn (reg, SET_SRC (single_set (del)));
 
   unsigned int i;
   rtx_insn *temp;
@@ -941,6 +940,7 @@ replace_store_insn (rtx reg, rtx_insn *del, basic_block bb,
   /* Now we must handle REG_EQUAL notes whose contents is equal to the mem;
      they are no longer accurate provided that they are reached by this
      definition, so drop them.  */
+  mem = smexpr->pattern;
   for (; insn != NEXT_INSN (BB_END (bb)); insn = NEXT_INSN (insn))
     if (NONDEBUG_INSN_P (insn))
       {
diff --git a/gcc/symtab.c b/gcc/symtab.c
index 342cc36f3af..c18f1b25199 100644
--- a/gcc/symtab.c
+++ b/gcc/symtab.c
@@ -35,6 +35,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "output.h"
 #include "ipa-utils.h"
 #include "calls.h"
+#include "builtins.h"
 
 static const char *ipa_ref_use_name[] = {"read","write","addr","alias","chkp"};
 
@@ -2279,3 +2280,58 @@ symtab_node::binds_to_current_def_p (symtab_node *ref)
 
   return false;
 }
+
+/* Return true if symbol should be output to the symbol table.  */
+
+bool
+symtab_node::output_to_lto_symbol_table_p (void)
+{
+  /* Only externally visible symbols matter.  */
+  if (!TREE_PUBLIC (decl))
+    return false;
+  if (!real_symbol_p ())
+    return false;
+  /* FIXME: variables probably should not be considered as real symbols at
+     first place.  */
+  if (VAR_P (decl) && DECL_HARD_REGISTER (decl))
+    return false;
+  /* FIXME: Builtins corresponding to real functions probably should have
+     symbol table entries.  */
+  if (is_builtin_fn (decl))
+    return false;
+
+  /* We have real symbol that should be in symbol table.  However try to trim
+     down the refernces to libraries bit more because linker will otherwise
+     bring unnecesary object files into the final link.
+     FIXME: The following checks can easily be confused i.e. by self recursive
+     function or self-referring variable.  */
+
+  /* We keep external functions in symtab for sake of inlining
+     and devirtualization.  We do not want to see them in symbol table as
+     references unless they are really used.  */
+  cgraph_node *cnode = dyn_cast <cgraph_node *> (this);
+  if (cnode && (!definition || DECL_EXTERNAL (decl))
+      && cnode->callers)
+    return true;
+
+ /* Ignore all references from external vars initializers - they are not really
+    part of the compilation unit until they are used by folding.  Some symbols,
+    like references to external construction vtables can not be referred to at
+    all.  We decide this at can_refer_decl_in_current_unit_p.  */
+ if (!definition || DECL_EXTERNAL (decl))
+    {
+      int i;
+      struct ipa_ref *ref;
+      for (i = 0; iterate_referring (i, ref); i++)
+	{
+	  if (ref->use == IPA_REF_ALIAS)
+	    continue;
+          if (is_a <cgraph_node *> (ref->referring))
+	    return true;
+	  if (!DECL_EXTERNAL (ref->referring->decl))
+	    return true;
+	}
+      return false;
+    }
+  return true;
+}
diff --git a/gcc/testsuite/ChangeLog b/gcc/testsuite/ChangeLog
index 429f51c1983..67b3f93f83d 100644
--- a/gcc/testsuite/ChangeLog
+++ b/gcc/testsuite/ChangeLog
@@ -1,3 +1,2894 @@
+2019-05-13  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	Backport from mainline.
+	2019-05-06  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	PR target/89424
+	* gcc.target/powerpc/pr89424-0.c: New test.
+	* gcc.target/powerpc/vsx-builtin-13a.c: Define macro PR89424 to
+	enable testing of newly patched capability.
+	* gcc.target/powerpc/vsx-builtin-13b.c: Likewise.
+	* gcc.target/powerpc/vsx-builtin-20a.c: Likewise.
+	* gcc.target/powerpc/vsx-builtin-20b.c: Likewise.
+
+2019-05-07  Richard Sandiford  <richard.sandiford@arm.com>
+
+	Backport from mainline:
+	2019-01-25  Richard Sandiford  <richard.sandiford@arm.com>
+
+	PR middle-end/89037
+	* gcc.dg/pr89037.c: New test.
+
+2019-05-05  Thomas Koenig <tkoenig@gcc.gnu.org>
+
+	PR fortran/90344
+	* gfortran.dg/pr90344.f90: New test
+
+2019-04-30  Srinath Parvathaneni  <srinath.parvathaneni@arm.com>
+
+	PR target/90075
+	* gcc.target/aarch64/pr90075.c: New test.
+
+2019-04-25  Xiong Hu Luo  <luoxhu@linux.ibm.com>
+
+	* gcc.target/powerpc/vsx-vector-6.p8.c: Fix failure caused by typo.
+
+2019-04-22  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	Backport from mainline
+	2019-03-15  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	PR target/87532
+	* gcc.target/powerpc/pr87532-mc.c: New test.
+	* gcc.target/powerpc/pr87532.c: New test.
+	* gcc.target/powerpc/vec-extract-v16qiu-v2.h: New test.
+	* gcc.target/powerpc/vec-extract-v16qiu-v2a.c: New test.
+	* gcc.target/powerpc/vec-extract-v16qiu-v2b.c: New test.
+	* gcc.target/powerpc/vsx-builtin-10a.c: New test.
+	* gcc.target/powerpc/vsx-builtin-10b.c: New test.
+	* gcc.target/powerpc/vsx-builtin-11a.c: New test.
+	* gcc.target/powerpc/vsx-builtin-11b.c: New test.
+	* gcc.target/powerpc/vsx-builtin-12a.c: New test.
+	* gcc.target/powerpc/vsx-builtin-12b.c: New test.
+	* gcc.target/powerpc/vsx-builtin-13a.c: New test.
+	* gcc.target/powerpc/vsx-builtin-13b.c: New test.
+	* gcc.target/powerpc/vsx-builtin-14a.c: New test.
+	* gcc.target/powerpc/vsx-builtin-14b.c: New test.
+	* gcc.target/powerpc/vsx-builtin-15a.c: New test.
+	* gcc.target/powerpc/vsx-builtin-15b.c: New test.
+	* gcc.target/powerpc/vsx-builtin-16a.c: New test.
+	* gcc.target/powerpc/vsx-builtin-16b.c: New test.
+	* gcc.target/powerpc/vsx-builtin-17a.c: New test.
+	* gcc.target/powerpc/vsx-builtin-17b.c: New test.
+	* gcc.target/powerpc/vsx-builtin-18a.c: New test.
+	* gcc.target/powerpc/vsx-builtin-18b.c: New test.
+	* gcc.target/powerpc/vsx-builtin-19a.c: New test.
+	* gcc.target/powerpc/vsx-builtin-19b.c: New test.
+	* gcc.target/powerpc/vsx-builtin-20a.c: New test.
+	* gcc.target/powerpc/vsx-builtin-20b.c: New test.
+	* gcc.target/powerpc/vsx-builtin-9a.c: New test.
+	* gcc.target/powerpc/vsx-builtin-9b.c: New test.
+
+	2019-03-19  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	PR target/89736
+	* gcc.target/powerpc/pr87532-mc.c: Modify dejagnu directives to
+	restrict this test to vsx targets.
+
+2019-04-19  Xiong Hu Luo  <luoxhu@linux.ibm.com>
+
+	Backport from trunk
+	2018-02-07  Will Schmidt  <will_schmidt@vnet.ibm.com>
+
+	* gcc.target/powerpc/vsx-vector-6-le.c: Update CPU target.
+	* gcc.target/powerpc/vsx-vector-6-le.p9.c: New.
+
+	Backport from trunk
+	2018-05-04  Carl Love  <cel@us.ibm.com>
+	* gcc.target/powerpc/vsx-vector-6.h (foo): Add test for vec_max,
+	vec_trunc.
+	* gcc.target/powerpc/vsx-vector-6-le.c (dg-final): Update xvcmpeqdp,
+	xvcmpgtdp, xvcmpgedp counts. Add xxsel counts.
+	* gcc.target/powerpc/vsx-vector-6-be.c (dg-final): Update xvcmpgtdp,
+	xvcmpgedp counts. Add xxsel counts.
+
+	Backport from trunk
+	2018-05-16  Carl Love  <cel@us.ibm.com>
+	* gcc.target/powerpc/vsx-vector-6-be.c: Remove file.
+	* gcc.target/powerpc/vsx-vector-6-be.p7.c: New test file.
+	* gcc.target/powerpc/vsx-vector-6-be.p8.c: New test file.
+	* gcc.target/powerpc/vsx-vector-6-le.c (dg-final): Update counts for
+	xvcmpeqdp., xvcmpgtdp., xvcmpgedp., xxlxor, xvrdpi.
+
+	Backport from trunk
+	2018-05-23  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	* lib/target-supports.exp (check_effective_target_be): New.
+	(check_effective_target_le): New.
+
+	Backport from trunk
+	2018-06-01  Carl Love  <cel@us.ibm.com>
+
+	* gcc.target/powerpc/altivec-7-be.c: Delete file.
+	* gcc.target/powerpc/altivec-7-le.c: Delete file.
+	* gcc.target/powerpc/vsx-7-be.c: Remove file.
+
+	Backport from trunk
+	2018-06-01  Carl Love  <cel@us.ibm.com>
+
+	Commit 260294 on 2018-05-16 by Carl Love was supposed to add the
+	following files.
+
+	* gcc.target/powerpc/vsx-vector-6-be.p7.c: New test file.
+	* gcc.target/powerpc/vsx-vector-6-be.p8.c: New test file.
+
+	Backport from trunk
+	2018-06-08  Carl Love  <cel@us.ibm.com>
+
+	* gcc.target/powerpc/vsx-vector-6-be.p7.c: Rename this file to
+	vsx-vector-6.p7.c.
+	* gcc.target/powerpc/vsx-vector-6-le.p9.c: Rename this file to
+	vsx-vector-6.p9.c.
+	* gcc.target/powerpc/vsx-vector-6-be.p8.c: Move instruction counts
+	for BE system that are different then for an LE system from this file
+	into vsx-vector-6-le.c using be target qualifier.  Remove this file.
+	* gcc.target/powerpc/vsx-vector-6-le.c: Add le qualifiers as needed for
+	the various instruction counts.  Rename file to vsx-vector-6.p8.c.
+
+	Backport from trunk
+	2019-02-06  Bill Seurer  <seurer@linux.vnet.ibm.com>
+
+	* gcc.target/powerpc/vsx-vector-6.p7.c: Update instruction
+	counts and target.
+	* gcc.target/powerpc/vsx-vector-6.p8.c: Update instruction
+	counts and target.
+	* gcc.target/powerpc/vsx-vector-6.p9.c: Update instruction
+	counts and target.
+
+2019-04-14  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/87352
+	* gfortran.dg/finalize_28.f90: Adjust count of __builtin_free.
+	* gfortran.dg/finalize_34.f90: New test.
+
+2019-04-14  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/87352
+	* gfortran.dg/finalize_28.f90: Adjust count of __builtin_free.
+	* gfortran.dg/finalize_34.f90: New test.
+
+2019-04-11  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2019-03-08  Martin Liska  <mliska@suse.cz>
+
+	PR target/86952
+	* gcc.target/i386/pr86952.c: New test.
+	* gcc.target/i386/indirect-thunk-7.c: Use jump tables to match
+	scanned pattern.
+	* gcc.target/i386/indirect-thunk-inline-7.c: Likewise.
+
+2019-04-10  Harald Anlauf  <anlauf@gmx.de>
+
+	Backport from trunk
+	PR fortran/89904
+	* gfortran.dg/pr85797.f90: Adjust testcase.
+
+2019-04-10  Matthew Malcomson  <matthew.malcomson@arm.com>
+
+	PR target/90024
+	* gcc.dg/torture/neon-immediate-timode.c: New test.
+
+2019-04-07  Uroš Bizjak  <ubizjak@gmail.com>
+
+	PR target/89945
+	* gcc.target/i386/pr89945.c: New test.
+
+2019-04-06  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gnat.dg/opt73.adb: New test.
+
+2019-04-02  Xiong Hu Luo <luoxhu@linux.ibm.com>
+
+	Backport from trunk r250477.
+
+	2017-07-24  Carl Love  <cel@us.ibm.com>
+
+	* gcc.target/powerpc/builtins-3-p9-runnable.c: Add new test file for
+	the new built-ins.
+
+	Backport from trunk r255555.
+
+	2017-12-11  Carl Love  <cel@us.ibm.com>
+	* gcc.target/powerpc/altivec-7.c: Renamed altivec-7.h.
+	* gcc.target/powerpc/altivec-7.h (main): Add testcases for vec_unpackl.
+	Add dg-final tests for the instructions generated.
+	* gcc.target/powerpc/altivec-7-be.c: New file to test on big endian.
+	* gcc.target/powerpc/altivec-7-le.c: New file to test on little endian.
+	* gcc.target/powerpc/altivec-13.c (foo): Add vec_sld, vec_srl,
+	 vec_sro testcases. Add dg-final tests for the instructions generated.
+	* gcc.target/powerpc/builtins-3-p8.c (test_vsi_packs_vui,
+	test_vsi_packs_vsi, test_vsi_packs_vssi, test_vsi_packs_vusi,
+	test_vsi_packsu-vssi, test_vsi_packsu-vusi, test_vsi_packsu-vsll,
+	test_vsi_packsu-vull, test_vsi_packsu-vsi, test_vsi_packsu-vui): Add
+	testcases. Add dg-final tests for new instructions.
+	* gcc.target/powerpc/p8vector-builtin-2.c (vbschar_eq, vbchar_eq,
+	vuchar_eq, vbint_eq, vsint_eq, viint_eq, vuint_eq, vbool_eq, vbint_ne,
+	vsint_ne, vuint_ne, vbool_ne, vsign_ne, vuns_ne, vbshort_ne): Add
+	tests.
+	Add dg-final instruction tests.
+	* gcc.target/powerpc/vsx-vector-6.c: Renamed vsx-vector-6.h.
+	* gcc.target/powerpc/vsx-vector-6.h (vec_andc,vec_nmsub, vec_nmadd,
+	vec_or, vec_nor, vec_andc, vec_or, vec_andc, vec_msums): Add tests.
+	Add dg-final tests for the generated instructions.
+	* gcc.target/powerpc/builtins-3.c (test_sll_vsc_vsc_vsuc,
+	test_sll_vuc_vuc, test_sll_vsi_vsi_vuc, test_sll_vui_vui_vuc,
+	test_sll_vbll_vull, test_sll_vbll_vbll_vus, test_sll_vp_vp_vuc,
+	test_sll_vssi_vssi_vuc, test_sll_vusi_vusi_vuc, test_slo_vsc_vsc_vsc,
+	test_slo_vuc_vuc_vsc, test_slo_vsi_vsi_vsc, test_slo_vsi_vsi_vuc,
+	test_slo_vui_vui_vsc, test_slo_vui_vui_vuc, test_slo_vsll_slo_vsll_vsc,
+	test_slo_vsll_slo_vsll_vuc, test_slo_vull_slo_vull_vsc,
+	test_slo_vull_slo_vull_vuc, test_slo_vp_vp_vsc, test_slo_vp_vp_vuc,
+	test_slo_vssi_vssi_vsc, test_slo_vssi_vssi_vuc, test_slo_vusi_vusi_vsc,
+	test_slo_vusi_vusi_vuc, test_slo_vusi_vusi_vuc, test_slo_vf_vf_vsc,
+	test_slo_vf_vf_vuc, test_cmpb_float): Add tests.
+
+	Backport from trunk r257253.
+
+	2018-01-31  Will Schmidt  <will_schmidt@vnet.ibm.com>
+
+	* gcc.target/powerpc/altivec-13.c: Remove VSX-requiring built-ins.
+	* gcc.target/powerpc/vsx-13.c: New.
+
+	Backport from trunk r258137.
+
+	2018-03-02  Will Schmidt  <will_schmidt@vnet.ibm.com>
+
+	* gcc.target/powerpc/altivec-7-be.c: Remove VSX content, allow
+	32-bit target.
+	* gcc.target/powerpc/altivec-7.h: Remove VSX content.
+	* gcc.target/powerpc/vsx-7-be.c: New test (VSX content).
+	* gcc.target/powerpc/vsx-7.h: New include (VSX content).
+	* gcc.target/powerpc/altivec-7-le.c: Add vsx-7.h include.
+
+2019-03-31  Harald Anlauf  <anlauf@gmx.de>
+
+	Backport from trunk
+	PR fortran/83515
+	PR fortran/85797
+	* gfortran.dg/pr85797.f90: New test.
+
+2019-02-26  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-02-12  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/89253
+	* gfortran.dg/pr89253.f: New testcase.
+
+	2019-02-08  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/89223
+	* gcc.dg/torture/pr89223.c: New testcase.
+
+	2019-01-28  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/88739
+	* gcc.c-torture/execute/pr88739.c: New test.
+
+2019-03-26  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-01-08  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/86554
+	* gcc.dg/torture/pr86554-1.c: New testcase.
+	* gcc.dg/torture/pr86554-2.c: Likewise.
+
+	2018-11-20  Richard Biener  <rguenther@suse.de>
+ 
+	PR tree-optimization/88105
+	* gcc.dg/gomp/pr88105.c: New testcase.
+
+	2018-03-08  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/84552
+	* gcc.dg/graphite/pr84552.c: New testcase.
+
+2019-03-25  Janus Weil  <janus@gcc.gnu.org>
+
+	PR fortran/71861
+	Backport from trunk
+	* gfortran.dg/interface_abstract_5.f90: New test case.
+
+2019-03-21  Thomas Schwinge  <thomas@codesourcery.com>
+
+	PR fortran/56408
+	* gcc.target/powerpc/ppc-fortran/ppc-fortran.exp
+	(dg-compile-aux-modules): Fix diagnostic.
+	* gfortran.dg/coarray/caf.exp (dg-compile-aux-modules): Likewise.
+	* gfortran.dg/dg.exp (dg-compile-aux-modules): Likewise.
+
+	PR fortran/56408
+	* gfortran.dg/coarray/caf.exp (dg-compile-aux-modules): Workaround
+	missing nexted dg-test call support in dejaGNU 1.4.4.
+
+	PR fortran/29383
+	* gfortran.dg/ieee/ieee.exp (DEFAULT_FFLAGS): Set the same as in
+	other '*.exp' files.
+
+2019-03-21  Matthias Klose  <doko@ubuntu.com>
+
+	Backport from mainline
+	2019-02-26  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/89505
+	* gcc.dg/torture/pr89505.c: New testcase.
+
+2019-03-17  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/84394
+	Backport from trunk
+	* gfortran.dg/blockdata_11.f90: New test.
+
+2019-03-17  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline
+	2019-03-14  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR target/89523
+	* gcc.target/i386/pr89523-1a.c: New test.
+	* gcc.target/i386/pr89523-1b.c: Likewise.
+	* gcc.target/i386/pr89523-2.c: Likewise.
+	* gcc.target/i386/pr89523-3.c: Likewise.
+	* gcc.target/i386/pr89523-4.c: Likewise.
+	* gcc.target/i386/pr89523-5.c: Likewise.
+	* gcc.target/i386/pr89523-6.c: Likewise.
+	* gcc.target/i386/pr89523-7.c: Likewise.
+	* gcc.target/i386/pr89523-8.c: Likewise.
+	* gcc.target/i386/pr89523-9.c: Likewise.
+
+2019-03-16  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/66089
+	Backport from trunk
+	* gfortran.dg/dependency_53.f90: New test.
+	* gfortran.dg/assumed_type_2.f90: Adapted tree dumps.
+	* gfortran.dg/no_arg_check_2.f90: Likewise.
+
+2019-03-16 Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/66695
+	PR fortran/77746
+	PR fortran/79485
+	Backport from trunk
+	* gfortran.dg/binding_label_tests_30.f90: New test.
+	* gfortran.dg/binding_label_tests_31.f90: New test.
+	* gfortran.dg/binding_label_tests_32.f90: New test.
+	* gfortran.dg/binding_label_tests_33.f90: New test.
+
+2019-03-14  Martin Jambor  <mjambor@suse.cz>
+
+	Backport from mainline
+	2019-03-07  Martin Jambor  <mjambor@suse.cz>
+
+	PR lto/87525
+	* gcc.dg/ipa/ipcp-5.c: New test.
+
+2019-03-14  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2018-02-16  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/84272
+	* g++.dg/opt/pr84272.C: New test.
+
+2019-03-13  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/87673
+	Backport from trunk
+	* gfortran.dg/charlen_17.f90: New test.
+
+2019-03-13  Andre Vieira  <andre.simoesdiasvieira@arm.com>
+
+	Backport from mainline
+	2019-03-08  Andre Vieira  <andre.simoesdiasvieira@arm.com>
+
+	* gcc.target/arm/f16_f64_conv_no_dp.c: New test.
+
+	Backport from mainline
+	2019-03-11  Christophe Lyon  <christophe.lyon@linaro.org>
+
+	* gcc.target/arm/f16_f64_conv_no_dp.c: Add arm_fp16_ok effective
+	target.
+
+2019-03-10  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/71544
+	Backport from trunk
+	* gfortran.dg/c_ptr_tests_19.f90: New test.
+
+2019-03-10  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/87734
+	Backport from trunk
+	* gfortran.dg/public_private_module_10.f90: New test.
+
+2019-04-10  Matthias Klose  <doko@ubuntu.com>
+
+	Backport from the gcc-8 branch
+	2019-03-07  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/89585
+	* g++.dg/asm-qual-3.C: Adjust expected diagnostics.
+
+2019-03-07  Xiong Hu Luo  <luoxhu@linux.ibm.com>
+
+	Backport of r268834 from mainline to gcc-7-branch.
+	2019-01-23  Xiong Hu Luo  <luoxhu@linux.vnet.ibm.com>
+
+	* gcc.target/powerpc/crypto-builtin-1.c
+	(crypto1_be, crypto2_be, crypto3_be, crypto4_be, crypto5_be):
+	New testcases.
+
+2019-03-06  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/72714
+	Backport from trunk
+	* gfortran.dg/coarray_allocate_11.f90: New test.
+
+2019-03-03  Harald Anlauf  <anlauf@gmx.de>
+
+	Backport from trunk
+	PR fortran/77583
+	* gfortran.dg/pr77583.f90: New test.
+
+2019-03-03  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/87689
+	Backport from trunk
+	* gfortran.dg/lto/20091028-1_0.f90: Add -Wno-lto-type-mismatch to
+	options.
+	* gfortran.dg/lto/20091028-2_0.f90: Likewise.
+	* gfortran.dg/lto/pr87689_0.f: New file.
+	* gfortran.dg/lto/pr87689_1.f: New file.
+	* gfortran.dg/altreturn_9_0.f90: New file.
+	* gfortran.dg/altreturn_9_1.f90: New file.
+
+2019-02-23  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/88117
+	* gfortran.dg/deferred_character_32.f90 : New test
+
+2019-02-23  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/71066
+	Backport from trunk
+	* gfortran.dg/coarray_data_1.f90: New test.
+
+2019-02-15  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2019-02-14  Martin Liska  <mliska@suse.cz>
+
+	PR rtl-optimization/89242
+	* g++.dg/pr89242.C: New test.
+
+2019-02-15  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2019-02-11  Martin Liska  <mliska@suse.cz>
+
+	PR ipa/89009
+	* g++.dg/ipa/pr89009.C: New test.
+
+2019-02-15  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc.target/sparc/struct-ret-check-1.c: Add -fno-pie option.
+
+2019-02-11  Stefan Agner  <stefan@agner.ch>
+
+	Backport from mainline
+	2019-01-10  Stefan Agner  <stefan@agner.ch>
+
+	PR target/88648
+	* gcc.target/arm/pr88648-asm-syntax-unified.c: Add test to
+	check if -masm-syntax-unified gets applied properly.
+
+2019-02-10  Harald Anlauf  <anlauf@gmx.de>
+
+	Backport from trunk
+	PR fortran/89077
+	* gfortran.dg/pr89077.f90: New test.
+
+2019-02-10  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/71723
+	Backport from trunk
+	* gfortran.dg/pointer_init_2.f90: Adjust error messages.
+	* gfortran.dg/pointer_init_6.f90: Likewise.
+	* gfortran.dg/pointer_init_9.f90: New test.
+
+2019-02-09  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/71860
+	Backport from trunk
+	* gfortran.dg/null_10.f90: New test.
+
+2019-02-06  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	2019-02-05  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+	* gcc.target/powerpc/vec-extract-slong-1.c: Require p8 execution
+	hardware.
+	* gcc.target/powerpc/vec-extract-schar-1.c: Likewise.
+	* gcc.target/powerpc/vec-extract-sint128-1.c: Likewise.
+	* gcc.target/powerpc/vec-extract-sshort-1.c: Likewise.
+	* gcc.target/powerpc/vec-extract-ulong-1.c: Likewise.
+	* gcc.target/powerpc/vec-extract-uchar-1.c: Likewise.
+	* gcc.target/powerpc/vec-extract-sint-1.c: Likewise.
+	* gcc.target/powerpc/vec-extract-uint128-1.c: Likewise.
+	* gcc.target/powerpc/vec-extract-ushort-1.c: Likewise.
+	* gcc.target/powerpc/vec-extract-uint-1.c: Likewise.
+
+	Backport from mainline.
+	2019-01-30  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+	* gcc.target/powerpc/vec-extract-schar-1.c: New test.
+	* gcc.target/powerpc/vec-extract-sint-1.c: New test.
+	* gcc.target/powerpc/vec-extract-sint128-1.c: New test.
+	* gcc.target/powerpc/vec-extract-slong-1.c: New test.
+	* gcc.target/powerpc/vec-extract-sshort-1.c: New test.
+	* gcc.target/powerpc/vec-extract-uchar-1.c: New test.
+	* gcc.target/powerpc/vec-extract-uint-1.c: New test.
+	* gcc.target/powerpc/vec-extract-uint128-1.c: New test.
+	* gcc.target/powerpc/vec-extract-ulong-1.c: New test.
+	* gcc.target/powerpc/vec-extract-ushort-1.c: New test.
+
+2019-02-06  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gnat.dg/opt76.adb: New test.
+
+2019-02-05  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/67679
+	Backport from trunk
+	* gfortran.dg/warn_undefined_1.f90: New test.
+	* gfortran.dg/coarray_lock_7.f90: Fix patterns in test.
+
+2019-02-03  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/88393
+	* gfortran.dg/alloc_comp_assign_16.f03 : New test.
+
+2019-02-02  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/88298
+	Backport from trunk
+	* gfortran.dg/warn_conversion_10.f90: New test.
+
+2019-02-02  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/57048
+	Backport from trunk
+	* gfortran.dg/c_funptr_1.f90: New file.
+	* gfortran.dg/c_funptr_1_mod.f90: New file.
+
+2019-01-30  Manfred Schwarb  <manfred99@gmx.ch>
+
+	* gfortran.dg/pr68318_1.f90: Fix a dg directive.
+
+2019-01-30  Kewen Lin  <linkw@gcc.gnu.org>
+
+	Backport from mainline
+	2019-01-20  Kewen Lin  <linkw@gcc.gnu.org>
+
+	* gcc.target/powerpc/altivec_vld_vst_addr.c: Remove, split into
+	altivec_vld_vst_addr-1.c and altivec_vld_vst_addr-2.c.
+	* gcc.target/powerpc/altivec_vld_vst_addr-1.c: New test.
+	* gcc.target/powerpc/altivec_vld_vst_addr-2.c: Ditto.
+
+	2019-01-17  Kewen Lin  <linkw@gcc.gnu.org>
+
+	* gcc.target/powerpc/altivec_vld_vst_addr.c: New test.
+
+2019-01-27  Uroš Bizjak  <ubizjak@gmail.com>
+
+	PR fortran/70696
+	* gfortran.dg/coarray/event_3.f0: Add save attribue to x.
+
+2019-01-27  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/56386
+	PR fortran/58906
+	PR fortran/77385
+	* gfortran.dg/associate_44.f90 : New test.
+
+	PR fortran/80260
+	* gfortran.dg/select_type_45.f90 : New test.
+
+	PR fortran/82077
+	* gfortran.dg/select_type_46.f90 : New test.
+
+2019-01-27  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gnat.dg/opt75.adb: New test.
+	* gnat.dg/opt75_pkg.ad[sb]: New helper.
+
+2019-01-27  Uroš Bizjak  <ubizjak@gmail.com>
+
+	PR target/88948
+	* gcc.target/i386/pr88948.c: New test.
+
+2019-01-26  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gnat.dg/array34.adb: New test.
+
+2019-01-26  Dominique d'Humieres  <dominiq@gcc.gnu.org>
+
+	PR fortran/85579
+	* gfortran.dg/pr51434.f90: Fix the TRANSFER argument.
+
+2019-01-26  Manfred Schwarb  <manfred99@gmx.ch>
+
+	* gfortran.dg/array_function_5.f90
+	* gfortran.dg/class_66.f90
+	* gfortran.dg/dec_structure_12.f90
+	* gfortran.dg/dec_structure_14.f90
+	* gfortran.dg/dec_structure_15.f90
+	* gfortran.dg/extends_11.f03
+	* gfortran.dg/pr58968.f
+	* gfortran.dg/pr78259.f90
+	* gfortran.dg/debug/pr35154-stabs.f
+
+2019-01-24  Uroš Bizjak  <ubizjak@gmail.com>
+
+	PR target/88998
+	* g++.dg/pr88998.c: New test.
+
+2019-01-24  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-01-23  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/89008
+	* gcc.dg/torture/pr89008.c: New testcase.
+
+2019-01-22  Uroš Bizjak  <ubizjak@gmail.com>
+
+	PR target/88938
+	* gcc.target/i386/pr88938.c: New test.
+
+2019-01-16  Joseph Myers  <joseph@codesourcery.com>
+
+	Backport from mainline
+	2019-01-07  Joseph Myers  <joseph@codesourcery.com>
+
+	PR c/88720
+	PR c/88726
+	* gcc.dg/inline-40.c, gcc.dg/inline-41.c: New tests.
+
+2019-01-16  Martin Jambor  <mjambor@suse.cz>
+
+	Backported from mainline
+	2018-12-10  Martin Jambor  <mjambor@suse.cz>
+
+	PR ipa/88214
+	* gcc.dg/ipa/pr88214.c: New test.
+
+2019-01-15  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/81849
+	* gfortran.dg/pr81849.f90: New test.
+
+2019-01-13  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	PR libfortran/88776
+	* gfortran.dg/namelist_96.f90: New test.
+
+2019-01-11  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/35031
+	* gfortran.dg/pr35031.f90: new test.
+
+2019-01-09  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc.target/sparc/tls-ld-int8.c: New test.
+	* gcc.target/sparc/tls-ld-int16.c: Likewise.
+	* gcc.target/sparc/tls-ld-int32.c: Likewise.
+	* gcc.target/sparc/tls-ld-uint8.c: Likewise.
+	* gcc.target/sparc/tls-ld-uint16.c: Likewise.
+	* gcc.target/sparc/tls-ld-uint32.c: Likewise.
+
+2019-01-05  Dominique d'Humieres  <dominiq@gcc.gnu.org>
+
+	PR target/60563
+	* g++.dg/ext/sync-4.C: Add dg-xfail-run-if for darwin.
+
+2018-01-02  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	Backport from trunk
+	2018-12-06  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	PR inline-asm/55681
+	* gcc.dg/asm-qual-1.c: Test that "const" and "restrict" are refused.
+	* gcc.dg/asm-qual-2.c: New test, test that asm-qualifiers are allowed
+	in any order, but that duplicates are not allowed.
+
+	Backport from trunk
+	2018-12-06  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	* c-c++-common/torture/asm-inline.c: New testcase.
+	* gcc.dg/asm-qual-2.c: Test asm inline, too.
+
+	Backport from trunk
+	2018-12-19  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	* g++.dg/asm-qual-1.C: New testcase.
+	* g++.dg/asm-qual-2.C: New testcase.
+	* gcc.dg/asm-qual-1.c: Update.
+
+	Backport from trunk
+	2018-12-19  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	* g++.dg/asm-qual-3.C: New testcase.
+	* gcc.dg/asm-qual-3.c: New testcase.
+
+	And extra for the backport
+	2019-01-02  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	* gcc.dg/asm-qual-1.c: Adjust.
+
+2018-12-30  Dominique d'Humieres  <dominiq@gcc.gnu.org>
+
+	PR tree-optimization/68356
+	PR target/81210
+	* gcc.dg/torture/pr68264.c: Skip on darwin.
+	* gcc.dg/torture/pr68037-1.c: Likewise.
+	* gcc.dg/torture/pr68037-2.c: Likewise.
+	* gcc.dg/torture/pr68037-3.c: Likewise.
+
+2018-12-29  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/82550
+	* gfortran.dg/submodule_30.f08 : New test.
+
+2018-12-24  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2018-12-24  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR testsuite/67974
+	* gcc.target/x86_64/abi/avx/asm-support-darwin.s: New.
+
+2018-12-24  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2018-08-16  Iain Sandoe <iain@sandoe.co.uk>
+
+	* g++.dg/torture/pr44295.C : Skip for Darwin.
+
+2018-12-24  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2018-08-22  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* gcc.dg/lto/pr85248_0.c (test_alias):
+	Stringify __USER_LABEL_PREFIX__.
+	(test_noreturn): Likewise.
+
+	2018-08-16  Iain Sandoe <iain@sandoe.co.uk>
+
+	* gcc.dg/memcmp-1.c (lib_memcmp): Apply __USER_LABEL_PREFIX__.
+	(lib_strncmp): Likewise.
+
+	2018-08-16  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* gcc.dg/asan/pr81923.c: Stringify __USER_LABEL_PREFIX__.
+
+2018-12-24  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2018-08-16  Iain Sandoe <iain@sandoe.co.uk>
+
+	PR testsuite/78544
+	* gcc.dg/tree-prof/section-attr-1.c: Add Darwin-specific section
+	attributes and matching.
+	* gcc.dg/tree-prof/section-attr-2.c: Likewise.
+	* gcc.dg/tree-prof/section-attr-3.c: Likewise.
+
+2018-12-23  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/77703
+	* gfortran.dg/ptr_func_assign_5.f08 : New test.
+
+2018-12-22  Steven G . Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/85798
+	* gfortran.dg/pr85798.f90: New test.
+
+2018-12-22  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/85544
+	* gfortran.dg/power_7.f90: New test.
+
+2018-12-21  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/88169
+	* gfortran.dg/pr88169_1.f90: new test.
+	* gfortran.dg/pr88169_2.f90: Ditto.
+	* gfortran.dg/pr88169_3.f90: Ditto.
+
+2018-12-21  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline
+	2018-12-10  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/88418
+	* gcc.target/i386/pr88418.c: New test.
+
+2018-12-17  Senthil Kumar Selvaraj  <senthilkumar.selvaraj@microchip.com>
+
+	Backport from trunk
+	2018-12-17  Senthil Kumar Selvaraj  <senthilkumar.selvaraj@microchip.com>
+
+	PR rtl-optimization/88253
+	* gcc.target/avr/pr88253.c: New test.
+
+2018-12-15  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/88138
+	* gfortran.dg/pr88138.f90: new test.
+
+2018-12-13  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	Backport from mainline
+	2018-12-13  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	* gcc.target/s390/zvector/vec-double-1.c: New test.
+	* gcc.target/s390/zvector/vec-double-2.c: New test.
+
+2018-12-12  Peter Bergner  <bergner@linux.ibm.com>
+
+	Backport from mainline
+	2018-12-07  Peter Bergner  <bergner@linux.ibm.com>
+
+	PR target/87496
+	* gcc.target/powerpc/pr87496-1.c: New test.
+	* gcc.target/powerpc/pr87496-2.c: New test.
+	* gcc.target/powerpc/pr87496-3.c: New test.
+
+2018-12-11  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/88155
+	* gfortran.dg/pr70870_1.f90: Update testcase to use -std=gnu.
+	* gfortran.dg/pr88155.f90: New test.
+
+2018-12-11  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/88249
+	* gfortran.dg/pr88249.f90: New test.
+
+2018-12-10  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/88269
+	* gfortran.dg/pr88269.f90: New test.
+
+2018-12-09  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/88205
+	* gfortran.dg/pr88205.f90: New unit.
+
+2018-12-09  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/88206
+	* gfortran.dg/pr88206.f90: New test.
+
+2018-12-09  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/88228
+	* gfortran.dg/pr88228.f90: New test.
+
+2018-12-06  Release Manager
+
+	* GCC 7.4.0 released.
+
+2018-11-28  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/79351
+	* gcc.dg/torture/pr79351.c: New testcase.
+
+2018-11-26  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	Backport from mainline
+	2018-11-20  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	* gcc.target/s390/flogr-1.c: New test.
+
+2018-10-19  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/87645
+	Backport from mainline
+	2018-07-12  Richard Biener  <rguenther@suse.de>
+
+	* gcc.dg/torture/pr87645.c: New testcase.
+
+2018-11-26  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2018-10-15  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/87610
+	* gcc.dg/torture/restrict-6.c: New testcase.
+
+	2018-10-25  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/87665
+	PR tree-optimization/87745
+	* gfortran.dg/20181025-1.f: New testcase.
+
+	2018-10-24  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/87665
+	* gcc.dg/torture/pr87665.c: New testcase.
+
+2018-11-26  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2018-06-15  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/86076
+	* gcc.dg/pr86076.c: New testcase.
+
+2018-11-26  Matthias Klose  <doko@ubuntu.com>
+
+	* jit.dg/test-long-names.c: Fix build with -Wformat-security.
+
+2018-11-25  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/88073
+	* gfortran.dg/where_7.f90: New test.
+
+2018-11-24  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from mainline
+	PR fortran/88143
+	* gfortran.dg/associate_46.f90: New test.
+
+2018-11-22  Eric Botcazou  <ebotcazou@adacore.com>
+
+	Backport from mainline
+	2018-11-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/85925
+	* gcc.c-torture/execute/20181120-1.c: Require effective target
+	int32plus.
+	(u): New variable.
+	(main): Compare d against u.f1 rather than 0x101.  Use 0x4030201
+	instead of 0x10101.
+
+2018-11-21  Mihail Ionescu  <mihail.ionescu@arm.com>
+
+	PR target/87867
+	Backport from mainiline
+	2018-09-17  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* g++.dg/other/thunk2a.C: New test.
+	* g++.dg/other/thunk2b.C: Likewise.
+
+2018-11-20  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2018-01-26  Richard Biener  <rguenther@suse.de>
+
+	PR rtl-optimization/84003
+	* g++.dg/torture/pr77745.C: Mark foo noinline to trigger
+	latent bug in DSE if NOINLINE is appropriately defined.
+	* g++.dg/torture/pr77745-2.C: New testcase including pr77745.C
+	and defining NOINLINE.
+
+2018-11-20  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc.c-torture/execute/20181120-1.c: New test.
+
+2018-11-18  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline
+	2018-11-11  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/87928
+	* gcc.target/i386/pr87928.c: New test.
+
+2018-11-15  Nathan Sidwell  <nathan@acm.org>
+
+	PR debug/88006
+	PR debug/87462
+	* g++.dg/debug/dwarf2/pr87462.C: New.
+	* g++.dg/debug/dwarf2/pr88006.C: New.
+
+2018-11-11  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline
+	2018-11-04  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR middle-end/58372
+	* g++.dg/pr58372.C: New test.
+
+2018-11-08  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gnat.dg/null_pointer_deref1.adb: Remove -gnatp and add pragma.
+	* gnat.dg/null_pointer_deref2.adb: Likewise.
+	* gnat.dg/null_pointer_deref3.adb: Likewise.
+	* gnat.dg/opt74.adb: New test.
+	* gnat.dg/opt74_pkg.ad[sb]: New helper.
+	* gnat.dg/warn12.adb: Delete.
+	* gnat.dg/warn12_pkg.ads: Likewise.
+
+2018-11-03  Tobias Burnus  <burnus@net-b.de>
+	Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/87597
+	* gfortran.dg/inline_matmul_24.f90: New.
+
+2018-10-26  Bill Schmidt  <wschmidt@linux.ibm.com>
+
+	Backport from mainline
+	2018-10-19  Bill Schmidt  <wschmidt@linux.ibm.com>
+
+	PR tree-optimization/87473
+	* gcc.c-torture/compile/pr87473.c: New file.
+
+2018-10-23  Tom de Vries  <tdevries@suse.de>
+
+	backport from trunk:
+	2018-07-31  Tom de Vries  <tdevries@suse.de>
+
+	PR debug/86687
+	* g++.dg/guality/pr86687.C: New test.
+
+2018-10-22  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gnat.dg/sso14.adb: New test.
+	* gnat.dg/sso15.adb: Likewise.
+
+2018-10-19  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	Backport from mainline
+	2018-10-15  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	* g++.dg/vec-init-1.C: New test.
+
+2018-10-17  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc.c-torture/execute/pr87623.c: New test.
+
+2018-10-16  Wilco Dijkstra  <wdijkstr@arm.com>
+
+	Backported from mainline
+	PR target/87511
+	* gcc.target/aarch64/pr87511.c: Add new test.
+
+2018-10-12  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-10-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/87550
+	* gcc.target/i386/pr87550.c: New test.
+
+	2018-09-12  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/87248
+	* c-c++-common/torture/pr87248.c: New test.
+
+	2018-08-27  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/87065
+	* gcc.target/i386/pr87065.c: New test.
+
+	2018-07-24  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/86627
+	* gcc.target/i386/pr86627.c: New test.
+
+	2018-07-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/86421
+	* gfortran.dg/vect/pr86421.f90: New test.
+
+	2018-07-16  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/3698
+	PR c++/86208
+	* g++.dg/opt/pr3698.C: New test.
+
+2018-10-12  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2018-08-23  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/87024
+	* gcc.dg/pr87024.c: New testcase.
+
+	2018-08-17  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/86505
+	* gcc.dg/torture/pr86505.c: New testcase.
+
+2018-10-09  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline
+	2018-09-29  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR target/87370
+	* gcc.target/i386/pr87370.c: New test.
+
+2018-10-01  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backport from mainline
+	2018-07-02  Christophe Lyon  <christophe.lyon@linaro.org>
+
+	* gcc.target/arm/arm-soft-strd-even.c: Skip if -mfloat-abi is
+	overriden.
+	2018-06-29  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	* gcc.target/arm/arm-soft-strd-even.c: New test.
+
+2018-09-29  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/87467
+	* gcc.target/i386/avx512f-abspd-1.c (SIZE): Divide by two.
+	(CALC): Use double instead of float.
+	(TEST): Adjust to test _mm512_abs_pd and _mm512_mask_abs_pd rather than
+	_mm512_abs_ps and _mm512_mask_abs_ps.
+
+2018-09-27  Michael Meissner  <meissner@linux.ibm.com>
+
+	Backport from mainline
+	2018-08-20  Michael Meissner  <meissner@linux.ibm.com>
+
+	PR target/87033
+	* gcc.target/powerpc/pr87033.c: New test.
+
+2018-09-21  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc.dg/nested-func-11.c: New test.
+
+2018-09-13  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from trunk
+	PR fortran/87284
+	* gfortran.dg/allocate_with_mold_2.f90: New test.
+
+2018-09-12  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	Backport from mainline
+	2018-09-12  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	* gcc.target/s390/dfp_to_bfp_rounding.c: New test.
+
+2018-09-07  Janus Weil  <janus@gcc.gnu.org>
+
+	Backported from trunk
+	PR fortran/86116
+	* gfortran.dg/generic_34.f90: New test case.
+
+2018-09-03  Tom de Vries  <tdevries@suse.de>
+
+	backport from trunk:
+	2018-06-21  Tom de Vries  <tdevries@suse.de>
+
+	PR tree-optimization/85859
+	* gcc.dg/pr85859.c: New test.
+
+2018-08-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline
+	2018-08-20  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR target/87014
+	* g++.dg/torture/pr87014.C: New file.
+
+2018-08-21  Szabolcs Nagy  <szabolcs.nagy@arm.com>
+
+	Backport from mainline
+	2018-08-21  Szabolcs Nagy  <szabolcs.nagy@arm.com>
+
+	* g++.dg/torture/pr86763.C: Restrict to *-*-linux*.
+
+2018-08-17  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2018-08-02  Richard Biener  <rguenther@suse.de>
+
+	PR c++/86763
+	* g++.dg/torture/pr86763.C: New testcase.
+
+2018-07-17  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gnat.dg/discr55.adb: New test.
+
+2018-07-16  Fritz Reese  <fritzoreese@gmail.com>
+
+	PR fortran/83184
+	Backport from trunk.
+	* gfortran.dg/assumed_rank_14.f90: New testcase.
+	* gfortran.dg/assumed_rank_15.f90: New testcase.
+	* gfortran.dg/dec_structure_8.f90: Update error messages.
+	* gfortran.dg/dec_structure_23.f90: Update error messages.
+
+2018-07-16  Fritz Reese  <fritzoreese@gmail.com>
+
+	Backport from trunk:
+
+	PR fortran/83183
+	PR fortran/86325
+	* gfortran.dg/init_flag_18.f90: New testcase.
+	* gfortran.dg/init_flag_19.f03: New testcase.
+
+2018-07-12  Richard Biener  <rguenther@suse.de>
+
+	PR target/84829
+	* gcc.target/i386/pr84829.c: New testcase.
+
+2018-07-03  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/82969
+	PR fortran/86242
+	* gfortran.dg/proc_ptr_50.f90: New test.
+
+2018-06-26  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	Backported from mainline
+	2018-06-20  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	* gcc.target/powerpc/builtins-1.c: Add dg directives to scan
+	for vpkudus.
+
+2018-06-26  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/86314
+	* gcc.dg/pr86314.c: New test.
+
+2018-06-25  Fritz Reese  <fritzoreese@gmail.com>
+
+	PR fortran/82972
+	PR fortran/83088
+	PR fortran/85851
+	Backport from trunk.
+	* gfortran.dg/init_flag_17.f90: New testcase.
+
+2018-06-25  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/84786
+	* gcc.target/i386/avx512f-pr84786-3.c: New test.
+
+2018-06-25  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/83118
+	Back port from trunk
+	* gfortran.dg/unlimited_polymorphic_30.f03: New test.
+
+2018-06-23  Richard Sandiford  <richard.sandiford@linaro.org>
+
+	PR tree-optimization/85989
+	* gcc.dg/torture/pr85989.c: New test.
+
+2018-06-22  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-06-22  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/85662
+	* g++.dg/ext/offsetof3.C: New test.
+
+	2018-06-20  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/86210
+	* g++.dg/warn/Wnonnull4.C: New test.
+
+	PR tree-optimization/86231
+	* gcc.dg/tree-ssa/vrp119.c: New test.
+	* gcc.c-torture/execute/pr86231.c: New test.
+
+	2018-06-15  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/85878
+	* gfortran.fortran-torture/compile/pr85878.f90: New test.
+
+	2018-06-14  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/85945
+	* gcc.c-torture/compile/pr85945.c: New test.
+
+	2018-06-04  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/86025
+	* c-c++-common/gomp/pr86025.c: New test.
+
+	2018-05-29  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/85952
+	* g++.dg/warn/Wunused-var-33.C: New test.
+
+	2018-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/85696
+	* c-c++-common/gomp/pr85696.c: New test.
+
+	2018-05-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/85662
+	* g++.dg/ext/offsetof2.C: New test.
+
+	2018-05-06  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/85659
+	* g++.dg/ext/asm14.C: New test.
+	* g++.dg/ext/asm15.C: New test.
+	* g++.dg/ext/asm16.C: New test.
+
+	2018-04-27  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/85529
+	* gcc.c-torture/execute/pr85529-1.c: New test.
+	* gcc.c-torture/execute/pr85529-2.c: New test.
+	* gcc.dg/pr85529.c: New test.
+
+	2018-04-18  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/84463
+	* g++.dg/cpp0x/constexpr-nullptr-1.C: Add -O1 to dg-options.
+	* g++.dg/cpp0x/constexpr-nullptr-2.C: Expect different diagnostics
+	in two cases.  Uncomment two other tests and add expected dg-error for
+	them.
+	* g++.dg/init/struct2.C: Cast to int rather than long to avoid
+	-Wnarrowing diagnostics on some targets for c++11.
+	* g++.dg/parse/array-size2.C: Remove xfail.
+	* g++.dg/cpp0x/constexpr-84463.C: New test.
+
+	2018-04-17  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/85430
+	* gcc.dg/pr85430.c: New test.
+
+	2018-04-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/85300
+	* gcc.dg/pr85300.c: New test.
+
+	PR fortran/85313
+	* gfortran.dg/gomp/pr85313.f90: New test.
+
+	2018-04-07  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/85257
+	* gcc.dg/pr85257.c: New test.
+
+	2018-04-06  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/85252
+	* gcc.dg/debug/pr85252.c: New test.
+
+	PR c++/85210
+	* g++.dg/cpp1z/decomp42.C: New test.
+
+	2018-04-05  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/85208
+	* g++.dg/cpp1z/decomp41.C: New test.
+
+	2018-04-04  Jakub Jelinek  <jakub@redhat.com>
+
+	PR inline-asm/85172
+	* g++.dg/ext/builtin13.C: New test.
+	* g++.dg/ext/atomic-4.C: New test.
+
+	2018-04-03  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/85167
+	* gcc.dg/pr85167.c: New test.
+
+	PR c++/85147
+	* g++.dg/cpp0x/pr85147.C: New test.
+
+	PR c++/85140
+	* g++.dg/cpp0x/gen-attrs-64.C: New test.
+
+	2018-03-30  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/84791
+	* g++.dg/gomp/pr84791.C: New test.
+
+	2018-03-28  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/85095
+	* gcc.target/i386/pr85095-1.c: New test.
+	* gcc.target/i386/pr85095-2.c: New test.
+	* gcc.c-torture/execute/pr85095.c: New test.
+
+	2018-03-27  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/85076
+	* g++.dg/cpp1y/pr85076.C: New test.
+
+	PR c++/85068
+	* g++.dg/inherit/covariant22.C: New test.
+
+	2018-03-23  Jakub Jelinek  <jakub@redhat.com>
+
+	PR inline-asm/85034
+	* gcc.target/i386/pr85034.c: New test.
+
+	PR inline-asm/85022
+	* c-c++-common/torture/pr85022.c: New test.
+
+	2018-03-22  Jakub Jelinek  <jakub@redhat.com>
+
+	PR inline-asm/84941
+	* gcc.dg/pr84941.c: New test.
+
+	2018-03-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/84999
+	* c-c++-common/pr84999.c: New test.
+
+	PR c++/84961
+	* c-c++-common/pr43690.c: Don't expect errors on "m" (--x) and
+	"m" (++x) in C++.
+	* g++.dg/torture/pr84961-1.C: New test.
+	* g++.dg/torture/pr84961-2.C: New test.
+
+	2018-03-20  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/84875
+	* gcc.dg/pr84875.c: New test.
+
+	PR c/84953
+	* gcc.dg/pr84953.c: New test.
+
+	2018-03-19  Maxim Ostapenko  <m.ostapenko@samsung.com>
+
+	PR sanitizer/78651
+	* g++.dg/asan/pr78651.C: New test.
+
+	2018-03-16  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/84899
+	* gcc.dg/pr84899.c: New test.
+
+	PR c++/84874
+	* g++.dg/cpp1z/desig8.C: New test.
+
+	PR tree-optimization/84841
+	* gcc.dg/pr84841.c: New test.
+
+	PR c++/84874
+	* g++.dg/cpp1z/desig7.C: New test.
+
+	2018-03-15  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/79085
+	* g++.dg/opt/pr79085.C: New test.
+
+	PR c++/84222
+	* g++.dg/warn/deprecated.C (T::member3): Change dg-warning to dg-bogus.
+	* g++.dg/warn/deprecated-6.C (T::member3): Likewise.
+	* g++.dg/warn/deprecated-13.C: New test.
+
+	PR target/84860
+	* gcc.c-torture/compile/pr84860.c: New test.
+
+	PR c/84853
+	* gcc.dg/pr84853.c: New test.
+
+	2018-03-13  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/84834
+	* gcc.dg/pr84834.c: New test.
+
+	PR target/84827
+	* gcc.target/i386/pr84827.c: New test.
+
+	PR target/84786
+	* gcc.target/i386/avx512f-pr84786-1.c: New test.
+	* gcc.target/i386/avx512f-pr84786-2.c: New test.
+
+	2018-03-09  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/84772
+	* gcc.dg/pr84772.c: New test.
+
+	2018-03-09  Jason Merrill  <jason@redhat.com>
+		    Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/84076
+	* g++.dg/warn/Wformat-2.C: New test.
+
+	2018-03-09  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/84767
+	* g++.dg/ext/vla18.C: New test.
+
+	2018-03-08  Jason Merrill  <jason@redhat.com>
+		    Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/80598
+	* g++.dg/warn/Wunused-function4.C: New test.
+
+	2018-03-08  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/84739
+	* gcc.dg/pr84739.c: New test.
+
+	2018-03-05  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/84700
+	* gcc.target/powerpc/pr84700.c: New test.
+
+	2018-03-02  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/84662
+	* g++.dg/cpp1y/pr84662.C: New test.
+
+2018-06-22  Andre Vieira  <andre.simoesdiasvieira@arm.com>
+
+	Backport from mainline
+	2018-06-05  Andre Vieira  <andre.simoesdiasvieira@arm.com>
+
+	* gcc.target/arm/cmse/cmse-1c99.c: New test.
+
+2018-06-19  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gnat.dg/aggr24.adb: New test.
+	* gnat.dg/aggr24_pkg.ad[sb]: New helper.
+
+2018-06-18  Martin Sebor  <msebor@redhat.com>
+
+	PR middle-end/82063
+	* gcc.dg/Walloc-size-larger-than-1.c: New test.
+	* gcc.dg/Walloc-size-larger-than-10.c: New test.
+	* gcc.dg/Walloc-size-larger-than-11.c: New test.
+	* gcc.dg/Walloc-size-larger-than-12.c: New test.
+	* gcc.dg/Walloc-size-larger-than-13.c: New test.
+	* gcc.dg/Walloc-size-larger-than-14.c: New test.
+	* gcc.dg/Walloc-size-larger-than-15.c: New test.
+	* gcc.dg/Walloc-size-larger-than-16.c: New test.
+	* gcc.dg/Walloc-size-larger-than-2.c: New test.
+	* gcc.dg/Walloc-size-larger-than-3.c: New test.
+	* gcc.dg/Walloc-size-larger-than-4.c: New test.
+	* gcc.dg/Walloc-size-larger-than-5.c: New test.
+	* gcc.dg/Walloc-size-larger-than-6.c: New test.
+	* gcc.dg/Walloc-size-larger-than-7.c: New test.
+	* gcc.dg/Walloc-size-larger-than-8.c: New test.
+	* gcc.dg/Walloc-size-larger-than-9.c: New test.
+	* gcc.dg/Walloc-size-larger-than.c: New test.
+
+2018-06-13  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/86110
+	* gfortran.dg/pr86110.f90: New test.
+
+2018-06-12  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/44491
+	* gfortran.dg/pr44491.f90: New testcase
+
+2018-06-11  Peter Bergner  <bergner@vnet.ibm.com>
+
+	Backport from mainline
+	2018-06-08  Peter Bergner  <bergner@vnet.ibm.com>
+
+	PR target/85755
+	* gcc.target/powerpc/pr85755.c: New test.
+
+2018-06-09  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/38351
+	* gfortran.dg/pr38351.f90: New test.
+	* gfortran.dg/typebound_operator_4.f03: Adjust for new error message.
+
+2018-06-09  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/63514
+	* gfortran.dg/pr63514.f90: New test.
+
+2018-06-09  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/78278
+	* gfortran.dg/data_bounds_1.f90: Add -std=gnu option.
+	* gfortran.dg/data_char_1.f90: Ditto.
+	* gfortran.dg/pr78571.f90: Ditto.
+	* gfortran.dg/pr78278.f90: New test.
+
+2018-06-09  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/86059
+	* gfortran.dg/associate_30.f90: Remove code tested ...
+	* gfortran.dg/pr67803.f90: Ditto.
+	* gfortran.dg/pr67805.f90: Ditto.
+	* gfortran.dg/pr86059.f90: ... here.  New test.
+
+2018-06-09  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/85138
+	PR fortran/85996
+	PR fortran/86051
+	* gfortran.dg/pr85138_1.f90: New test.
+	* gfortran.dg/pr85138_2.f90: Ditto.
+	* gfortran.dg/pr85996.f90: Ditto.
+
+2018-06-07  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/86045
+	Backport from trunk.
+	* gfortran.dg/pr86045.f90: New test.
+
+2018-06-07  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/85641
+	Backport from trunk.
+	* gfortran.dg/realloc_on_assign_30.f90: New test.
+
+2018-06-07  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2018-05-04  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/85588
+	* gcc.dg/torture/pr85588.c: New testcase.
+	* gcc.dg/torture/pr57656.c: Use dg-additional-options.
+
+	2018-05-02  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/85567
+	* gcc.dg/torture/pr85567.c: New testcase.
+
+	2018-05-02  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/85597
+	* gcc.dg/vect/pr85597.c: New testcase.
+
+2018-06-05  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	Backport from mainline
+	2018-06-05  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	* gcc.target/s390/htm-builtins-compile-4.c: New test.
+
+2018-06-04  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/85981
+	* gfortran.dg/allocate_alloc_opt_14.f90: New test.
+	* gfortran.dg/allocate_alloc_opt_1.f90: Update error string.
+	* gfortran.dg/allocate_stat_2.f90: Ditto.
+	* gfortran.dg/deallocate_alloc_opt_1.f90: Ditto.
+
+2018-06-02  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gnat.dg/specs/opt3.ads: New test.
+	* gnat.dg/specs/opt3_pkg.ads: New helper.
+
+2018-06-02  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gnat.dg/discr53.ad[sb]: New test.
+	* gnat.dg/discr53_pkg.ads: New helper.
+
+2018-05-25  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/85543
+	Backport from trunk
+	* gfortran.dg/pr85543.f90: New test.
+
+2018-05-25  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/85779
+	Backport from trunk
+	* gfortran.dg/pr85779_1.f90: New test.
+	* gfortran.dg/pr85779_2.f90: Ditto.
+	* gfortran.dg/pr85779_3.f90: Ditto.
+
+2018-05-25  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/85780
+	Backport from trunk
+	* gfortran.dg/pr85780.f90: New test.
+
+2018-05-25  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/85895
+	Backport from trunk
+	* gfortran.dg/coarray_3.f90: Fix invalid testcase.
+	* gfortran.dg/pr85895.f90: New test.
+
+2018-05-24  Uros Bizjak  <ubizjak@gmail.com>
+
+	* gcc.target/i386/avx512f-vcvtusi2sd64-1.c: Update scan string.
+	* gcc.target/i386/avx512f-vcvtusi2ss64-1.c: Ditto.
+
+2018-05-21  Pat Haugen  <pthaugen@us.ibm.com>
+
+	Backport from mainline:
+	2018-05-17  Pat Haugen  <pthaugen@us.ibm.com>
+
+	PR target/85698
+	* gcc.target/powerpc/pr85698.c: New test.
+
+2018-05-20  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/80657
+	Backport from trunk
+	* gfortran.dg/char_result_18.f90: New test.
+
+2018-05-20  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/82275
+	Backport from trunk
+	* gfortran.dg/select_type_42.f90: New test.
+
+2018-05-19  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/82923
+	Backport from trunk
+	* gfortran.dg/allocate_assumed_charlen_4.f90: New test. Note
+	that the patch fixes PR66694 & PR82617, although the testcases
+	are not explicitly included.
+
+2017-05-17  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/82814
+	Backport from trunk
+	* gfortran.dg/submodule_31.f08: New test.
+
+2018-05-16  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/83149
+	Backport from trunk
+	* gfortran.dg/pr83149_1.f90: New test.
+	* gfortran.dg/pr83149.f90: Additional source for previous.
+	* gfortran.dg/pr83149_b.f90: New test.
+	* gfortran.dg/pr83149_a.f90: Additional source for previous.
+
+2018-16-05  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/83898
+	Backport from trunk
+	* gfortran.dg/associate_33.f03 : New test.
+
+2018-05-16  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/84546
+	Backport from trunk
+	* gfortran.dg/unlimited_polymorphic_29.f90 : New test.
+
+2018-05-12  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/85542
+	Backport from trunk
+	* gfortran.dg/pr85542.f90: New test.
+
+2018-05-12  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/68846
+	Backport from trunk
+	* gfortran.dg/temporary_3.f90 : New test.
+
+	PR fortran/70864
+	Backport from trunk
+	* gfortran.dg/temporary_2.f90 : New test.
+
+2018-05-11  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/70870
+	Backport from trunk
+	* gfortran.dg/pr70870_1.f90: New test.
+
+2018-05-11  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/85521
+	Backport from trunk
+	* gfortran.dg/pr85521_1.f90: New test.
+	* gfortran.dg/pr85521_2.f90: New test.
+
+2018-05-11  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/85687
+	Backport from trunk
+	* gfortran.dg/pr85687.f90: new test.
+
+2018-05-06  Andre Vehreschild  <vehre@gcc.gnu.org>
+
+	PR fortran/85507
+	Backport from trunk.
+	* gfortran.dg/coarray_dependency_1.f90: New test.
+	* gfortran.dg/coarray_lib_comm_1.f90: Fix counting caf-expressions.
+
+2018-05-01  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backport from trunk
+	2018-04-27  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	PR target/82518
+	* lib/target-supports.exp (check_effective_target_vect_load_lanes):
+	Use check_effective_target_arm_little_endian.
+
+2018-04-28  Andre Vehreschild  <vehre@gcc.gnu.org>
+
+	PR fortran/81773
+	PR fortran/83606
+	Backport from trunk.
+	* gfortran.dg/coarray/get_to_indexed_array_1.f90: New test.
+	* gfortran.dg/coarray/get_to_indirect_array.f90: New test.
+
+2018-04-26  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2018-04-09  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/85284
+	* gcc.dg/torture/pr85284.c: New testcase.
+
+	2018-04-06  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/85244
+	* gcc.dg/torture/pr85244-1.c: New testcase.
+	* gcc.dg/torture/pr85244-2.c: Likewise.
+
+	2018-04-04  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/85168
+	* gcc.dg/torture/pr85168.c: New testcase.
+
+	2018-03-15  Richard Biener  <rguenther@suse.de>
+
+	PR c/84873
+	* c-c++-common/pr84873.c: New testcase.
+
+2018-04-24  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/85520
+	* gfortran.dg/pr85520.f90: New test.
+
+2018-04-24  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-04-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR lto/85248
+	* gcc.dg/lto/pr85248_0.c: New test.
+	* gcc.dg/lto/pr85248_1.c: New test.
+
+2018-04-24  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-03-28  Jakub Jelinek  <jakub@redhat.com>
+		    Martin Liska  <mliska@suse.cz>
+
+	PR sanitizer/85081
+	* g++.dg/asan/pr85081.C: New test.
+
+2018-04-24  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-03-21  Martin Liska  <mliska@suse.cz>
+
+	PR ipa/84963
+	* gfortran.dg/goacc/pr84963.f90: New test.
+
+2018-04-24  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-03-13  Martin Liska  <mliska@suse.cz>
+
+	PR ipa/84658.
+	* g++.dg/ipa/pr84658.C: New test.
+
+2018-04-23  Aaron Sawdey  <acsawdey@linux.ibm.com>
+
+	Backport from mainline
+	2018-04-16  Aaron Sawdey  <acsawdey@linux.ibm.com>
+
+	PR target/83660
+	* gcc.target/powerpc/pr83660.C: New test.
+
+2018-04-23  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* g++.dg/torture/pr85496.C: New test.
+
+2018-04-20  Peter Bergner  <bergner@vnet.ibm.com>
+
+	PR target/85436
+	* go.dg/pr85436.go: New test.
+
+	Backport from mainline
+	2018-03-09  Peter Bergner  <bergner@vnet.ibm.com>
+
+	PR target/83969
+	* gcc.target/powerpc/pr83969.c: New test.
+
+2018-04-19  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR c++/85464 - missing location for -Wignored-qualifiers diagnostic
+	* g++.dg/diagnostic/pr85464.C: New.
+
+2018-04-18  Thomas Preud'homme  <thomas.preudhomme@arm.com>
+
+	Backport from mainline
+	2018-04-11  Thomas Preud'homme  <thomas.preudhomme@arm.com>
+
+	PR target/85261
+	* gcc.target/arm/fpscr.c: Add call to __builtin_arm_set_fpscr with
+	literal value.  Expect 2 MCR instruction.  Fix function prototype.
+	Remove volatile keyword.
+
+2018-04-12  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2018-04-12  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	* gcc.target/s390/nobp-no-dwarf2-cfi.c: New test.
+
+2018-04-11  Thomas Preud'homme  <thomas.preudhomme@arm.com>
+
+	Backport from mainline
+	2018-04-04  Thomas Preud'homme  <thomas.preudhomme@arm.com>
+
+	PR target/85203
+	* gcc.target/arm/cmse/cmse-1.c: Tighten cmse_nonsecure_caller RTL scan
+	to match a single insn of the baz function.  Move scan directives at
+	the end of the file below the functions they are trying to test for
+	better readability.
+	* gcc.target/arm/cmse/cmse-16.c: New testcase.
+
+2018-04-10  Thomas Schwinge  <thomas@codesourcery.com>
+
+	PR target/85056
+	* gcc.target/nvptx/pr85056.c (main): Initialize "sum".
+
+2018-04-10  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backport from mainline
+	2018-03-08  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	PR target/84748
+	* gcc.c-torture/execute/pr84748.c: New test.
+
+2018-04-06  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* g++.dg/opt/pr85196.C: New test.
+
+2018-04-05  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/85193
+	* gcc.target/i386/pr85193.c: New test.
+
+2018-04-04  Peter Bergner  <bergner@vnet.ibm.com>
+
+	Backport from mainline
+	2018-04-04  Peter Bergner  <bergner@vnet.ibm.com>
+
+	PR rtl-optimization/84878
+	* gcc.target/powerpc/pr84878.c: New test.
+
+2018-04-03  Cesar Philippidis  <cesar@codesourcery.com>
+
+	Backport from mainline
+	2018-03-27  Cesar Philippidis  <cesar@codesourcery.com>
+
+	PR target/85056
+	* testsuite/gcc.target/nvptx/pr85056.c: New test.
+	* testsuite/gcc.target/nvptx/pr85056a.c: New test.
+
+2018-04-02  Peter Bergner  <bergner@vnet.ibm.com>
+
+	Backport from mainline
+	2018-03-28  Peter Bergner  <bergner@vnet.ibm.com>
+
+	PR target/84912
+	* gcc.target/powerpc/extend-divide-1.c (div_weo): Remove test for
+	deleted builtin function.
+	(div_weuo): Likewise.
+	* gcc.target/powerpc/extend-divide-2.c (div_deo): Likewise.
+	(div_deuo): Likewise.
+
+2018-04-02  Peter Bergner  <bergner@vnet.ibm.com>
+
+	Backport from mainline
+	2018-02-08  Peter Bergner  <bergner@vnet.ibm.com>
+
+	PR target/81143
+	* gcc.target/powerpc/pr79799-2.c: Use __LITTLE_ENDIAN__.
+
+2018-03-29  Sebastian Peryt  <sebastian.peryt@intel.com>
+
+	PR c++/84783
+	* gcc.target/i386/avx512vl-vpermd-1.c (_mm256_permutexvar_epi32):
+	Test new intrinsic.
+	* gcc.target/i386/avx512vl-vpermq-imm-1.c (_mm256_permutex_epi64):
+	Ditto.
+	* gcc.target/i386/avx512vl-vpermq-var-1.c (_mm256_permutexvar_epi64):
+	Ditto.
+	* gcc.target/i386/avx512f-vpermd-2.c: Do not check for AVX512F_LEN.
+	* gcc.target/i386/avx512f-vpermq-imm-2.c: Ditto.
+	* gcc.target/i386/avx512f-vpermq-var-2.c: Ditto.
+
+2018-03-29  Sudakshina Das  <sudi.das@arm.com>
+
+	* gcc.target/arm/pr84826.c: Change dg-option to -fstack-check.
+
+	Backport from mainline
+	2018-03-23  Sudakshina Das  <sudi.das@arm.com>
+
+	PR target/84826
+	* gcc.target/arm/pr84826.c: Add dg directive.
+
+	Backport from mainline
+	2018-03-22  Sudakshina Das  <sudi.das@arm.com>
+
+	PR target/84826
+	* gcc.target/arm/pr84826.c: New test.
+
+2018-03-28  Carl Love  <cel@us.ibm.com>
+
+	* gcc.target/powerpc/crypto-builtin-1-runnable:  Add
+	p8vector_hw to dg-do run.
+
+2018-03-28  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/85084
+	Backport from trunk.
+	* gfortran.dg/matmul_rank_1.f90: New test.
+
+2018-03-28  Sudakshina Das  <sudi.das@arm.com>
+	    Christophe Lyon  <christophe.lyon@linaro.org>
+
+	2018-03-20  Christophe Lyon  <christophe.lyon@linaro.org>
+
+	PR target/81647
+	* gcc.target/aarch64/pr81647.c: Require fenv_exceptions.
+
+	2018-03-19  Sudakshina Das  <sudi.das@arm.com>
+
+	PR target/81647
+	* gcc.target/aarch64/pr81647.c: New.
+
+2018-03-28  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backport from mainline
+	2018-03-23  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	PR target/85026
+	* g++.dg/pr85026.C: New test.
+
+2018-03-28  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	Backport from mainline
+	2018-03-08  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	PR target/82411
+	* gcc.target/powerpc/ppc-sdata-2.c: Skip if -mno-readonly-in-sdata.
+
+2018-03-27  Sudakshina Das  <sudi.das@arm.com>
+
+	Backport from mainline:
+	2018-03-20  Sudakshina Das  <sudi.das@arm.com>
+
+	PR target/82989
+	* gcc.target/arm/pr82989.c: New test.
+
+	Backport from mainline:
+	2018-03-21  Sudakshina Das  <sudi.das@arm.com>
+
+	PR target/82989
+	* gcc.target/arm/pr82989.c: Change dg scan-assembly directives.
+
+2018-03-27  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backport from mainline
+	2018-03-20  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	PR target/82518
+	* lib/target-supports.exp (check_effective_target_vect_load_lanes):
+	Disable for armeb targets.
+	* gcc.target/arm/pr82518.c: New test.
+
+2018-03-23  Carl Love  <cel@us.ibm.com>
+
+	* gcc.target/powerpc/crypto-builtin-1-runnable.c: New test file.
+
+2018-03-22  Tom de Vries  <tom@codesourcery.com>
+
+	backport from trunk:
+	2018-03-22  Tom de Vries  <tom@codesourcery.com>
+
+	PR tree-optimization/84956
+	* gcc.dg/pr84956.c: New test.
+
+2018-03-20  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/85001
+	* gfortran.dg/interface_41.f90: New test.
+
+2018-03-19  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/84931
+	Backport from trunk
+	* gfortran.dg/array_constructor_52.f90: New test.
+
+2018-03-19  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/77414
+	* gfortran.dg/pr77414.f90: New test.
+	* gfortran.dg/internal_references_1.f90: Adjust error message.
+
+2018-03-19  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/65453
+	* gfortran.dg/pr65453.f90: New test.
+
+2018-03-19  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline
+	2018-03-15  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR target/84574
+	* gcc.target/i386/ret-thunk-9.c: Expect __x86_return_thunk
+	label instead of __x86_indirect_thunk label.
+
+2018-03-15  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/78741
+	* gfortran.dg/pr78741.f90: New test.
+
+2018-03-12  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/83939
+	* gfortran.dg/pr83939.f90
+
+2018-03-12  Richard Sandiford  <richard.sandiford@linaro.org>
+
+	PR tree-optimization/84485
+	* gcc.dg/vect/pr84485.c: New test.
+
+2018-03-10  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/84734
+	* gfortran.dg/pr84734.f90: New test.
+
+2018-03-10  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gnat.dg/prot3.adb: New test.
+	* gnat.dg/prot3_pkg.ad[sb]: New helper.
+
+2018-03-09  Kugan Vivekanandarajah  <kuganv@linaro.org>
+
+	Backport from mainline
+	2017-09-13  Kugan Vivekanandarajah  <kuganv@linaro.org>
+
+	* gcc.target/aarch64/pr63304_1.c: Remove-mno-fix-cortex-a53-843419.
+
+2018-03-08  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/64124
+	PR fortran/70409
+	* gfortran.dg/pr64124.f90: New tests.
+	* gfortran.dg/pr70409.f90: New tests.
+
+2018-03-06  Carl Love  <cel@us.ibm.com>
+
+	Backport from mainline
+	2/16/18  commit 257748  Carl Love  <cel@us.ibm.com>
+
+	* gcc.target/powerpc/p9-vinsert4b-1.c: Remove test file for non-ABI
+	tests.
+	* gcc.target/powerpc/p9-vinsert4b-2.c: Remove test file for non-ABI
+	tests.
+
+2018-03-06  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-02-23  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	PR testsuite/80551
+	* c-c++-common/tsan/race_on_mutex.c: Change regexp to allow
+	__GI___pthread_mutex_init as well.
+
+2018-03-06  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-02-20  Martin Liska  <mliska@suse.cz>
+
+	PR c/84310
+	PR target/79747
+	* gcc.target/i386/pr84310.c: New test.
+	* gcc.target/i386/pr84310-2.c: Likewise.
+
+2018-03-06  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-01-23  Martin Liska  <mliska@suse.cz>
+
+	PR lto/81440
+	* gcc.dg/lto/pr81440.h: New test.
+	* gcc.dg/lto/pr81440_0.c: New test.
+	* gcc.dg/lto/pr81440_1.c: New test.
+
+2018-03-06  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2017-04-27  Martin Liska  <mliska@suse.cz>
+
+	PR testsuite/79455
+	* c-c++-common/tsan/race_on_mutex.c: Make the scanned pattern
+	more generic.
+
+2018-03-06  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-01-30  Jan Hubicka  <hubicka@ucw.cz>
+
+	PR lto/83954
+	* gcc.dg/lto/pr83954.h: New testcase.
+	* gcc.dg/lto/pr83954_0.c: New testcase.
+	* gcc.dg/lto/pr83954_1.c: New testcase.
+
+2018-03-06  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/56667
+	* gfortran.dg/implied_do_2.f90: New test.
+	* gfortran.dg/coarray_8.f90: Update for new error message.
+
+2018-03-06  Peter Bergner  <bergner@vnet.ibm.com>
+
+	Backport from mainline
+	2018-02-22  Vladimir Makarov  <vmakarov@redhat.com>
+
+	PR target/81572
+	* gcc.target/powerpc/pr81572.c: New.
+
+2018-03-06  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2018-02-28  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/84607
+	* gcc.dg/pr84607.c: New testcase.
+
+2018-03-05  Will Schmidt  <will_schmidt@vnet.ibm.com>
+
+	Backport from trunk.
+
+	2018-02-16  Will Schmidt  <will_schmidt@vnet.ibm.com>
+
+	PR target/84371
+	* gcc.target/powerpc/builtins-3.c: Update dg-options and dg-skip-if
+	stanzas.
+	* gcc.target/powerpc/builtins-3.p8.c: Add dg-skip-if stanza.
+	* gcc.target/powerpc/builtins-3.p9.c: Add dg-skip-if stanza.
+
+2018-03-05  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/84524
+	* gcc.c-torture/execute/pr84524.c: New test.
+	* gcc.target/i386/avx512bw-pr84524.c: New test.
+
+2018-03-04  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/83076
+	* gfortran.dg/coarray_45.f90: New test.
+
+	PR fortran/83319
+	* gfortran.dg/coarray_46.f90: New test.
+
+2018-03-03  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/71085
+	* gfortran.dg/pr71085.f90: New test.
+
+2018-03-03  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/51434
+	* gfortran.dg/pr51434.f90: New test.
+
+2018-03-03  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/80965
+	* gfortran.dg/select_type_41.f90: New test.
+
+2018-03-03  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from trunk.
+	PR fortran/78990
+	* gfortran.dg/class_67.f90: New test.
+
+2018-03-03  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-03-02  Jakub Jelinek  <jakub@redhat.com>
+
+	PR ipa/84628
+	* gcc.dg/pr84628.c: New test.
+
+	PR inline-asm/84625
+	* gcc.target/i386/pr84625.c: New test.
+
+	2018-03-02  Jakub Jelinek  <jakub@redhat.com>
+
+	PR sanitizer/70875
+	* gcc.dg/ubsan/bounds-3.c: Add -fno-sanitize-recover=bounds to
+	dg-options and dg-shouldfail "ubsan" directive.
+
+	2018-02-26  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/84558
+	* g++.dg/cpp1y/pr84558.C: New test.
+
+	PR c++/84557
+	* g++.dg/gomp/pr84557.C: New test.
+
+	PR c++/84556
+	* g++.dg/gomp/pr84556.C: New test.
+	* g++.dg/vect/pr84556.cc: New test.
+
+	2018-02-22  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/84503
+	* gcc.dg/pr84503-1.c: New test.
+	* gcc.dg/pr84503-2.c: New test.
+
+	2017-11-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR bootstrap/82916
+	* gcc.dg/pr82916.c: New test.
+
+	2018-02-20  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/84445
+	* g++.dg/cpp1z/launder7.C: New test.
+
+	PR c++/84449
+	* g++.dg/cpp0x/constexpr-84449.C: New test.
+
+	2018-02-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/84444
+	* g++.dg/cpp1z/launder8.C: New test.
+
+	PR c++/84448
+	* g++.dg/gomp/pr84448.C: New test.
+
+	PR c++/84430
+	* g++.dg/gomp/pr84430.C: New test.
+
+	2018-02-16  Jakub Jelinek  <jakub@redhat.com>
+
+	PR ipa/84425
+	* gcc.c-torture/compile/pr84425.c: New test.
+
+	2018-02-16  Marek Polacek  <polacek@redhat.com>
+		    Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/84192
+	* g++.dg/cpp1y/constexpr-84192.C: New test.
+
+	2018-02-13  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/82210
+	* gcc.c-torture/execute/pr82210.c: New test.
+
+	2018-02-12  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/84341
+	* c-c++-common/gomp/pr84341.c: New test.
+
+	2018-02-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR sanitizer/83987
+	* g++.dg/ubsan/pr83987-2.C: New test.
+
+	2018-02-09  Marek Polacek  <polacek@redhat.com>
+		    Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/83659
+	* g++.dg/torture/pr83659.C: New test.
+
+	2018-02-07  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/84082
+	* g++.dg/template/incomplete11.C: New test.
+	* g++.dg/parse/crash67.C: Expect an incomplete type diagnostics too.
+
+	2018-02-01  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/81661
+	PR tree-optimization/84117
+	* gcc.dg/pr81661.c: New test.
+	* gfortran.dg/pr84117.f90: New test.
+
+	2018-01-31  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/84116
+	* gfortran.dg/gomp/pr84116.f90: New test.
+
+	PR c++/83993
+	* g++.dg/init/pr83993-2.C: New test.
+
+	PR preprocessor/69869
+	* gcc.dg/cpp/trad/pr69869.c: New test.
+
+	2018-01-30  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/83986
+	* gcc.dg/pr83986.c: New test.
+
+	2018-01-25  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/84031
+	* g++.dg/cpp1z/decomp36.C: New test.
+
+	2018-01-24  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/83977
+	* c-c++-common/gomp/pr83977-1.c: New test.
+	* c-c++-common/gomp/pr83977-2.c: New test.
+	* c-c++-common/gomp/pr83977-3.c: New test.
+	* gfortran.dg/gomp/pr83977.f90: New test.
+
+	2018-01-23  Jakub Jelinek  <jakub@redhat.com>
+
+	PR sanitizer/83987
+	* g++.dg/ubsan/pr83987.C: New test.
+
+	PR c++/83958
+	* g++.dg/cpp1z/decomp35.C: New test.
+
+	2018-01-20  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/83945
+	* gcc.dg/tls/pr83945.c: New test.
+
+	PR target/83930
+	* gcc.dg/pr83930.c: New test.
+
+	2018-01-18  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/83824
+	* g++.dg/cpp0x/pr83824.C: New test.
+
+	2018-01-16  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/83817
+	* g++.dg/cpp1y/pr83817.C: New test.
+
+	2018-01-05  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/83605
+	* gcc.dg/pr83605.c: New test.
+
+2018-03-01  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline
+	2018-02-26  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR target/84039
+	* gcc.target/i386/indirect-thunk-1.c: Updated.
+	* gcc.target/i386/indirect-thunk-2.c: Likewise.
+	* gcc.target/i386/indirect-thunk-3.c: Likewise.
+	* gcc.target/i386/indirect-thunk-4.c: Likewise.
+	* gcc.target/i386/indirect-thunk-5.c: Likewise.
+	* gcc.target/i386/indirect-thunk-6.c: Likewise.
+	* gcc.target/i386/indirect-thunk-7.c: Likewise.
+	* gcc.target/i386/indirect-thunk-attr-1.c: Likewise.
+	* gcc.target/i386/indirect-thunk-attr-2.c: Likewise.
+	* gcc.target/i386/indirect-thunk-attr-3.c: Likewise.
+	* gcc.target/i386/indirect-thunk-attr-4.c: Likewise.
+	* gcc.target/i386/indirect-thunk-attr-5.c: Likewise.
+	* gcc.target/i386/indirect-thunk-attr-6.c: Likewise.
+	* gcc.target/i386/indirect-thunk-attr-7.c: Likewise.
+	* gcc.target/i386/indirect-thunk-bnd-1.c: Likewise.
+	* gcc.target/i386/indirect-thunk-bnd-2.c: Likewise.
+	* gcc.target/i386/indirect-thunk-bnd-3.c: Likewise.
+	* gcc.target/i386/indirect-thunk-bnd-4.c: Likewise.
+	* gcc.target/i386/indirect-thunk-extern-1.c: Likewise.
+	* gcc.target/i386/indirect-thunk-extern-2.c: Likewise.
+	* gcc.target/i386/indirect-thunk-extern-3.c: Likewise.
+	* gcc.target/i386/indirect-thunk-extern-4.c: Likewise.
+	* gcc.target/i386/indirect-thunk-extern-5.c: Likewise.
+	* gcc.target/i386/indirect-thunk-extern-6.c: Likewise.
+	* gcc.target/i386/indirect-thunk-extern-7.c: Likewise.
+	* gcc.target/i386/indirect-thunk-inline-1.c: Likewise.
+	* gcc.target/i386/indirect-thunk-inline-2.c: Likewise.
+	* gcc.target/i386/indirect-thunk-inline-3.c: Likewise.
+	* gcc.target/i386/indirect-thunk-inline-4.c: Likewise.
+	* gcc.target/i386/indirect-thunk-inline-5.c: Likewise.
+	* gcc.target/i386/indirect-thunk-inline-6.c: Likewise.
+	* gcc.target/i386/indirect-thunk-inline-7.c: Likewise.
+	* gcc.target/i386/ret-thunk-9.c: Likewise.
+	* gcc.target/i386/ret-thunk-10.c: Likewise.
+	* gcc.target/i386/ret-thunk-11.c: Likewise.
+	* gcc.target/i386/ret-thunk-12.c: Likewise.
+	* gcc.target/i386/ret-thunk-13.c: Likewise.
+	* gcc.target/i386/ret-thunk-14.c: Likewise.
+	* gcc.target/i386/ret-thunk-15.c: Likewise.
+
+2018-03-01  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline
+	2018-02-26  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR target/84530
+	* gcc.target/i386/ret-thunk-22.c: New test.
+	* gcc.target/i386/ret-thunk-23.c: Likewise.
+	* gcc.target/i386/ret-thunk-24.c: Likewise.
+	* gcc.target/i386/ret-thunk-25.c: Likewise.
+	* gcc.target/i386/ret-thunk-26.c: Likewise.
+
+2017-03-02  Thomas Schwinge  <thomas@codesourcery.com>
+
+	Backport from trunk r256891:
+	2018-01-19  Cesar Philippidis  <cesar@codesourcery.com>
+
+	PR target/83790
+	* gcc.target/nvptx/indirect_call.c: New test.
+
+2017-03-01  Thomas Preud'homme  <thomas.preudhomme@arm.com>
+
+	Backport from mainline
+	2017-12-05  Matthew Gretton-Dann  <matthew.gretton-dann@arm.com>
+	with follow-up r255433 commit.
+
+	* gcc.c-torture/unsorted/dump-noaddr.x: Generate dump files in
+	tmpdir.
+
+2018-02-28  Alan Modra  <amodra@gmail.com>
+
+	* lib/prune.exp (prune_gcc_output): Match lower case "in function"
+	GNU ld message.
+	* g++.dg/other/anon5.C: Match lower case "bad value" GNU ld message.
+
+2018-02-26  Carl Love  <cel@us.ibm.com>
+
+	Backport from mainline: commit 257747 on 2018-02-16.
+
+	* gcc.target/powerpc/builtins-7-p9-runnable.c: New runnable test file
+	for the ABI definitions for vec_extract4b and vec_insert4b.
+
+2018-02-26  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc.c-torture/execute/20180226-1.c: New test.
+
+2018-02-25  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	ChangeLog for r257972
+	PR fortran/83633
+	* gfortran.dg/explicit_shape_1.f90: New test.
+	* gfortran.dg/automatic_module_variable.f90: Update regex.
+	* gfortran.dg/bad_automatic_objects_1.f90: Ditto.
+
+2018-02-25  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/78238
+	Backport from trunk
+	* gfortran.dg/select_type_40.f90: New test.
+
+2018-02-24  Steven G. Kargl <kargl@gcc.gnu.org>
+
+	PR fortran/30792
+	* gfortran.dg/data_substring.f90: New test.
+
+2018-02-23  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/84346
+	* gfortran.dg/statement_function_1.f90: Update test.
+
+2018-02-23  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/84506
+	* gfortran.dg/inquire_19.f90: New test.
+
+2018-02-22  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/81116
+	PR fortran/84495
+	* gfortran.dg/realloc_on_assignment_29.f90:  New test.
+
+2017-02-22  Sudakshina Das  <sudi.das@arm.com>
+
+	Backport from mainline:
+	2017-12-14  Sudakshina Das  <sudi.das@arm.com>
+
+	PR target/81228
+	* gcc.dg/pr81228.c: New.
+
+2018-02-19  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2018-01-02  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/81860
+	* g++.dg/cpp0x/inh-ctor30.C: New test.
+
+2018-02-18  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	Backport from trunk
+	PR libgfortran/84412
+	* gfortran.dg/inquire_18.f90: New test.
+
+2018-02-17  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/84270
+	* gfortran.dg/inline_matmul_22.f90: New test.
+
+2018-02-16  Jozef Lawrynowicz <jozefl.gcc@gmail.com>
+
+	PR target/79242
+	gcc.target/msp430/pr79242.c: New test.
+
+2018-02-16  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR ada/84277
+	* gnat.dg/array11.adb (Array11): Tweak index and remove warning.
+	* gnat.dg/dispatch1.adb: Rename into...
+	* gnat.dg/disp1.adb: ...this.
+	* gnat.dg/dispatch1_p.ads: Rename into...
+	* gnat.dg/disp1_pkg.ads: ...this.
+	* gnat.dg/disp2.adb: Rename into...
+	* gnat.dg/dispatch2.adb: ...this.
+	* gnat.dg/dispatch2_p.ads: Rename into...
+	* gnat.dg/disp2_pkg.ads: ...this.
+	* gnat.dg/dispatch2_p.adb: Rename into...
+	* gnat.dg/disp2_pkg.adb: this.
+	* gnat.dg/generic_dispatch.adb: Rename into...
+	* gnat.dg/generic_disp.adb: this.
+	* gnat.dg/generic_dispatch_p.ads: Rename into...
+	* gnat.dg/generic_disp_pkg.ads: ...this.
+	* gnat.dg/generic_dispatch_p.adb: Rename into...
+	* gnat.dg/generic_disp_pkg.adb: ...this.
+	* gnat.dg/null_pointer_deref1.adb (Null_Pointer_Deref1): Robustify.
+	* gnat.dg/null_pointer_deref2.adb (Null_Pointer_Deref2): Likewise.
+	* gnat.dg/object_overflow1.adb: Tweak index.
+	* gnat.dg/object_overflow2.adb: Likewise.
+	* gnat.dg/object_overflow3.adb: Likewise.
+	* gnat.dg/object_overflow4.adb: Likewise.
+	* gnat.dg/object_overflow5.adb: Likewise.
+
+2018-02-16  Sudakshina Das  <sudi.das@arm.com>
+
+	Backport from trunk
+	2018-01-12  Sudakshina Das  <sudi.das@arm.com>
+
+	* gcc.c-torture/compile/pr82096.c: Add dg-skip-if
+	directive.
+
+	Backport from trunk
+	2018-01-10  Sudakshina Das  <sudi.das@arm.com>
+
+	PR target/82096
+	* gcc.c-torture/compile/pr82096.c: New test.
+
+2018-02-16  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/84190
+	* g++.dg/torture/pr84190.C: New testcase.
+
+2018-02-15  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	Back port from trunk
+	2018-02-07  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	PR target/84154
+	* gcc.target/powerpc/pr84154-1.c: New tests.
+	* gcc.target/powerpc/pr84154-2.c: Likewise.
+	* gcc.target/powerpc/pr84154-3.c: Likewise.
+
+2018-02-15  Will Schmidt  <will_schmidt@vnet.ibm.com>
+
+	PR target/84388
+	* gcc.target/powerpc/fold-vec-mult-int128-p8.c: Update dg-options
+	and scan-assembler stanzas.
+	* gcc.target/powerpc/fold-vec-mult-int128-p9.c: Same.
+
+2018-02-14  Peter Bergner  <bergner@vnet.ibm.com>
+
+	PR target/84390
+	* gcc.target/powerpc/vsxcopy.c: Also match lxv when compiling
+	with -mcpu=power9.
+
+2018-02-14  Peter Bergner  <bergner@vnet.ibm.com>
+
+	Back port from mainline
+	2018-02-13  Peter Bergner  <bergner@vnet.ibm.com>
+
+	PR target/84279
+	* g++.dg/pr84279.C: New test.
+
+2018-02-12  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/68560
+	* gfortran.dg/shape_9.f90: New test.
+
+2018-02-12  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>
+
+	PR fortran/35299
+	ChangeLog for r257566
+	* gfortran.dg/statement_function_3.f: New test.
+
+2018-02-12  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/54223
+	PR fortran/84276
+	* gfortran.dg/statement_function_1.f90: New test.
+	* gfortran.dg/statement_function_2.f90: New test.
+
+2018-02-09  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2018-02-09  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	PR target/PR84295
+	* gcc.target/s390/pr84295.c: New test.
+
+2018-02-08  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2018-02-08  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	* gcc.target/s390/nobp-function-pointer-attr.c: New test.
+	* gcc.target/s390/nobp-function-pointer-nothunk.c: New test.
+	* gcc.target/s390/nobp-function-pointer-z10.c: New test.
+	* gcc.target/s390/nobp-function-pointer-z900.c: New test.
+	* gcc.target/s390/nobp-indirect-jump-attr.c: New test.
+	* gcc.target/s390/nobp-indirect-jump-inline-attr.c: New test.
+	* gcc.target/s390/nobp-indirect-jump-inline-z10.c: New test.
+	* gcc.target/s390/nobp-indirect-jump-inline-z900.c: New test.
+	* gcc.target/s390/nobp-indirect-jump-nothunk.c: New test.
+	* gcc.target/s390/nobp-indirect-jump-z10.c: New test.
+	* gcc.target/s390/nobp-indirect-jump-z900.c: New test.
+	* gcc.target/s390/nobp-return-attr-all.c: New test.
+	* gcc.target/s390/nobp-return-attr-neg.c: New test.
+	* gcc.target/s390/nobp-return-mem-attr.c: New test.
+	* gcc.target/s390/nobp-return-mem-nothunk.c: New test.
+	* gcc.target/s390/nobp-return-mem-z10.c: New test.
+	* gcc.target/s390/nobp-return-mem-z900.c: New test.
+	* gcc.target/s390/nobp-return-reg-attr.c: New test.
+	* gcc.target/s390/nobp-return-reg-mixed.c: New test.
+	* gcc.target/s390/nobp-return-reg-nothunk.c: New test.
+	* gcc.target/s390/nobp-return-reg-z10.c: New test.
+	* gcc.target/s390/nobp-return-reg-z900.c: New test.
+	* gcc.target/s390/nobp-table-jump-inline-z10.c: New test.
+	* gcc.target/s390/nobp-table-jump-inline-z900.c: New test.
+	* gcc.target/s390/nobp-table-jump-z10.c: New test.
+	* gcc.target/s390/nobp-table-jump-z900.c: New test.
+
+2018-02-08  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/84233
+	* g++.dg/torture/pr84233.C: New testcase.
+
+2018-02-07  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/82994
+	* gfortran.dg/deallocate_error_3.f90: New test.
+	* gfortran.dg/deallocate_error_4.f90: New test.
+
+2018-02-07  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/82049
+	* gfortran.dg/assumed_charlen_parameter.f90: New test.
+
+2018-02-07  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2018-02-06  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	* gcc.target/powerpc/safe-indirect-jump-1.c: Detect deprecation
+	warning for -mno-speculate-indirect-jumps.
+	* gcc.target/powerpc/safe-indirect-jump-2.c: Likewise.
+	* gcc.target/powerpc/safe-indirect-jump-3.c: Likewise.
+	* gcc.target/powerpc/safe-indirect-jump-4.c: Likewise.
+	* gcc.target/powerpc/safe-indirect-jump-5.c: Likewise.
+	* gcc.target/powerpc/safe-indirect-jump-6.c: Likewise.
+	* gcc.target/powerpc/safe-indirect-jump-7.c: Likewise.
+
+2018-02-06  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	PR target/79975
+	* gcc.dg/rtl/x86_64/final.c: Add -fdwarf2-cfi-asm to dg-options.
+
+2017-02-02  Uros Bizjak  <ubizjak@gmail.com>
+
+	* gfortran.dg/dec_parameter_1.f (sub1): Remove statement with no effect.
+	* gfortran.dg/dec_parameter_2.f90 (sub1): Ditto.
+
+2018-02-01  Renlin Li  <renlin.li@arm.com>
+
+	Backport from mainline
+	2018-02-01  Richard Sandiford  <richard.sandiford@linaro.org>
+
+	PR target/83370
+	* gcc.target/aarch64/pr83370.c: New.
+
+2018-02-01  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2017-11-02  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/82795
+	* gcc.target/i386/pr82795.c: New testcase.
+
+2018-02-01  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	Backport from mainline
+	2018-01-12  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	* lib/target-supports.exp (check_effective_target_avx512f): Also
+	check for __builtin_ia32_addsd_round,
+	__builtin_ia32_getmantsd_round.
+	* gcc.target/i386/i386.exp (check_effective_target_avx512f):
+	Remove.
+
+2018-01-31  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc.c-torture/execute/20180131-1.c: New test.
+
+2018-01-29  Alan Modra  <amodra@gmail.com>
+
+	PR target/84033
+	* gcc.target/powerpc/swaps-p8-46.c: New.
+
+2018-01-26  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	Backport from trunk
+	2018-01-26  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	* gcc.target/powerpc/safe-indirect-jump-1.c: Build on all targets.
+	Make expected output depend on whether we expect sibcalls or not.
+	* gcc.target/powerpc/safe-indirect-jump-8.c: Delete (merged into
+	safe-indirect-jump-1.c).
+
+	Backport from trunk
+	2018-01-21  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	PR target/83946
+	* gcc.target/powerpc/safe-indirect-jump-8.c: Skip for AIX.
+
+2018-01-26  Nathan Sidwell  <nathan@acm.org>
+
+	PR c++/82878
+	* g++.dg/cpp0x/pr82878.C: New.
+	* g++.dg/cpp1z/inh-ctor38.C: Check moves too.
+
+2018-01-26  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/83985
+	* gcc.dg/pr83985.c: New test.
+
+2018-01-25  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	Back port from trunk
+	2018-01-22  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	PR target/83862
+	* gcc.target/powerpc/pr83862.c: New test.
+
+2018-01-25  Peter Bergner  <bergner@vnet.ibm.com>
+
+	Back port from mainline
+	2018-01-10  Peter Bergner  <bergner@vnet.ibm.com>
+
+	PR target/83399
+	* gcc.target/powerpc/pr83399.c: New test.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
@@ -920,7 +3811,7 @@
 
 	Backported from trunk
 	PR fortran/80850
-	* gfortran.dg/class_64_f90 : New test.
+	* gfortran.dg/class_64_f90: New test.
 
 2017-10-30  Paolo Carlini  <paolo.carlini@oracle.com>
 
@@ -971,7 +3862,7 @@
 
 	Backport from trunk
 	PR fortran/82312
-	* gfortran.dg/typebound_proc_36.f90 : New test.
+	* gfortran.dg/typebound_proc_36.f90: New test.
 
 2017-10-20  Thomas Koenig  <tkoenig@gcc.gnu.org>
 
diff --git a/gcc/testsuite/c-c++-common/gomp/pr83977-1.c b/gcc/testsuite/c-c++-common/gomp/pr83977-1.c
new file mode 100644
index 00000000000..9941db49469
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/gomp/pr83977-1.c
@@ -0,0 +1,19 @@
+/* PR middle-end/83977 */
+/* { dg-do compile } */
+/* { dg-additional-options "-O2" } */
+
+struct S { int a, b, c; };
+
+#pragma omp declare simd uniform(z) linear(v:1)
+__attribute__((noinline)) static int
+foo (int x, int y, struct S z, int u, int v)
+{
+  return x + y + z.a;
+}
+
+int
+bar (int x, int y, int z)
+{
+  struct S s = { z, 1, 1 };
+  return foo (x, y, s, 0, 0);
+}
diff --git a/gcc/testsuite/c-c++-common/gomp/pr83977-2.c b/gcc/testsuite/c-c++-common/gomp/pr83977-2.c
new file mode 100644
index 00000000000..c3359b9f05e
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/gomp/pr83977-2.c
@@ -0,0 +1,18 @@
+/* PR middle-end/83977 */
+/* { dg-do compile } */
+
+void bar (void);
+
+#pragma omp declare simd uniform (b) linear(a:b)
+int
+foo (int a, int b)
+{
+  a = a + 1;
+/* This function can't be called from simd loops,
+   because it violates declare simd restrictions.
+   We shouldn't ICE on it though, nor attempt to generate
+   simd clones for the *omp_fn* functions.  */
+  #pragma omp parallel
+  bar ();  
+  return a;
+}
diff --git a/gcc/testsuite/c-c++-common/gomp/pr83977-3.c b/gcc/testsuite/c-c++-common/gomp/pr83977-3.c
new file mode 100644
index 00000000000..00e18d85b37
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/gomp/pr83977-3.c
@@ -0,0 +1,21 @@
+/* PR middle-end/83977 */
+/* { dg-do compile } */
+
+void bar (void);
+int foo (int, int) __attribute__((used));
+
+#pragma omp declare simd uniform (b) linear(a:b)
+int
+foo (int a, int b)
+{
+  a = a + 1;
+/* This function can't be called from simd loops,
+   because it violates declare simd restrictions.
+   We shouldn't ICE on it though, nor attempt to generate
+   simd clones for the *omp_fn* functions.  */
+  #pragma omp parallel
+  bar ();  
+  return a;
+}
+
+int foo (int, int)  __attribute__((unused));
diff --git a/gcc/testsuite/c-c++-common/gomp/pr84341.c b/gcc/testsuite/c-c++-common/gomp/pr84341.c
new file mode 100644
index 00000000000..557f1ba21bd
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/gomp/pr84341.c
@@ -0,0 +1,10 @@
+/* PR c++/84341 */
+/* { dg-do compile } */
+/* { dg-options "-fopenmp" } */
+
+void
+foo (int i)
+{
+  #pragma omp atomic
+    i = &i + 1;		/* { dg-error "invalid form of" } */
+}
diff --git a/gcc/testsuite/c-c++-common/gomp/pr85696.c b/gcc/testsuite/c-c++-common/gomp/pr85696.c
new file mode 100644
index 00000000000..798718b563d
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/gomp/pr85696.c
@@ -0,0 +1,20 @@
+/* PR c/85696 */
+
+#ifndef __cplusplus
+void
+foo (int n, int a[][n])
+{
+  #pragma omp parallel shared(a) default(none)
+  #pragma omp master
+    a[23][0] = 42;
+}
+#endif
+
+void
+bar (int n, void *p)
+{
+  int (*a)[n] = (int (*)[n]) p;
+  #pragma omp parallel shared(a) default(none)
+  #pragma omp master
+    a[23][0] = 42;
+}
diff --git a/gcc/testsuite/c-c++-common/gomp/pr86025.c b/gcc/testsuite/c-c++-common/gomp/pr86025.c
new file mode 100644
index 00000000000..c1c50799413
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/gomp/pr86025.c
@@ -0,0 +1,20 @@
+/* PR c++/86025 */
+/* { dg-do compile } */
+/* { dg-additional-options "-Wduplicated-branches" } */
+
+int i;
+
+void
+foo (int x)
+{
+  if (x)
+    {
+      #pragma omp critical (foo)
+      i++;
+    }
+  else
+    {
+      #pragma omp critical
+      i++;
+    }
+}
diff --git a/gcc/testsuite/c-c++-common/pr43690.c b/gcc/testsuite/c-c++-common/pr43690.c
index 67c6cb0f88c..8d10744903f 100644
--- a/gcc/testsuite/c-c++-common/pr43690.c
+++ b/gcc/testsuite/c-c++-common/pr43690.c
@@ -6,8 +6,8 @@ void
 foo (char *x)
 {
   asm ("" : : "m" (x++));	/* { dg-error "is not directly addressable" } */
-  asm ("" : : "m" (++x));	/* { dg-error "is not directly addressable" } */
+  asm ("" : : "m" (++x));	/* { dg-error "is not directly addressable" "" { target c } } */
   asm ("" : : "m" (x--));	/* { dg-error "is not directly addressable" } */
-  asm ("" : : "m" (--x));	/* { dg-error "is not directly addressable" } */
+  asm ("" : : "m" (--x));	/* { dg-error "is not directly addressable" "" { target c } } */
   asm ("" : : "m" (x + 1));	/* { dg-error "is not directly addressable" } */
 }
diff --git a/gcc/testsuite/c-c++-common/pr84873.c b/gcc/testsuite/c-c++-common/pr84873.c
new file mode 100644
index 00000000000..5eb8a8df81d
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/pr84873.c
@@ -0,0 +1,8 @@
+/* { dg-do compile } */
+/* { dg-additional-options "-frounding-math" } */
+
+int
+i1 (int w3, int n9)
+{
+  return w3 >> ((long int)(1 + 0.1) + -!n9);
+}
diff --git a/gcc/testsuite/c-c++-common/pr84999.c b/gcc/testsuite/c-c++-common/pr84999.c
new file mode 100644
index 00000000000..42d53769a3b
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/pr84999.c
@@ -0,0 +1,12 @@
+/* PR c/84999 */
+/* { dg-do compile { target { i?86-*-* x86_64-*-* } } } */
+/* { dg-options "" } */
+
+typedef __float128 V __attribute__ ((__vector_size__ (2 * sizeof (__float128))));
+V a;
+typeof (a != 0) b;	/* { dg-error "could not find an integer type of the same size as" "" { target ia32 } } */
+typeof (a == 0) c;	/* { dg-error "could not find an integer type of the same size as" "" { target ia32 } } */
+typeof (a < 0) d;	/* { dg-error "could not find an integer type of the same size as" "" { target ia32 } } */
+typeof (a <= 0) e;	/* { dg-error "could not find an integer type of the same size as" "" { target ia32 } } */
+typeof (a > 0) f;	/* { dg-error "could not find an integer type of the same size as" "" { target ia32 } } */
+typeof (a >= 0) g;	/* { dg-error "could not find an integer type of the same size as" "" { target ia32 } } */
diff --git a/gcc/testsuite/c-c++-common/torture/asm-inline.c b/gcc/testsuite/c-c++-common/torture/asm-inline.c
new file mode 100644
index 00000000000..dea89658be4
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/torture/asm-inline.c
@@ -0,0 +1,53 @@
+/* { dg-do compile } */
+/* -O0 does no inlining, and -O3 does it too aggressively for this test:  */
+/* { dg-skip-if "" { *-*-* } { "-O0" "-O3" } { "" } }
+/* The normal asm is not inlined:  */
+/* { dg-final { scan-assembler-times "w.w.w.w.w.w.w.w.w.w.w.w.w.w.w.w.w.w.w.w.w.w.w.w.w.w.w.w.w.w" 2 } } */
+/* But the asm inline is inlined:  */
+/* { dg-final { scan-assembler-times "x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x" 8 } } */
+
+static void f(void)
+{
+  asm ("w\nw\nw\nw\nw\nw\nw\nw\nw\nw\nw\nw\nw\nw\nw\n"
+       "w\nw\nw\nw\nw\nw\nw\nw\nw\nw\nw\nw\nw\nw\nw");
+}
+
+int f0(void) { f(); return 0; }
+int f1(void) { f(); return 1; }
+int f2(void) { f(); return 2; }
+int f3(void) { f(); return 3; }
+
+static void fg(void)
+{
+  asm goto("w\nw\nw\nw\nw\nw\nw\nw\nw\nw\nw\nw\nw\nw\nw\n"
+	   "w\nw\nw\nw\nw\nw\nw\nw\nw\nw\nw\nw\nw\nw\nw" :::: q);
+  q: ;
+}
+
+int fg0(void) { fg(); return 0; }
+int fg1(void) { fg(); return 1; }
+int fg2(void) { fg(); return 2; }
+int fg3(void) { fg(); return 3; }
+
+static void g(void)
+{
+  asm inline("x\nx\nx\nx\nx\nx\nx\nx\nx\nx\nx\nx\nx\nx\nx\n"
+	     "x\nx\nx\nx\nx\nx\nx\nx\nx\nx\nx\nx\nx\nx\nx");
+}
+
+int g0(void) { g(); return 0; }
+int g1(void) { g(); return 1; }
+int g2(void) { g(); return 2; }
+int g3(void) { g(); return 3; }
+
+static void gg(void)
+{
+  asm inline goto("x\nx\nx\nx\nx\nx\nx\nx\nx\nx\nx\nx\nx\nx\nx\n"
+		  "x\nx\nx\nx\nx\nx\nx\nx\nx\nx\nx\nx\nx\nx\nx" :::: q);
+  q: ;
+}
+
+int gg0(void) { gg(); return 0; }
+int gg1(void) { gg(); return 1; }
+int gg2(void) { gg(); return 2; }
+int gg3(void) { gg(); return 3; }
diff --git a/gcc/testsuite/c-c++-common/torture/pr85022.c b/gcc/testsuite/c-c++-common/torture/pr85022.c
new file mode 100644
index 00000000000..3ec2c781aa1
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/torture/pr85022.c
@@ -0,0 +1,9 @@
+/* PR inline-asm/85022 */
+
+extern struct B b;
+
+void
+foo ()
+{
+  __asm ("" : "+m" (b));
+}
diff --git a/gcc/testsuite/c-c++-common/torture/pr87248.c b/gcc/testsuite/c-c++-common/torture/pr87248.c
new file mode 100644
index 00000000000..6f89bc9a31c
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/torture/pr87248.c
@@ -0,0 +1,36 @@
+/* PR middle-end/87248 */
+/* { dg-do run } */
+
+void
+foo (signed char *p, int q)
+{
+  *p = q & (-__SCHAR_MAX__ - 1) ? (-__SCHAR_MAX__ - 1) : 0;
+}
+
+int
+bar (long long x)
+{
+  return x & (-__INT_MAX__ - 1) ? (-__INT_MAX__ - 1) : 0;
+}
+
+int
+main ()
+{
+#if __INT_MAX__ > 4 * __SCHAR_MAX__
+  signed char a[4];
+  foo (a, __SCHAR_MAX__ + 1U);
+  foo (a + 1, 2 * (__SCHAR_MAX__ + 1U));
+  foo (a + 2, -__INT_MAX__ - 1);
+  foo (a + 3, (__SCHAR_MAX__ + 1U) / 2);
+  if (a[0] != (-__SCHAR_MAX__ - 1) || a[1] != a[0] || a[2] != a[0] || a[3] != 0)
+    __builtin_abort ();
+#endif
+#if __LONG_LONG_MAX__ > 4 * __INT_MAX__
+  if (bar (__INT_MAX__ + 1LL) != (-__INT_MAX__ - 1)
+      || bar (2 * (__INT_MAX__ + 1LL)) != (-__INT_MAX__ - 1)
+      || bar (-__LONG_LONG_MAX__ - 1) != (-__INT_MAX__ - 1)
+      || bar ((__INT_MAX__ + 1LL) / 2) != 0)
+    __builtin_abort ();
+#endif
+  return 0;
+}
diff --git a/gcc/testsuite/c-c++-common/tsan/race_on_mutex.c b/gcc/testsuite/c-c++-common/tsan/race_on_mutex.c
index ae30d053c92..2e4b7ac3cb9 100644
--- a/gcc/testsuite/c-c++-common/tsan/race_on_mutex.c
+++ b/gcc/testsuite/c-c++-common/tsan/race_on_mutex.c
@@ -37,9 +37,10 @@ int main() {
 }
 
 /* { dg-output "WARNING: ThreadSanitizer: data race.*(\n|\r\n|\r)" } */
-/* { dg-output "  Atomic read of size 1 at .* by thread T2:(\n|\r\n|\r)" } */
+/* { dg-output "  Atomic read of size \[0-9]\+ at .* by thread T2:(\n|\r\n|\r)" } */
 /* { dg-output "    #0 pthread_mutex_lock.*" } */
 /* { dg-output "    #1 Thread2.* .*(race_on_mutex.c:22|\\?{2}:0) (.*)" } */
-/* { dg-output "  Previous write of size 1 at .* by thread T1:(\n|\r\n|\r)" } */
-/* { dg-output "    #0 pthread_mutex_init .* (.)*" } */
-/* { dg-output "    #1 Thread1.* .*(race_on_mutex.c:12|\\?{2}:0) .*" } */
+/* { dg-output "  Previous write of size \[0-9]\+ at .* by thread T1:(\n|\r\n|\r)" } */
+/* { dg-output "(    #0 \[^\n\r\]*(\n|\r\n|\r))?" } */
+/* { dg-output "    #\[01\] ((__GI_)?__)?pthread_mutex_init \[^\n\r\]* (.)*" } */
+/* { dg-output "    #\[12\] Thread1.* .*(race_on_mutex.c:12|\\?{2}:0) .*" } */
diff --git a/gcc/testsuite/g++.dg/asan/pr78651.C b/gcc/testsuite/g++.dg/asan/pr78651.C
new file mode 100644
index 00000000000..09f1be538c3
--- /dev/null
+++ b/gcc/testsuite/g++.dg/asan/pr78651.C
@@ -0,0 +1,26 @@
+// PR sanitizer/78651
+// { dg-do run }
+// { dg-additional-options "-fpic" { target fpic } }
+
+struct A { };
+
+namespace {
+
+void thisThrows () {
+  throw A();
+}
+
+struct SomeRandomType {};
+}
+
+int main() {
+  try {
+    thisThrows();
+  }
+  catch (SomeRandomType) {
+    throw;
+  }
+  catch (A) {
+  }
+  return 0;
+}
diff --git a/gcc/testsuite/g++.dg/asan/pr85081.C b/gcc/testsuite/g++.dg/asan/pr85081.C
new file mode 100644
index 00000000000..d7dec311450
--- /dev/null
+++ b/gcc/testsuite/g++.dg/asan/pr85081.C
@@ -0,0 +1,20 @@
+/* PR sanitizer/85081 */
+/* { dg-do run } */
+/* { dg-options "-fopenmp-simd" } */
+/* { dg-require-effective-target fopenmp } */
+
+inline const int& max(const int& a, const int& b)
+{
+  return a < b ? b : a;
+}
+
+int main()
+{
+  #pragma omp simd
+  for ( int i = 0; i < 20; ++i )
+  {
+    const int j = max(i, 1);
+  }
+
+  return 0;
+}
diff --git a/gcc/testsuite/g++.dg/asm-qual-1.C b/gcc/testsuite/g++.dg/asm-qual-1.C
new file mode 100644
index 00000000000..3fba592ee99
--- /dev/null
+++ b/gcc/testsuite/g++.dg/asm-qual-1.C
@@ -0,0 +1,13 @@
+// Test that qualifiers other than volatile are disallowed on asm.
+// { dg-do compile }
+// { dg-options "-std=gnu++98" }
+
+void
+f ()
+{
+  asm volatile ("");
+
+  asm const (""); // { dg-error {'const' is not an asm qualifier} }
+
+  asm __restrict (""); // { dg-error {'__restrict' is not an asm qualifier} }
+}
diff --git a/gcc/testsuite/g++.dg/asm-qual-2.C b/gcc/testsuite/g++.dg/asm-qual-2.C
new file mode 100644
index 00000000000..52968bdfd17
--- /dev/null
+++ b/gcc/testsuite/g++.dg/asm-qual-2.C
@@ -0,0 +1,46 @@
+// Test that qualifiers on asm are allowed in any order.
+// { dg-do compile }
+// { dg-options "-std=c++98" }
+
+void
+f ()
+{
+  asm volatile goto ("" :::: lab);
+  asm volatile inline ("" :::);
+  asm inline volatile ("" :::);
+  asm inline goto ("" :::: lab);
+  asm goto volatile ("" :::: lab);
+  asm goto inline ("" :::: lab);
+
+  asm volatile inline goto ("" :::: lab);
+  asm volatile goto inline ("" :::: lab);
+  asm inline volatile goto ("" :::: lab);
+  asm inline goto volatile ("" :::: lab);
+  asm goto volatile inline ("" :::: lab);
+  asm goto inline volatile ("" :::: lab);
+
+  /* Duplicates are not allowed.  */
+  asm goto volatile volatile ("" :::: lab);  /* { dg-error "" } */
+  asm volatile goto volatile ("" :::: lab);  /* { dg-error "" } */
+  asm volatile volatile goto ("" :::: lab);  /* { dg-error "" } */
+  asm goto goto volatile ("" :::: lab);  /* { dg-error "" } */
+  asm goto volatile goto ("" :::: lab);  /* { dg-error "" } */
+  asm volatile goto goto ("" :::: lab);  /* { dg-error "" } */
+
+  asm inline volatile volatile ("" :::);  /* { dg-error "" } */
+  asm volatile inline volatile ("" :::);  /* { dg-error "" } */
+  asm volatile volatile inline ("" :::);  /* { dg-error "" } */
+  asm inline inline volatile ("" :::);  /* { dg-error "" } */
+  asm inline volatile inline ("" :::);  /* { dg-error "" } */
+  asm volatile inline inline ("" :::);  /* { dg-error "" } */
+
+  asm goto inline inline ("" :::: lab);  /* { dg-error "" } */
+  asm inline goto inline ("" :::: lab);  /* { dg-error "" } */
+  asm inline inline goto ("" :::: lab);  /* { dg-error "" } */
+  asm goto goto inline ("" :::: lab);  /* { dg-error "" } */
+  asm goto inline goto ("" :::: lab);  /* { dg-error "" } */
+  asm inline goto goto ("" :::: lab);  /* { dg-error "" } */
+
+lab:
+  ;
+}
diff --git a/gcc/testsuite/g++.dg/asm-qual-3.C b/gcc/testsuite/g++.dg/asm-qual-3.C
new file mode 100644
index 00000000000..6faf0ef5e06
--- /dev/null
+++ b/gcc/testsuite/g++.dg/asm-qual-3.C
@@ -0,0 +1,12 @@
+// Test that asm-qualifiers are not allowed on toplevel asm.
+// { dg-do compile }
+// { dg-options "-std=gnu++98" }
+
+asm const ("");    // { dg-error {'const' is not an asm qualifier} }
+asm volatile ("");
+asm restrict (""); // { dg-error {expected '\(' before 'restrict'} }
+asm inline ("");   // { dg-error {asm qualifier outside of function body} }
+asm goto ("");     // { dg-error {asm qualifier outside of function body} }
+
+// There are many other things wrong with this code, so:
+// { dg-excess-errors "" }
diff --git a/gcc/testsuite/g++.dg/concepts/auto4.C b/gcc/testsuite/g++.dg/concepts/auto4.C
new file mode 100644
index 00000000000..e80341ec038
--- /dev/null
+++ b/gcc/testsuite/g++.dg/concepts/auto4.C
@@ -0,0 +1,11 @@
+// PR c++/85006
+// { dg-additional-options "-std=c++17 -fconcepts" }
+
+template<typename... Ts> struct A {};
+
+template<typename... Us> A<auto...> foo() { return A{}; }
+
+void bar()
+{
+  foo();
+}
diff --git a/gcc/testsuite/g++.dg/cpp0x/auto-60626.C b/gcc/testsuite/g++.dg/cpp0x/auto-60626.C
new file mode 100644
index 00000000000..35671924ea9
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/auto-60626.C
@@ -0,0 +1,6 @@
+// PR c++/60626
+// { dg-do compile { target c++14 } }
+
+struct A {};
+
+void (*A::p)(auto) = 0;  // { dg-error "auto|static data member|template" }
diff --git a/gcc/testsuite/g++.dg/cpp0x/auto51.C b/gcc/testsuite/g++.dg/cpp0x/auto51.C
new file mode 100644
index 00000000000..dfb08336b53
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/auto51.C
@@ -0,0 +1,9 @@
+// PR c++/84798
+// { dg-do compile { target c++11 } }
+
+template<typename T>
+struct S {
+    static constexpr T value = 0;
+};
+
+constexpr auto x = S<void(*)(auto)>::value; // { dg-error "auto" }
diff --git a/gcc/testsuite/g++.dg/cpp0x/constexpr-84449.C b/gcc/testsuite/g++.dg/cpp0x/constexpr-84449.C
new file mode 100644
index 00000000000..f187c425272
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/constexpr-84449.C
@@ -0,0 +1,14 @@
+// PR c++/84449
+// { dg-do compile { target c++11 } }
+
+struct A
+{
+  constexpr A (int) {}
+  ~A () = delete;
+};
+
+struct B
+{
+  A a;
+  constexpr B () : a (0) {}	// { dg-error "use of deleted function" }
+};
diff --git a/gcc/testsuite/g++.dg/cpp0x/constexpr-84463.C b/gcc/testsuite/g++.dg/cpp0x/constexpr-84463.C
new file mode 100644
index 00000000000..0743059be53
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/constexpr-84463.C
@@ -0,0 +1,22 @@
+// PR c++/84463
+// { dg-do compile { target c++11 } }
+
+struct S { int r; const unsigned char s[5]; };
+static constexpr S a[] = { { 0, "abcd" } };
+struct T { const unsigned char s[5]; };
+static constexpr T b[] = { { "abcd" } };
+
+constexpr int
+foo (const unsigned char *x)
+{
+  return x[0];
+}
+
+constexpr static const S *j = &a[0];
+constexpr static const int k = j->s[0];
+constexpr static int l = foo (a[0].s);
+constexpr static int m = foo (j->s);
+constexpr static const T *n = &b[0];
+constexpr static const int o = n->s[0];
+constexpr static int p = foo (b[0].s);
+constexpr static int q = foo (n->s);
diff --git a/gcc/testsuite/g++.dg/cpp0x/constexpr-ctor21.C b/gcc/testsuite/g++.dg/cpp0x/constexpr-ctor21.C
new file mode 100644
index 00000000000..4bf57b9e897
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/constexpr-ctor21.C
@@ -0,0 +1,15 @@
+// PR c++/83835
+// { dg-do compile { target c++11 } }
+
+struct Z
+{
+  void const * p_;
+  constexpr Z( void const * p ): p_( p ) {}
+  ~Z();
+};
+
+struct Y
+{
+  Z z_;
+  constexpr Y() noexcept: z_( this ) {}
+};
diff --git a/gcc/testsuite/g++.dg/cpp0x/constexpr-list2.C b/gcc/testsuite/g++.dg/cpp0x/constexpr-list2.C
new file mode 100644
index 00000000000..780a64dbbc4
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/constexpr-list2.C
@@ -0,0 +1,20 @@
+// PR c++/82461
+// { dg-do compile { target c++11 } }
+
+class A {
+private:
+public:
+  constexpr A() {}
+  ~A() {}
+};
+
+class B {
+private:
+  A  a;
+public:
+  constexpr B() : a{} {}
+// works
+// constexpr B() : a() {}
+
+  ~B() {}
+};
diff --git a/gcc/testsuite/g++.dg/cpp0x/constexpr-nullptr-1.C b/gcc/testsuite/g++.dg/cpp0x/constexpr-nullptr-1.C
index e2f7917d36e..ed53fcd69aa 100644
--- a/gcc/testsuite/g++.dg/cpp0x/constexpr-nullptr-1.C
+++ b/gcc/testsuite/g++.dg/cpp0x/constexpr-nullptr-1.C
@@ -6,7 +6,7 @@
 // c++/67376 on gcc-patches for additional background.
 
 // { dg-do compile { target c++11 } }
-// { dg-options "-fdelete-null-pointer-checks -fdump-tree-optimized" }
+// { dg-options "-O1 -fdelete-null-pointer-checks -fdump-tree-optimized" }
 
 // Runtime assert.  Used for potentially invalid expressions.
 #define RA(e)  ((e) ? (void)0 : __builtin_abort ())
diff --git a/gcc/testsuite/g++.dg/cpp0x/constexpr-nullptr-2.C b/gcc/testsuite/g++.dg/cpp0x/constexpr-nullptr-2.C
index aeea87c2ae7..3b3f01adea3 100644
--- a/gcc/testsuite/g++.dg/cpp0x/constexpr-nullptr-2.C
+++ b/gcc/testsuite/g++.dg/cpp0x/constexpr-nullptr-2.C
@@ -192,12 +192,11 @@ constexpr bool b11 = ps >= (S*)0;
 constexpr S* ps1 = ps;
 constexpr S* ps2 = ps1;
 
-// The following aren't diagnosed due to a bug.
-// constexpr int* pi0 = &((S*)0)->i;
-// constexpr int* pi1 = &((S*)nullptr)->i;
+constexpr int* pi0 = &((S*)0)->i;	// { dg-error "null pointer|not a constant" }
+constexpr int* pi1 = &((S*)nullptr)->i;	// { dg-error "null pointer|not a constant" }
 
-constexpr int* pj0 = &((S*)0)->j;	// { dg-error "not a constant expression" }
-constexpr int* pj1 = &((S*)nullptr)->j;  // { dg-error "not a constant expression" }
+constexpr int* pj0 = &((S*)0)->j;	// { dg-error "null pointer|not a constant" }
+constexpr int* pj1 = &((S*)nullptr)->j;	// { dg-error "null pointer|not a constant" }
 
 constexpr int* psi = &ps->i;	    // { dg-error "null pointer|not a constant" }
 constexpr int* psj = &ps->j;	    // { dg-error "null pointer|not a constant" }
diff --git a/gcc/testsuite/g++.dg/cpp0x/decltype-33837.C b/gcc/testsuite/g++.dg/cpp0x/decltype-33837.C
index fbbc6a14972..4a8f053234e 100644
--- a/gcc/testsuite/g++.dg/cpp0x/decltype-33837.C
+++ b/gcc/testsuite/g++.dg/cpp0x/decltype-33837.C
@@ -2,6 +2,6 @@
 // PR c++/33837
 void foo()
 {
-  __decltype (A::foo()); // { dg-error "was not declared|expected" }
-  __decltype (B); // { dg-error "was not declared" }
+  __decltype (A::foo()); // { dg-error "A" }
+  __decltype (B); // { dg-error "B" }
 }
diff --git a/gcc/testsuite/g++.dg/cpp0x/decltype43.C b/gcc/testsuite/g++.dg/cpp0x/decltype43.C
index 4df95a1047c..7a1dcbf8744 100644
--- a/gcc/testsuite/g++.dg/cpp0x/decltype43.C
+++ b/gcc/testsuite/g++.dg/cpp0x/decltype43.C
@@ -22,6 +22,6 @@ struct B
 int main()
 {
   int x = B<decltype(A<int>::a(1))>::b(A<int>::a(1));
-  int y = B<decltype(A     ::a(2))>::b(A<int>::a(2)); // { dg-error "template argument" }
+  int y = B<decltype(A     ::a(2))>::b(A<int>::a(2)); // { dg-error "template" }
   return x + y;
 }
diff --git a/gcc/testsuite/g++.dg/cpp0x/decltype67.C b/gcc/testsuite/g++.dg/cpp0x/decltype67.C
new file mode 100644
index 00000000000..e8042ac59e7
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/decltype67.C
@@ -0,0 +1,7 @@
+// PR c++/85279
+// { dg-do compile { target c++11 } }
+
+template<typename T> struct A
+{
+  void foo(decltype(T())::Y);	// { dg-error {decltype\(T\(\)\)::Y} }
+};
diff --git a/gcc/testsuite/g++.dg/cpp0x/elision3.C b/gcc/testsuite/g++.dg/cpp0x/elision3.C
new file mode 100644
index 00000000000..7c5c8b9f0b9
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/elision3.C
@@ -0,0 +1,21 @@
+// PR c++/84441
+// { dg-do compile { target c++11 } }
+
+struct B {
+  int *b;
+};
+struct A {
+  B b;
+  A (A &&);
+};
+struct C {
+  A c;
+  int d;
+};
+C bar ();
+struct D : C {
+  D ()
+    : C (0 ? bar () : bar ())
+  {}
+};
+D d;
diff --git a/gcc/testsuite/g++.dg/cpp0x/extern_template-4.C b/gcc/testsuite/g++.dg/cpp0x/extern_template-4.C
new file mode 100644
index 00000000000..9f0c7d720ab
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/extern_template-4.C
@@ -0,0 +1,23 @@
+// PR c++/85470
+// { dg-do compile { target c++11 } }
+
+template <class T>
+struct StaticObject
+{
+    static T& create()
+    {
+      static T t;
+      return t;
+    }
+
+    static T & instance;
+};
+
+template <class T> T & StaticObject<T>::instance = StaticObject<T>::create();
+
+extern template class StaticObject<int>;
+
+void test()
+{
+    StaticObject<int>::instance;
+}
diff --git a/gcc/testsuite/g++.dg/cpp0x/fntmpdefarg8.C b/gcc/testsuite/g++.dg/cpp0x/fntmpdefarg8.C
new file mode 100644
index 00000000000..8d9b2d26f01
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/fntmpdefarg8.C
@@ -0,0 +1,10 @@
+// PR c++/80227
+// { dg-do compile { target c++11 } }
+
+template <class T>
+int foo (T);
+
+template <class T, class U = T [sizeof (T) - 5]>
+int foo (T, U* = 0);
+
+int i = foo (123);
diff --git a/gcc/testsuite/g++.dg/cpp0x/gen-attrs-64.C b/gcc/testsuite/g++.dg/cpp0x/gen-attrs-64.C
new file mode 100644
index 00000000000..c0d48fc88e9
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/gen-attrs-64.C
@@ -0,0 +1,4 @@
+// PR c++/85140
+// { dg-do compile { target c++11 } }
+
+namespace N alignas() {}	// { dg-error "expected" }
diff --git a/gcc/testsuite/g++.dg/cpp0x/inh-ctor30.C b/gcc/testsuite/g++.dg/cpp0x/inh-ctor30.C
new file mode 100644
index 00000000000..04c58636d8d
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/inh-ctor30.C
@@ -0,0 +1,27 @@
+// PR c++/81860
+// { dg-do compile { target c++11 } }
+// { dg-final { scan-assembler "_ZN1AIjEC\[12\]Ev" } }
+
+template <typename T>
+struct A
+{
+  A() {}
+};
+
+struct B
+{
+  template <typename D>
+  B(D, const A<unsigned>& a = A<unsigned>()) : a(a) {}
+
+  A<unsigned> a;
+};
+
+struct C : B
+{
+  using B::B;
+};
+
+int main()
+{
+  C c(0);
+}
diff --git a/gcc/testsuite/g++.dg/cpp0x/initlist-defarg2.C b/gcc/testsuite/g++.dg/cpp0x/initlist-defarg2.C
new file mode 100644
index 00000000000..65240355fc3
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/initlist-defarg2.C
@@ -0,0 +1,8 @@
+// PR c++/82336
+// { dg-do link { target c++11 } }
+
+struct foo { int x = 5; };
+struct bar : foo { bar() = default; };
+struct baz { bar x; };
+void qux(baz = {}){}
+int main() { qux(); }
diff --git a/gcc/testsuite/g++.dg/cpp0x/initlist98.C b/gcc/testsuite/g++.dg/cpp0x/initlist98.C
new file mode 100644
index 00000000000..4f2fcd20219
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/initlist98.C
@@ -0,0 +1,17 @@
+// PR c++/83227
+// { dg-do compile { target c++11 } }
+
+#include <initializer_list>
+
+template <typename d> struct f {
+  f(std::initializer_list<d>) {}
+};
+
+struct h {};
+struct i : h {
+  i();
+};
+void foo(f<h>);
+int main() {
+  foo({i{}});
+}
diff --git a/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-dependent1.C b/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-dependent1.C
new file mode 100644
index 00000000000..6fd2bb379bf
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-dependent1.C
@@ -0,0 +1,19 @@
+// PR c++/85815
+// { dg-do compile { target c++11 } }
+
+template<class T>
+class A {
+    static A* INSTANCE;
+    void foobar();
+    void moo() {}
+};
+
+template<class T>
+A<T>* A<T>::INSTANCE = nullptr;
+
+template<class T>
+void A<T>::foobar() {
+    auto x = []() {
+        INSTANCE->moo();
+    };
+}
diff --git a/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-mangle5.C b/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-mangle5.C
new file mode 100644
index 00000000000..dd95894755c
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-mangle5.C
@@ -0,0 +1,15 @@
+// { dg-do compile { target c++11 } }
+// { dg-final { scan-assembler "_ZZN1AIiEC4IiEET_S2_Ed_NKUlvE_clEv" } }
+
+template <class T> struct A
+{
+  template <class U>
+  A(U, U = []{ return 42; }());
+};
+
+struct B: A<int>
+{
+  using A::A;
+};
+
+B b(24);
diff --git a/gcc/testsuite/g++.dg/cpp0x/noexcept32.C b/gcc/testsuite/g++.dg/cpp0x/noexcept32.C
new file mode 100644
index 00000000000..9a435049599
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/noexcept32.C
@@ -0,0 +1,14 @@
+// PR c++/84045
+// { dg-do compile { target c++11 } }
+
+template <typename T> struct K {
+  static const bool d = true;
+};
+template <typename T, typename> struct B {
+  typedef K<T> D;
+  void foo () noexcept (D::d);
+};
+template <typename T> struct P {
+  P () noexcept (K<T>::d);
+};
+P<int> p;
diff --git a/gcc/testsuite/g++.dg/cpp0x/noexcept33.C b/gcc/testsuite/g++.dg/cpp0x/noexcept33.C
new file mode 100644
index 00000000000..c5a03de38dd
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/noexcept33.C
@@ -0,0 +1,28 @@
+// PR c++/86378
+// { dg-do compile { target c++11 } }
+
+struct Pepper {};
+struct Apple { Apple(int) {} };
+
+struct Combination : Apple, Pepper
+{
+  Combination(Pepper p, Apple a)
+    : Apple(a), Pepper(p)
+  {}
+};
+
+struct MyCombination
+{
+  using Spice = Pepper;
+  using Fruit = Apple;
+
+  Combination combination;
+
+  template<typename T>
+  constexpr MyCombination(T&& t)
+  noexcept(noexcept(Combination(Spice(), Fruit(t))))
+    : combination(Spice(), Fruit(t))
+  {}
+};
+
+MyCombination obj(Apple(4));
diff --git a/gcc/testsuite/g++.dg/cpp0x/nsdmi-empty1.C b/gcc/testsuite/g++.dg/cpp0x/nsdmi-empty1.C
new file mode 100644
index 00000000000..66d94e53824
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/nsdmi-empty1.C
@@ -0,0 +1,18 @@
+// PR c++/82764
+// { dg-do compile { target c++11 } }
+
+struct Empty {};
+struct Empty2 : Empty {};
+
+struct A : Empty2
+{
+  int x {1};
+  int y {2};
+};
+
+struct B
+{
+  A a {};
+};
+
+B b;
diff --git a/gcc/testsuite/g++.dg/cpp0x/nsdmi14.C b/gcc/testsuite/g++.dg/cpp0x/nsdmi14.C
new file mode 100644
index 00000000000..aac6fa1c81b
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/nsdmi14.C
@@ -0,0 +1,19 @@
+// PR c++/71638
+// { dg-do compile { target c++11 } }
+// { dg-options "-Wall" }
+
+struct A {
+  struct {
+    int i;
+    int &j = i;
+  } b;
+  int a = b.j;
+};
+
+void bar (A);
+
+void
+foo ()
+{
+  bar (A{});
+}
diff --git a/gcc/testsuite/g++.dg/cpp0x/pr82878.C b/gcc/testsuite/g++.dg/cpp0x/pr82878.C
new file mode 100644
index 00000000000..c75e93b56c3
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/pr82878.C
@@ -0,0 +1,20 @@
+// { dg-do compile { target c++11 } }
+// { dg-additional-options "-O" }
+// pr 82878 erroneously unwrapped a reference parm in the lambda::_FUN
+// thunk.
+
+struct A {
+  ~A();
+  operator int ();
+};
+
+void baz ();
+
+void
+bar (A b)
+{
+  void (*lam) (A) = [](A) { baz (); };
+
+  if (auto c = b)
+    lam (c);
+}
diff --git a/gcc/testsuite/g++.dg/cpp0x/pr83824.C b/gcc/testsuite/g++.dg/cpp0x/pr83824.C
new file mode 100644
index 00000000000..9474e1ebb25
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/pr83824.C
@@ -0,0 +1,9 @@
+// PR c++/83824
+// { dg-do compile { target c++11 } }
+
+void
+foo ()
+{
+  if (alignas(1 alignas(1)))	// { dg-error "expected" }
+    ;
+}
diff --git a/gcc/testsuite/g++.dg/cpp0x/pr85147.C b/gcc/testsuite/g++.dg/cpp0x/pr85147.C
new file mode 100644
index 00000000000..68c0022d80a
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/pr85147.C
@@ -0,0 +1,9 @@
+// PR c++/85147
+// { dg-do compile { target c++11 } }
+
+template<typename T> struct A
+{
+  template<template<...T> class...> struct B {};	// { dg-error "expected|mismatch" }
+};
+
+A<int>::B<> b;						// { dg-error "does not name a template type" }
diff --git a/gcc/testsuite/g++.dg/cpp0x/range-for13.C b/gcc/testsuite/g++.dg/cpp0x/range-for13.C
index 100f531f760..7babd713cfb 100644
--- a/gcc/testsuite/g++.dg/cpp0x/range-for13.C
+++ b/gcc/testsuite/g++.dg/cpp0x/range-for13.C
@@ -3,16 +3,6 @@
 
 // { dg-do compile { target c++11 } }
 
-//These should not be used
-template<typename T> int *begin(T &t)
-{
-    T::fail;
-}
-template<typename T> int *end(T &t)
-{
-    T::fail;
-}
-
 struct container1
 {
     int *begin();
@@ -87,10 +77,37 @@ struct container10
     static function end;
 };
 
+namespace N
+{
+template<typename T> int *begin(T &t)
+{
+    return 0;
+}
+template<typename T> int *end(T &t)
+{
+    return 0;
+}
+struct container11
+{
+    int *begin();
+    //no end
+};
+
+struct container12
+{
+    int *end();
+    //no begin
+};
+
+struct container13
+{
+};
+}
+
 void test1()
 {
-  for (int x : container1()); // { dg-error "member but not" }
-  for (int x : container2()); // { dg-error "member but not" }
+  for (int x : container1()); // { dg-error "'begin' was not declared|'end' was not declared" }
+  for (int x : container2()); // { dg-error "'begin' was not declared|'end' was not declared" }
   for (int x : container3()); // { dg-error "within this context" }
   for (int x : container4()); // { dg-error "cannot be used as a function" }
   for (int x : container5()); // { dg-error "invalid use of" }
@@ -99,4 +116,7 @@ void test1()
   for (int x : container8());
   for (int x : container9()); // { dg-error "within this context" }
   for (int x : container10());
+  for (int x : N::container11());
+  for (int x : N::container12());
+  for (int x : N::container13());
 }
diff --git a/gcc/testsuite/g++.dg/cpp0x/range-for35.C b/gcc/testsuite/g++.dg/cpp0x/range-for35.C
new file mode 100644
index 00000000000..c77a5af5a44
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/range-for35.C
@@ -0,0 +1,8 @@
+// PR c++/86060
+// { dg-options -Wpedantic }
+
+template <typename T> void foo(T (&a)[8]) {
+  for (int i : a)		// { dg-warning "range-based" "" { target c++98_only } }
+    i;
+}
+void fn1() { foo<int>; }
diff --git a/gcc/testsuite/g++.dg/cpp0x/range-for9.C b/gcc/testsuite/g++.dg/cpp0x/range-for9.C
index 6a50ec36c14..eaa5b406880 100644
--- a/gcc/testsuite/g++.dg/cpp0x/range-for9.C
+++ b/gcc/testsuite/g++.dg/cpp0x/range-for9.C
@@ -5,6 +5,6 @@
 void test()
 {
     int a[] = {0,1,2};
-    for (int x : a)  // { dg-error "range-based 'for'" }
+    for (int x : a)  // { dg-error "range-based 'for'|forming reference" }
         ;
 }
diff --git a/gcc/testsuite/g++.dg/cpp0x/ref-qual18.C b/gcc/testsuite/g++.dg/cpp0x/ref-qual18.C
new file mode 100644
index 00000000000..aaa00b9cfc3
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/ref-qual18.C
@@ -0,0 +1,18 @@
+// PR c++/71784
+// { dg-do compile { target c++11 } }
+
+template<typename T> struct A {
+  template<typename U> void f(U const&) & { }
+  template<typename U> void f(U const&) && { }
+};
+
+template void A<int>::f<int>(int const&) &;
+template void A<float>::f<int>(int const&) &&;
+
+template<typename T> struct B {
+  void f(int const&) & { }
+  void f(int const&) && { }
+};
+
+template void B<int>::f(int const&) &;
+template void B<float>::f(int const&) &&;
diff --git a/gcc/testsuite/g++.dg/cpp0x/sfinae60.C b/gcc/testsuite/g++.dg/cpp0x/sfinae60.C
new file mode 100644
index 00000000000..cfb4dc0b9a7
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/sfinae60.C
@@ -0,0 +1,25 @@
+// PR c++/78489
+// { dg-do compile { target c++11 } }
+
+template <bool P, class T = void> struct enable_if { using type = T; };
+template <class T> struct enable_if<false, T> {};
+
+template <class Dummy> struct use_type { using type = int; };
+
+template <bool Pred>
+struct get_type {
+    static_assert(Pred, "");
+    using type = int;
+};
+
+template <bool Val,
+              class      = typename enable_if<Val>::type, // Evaluation/Substitution should end here
+              class ValT = typename get_type<Val>::type,  // This should not be instantiated
+              typename use_type<ValT>::type = 0           // This NTTP causes ValT to be required
+            >
+constexpr bool test(int) { return false; }
+
+template <bool>
+constexpr bool test(long) { return true; }
+
+static_assert(test<false>(0), ""); // should call test(long)
diff --git a/gcc/testsuite/g++.dg/cpp0x/variadic-nested2.C b/gcc/testsuite/g++.dg/cpp0x/variadic-nested2.C
new file mode 100644
index 00000000000..ce18f99ea50
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/variadic-nested2.C
@@ -0,0 +1,9 @@
+// PR c++/84839
+// { dg-do compile { target c++11 } }
+
+template<typename... T>
+struct S {
+    using fptr = void(*)(T... x, decltype(x)... y);
+};
+
+using F = S<int>::fptr;
diff --git a/gcc/testsuite/g++.dg/cpp0x/variadic-nested3.C b/gcc/testsuite/g++.dg/cpp0x/variadic-nested3.C
new file mode 100644
index 00000000000..381ff731c09
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/variadic-nested3.C
@@ -0,0 +1,10 @@
+// PR c++/71834
+// { dg-do compile { target c++11 } }
+
+template < typename ... Ts > struct A 
+{
+  template < Ts ..., typename U > struct B {};
+};
+
+// should be, e.g.: A < int >::B < 0, int > e; 
+A < int >::B < 0 > e;	   // { dg-error "wrong number of template arguments" }
diff --git a/gcc/testsuite/g++.dg/cpp1y/constexpr-84192.C b/gcc/testsuite/g++.dg/cpp1y/constexpr-84192.C
new file mode 100644
index 00000000000..ad9458d238f
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1y/constexpr-84192.C
@@ -0,0 +1,41 @@
+// PR c++/84192
+// { dg-do compile { target c++14 } }
+// { dg-options "" }
+
+bool
+f1 ()
+{ 
+  return ({ return true; }) && false;	// { dg-error "could not convert" }
+}
+
+void
+f2 ()
+{ 
+  for (;;)
+    constexpr bool b = ({ break; false; }) && false;	// { dg-error "statement is not a constant expression" }
+}
+
+constexpr bool
+f3 (int n)
+{
+  bool b = false;
+  for (int i = 0; i < n; i++)
+    b = ({ break; });	// { dg-error "void value not ignored as it ought to be" }
+  return b;
+}
+
+constexpr bool b = f3 (4);
+
+bool
+f4 ()
+{
+  constexpr bool b = ({ return true; }) && false;	// { dg-error "could not convert" }
+  return false;
+}
+
+constexpr bool
+f5 (int x)
+{
+  constexpr bool b = ({ switch (x) case 0: true; }) && false;	// { dg-error "could not convert" }
+  return false;
+}
diff --git a/gcc/testsuite/g++.dg/cpp1y/constexpr-array6.C b/gcc/testsuite/g++.dg/cpp1y/constexpr-array6.C
new file mode 100644
index 00000000000..1f15bef8d0c
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1y/constexpr-array6.C
@@ -0,0 +1,26 @@
+// PR c++/87075
+// { dg-do compile { target c++14 } }
+
+template <typename T>
+struct vec
+{
+  struct { T y; } n;
+  vec() = default;
+};
+
+template <typename T>
+struct S
+{
+  vec<T> value[2];
+  template<typename U>
+  constexpr S(const U&);
+};
+
+template<typename T>
+template<typename X>
+constexpr S<T>::S(const X&)
+{
+  value[0] = vec<T>();
+}
+
+S<float>m(0);
diff --git a/gcc/testsuite/g++.dg/cpp1y/lambda-generic-nsdmi1.C b/gcc/testsuite/g++.dg/cpp1y/lambda-generic-nsdmi1.C
new file mode 100644
index 00000000000..89ce519d812
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1y/lambda-generic-nsdmi1.C
@@ -0,0 +1,8 @@
+// PR c++/84520
+// { dg-do compile { target c++14 } }
+
+struct A
+{
+  static void foo(int);
+  void (*f)(int) = [](auto i) { foo(i); };
+};
diff --git a/gcc/testsuite/g++.dg/cpp1y/lambda-generic-variadic16.C b/gcc/testsuite/g++.dg/cpp1y/lambda-generic-variadic16.C
new file mode 100644
index 00000000000..a9292253453
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1y/lambda-generic-variadic16.C
@@ -0,0 +1,8 @@
+// PR c++/64095
+// { dg-do compile { target c++14 } }
+
+void f()
+{
+  [](auto...){}();
+  [](auto&&...){}();
+}
diff --git a/gcc/testsuite/g++.dg/cpp1y/lambda-generic-variadic17.C b/gcc/testsuite/g++.dg/cpp1y/lambda-generic-variadic17.C
new file mode 100644
index 00000000000..4a7392f93bc
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1y/lambda-generic-variadic17.C
@@ -0,0 +1,125 @@
+// PR c++/85118
+// { dg-do compile { target c++14 } }
+
+namespace std
+{
+  template<typename _Tp>
+    struct remove_const
+    { typedef _Tp type; };
+
+  template<typename _Tp>
+    struct remove_const<_Tp const>
+    { typedef _Tp type; };
+
+
+  template<typename _Tp>
+    struct remove_volatile
+    { typedef _Tp type; };
+
+  template<typename _Tp>
+    struct remove_volatile<_Tp volatile>
+    { typedef _Tp type; };
+
+
+  template<typename _Tp>
+    struct remove_cv
+    {
+      typedef typename
+      remove_const<typename remove_volatile<_Tp>::type>::type type;
+    };
+
+  template<typename _Tp>
+    struct remove_reference
+    { typedef _Tp type; };
+
+  template<typename _Tp>
+    struct remove_reference<_Tp&>
+    { typedef _Tp type; };
+
+  template<typename _Tp>
+    struct remove_reference<_Tp&&>
+    { typedef _Tp type; };
+
+  template<typename _Tp>
+    struct decay
+    {
+      using type = typename remove_reference<typename remove_const<_Tp>::type>::type;
+    };
+
+  template<typename _Tp>
+    _Tp&&
+    declval() noexcept;
+
+  template<typename _Tp>
+    constexpr _Tp&&
+    forward(typename std::remove_reference<_Tp>::type& __t) noexcept
+    { return static_cast<_Tp&&>(__t); }
+
+
+  template<typename _Arg>
+    struct _Mu
+    {
+      template<typename _CVArg, typename _Tuple>
+         _CVArg&&
+         operator()(_CVArg&& __arg, _Tuple&) const volatile
+         { return std::forward<_CVArg>(__arg); }
+    };
+
+   template<typename _Functor, typename _Bound_args>
+    struct _Bind
+    {
+      _Functor _M_f;
+      _Bound_args _M_bound_args;
+
+      template<typename _Args, typename _Result
+         = decltype( std::declval<_Functor&>()(
+               _Mu<_Bound_args>()( std::declval<_Bound_args&>(),
+              std::declval<_Args&>() ) ) )>
+         _Result
+      operator()(_Args&& __args) { return {}; }
+
+      template<typename _Args, typename _Result
+         = decltype( std::declval<volatile _Functor&>()(
+               _Mu<_Bound_args>()( std::declval<volatile _Bound_args&>(),
+              std::declval<_Args&>() ) ) )>
+         _Result
+         operator()(_Args&& __args) volatile;
+
+    };
+
+  template<typename _Func, typename _BoundArgs>
+    _Bind<typename decay<_Func>::type, typename decay<_BoundArgs>::type>
+    bind(_Func&& __f, _BoundArgs&& __args)
+    {
+      return {
+        std::forward<_Func>(__f),
+          std::forward<_BoundArgs>(__args)
+      };
+    }
+
+} // namespace std
+
+
+template <typename T>
+bool isOneOf(const T& )
+{
+    return false;
+}
+
+template <typename T, typename FirstType, typename... Tail>
+bool isOneOf(const T& t, const FirstType& firstValue, const Tail&... tail)
+{
+    return t == firstValue || isOneOf(t, tail...);
+}
+
+int main()
+{
+    const auto isOneOfHelper = [](auto&&... params)
+    {
+      return isOneOf(std::forward<decltype(params)>(params)...);
+    };
+
+    auto isO = std::bind(isOneOfHelper, 'o');
+
+    isO('o');
+}
diff --git a/gcc/testsuite/g++.dg/cpp1y/lambda-generic-variadic19.C b/gcc/testsuite/g++.dg/cpp1y/lambda-generic-variadic19.C
new file mode 100644
index 00000000000..e78677de0b5
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1y/lambda-generic-variadic19.C
@@ -0,0 +1,4 @@
+// PR c++/86728
+// { dg-do compile { target c++14 } }
+
+auto c = [](auto x ...) { };
diff --git a/gcc/testsuite/g++.dg/cpp1y/lambda-mangle-1.C b/gcc/testsuite/g++.dg/cpp1y/lambda-mangle-1.C
index ca0910be503..8f135358465 100644
--- a/gcc/testsuite/g++.dg/cpp1y/lambda-mangle-1.C
+++ b/gcc/testsuite/g++.dg/cpp1y/lambda-mangle-1.C
@@ -85,4 +85,4 @@ void Baz ()
 // { dg-final { scan-assembler "_Z3eatIZ3FoovEUlPT_PT0_E4_Z3FoovEUlS1_S3_E5_EvRS0_RS2_:" } }
 // { dg-final { scan-assembler "_Z3eatIPiZ3BarIsEvvEUlPsPfS3_E_EvRT_RT0_:" } }
 // { dg-final { scan-assembler "_Z3eatIPiZ3BarIsEvvEUlPsPT_PT0_E0_EvRS3_RS5_:" } }
-// { dg-final { scan-assembler "_Z3eatIPiZ3BarIsEvvEUlPsPT_zE1_EvRS3_RT0_:" } }
+// { dg-final { scan-assembler "_Z3eatIPiZ3BarIsEvvEUlPsDpPT_E1_EvRT_RT0_:" } }
diff --git a/gcc/testsuite/g++.dg/cpp1y/nsdmi-aggr10.C b/gcc/testsuite/g++.dg/cpp1y/nsdmi-aggr10.C
new file mode 100644
index 00000000000..1dc396d9ca5
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1y/nsdmi-aggr10.C
@@ -0,0 +1,7 @@
+// PR c++/71638
+// { dg-do compile { target c++14 } }
+
+struct {
+  int &&a;
+  int b{a};
+} c[] { { 2 } };
diff --git a/gcc/testsuite/g++.dg/cpp1y/nsdmi-aggr11.C b/gcc/testsuite/g++.dg/cpp1y/nsdmi-aggr11.C
new file mode 100644
index 00000000000..09591df3807
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1y/nsdmi-aggr11.C
@@ -0,0 +1,12 @@
+// PR c++/85148
+// { dg-do compile { target c++14 } }
+
+template<typename T> struct A
+{
+  T x[1]{(__PTRDIFF_TYPE__)this};
+};
+
+void foo()
+{
+  A<A<__PTRDIFF_TYPE__>> a{};
+}
diff --git a/gcc/testsuite/g++.dg/cpp1y/nsdmi-aggr9.C b/gcc/testsuite/g++.dg/cpp1y/nsdmi-aggr9.C
new file mode 100644
index 00000000000..4e13fc5c9d8
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1y/nsdmi-aggr9.C
@@ -0,0 +1,14 @@
+// PR c++/84927 - ICE with NSDMI and reference
+// { dg-do compile { target c++14 } }
+
+struct A
+{
+  int& r;
+  int i = r;
+};
+
+void foo()
+{
+  int j;
+  A a = A{j};
+}
diff --git a/gcc/testsuite/g++.dg/cpp1y/pr60393.C b/gcc/testsuite/g++.dg/cpp1y/pr60393.C
index 27fe2b72296..2ae21ed1147 100644
--- a/gcc/testsuite/g++.dg/cpp1y/pr60393.C
+++ b/gcc/testsuite/g++.dg/cpp1y/pr60393.C
@@ -1,8 +1,7 @@
 // PR c++/60393
 // { dg-do compile { target c++14 } }
-// { dg-options "" }
 
-void (*f)(auto) + 0; // { dg-error "expected" }
+void (*f)(auto) + 0; // { dg-error "auto|expected" }
 
 struct A
 {
diff --git a/gcc/testsuite/g++.dg/cpp1y/pr60626.C b/gcc/testsuite/g++.dg/cpp1y/pr60626.C
deleted file mode 100644
index 311464472da..00000000000
--- a/gcc/testsuite/g++.dg/cpp1y/pr60626.C
+++ /dev/null
@@ -1,7 +0,0 @@
-// PR c++/60626
-// { dg-do compile { target c++14 } }
-// { dg-options "" }
-
-struct A {};
-
-void (*A::p)(auto) = 0;  // { dg-error "static data member|template" }
diff --git a/gcc/testsuite/g++.dg/cpp1y/pr83817.C b/gcc/testsuite/g++.dg/cpp1y/pr83817.C
new file mode 100644
index 00000000000..9a69cbb201c
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1y/pr83817.C
@@ -0,0 +1,17 @@
+// PR c++/83817
+// { dg-do compile { target c++14 } }
+
+struct A;
+struct B { template <typename> using C = A; };
+struct D : B { struct F { typedef C<char> E; }; };
+struct G {
+  struct I { I (D, A &); } h;
+  D::F::E &k ();
+  D j;
+  G (G &&) : h (j, k ()) {}
+};
+struct N { G l; };
+typedef N (*M)(N &);
+struct H { const char *o; M s; };
+N foo (N &);
+H r { "", [](auto &x) { return foo (x); }};
diff --git a/gcc/testsuite/g++.dg/cpp1y/pr84496.C b/gcc/testsuite/g++.dg/cpp1y/pr84496.C
new file mode 100644
index 00000000000..028d00235cd
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1y/pr84496.C
@@ -0,0 +1,44 @@
+// PR c++/84496
+// { dg-do compile { target c++14 } }
+
+template <typename T, T n> struct C { static constexpr T D = n; };
+struct E : C<bool, false> {};
+template <typename> struct F : C<bool, false> {};
+template <typename T> T foo ();
+template <typename> struct H { typedef int G; };
+template <typename> class I;
+struct L;
+template <typename, typename> struct J;
+template <bool, bool, typename...> struct K;
+struct R {
+  template <typename M, typename... N>
+  static J<decltype (foo<M> () (foo<N>...)), L> o;
+};
+template <typename P, typename... Q> struct K<false, false, P, Q...> : R {
+  typedef decltype (o<P, Q...>) G;
+};
+template <typename P, typename... Q>
+struct D : K<E::D, F<typename H<P>::G>::D, P, Q...> {};
+template <typename P, typename... Q> struct I<P (Q...)> : D<P, Q...> {};
+template <typename> class function;
+template <typename S, typename... Q> struct function<S (Q...)> {
+  template <typename T, typename = typename I<T (Q...)>::G> struct C;
+  template <typename, typename> using U = int;
+  template <typename P, typename = U<int, void>, typename = U<C<P>, void>>
+  function (P);
+};
+template <typename S, typename... Q>
+template <typename P, typename, typename>
+function<S (Q...)>::function (P)
+{
+}
+void bar (function<void (int)>);
+
+void
+baz ()
+{
+  auto a = [] {
+    static int counter;
+    bar ([] (auto) { counter++; });
+  };
+}
diff --git a/gcc/testsuite/g++.dg/cpp1y/pr84558.C b/gcc/testsuite/g++.dg/cpp1y/pr84558.C
new file mode 100644
index 00000000000..40d7ef68561
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1y/pr84558.C
@@ -0,0 +1,6 @@
+// PR c++/84558
+// { dg-do compile { target c++14 } }
+
+struct A { static int i; constexpr A () { i = 0; } };
+struct B { A a[2][3][4]; };
+B b;
diff --git a/gcc/testsuite/g++.dg/cpp1y/pr84662.C b/gcc/testsuite/g++.dg/cpp1y/pr84662.C
new file mode 100644
index 00000000000..36bd201073e
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1y/pr84662.C
@@ -0,0 +1,6 @@
+// PR c++/84662
+// { dg-do compile { target c++14 } }
+// { dg-options "" }
+
+double b;
+a (__attribute__((c (0 && int() - ([] {} && b) || auto))));	// { dg-error "expected constructor, destructor, or type conversion before" }
diff --git a/gcc/testsuite/g++.dg/cpp1y/pr85076.C b/gcc/testsuite/g++.dg/cpp1y/pr85076.C
new file mode 100644
index 00000000000..6d54dea6c01
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1y/pr85076.C
@@ -0,0 +1,6 @@
+// PR c++/85076
+// { dg-do compile { target c++14 } }
+
+template<typename> struct A*;	// { dg-error "expected unqualified-id before" }
+
+auto a = [](A<auto>) {};	// { dg-error "is not a template|has incomplete type" }
diff --git a/gcc/testsuite/g++.dg/cpp1y/var-templ58.C b/gcc/testsuite/g++.dg/cpp1y/var-templ58.C
new file mode 100644
index 00000000000..f9095f61e67
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1y/var-templ58.C
@@ -0,0 +1,12 @@
+// PR c++/71569
+// { dg-do compile { target c++14 } }
+
+template <class T>
+struct A {
+  template <class U>
+  static const U u;
+};
+
+template <class T>
+template <class U>
+const U A<T>::u<U> = 0;	// { dg-error "does not specialize" }
diff --git a/gcc/testsuite/g++.dg/cpp1y/var-templ58a.C b/gcc/testsuite/g++.dg/cpp1y/var-templ58a.C
new file mode 100644
index 00000000000..850a2c9689c
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1y/var-templ58a.C
@@ -0,0 +1,14 @@
+// PR c++/71569
+// { dg-do compile { target c++14 } }
+
+template <class T>
+struct A {
+  template <class U>
+  static const U u;
+};
+
+template <class T>
+template <class U>
+const U* A<T>::u<U*> = 0;
+
+const int *p = A<char>::u<int*>;
diff --git a/gcc/testsuite/g++.dg/cpp1y/var-templ59.C b/gcc/testsuite/g++.dg/cpp1y/var-templ59.C
new file mode 100644
index 00000000000..da9710e1ce4
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1y/var-templ59.C
@@ -0,0 +1,14 @@
+// PR c++/71569
+// { dg-do compile { target c++14 } }
+
+template <class T>
+struct A {
+  template <class U>
+  static U u;
+};
+
+int main()
+{
+  decltype(A<int>::u) a;	// { dg-error "missing template arguments" }
+  return a;
+}
diff --git a/gcc/testsuite/g++.dg/cpp1z/class-deduction49.C b/gcc/testsuite/g++.dg/cpp1z/class-deduction49.C
new file mode 100644
index 00000000000..086f12ad3c6
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1z/class-deduction49.C
@@ -0,0 +1,15 @@
+// PR c++/84015
+// { dg-additional-options -std=c++17 }
+
+template <int I>
+struct A { };
+
+template <int I>
+struct B
+{
+  template<template<auto>class T>
+  B(T<I>);
+};
+
+A<42> a;
+B b (a);
diff --git a/gcc/testsuite/g++.dg/cpp1z/class-deduction50.C b/gcc/testsuite/g++.dg/cpp1z/class-deduction50.C
new file mode 100644
index 00000000000..e8cdd8c710f
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1z/class-deduction50.C
@@ -0,0 +1,22 @@
+// PR c++/84355
+// { dg-additional-options -std=c++17 }
+
+template <class, class> struct same;
+template <class T> struct same<T,T> {};
+
+template<typename T> struct A
+{
+  template<class U> struct B
+  {
+    B(U);
+  };
+
+  A() {
+    B b(0);
+    same<decltype(b),B<int>>{};
+  }
+};
+
+struct C {};
+
+A<C> a;
diff --git a/gcc/testsuite/g++.dg/cpp1z/class-deduction51.C b/gcc/testsuite/g++.dg/cpp1z/class-deduction51.C
new file mode 100644
index 00000000000..eba7972c3c6
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1z/class-deduction51.C
@@ -0,0 +1,11 @@
+// PR c++/84937
+// { dg-additional-options -std=c++17 }
+
+template<int, int> struct A {};
+
+template<int I> struct B
+{
+  template<auto J> B(A<I,J>);
+};
+
+B b(A<0,0>{});
diff --git a/gcc/testsuite/g++.dg/cpp1z/class-deduction54.C b/gcc/testsuite/g++.dg/cpp1z/class-deduction54.C
new file mode 100644
index 00000000000..e51398bbbb0
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1z/class-deduction54.C
@@ -0,0 +1,15 @@
+// PR c++/82152
+// { dg-additional-options -std=c++17 }
+
+struct Base {};
+
+template<typename T>
+struct Derived : public Base {
+  using Base::Base;
+};
+
+Derived() -> Derived< void >;
+
+int main() {
+  Derived x;
+}
diff --git a/gcc/testsuite/g++.dg/cpp1z/constexpr-84684.C b/gcc/testsuite/g++.dg/cpp1z/constexpr-84684.C
new file mode 100644
index 00000000000..0e7912d4067
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1z/constexpr-84684.C
@@ -0,0 +1,163 @@
+// PR c++/84684
+// { dg-options -std=c++17 }
+
+typedef decltype (sizeof (0)) size_t;
+
+namespace std {
+  template<class _E>
+  struct initializer_list
+  {
+    typedef _E value_type;
+    typedef const _E& reference;
+    typedef const _E& const_reference;
+    typedef size_t size_type;
+    typedef const _E* iterator;
+    typedef const _E* const_iterator;
+    iterator _M_array;
+    size_type _M_len;
+    constexpr initializer_list(const_iterator __a, size_type __l) : _M_array(__a), _M_len(__l) { }
+    constexpr initializer_list() noexcept : _M_array(0), _M_len(0) { }
+    constexpr size_type size() const noexcept { return _M_len; }
+    constexpr const_iterator begin() const noexcept { return _M_array; }
+    constexpr const_iterator end() const noexcept { return begin() + size(); }
+  };
+}
+
+template <typename E, size_t N>
+struct array
+{
+  constexpr E &operator[](size_t n) noexcept { return elems[n]; }
+  constexpr const E &operator[](size_t n) const noexcept { return elems[n]; }
+  constexpr size_t size() const { return N; }
+  E elems[N];
+};
+
+template<typename T>
+constexpr
+inline T
+max (std::initializer_list<T> i)
+{
+  const T *b = i.begin ();
+  const T *e = i.end ();
+  if (b == e) return *b;
+  const T *r = b;
+  while (++b != e)
+  if (*r < *b)
+    r = b;
+  return *r;
+}
+
+template <typename alphabet_type>
+constexpr char to_char(alphabet_type const alph)
+{
+  return alph.to_char();
+}
+
+template <typename ...alphabet_types>
+struct union_composition
+{
+  static constexpr size_t value_size = (alphabet_types::value_size + ... );
+  unsigned char _value;
+  template <size_t fixed_size, typename alphabet_t>
+  static constexpr auto value_to_char_helper(alphabet_t alphabet)
+  {
+    array<char, fixed_size> value_to_char{};
+    for (size_t i = 0u; i < alphabet_t::value_size; ++i)
+      value_to_char[i] = to_char(alphabet.assign_rank(i));
+    return value_to_char;
+  }
+
+  static constexpr auto make_value_to_char()
+  {
+    constexpr auto N = sizeof...(alphabet_types);
+    constexpr array<size_t, N> alphabet_sizes { alphabet_types::value_size... };
+    constexpr size_t fixed_size = max({alphabet_types::value_size...});
+    array value_to_char_tables = array<array<char, fixed_size>, N> {
+      value_to_char_helper<fixed_size>(alphabet_types{})...
+    };
+    array<char, value_size> value_to_char{};
+    for (size_t i = 0u, value = 0u; i < N; ++i)
+      for (size_t k = 0u; k < alphabet_sizes[i]; ++k, ++value)
+        value_to_char[value] = value_to_char_tables[i][k];
+    return value_to_char;
+  }
+};
+
+struct gap
+{
+  constexpr char to_char() const noexcept { return '-'; }
+  constexpr gap & assign_rank([[maybe_unused]] bool const i) noexcept { return *this; }
+  static constexpr size_t value_size{1};
+};
+
+struct dna4
+{
+  constexpr char to_char() const noexcept { return value_to_char[_value]; }
+  constexpr dna4 & assign_rank(unsigned char const c) { _value = c; return *this; }
+  static constexpr size_t value_size{4};
+  static constexpr char value_to_char[value_size] { 'A', 'C', 'G', 'T' };
+  unsigned char _value;
+};
+
+struct dna5
+{
+  constexpr char to_char() const noexcept { return value_to_char[_value]; }
+  constexpr dna5 & assign_rank(unsigned char const c) { _value = c; return *this; }
+  static constexpr size_t value_size{5};
+  static constexpr char value_to_char[value_size] { 'A', 'C', 'G', 'T', 'N' };
+  unsigned char _value;
+};
+
+constexpr array value_to_char1 = union_composition<dna4>::make_value_to_char();
+static_assert(value_to_char1.size() == 4u);
+static_assert(value_to_char1[0] == 'A');
+static_assert(value_to_char1[1] == 'C');
+static_assert(value_to_char1[2] == 'G');
+static_assert(value_to_char1[3] == 'T');
+
+constexpr array value_to_char2 = union_composition<dna4, gap>::make_value_to_char();
+static_assert(value_to_char2.size() == 5u);
+static_assert(value_to_char2[0] == 'A');
+static_assert(value_to_char2[1] == 'C');
+static_assert(value_to_char2[2] == 'G');
+static_assert(value_to_char2[3] == 'T');
+static_assert(value_to_char2[4] == '-');
+
+constexpr array value_to_char3 = union_composition<dna4, gap, dna5>::make_value_to_char();
+static_assert(value_to_char3.size() == 10u);
+static_assert(value_to_char3[0] == 'A');
+static_assert(value_to_char3[1] == 'C');
+static_assert(value_to_char3[2] == 'G');
+static_assert(value_to_char3[3] == 'T');
+static_assert(value_to_char3[4] == '-');
+static_assert(value_to_char3[5] == 'A');
+static_assert(value_to_char3[6] == 'C');
+static_assert(value_to_char3[7] == 'G');
+static_assert(value_to_char3[8] == 'T');
+static_assert(value_to_char3[9] == 'N');
+
+constexpr array value_to_char4 = union_composition<dna5, gap, dna4>::make_value_to_char();
+static_assert(value_to_char4.size() == 10u);
+static_assert(value_to_char4[0] == 'A');
+static_assert(value_to_char4[1] == 'C');
+static_assert(value_to_char4[2] == 'G');
+static_assert(value_to_char4[3] == 'T');
+static_assert(value_to_char4[4] == 'N');
+static_assert(value_to_char4[5] == '-');
+static_assert(value_to_char4[6] == 'A');
+static_assert(value_to_char4[7] == 'C');
+static_assert(value_to_char4[8] == 'G');
+static_assert(value_to_char4[9] == 'T');
+
+constexpr array value_to_char5 = union_composition<gap, dna4, dna5>::make_value_to_char();
+static_assert(value_to_char5.size() == 10u);
+static_assert(value_to_char5[0] == '-');
+static_assert(value_to_char5[1] == 'A');
+static_assert(value_to_char5[2] == 'C');
+static_assert(value_to_char5[3] == 'G');
+static_assert(value_to_char5[4] == 'T');
+static_assert(value_to_char5[5] == 'A');
+static_assert(value_to_char5[6] == 'C');
+static_assert(value_to_char5[7] == 'G');
+static_assert(value_to_char5[8] == 'T');
+static_assert(value_to_char5[9] == 'N');
diff --git a/gcc/testsuite/g++.dg/cpp1z/constexpr-if13.C b/gcc/testsuite/g++.dg/cpp1z/constexpr-if13.C
new file mode 100644
index 00000000000..9a9053c3305
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1z/constexpr-if13.C
@@ -0,0 +1,11 @@
+// PR c++/84854
+// { dg-options -std=c++17 }
+
+constexpr int foo () { return 1; }
+constexpr int foo (int) { return 2; }
+
+template <typename>
+void a()
+{
+  if constexpr(foo) { };
+}
diff --git a/gcc/testsuite/g++.dg/cpp1z/decomp-lambda1.C b/gcc/testsuite/g++.dg/cpp1z/decomp-lambda1.C
new file mode 100644
index 00000000000..fbab0259643
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1z/decomp-lambda1.C
@@ -0,0 +1,10 @@
+// PR c++/84420
+// { dg-additional-options -std=c++17 }
+
+int main(){
+    int a[1]{};
+    [&a]{
+        auto [v] = a;
+        (void)v;
+    }();
+}
diff --git a/gcc/testsuite/g++.dg/cpp1z/decomp10.C b/gcc/testsuite/g++.dg/cpp1z/decomp10.C
index f27cbfbc0d9..95d8bf6364e 100644
--- a/gcc/testsuite/g++.dg/cpp1z/decomp10.C
+++ b/gcc/testsuite/g++.dg/cpp1z/decomp10.C
@@ -20,7 +20,7 @@ void f3() { auto [ x ] = a3; }	// { dg-error "get" }
 
 struct A3a { int i,j; int get(); } a3a;
 template<> struct std::tuple_size<A3a> { enum { value = 1 }; };
-void f3a() { auto [ x ] = a3a; }	// { dg-error "get<0>" }
+void f3a() { auto [ x ] = a3a; }	// { dg-error "get" }
 
 struct A3b { int i,j; } a3b;
 int get(A3b&&);
diff --git a/gcc/testsuite/g++.dg/cpp1z/decomp35.C b/gcc/testsuite/g++.dg/cpp1z/decomp35.C
new file mode 100644
index 00000000000..844ad43e141
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1z/decomp35.C
@@ -0,0 +1,35 @@
+// PR c++/83958
+// { dg-do compile { target c++11 } }
+// { dg-options "" }
+
+template <typename = void> struct A;
+class B;
+template <typename, typename, typename = A<>> class C;
+template <typename, typename> struct D;
+template <typename T, typename U, typename V, typename, typename, typename W>
+struct E {
+  using X = W;
+  X operator* ();
+  T operator++ ();
+  template <typename P, typename R, typename S, typename Q>
+  bool operator!= (E<P, U, V, R, S, Q>);
+};
+template <typename T, typename U, typename>
+struct F {
+  class G;
+  using H = D<T, U>;
+  using I = E<G, T, U, G, H, H &>;
+  class G : public I {};
+  G begin ();
+  G end ();
+};
+template <typename T, typename U, typename V> struct C : F<T, U, V> {
+  using J = F<T, U, V>;
+  using J::begin;
+  using J::end;
+};
+using K = class L;
+struct M {
+  void foo () { for (auto & [ a ] : m) {} }	// { dg-error "incomplete type" }
+  C<K, B> m;					// { dg-warning "only available with" "" { target c++14_down } .-1 }
+};
diff --git a/gcc/testsuite/g++.dg/cpp1z/decomp36.C b/gcc/testsuite/g++.dg/cpp1z/decomp36.C
new file mode 100644
index 00000000000..5a66d0c7b56
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1z/decomp36.C
@@ -0,0 +1,19 @@
+// PR c++/84031
+// { dg-do compile { target c++11 } }
+// { dg-options "" }
+
+struct A { unsigned char : 1, a1 : 1, a2 : 2, : 1, a3 : 3; };
+struct B { unsigned char : 1, : 7; };
+struct C : B { constexpr C () : c1 (1), c2 (2), c3 (3) {} unsigned char : 1, c1 : 1, c2 : 2, : 1, c3 : 3; };
+struct D : C { constexpr D () {} unsigned char : 1, : 7; };
+
+int
+main ()
+{
+  static constexpr A a { 1, 2, 3 };
+  const auto &[a1, a2, a3] = a;		// { dg-warning "only available with" "" { target c++14_down } }
+  static_assert (a1 == 1 && a2 == 2 && a3 == 3, "");
+  static constexpr D d;
+  const auto &[d1, d2, d3] = d;		// { dg-warning "only available with" "" { target c++14_down } }
+  static_assert (d1 == 1 && d2 == 2 && d3 == 3, "");
+}
diff --git a/gcc/testsuite/g++.dg/cpp1z/decomp37.C b/gcc/testsuite/g++.dg/cpp1z/decomp37.C
new file mode 100644
index 00000000000..dc47908cddf
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1z/decomp37.C
@@ -0,0 +1,62 @@
+// { dg-additional-options -std=c++17 }
+// { dg-do compile }
+
+#include <memory>
+#include <tuple>
+#include <string>
+
+struct X : private std::shared_ptr<int>
+{
+  std::string fun_payload;
+};
+
+template<int N> std::string& get(X& x)
+{
+  if constexpr(N==0) return x.fun_payload;
+}
+
+namespace std {
+  template<> class tuple_size<X> : public std::integral_constant<int, 1> {};
+  template<> class tuple_element<0, X> {public: using type = std::string;};
+}
+
+struct X2 : private std::shared_ptr<int>
+{
+  int fun_payload;
+  template <class T> void get();
+};
+
+template<int N> int& get(X2& x)
+{
+  if constexpr(N==0) return x.fun_payload;
+}
+
+namespace std {
+  template<> class tuple_size<X2> : public std::integral_constant<int, 1> {};
+  template<> class tuple_element<0, X2> {public: using type = int;};
+}
+
+class X3
+{
+  double fun_payload;
+public:
+  template <int N> double& get()
+  {
+    if constexpr(N==0) return fun_payload;
+  }
+};
+
+namespace std {
+  template<> class tuple_size<X3> : public std::integral_constant<int, 1> {};
+  template<> class tuple_element<0, X3> {public: using type = double;};
+}
+
+int main()
+{
+  X x;
+  auto& [b1] = x;
+  X2 x2;
+  auto& [b2] = x2;
+  X3 x3;
+  auto& [b3] = x3;
+}
diff --git a/gcc/testsuite/g++.dg/cpp1z/decomp38.C b/gcc/testsuite/g++.dg/cpp1z/decomp38.C
new file mode 100644
index 00000000000..fc69c02e4d3
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1z/decomp38.C
@@ -0,0 +1,48 @@
+// { dg-additional-options -std=c++17 }
+// { dg-do compile }
+
+class X
+{
+   int a, b;
+   void f()
+   {
+     auto[x,y] = *this;
+   }
+};
+
+class X2
+{
+   int a, b;
+   void f(X2& other)
+   {
+     auto[x,y] = other;
+   }
+};
+
+struct X3
+{
+  friend void foo();
+private:
+  int a;
+};
+
+void foo()
+{
+  X3 x;
+  auto [a] = x;
+}
+
+struct X4
+{
+  int a;
+};
+
+struct X5 : private X4
+{
+  friend void foo2();
+};
+
+void foo2() {
+  X5 x;
+  auto [a] = x;
+}
diff --git a/gcc/testsuite/g++.dg/cpp1z/decomp4.C b/gcc/testsuite/g++.dg/cpp1z/decomp4.C
index bc85263e986..30068592553 100644
--- a/gcc/testsuite/g++.dg/cpp1z/decomp4.C
+++ b/gcc/testsuite/g++.dg/cpp1z/decomp4.C
@@ -18,10 +18,10 @@ test (A &a, B &b, C &c, D &d, E &e, F &f, G &g, H &h, I &i)
 					// { dg-warning "decomposition declaration only available with -std=c..1z or -std=gnu..1z" "" { target c++14_down } .-1 }
   auto [ k ] { b };			// { dg-error "cannot decompose class type 'B' because it has an anonymous union member" }
 					// { dg-warning "decomposition declaration only available with -std=c..1z or -std=gnu..1z" "" { target c++14_down } .-1 }
-  auto [ l, l2 ] = c;			// { dg-error "cannot decompose non-public member 'C::b' of 'C'" }
+  auto [ l, l2 ] = c;			// { dg-error "cannot decompose inaccessible member 'C::b' of 'C'" }
 					// { dg-warning "decomposition declaration only available with -std=c..1z or -std=gnu..1z" "" { target c++14_down } .-1 }
   auto [ m ] = d;			// { dg-warning "decomposition declaration only available with -std=c..1z or -std=gnu..1z" "" { target c++14_down } }
-  auto [ n ] { e };			// { dg-error "cannot decompose non-public member 'E::a' of 'E'" }
+  auto [ n ] { e };			// { dg-error "cannot decompose inaccessible member 'E::a' of 'E'" }
 					// { dg-warning "decomposition declaration only available with -std=c..1z or -std=gnu..1z" "" { target c++14_down } .-1 }
   auto [ o ] { f };			// { dg-warning "decomposition declaration only available with -std=c..1z or -std=gnu..1z" "" { target c++14_down } }
   auto & [ p ] { g };			// { dg-error "cannot decompose class type 'G': both it and its base class 'F' have non-static data members" }
diff --git a/gcc/testsuite/g++.dg/cpp1z/decomp41.C b/gcc/testsuite/g++.dg/cpp1z/decomp41.C
new file mode 100644
index 00000000000..1ce836bd6dd
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1z/decomp41.C
@@ -0,0 +1,9 @@
+// PR c++/85208
+// { dg-do compile { target c++11 } }
+// { dg-require-weak "" }
+// { dg-options "" }
+
+#pragma weak _ZDC1d1e1fE
+struct A { int i, j, k; };
+auto [a, b, c] = A ();	// { dg-warning "decomposition declaration only available with" "" { target c++14_down } }
+auto [d, e, f] = A ();	// { dg-warning "decomposition declaration only available with" "" { target c++14_down } }
diff --git a/gcc/testsuite/g++.dg/cpp1z/decomp42.C b/gcc/testsuite/g++.dg/cpp1z/decomp42.C
new file mode 100644
index 00000000000..22c68ebd3a5
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1z/decomp42.C
@@ -0,0 +1,18 @@
+// PR c++/85210
+// { dg-do compile { target c++11 } }
+// { dg-options "" }
+
+struct A { int i; };
+
+template <int>
+void
+foo (int j)
+{
+  auto [j] = A{j};	// { dg-error "shadows a parameter" }
+}			// { dg-warning "decomposition declaration only available with" "" { target c++14_down } .-1 }
+
+void
+bar ()
+{
+  foo<0> (0);
+}
diff --git a/gcc/testsuite/g++.dg/cpp1z/desig7.C b/gcc/testsuite/g++.dg/cpp1z/desig7.C
new file mode 100644
index 00000000000..83688375f78
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1z/desig7.C
@@ -0,0 +1,18 @@
+// PR c++/84874
+// { dg-do compile { target c++11 } }
+// { dg-options "" }
+
+struct A { int a, b; };
+struct B { A d; };
+
+void
+foo (B *x)
+{
+  *x = { .d = { .b = 5 } };	// { dg-message "non-trivial designated initializers not supported" }
+}
+
+void
+bar (A *x)
+{
+  *x = { .b = 6 };		// { dg-message "non-trivial designated initializers not supported" }
+}
diff --git a/gcc/testsuite/g++.dg/cpp1z/desig8.C b/gcc/testsuite/g++.dg/cpp1z/desig8.C
new file mode 100644
index 00000000000..a6fc1600f5a
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1z/desig8.C
@@ -0,0 +1,18 @@
+// PR c++/84874
+// { dg-do compile { target c++1z } }
+// { dg-options "" }
+
+struct A { int a; struct { int b; }; };
+struct B { A d; };
+
+void
+foo (B *x)
+{
+  *x = { .d = { .b = 5 } };	// { dg-message "non-trivial designated initializers not supported" }
+}
+
+void
+bar (A *x)
+{
+  *x = { .b = 6 };		// { dg-message "non-trivial designated initializers not supported" }
+}
diff --git a/gcc/testsuite/g++.dg/cpp1z/inh-ctor38.C b/gcc/testsuite/g++.dg/cpp1z/inh-ctor38.C
index fbee8ca5c9e..356c36f5ff6 100644
--- a/gcc/testsuite/g++.dg/cpp1z/inh-ctor38.C
+++ b/gcc/testsuite/g++.dg/cpp1z/inh-ctor38.C
@@ -1,17 +1,19 @@
 // { dg-do run { target c++11 } }
 // PR78495 failed to propagate pass-by-value struct to base ctor.
 
+static int moves = 0;
+
 struct Ptr {
   void *ptr = 0;
 
   Ptr() {}
   Ptr(Ptr const&) = delete;
-  Ptr(Ptr&& other) : ptr (other.ptr) {}
+  Ptr(Ptr&& other) : ptr (other.ptr) {moves++;}
 };
 
 struct Base {
   Ptr val;
-  Base(Ptr val_) : val(static_cast<Ptr&&>(val_)) {}
+  Base(Ptr val_);
 };
 
 struct Derived: Base {
@@ -27,5 +29,13 @@ void *Foo () {
 }
 
 int main () {
-  return Foo () != 0;
+  if (Foo ())
+    return 1;
+
+  if (moves != 2)
+    return 2;
+
+  return 0;
 }
+
+Base::Base(Ptr val_) : val(static_cast<Ptr&&>(val_)) {}
diff --git a/gcc/testsuite/g++.dg/cpp1z/launder7.C b/gcc/testsuite/g++.dg/cpp1z/launder7.C
new file mode 100644
index 00000000000..e418329f931
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1z/launder7.C
@@ -0,0 +1,10 @@
+// PR c++/84445
+// { dg-do compile }
+
+struct A { virtual void foo (); };
+
+void
+bar (A *p)
+{
+  __builtin_launder (p)->foo ();
+}
diff --git a/gcc/testsuite/g++.dg/cpp1z/launder8.C b/gcc/testsuite/g++.dg/cpp1z/launder8.C
new file mode 100644
index 00000000000..f57e91b60cd
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1z/launder8.C
@@ -0,0 +1,11 @@
+// PR c++/84444
+// { dg-do compile }
+// { dg-options "-O2" }
+
+struct A {};
+
+__UINTPTR_TYPE__
+foo (A *p)
+{
+  return (__UINTPTR_TYPE__) __builtin_launder (p);
+}
diff --git a/gcc/testsuite/g++.dg/cpp1z/noexcept-type19.C b/gcc/testsuite/g++.dg/cpp1z/noexcept-type19.C
new file mode 100644
index 00000000000..2fc2b033ba6
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1z/noexcept-type19.C
@@ -0,0 +1,12 @@
+// { dg-do compile { target c++11 } }
+
+#include "noexcept-type19.h"
+
+extern "C" void *malloc (size_t);
+
+template<class T> void f(T*);
+
+int main()
+{
+  f<decltype(malloc)>(operator new);
+}
diff --git a/gcc/testsuite/g++.dg/cpp1z/noexcept-type19.h b/gcc/testsuite/g++.dg/cpp1z/noexcept-type19.h
new file mode 100644
index 00000000000..33a29357e7f
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1z/noexcept-type19.h
@@ -0,0 +1,4 @@
+#pragma GCC system_header
+
+typedef decltype(sizeof(0)) size_t;
+extern "C" void *malloc (size_t) throw();
diff --git a/gcc/testsuite/g++.dg/debug/dwarf2/pr87462.C b/gcc/testsuite/g++.dg/debug/dwarf2/pr87462.C
new file mode 100644
index 00000000000..bfbaad0c413
--- /dev/null
+++ b/gcc/testsuite/g++.dg/debug/dwarf2/pr87462.C
@@ -0,0 +1,20 @@
+// { dg-additional-options "-dA -std=gnu++17 -gdwarf-4 -O1 -fdebug-types-section" }
+// reject .pseudo label, but "label" is ok.
+// { dg-final { scan-assembler-not "\[^L\"\]_ZN5Test18testFuncEv" } }
+// undefined ref to _ZN5Test18testFuncEv
+
+class Test1 {
+public:
+  static int testFunc() { return 1; }
+};
+
+template <typename T,
+          T (*funcImpl)()>
+class TestWrapper {
+public:
+  static T func() __attribute((noinline)) { return (*funcImpl)(); } 
+};
+
+int main() {
+  return TestWrapper<int, &Test1::testFunc>::func();
+}
diff --git a/gcc/testsuite/g++.dg/debug/dwarf2/pr88006.C b/gcc/testsuite/g++.dg/debug/dwarf2/pr88006.C
new file mode 100644
index 00000000000..86584e17763
--- /dev/null
+++ b/gcc/testsuite/g++.dg/debug/dwarf2/pr88006.C
@@ -0,0 +1,39 @@
+// { dg-additional-options "-dA -std=gnu++17 -gdwarf-4 -O1 -fdebug-types-section" }
+// reject .pseudo label, but "label" is ok.
+// { dg-final { scan-assembler-not "\[^\"\]_ZN3Foo4mfunEv" } }
+// undefined ref to _ZN3Foo4mfunEv
+
+struct Foo {
+  void mfun () {}
+};
+
+struct A { static constexpr bool Value = false; };
+
+template <bool> struct B { typedef int Type; };
+
+class Arg
+{
+  template <typename Unused> struct Local : A {};
+
+public:
+  template <typename Init, typename = typename B<Local<Init>::Value>::Type>
+  Arg (Init) {}
+};
+
+class Lambda {
+  static constexpr int Unused = 0;
+    
+public:
+  Lambda (Arg);
+};
+
+// Generated ref to Foo::mfun in the type die of an instantiation of this
+template <void (Foo::*unused)()> struct Callable {};
+
+class I {
+  I() : lamb ([this] {}) {}
+
+  Lambda lamb;
+
+  Callable<&Foo::mfun> bm;
+};
diff --git a/gcc/testsuite/g++.dg/diagnostic/pr85464.C b/gcc/testsuite/g++.dg/diagnostic/pr85464.C
new file mode 100644
index 00000000000..ee8b65185e5
--- /dev/null
+++ b/gcc/testsuite/g++.dg/diagnostic/pr85464.C
@@ -0,0 +1,5 @@
+// { dg-options "-Wignored-qualifiers" }
+struct Test {
+   operator int const(); // { dg-warning "type qualifiers ignored" }
+   operator int const() const; // { dg-warning "type qualifiers ignored" }
+};
diff --git a/gcc/testsuite/g++.dg/ext/asm14.C b/gcc/testsuite/g++.dg/ext/asm14.C
new file mode 100644
index 00000000000..f7f61aabd93
--- /dev/null
+++ b/gcc/testsuite/g++.dg/ext/asm14.C
@@ -0,0 +1,10 @@
+// PR c++/85659
+// { dg-do compile }
+
+struct S { S (); ~S (); int s; };
+
+void
+foo (S &s)
+{
+  __asm volatile ("" : "+m,r" (s) : : "memory");
+}
diff --git a/gcc/testsuite/g++.dg/ext/asm15.C b/gcc/testsuite/g++.dg/ext/asm15.C
new file mode 100644
index 00000000000..c4946ddc536
--- /dev/null
+++ b/gcc/testsuite/g++.dg/ext/asm15.C
@@ -0,0 +1,10 @@
+// PR c++/85659
+// { dg-do compile }
+
+struct S { S (); ~S (); int s; };
+
+void
+foo (S &s)
+{
+  __asm volatile ("" : "+r" (s) : : "memory");	// { dg-error "" }
+}
diff --git a/gcc/testsuite/g++.dg/ext/asm16.C b/gcc/testsuite/g++.dg/ext/asm16.C
new file mode 100644
index 00000000000..565cbb33e5f
--- /dev/null
+++ b/gcc/testsuite/g++.dg/ext/asm16.C
@@ -0,0 +1,10 @@
+// PR c++/85659
+// { dg-do compile }
+
+struct S { S (); ~S (); int s[64]; } s;
+
+void
+foo ()
+{
+  __asm volatile ("" : "=r" (s) : : "memory");	// { dg-error "" }
+}
diff --git a/gcc/testsuite/g++.dg/ext/atomic-4.C b/gcc/testsuite/g++.dg/ext/atomic-4.C
new file mode 100644
index 00000000000..1eba11773e9
--- /dev/null
+++ b/gcc/testsuite/g++.dg/ext/atomic-4.C
@@ -0,0 +1,9 @@
+// PR inline-asm/85172
+// { dg-do compile }
+// { dg-options "" }
+
+int
+foo (int *p)
+{
+  return !__atomic_always_lock_free (4, ({ __asm (""); p; }));
+}
diff --git a/gcc/testsuite/g++.dg/ext/attr-noinline-4.C b/gcc/testsuite/g++.dg/ext/attr-noinline-4.C
new file mode 100644
index 00000000000..27c7ae80fec
--- /dev/null
+++ b/gcc/testsuite/g++.dg/ext/attr-noinline-4.C
@@ -0,0 +1,10 @@
+// PR c++/84665
+
+struct S {} a[1];
+
+template <int N>
+void
+foo ()
+{
+  __attribute__ ((noinline (a[0]))) int c = 0; // { dg-error "wrong number of arguments" }
+}
diff --git a/gcc/testsuite/g++.dg/ext/builtin12.C b/gcc/testsuite/g++.dg/ext/builtin12.C
new file mode 100644
index 00000000000..1d6bb75cd77
--- /dev/null
+++ b/gcc/testsuite/g++.dg/ext/builtin12.C
@@ -0,0 +1,10 @@
+// PR c++/85113
+// { dg-do compile { target c++14 } }
+
+template<bool> struct A {};
+
+constexpr int foo()
+{
+  A<__builtin_constant_p(0)> a{};
+  return 0;
+}
diff --git a/gcc/testsuite/g++.dg/ext/builtin13.C b/gcc/testsuite/g++.dg/ext/builtin13.C
new file mode 100644
index 00000000000..7007fe8a6ef
--- /dev/null
+++ b/gcc/testsuite/g++.dg/ext/builtin13.C
@@ -0,0 +1,9 @@
+// PR inline-asm/85172
+// { dg-do compile }
+// { dg-options "" }
+
+int
+foo ()
+{
+  return !__builtin_constant_p (({ __asm (""); 0; }));
+}
diff --git a/gcc/testsuite/g++.dg/ext/is_trivially_constructible6.C b/gcc/testsuite/g++.dg/ext/is_trivially_constructible6.C
new file mode 100644
index 00000000000..10a8dfbb8f0
--- /dev/null
+++ b/gcc/testsuite/g++.dg/ext/is_trivially_constructible6.C
@@ -0,0 +1,10 @@
+// PR c++/81589
+
+template <typename k>
+struct z {
+  z() {
+    k::error;
+  }
+};
+
+int x = __is_trivially_constructible(z<int>);
diff --git a/gcc/testsuite/g++.dg/ext/offsetof2.C b/gcc/testsuite/g++.dg/ext/offsetof2.C
new file mode 100644
index 00000000000..647cf8d0b77
--- /dev/null
+++ b/gcc/testsuite/g++.dg/ext/offsetof2.C
@@ -0,0 +1,6 @@
+// PR c++/85662
+// { dg-do compile { target c++11 } }
+
+struct S { unsigned long x[31]; };
+struct T { bool b; S f; };
+static_assert (__builtin_offsetof (T, f.x[31 - 1]) == __builtin_offsetof (T, f.x[30]), "");
diff --git a/gcc/testsuite/g++.dg/ext/offsetof3.C b/gcc/testsuite/g++.dg/ext/offsetof3.C
new file mode 100644
index 00000000000..6bf4c506fe3
--- /dev/null
+++ b/gcc/testsuite/g++.dg/ext/offsetof3.C
@@ -0,0 +1,5 @@
+// PR c++/85662
+// { dg-do compile { target c++11 } }
+// { dg-options "-O2" }
+
+#include "offsetof2.C"
diff --git a/gcc/testsuite/g++.dg/ext/stmtexpr22.C b/gcc/testsuite/g++.dg/ext/stmtexpr22.C
new file mode 100644
index 00000000000..f46523a5875
--- /dev/null
+++ b/gcc/testsuite/g++.dg/ext/stmtexpr22.C
@@ -0,0 +1,13 @@
+// PR c++/81853
+// { dg-do compile { target c++11 } }
+// { dg-options "" }
+
+namespace N {
+  enum { i };
+}
+
+int g ()
+{
+  constexpr int j = ({ using namespace N; i; });
+  return j;
+}
diff --git a/gcc/testsuite/g++.dg/ext/sync-4.C b/gcc/testsuite/g++.dg/ext/sync-4.C
index 47aa1e38d57..8a2de48ddda 100644
--- a/gcc/testsuite/g++.dg/ext/sync-4.C
+++ b/gcc/testsuite/g++.dg/ext/sync-4.C
@@ -1,4 +1,6 @@
 /* { dg-do run { target hppa*-*-hpux* *-*-linux* *-*-gnu* powerpc*-*-darwin* *-*-darwin[912]* } } */
+/* FIXME The following additional option should be removed after the fix for radr://19802258.
+/* { dg-xfail-run-if "PR60563 radr://19802258" { *-*-darwin* } } */
 /* { dg-require-effective-target sync_long_long_runtime } */
 /* { dg-options "-fexceptions -fnon-call-exceptions -O2" } */
 /* { dg-additional-options "-march=pentium" { target { { i?86-*-* x86_64-*-* } && ia32 } } } */
diff --git a/gcc/testsuite/g++.dg/ext/visibility/lambda1.C b/gcc/testsuite/g++.dg/ext/visibility/lambda1.C
new file mode 100644
index 00000000000..359f8e4af5a
--- /dev/null
+++ b/gcc/testsuite/g++.dg/ext/visibility/lambda1.C
@@ -0,0 +1,14 @@
+// PR c++/85646
+// { dg-do compile { target c++11 } }
+// { dg-additional-options -fvisibility=hidden }
+
+template<typename T>
+void foo() {
+    struct inner {
+        inner() {
+            (void)([this] { });
+        }
+    };
+}
+
+int main() { foo<int>(); }
diff --git a/gcc/testsuite/g++.dg/ext/vla18.C b/gcc/testsuite/g++.dg/ext/vla18.C
new file mode 100644
index 00000000000..31a1bb32f1a
--- /dev/null
+++ b/gcc/testsuite/g++.dg/ext/vla18.C
@@ -0,0 +1,19 @@
+// PR c++/84767
+// { dg-do compile }
+// { dg-options "" }
+
+int v[1][10];
+
+struct A
+{
+  A (int);
+};
+
+A::A (int i)
+{
+  typedef int T[1][i];
+  T *x = (T *) v;
+  (*x)[0][0] = 0;
+}
+
+A a = 10;
diff --git a/gcc/testsuite/g++.dg/gomp/pr84430.C b/gcc/testsuite/g++.dg/gomp/pr84430.C
new file mode 100644
index 00000000000..cf9275acaa0
--- /dev/null
+++ b/gcc/testsuite/g++.dg/gomp/pr84430.C
@@ -0,0 +1,12 @@
+// PR c++/84430
+// { dg-do compile { target c++11 } }
+
+void
+foo ()
+{
+  auto a = [] {
+    #pragma omp simd
+    for (int i = 0; i < 10; ++i)
+      ;
+  };
+}
diff --git a/gcc/testsuite/g++.dg/gomp/pr84448.C b/gcc/testsuite/g++.dg/gomp/pr84448.C
new file mode 100644
index 00000000000..3fad4741d38
--- /dev/null
+++ b/gcc/testsuite/g++.dg/gomp/pr84448.C
@@ -0,0 +1,17 @@
+// PR c++/84448
+// { dg-do compile }
+
+struct A
+{
+  operator int () const;
+  A& operator += (int);
+  A& operator ++ ();
+};
+
+void
+foo (A a, A b)
+{
+  #pragma omp for
+  for (A i = a; i <=; ++i)	// { dg-error "expected primary-expression before" }
+    ;				// { dg-error "invalid controlling predicate" "" { target *-*-* } .-1 }
+}
diff --git a/gcc/testsuite/g++.dg/gomp/pr84556.C b/gcc/testsuite/g++.dg/gomp/pr84556.C
new file mode 100644
index 00000000000..188d5a49b91
--- /dev/null
+++ b/gcc/testsuite/g++.dg/gomp/pr84556.C
@@ -0,0 +1,14 @@
+// PR c++/84556
+// { dg-do compile }
+// { dg-options "-std=c++17 -fopenmp-simd" }
+
+void
+foo ()
+{
+  auto x = [] ()
+  {
+    #pragma omp simd
+    for (int i = 0; i < 8; ++i)
+      ;
+  };
+}
diff --git a/gcc/testsuite/g++.dg/gomp/pr84557.C b/gcc/testsuite/g++.dg/gomp/pr84557.C
new file mode 100644
index 00000000000..cd215901aef
--- /dev/null
+++ b/gcc/testsuite/g++.dg/gomp/pr84557.C
@@ -0,0 +1,14 @@
+// PR c++/84557
+// { dg-do compile }
+
+template<int> struct A {};
+template<int> struct B {};
+
+void
+foo ()
+{
+  #pragma omp parallel firstprivate (A)		// { dg-error "is not a variable in clause" }
+  ;
+  #pragma omp parallel firstprivate (B<0>)	// { dg-error "is not a variable in clause" }
+  ;
+}
diff --git a/gcc/testsuite/g++.dg/gomp/pr84791.C b/gcc/testsuite/g++.dg/gomp/pr84791.C
new file mode 100644
index 00000000000..4e6d3b8fd44
--- /dev/null
+++ b/gcc/testsuite/g++.dg/gomp/pr84791.C
@@ -0,0 +1,15 @@
+// PR c++/84791
+// { dg-do compile }
+
+typedef int I;
+
+template <int>
+void
+foo ()
+{
+  I i;
+  #pragma omp parallel reduction (I::I: i)	// { dg-error "'I' is not a class, namespace, or enumeration" "" { target c++11 } }
+    ;						// { dg-error "'I' is not a class or namespace" "" { target c++98_only } .-1 }
+}
+
+template void foo<0> ();
diff --git a/gcc/testsuite/g++.dg/guality/pr86687.C b/gcc/testsuite/g++.dg/guality/pr86687.C
new file mode 100644
index 00000000000..b2cdaf8547b
--- /dev/null
+++ b/gcc/testsuite/g++.dg/guality/pr86687.C
@@ -0,0 +1,28 @@
+// PR debug/86687
+// { dg-do run }
+// { dg-options "-g" }
+
+class string {
+public:
+  string (int p) { this->p = p ; }
+  string (const string &s) { this->p = s.p; }
+
+  int p;
+};
+
+class foo {
+public:
+  foo (string dir_hint) {
+    p = dir_hint.p; // { dg-final { gdb-test 16 "dir_hint.p" 3 } }
+  }
+
+  int p;
+};
+
+int
+main (void)
+{
+  string s = 3;
+  foo bar(s);
+  return !(bar.p == 3);
+}
diff --git a/gcc/testsuite/g++.dg/inherit/covariant22.C b/gcc/testsuite/g++.dg/inherit/covariant22.C
new file mode 100644
index 00000000000..26c96e6abfc
--- /dev/null
+++ b/gcc/testsuite/g++.dg/inherit/covariant22.C
@@ -0,0 +1,19 @@
+// PR c++/85068
+// { dg-do compile }
+
+struct A;
+
+struct B
+{
+  virtual A *foo ();	// { dg-error "overriding" }
+};
+
+struct C : virtual B
+{
+  virtual C *foo ();	// { dg-error "invalid covariant return type for" }
+};
+
+struct D : C
+{
+  virtual C *foo ();
+};
diff --git a/gcc/testsuite/g++.dg/init/new44.C b/gcc/testsuite/g++.dg/init/new44.C
index ab6e3484cc8..4ab73209e22 100644
--- a/gcc/testsuite/g++.dg/init/new44.C
+++ b/gcc/testsuite/g++.dg/init/new44.C
@@ -87,10 +87,10 @@ test_one_dim_short_array ()
 static void __attribute__ ((used))
 test_two_dim_char_array ()
 {
-    p = new char [1][MAX];              // { dg-error "size of unnamed array" }
-    p = new char [1][MAX - 1];          // { dg-error "size of unnamed array" }
-    p = new char [1][MAX - 2];          // { dg-error "size of unnamed array" }
-    p = new char [1][MAX - 99];         // { dg-error "size of unnamed array" }
+    p = new char [1][MAX];              // { dg-error "size of (unnamed )?array" }
+    p = new char [1][MAX - 1];          // { dg-error "size of (unnamed )?array" }
+    p = new char [1][MAX - 2];          // { dg-error "size of (unnamed )?array" }
+    p = new char [1][MAX - 99];         // { dg-error "size of (unnamed )?array" }
     p = new char [1][MAX / 2];          // { dg-error "size of array" }
     p = new char [1][MAX / 2 - 1];      // { dg-error "size of array" }
     p = new char [1][MAX / 2 - 2];      // { dg-error "size of array" }
@@ -104,18 +104,18 @@ test_two_dim_char_array ()
     p = new char [1][MAX / 2 - 7];      // okay
     p = new char [1][MAX / 2 - 8];      // okay
 
-    p = new char [2][MAX];              // { dg-error "size of unnamed array" }
-    p = new char [2][MAX - 1];          // { dg-error "size of unnamed array" }
-    p = new char [2][MAX - 2];          // { dg-error "size of unnamed array" }
+    p = new char [2][MAX];              // { dg-error "size of (unnamed )?array" }
+    p = new char [2][MAX - 1];          // { dg-error "size of (unnamed )?array" }
+    p = new char [2][MAX - 2];          // { dg-error "size of (unnamed )?array" }
     p = new char [2][MAX / 2];          // { dg-error "size of array" }
     p = new char [2][MAX / 2 - 1];      // { dg-error "size of array" }
     p = new char [2][MAX / 2 - 2];      // { dg-error "size of array" }
     p = new char [2][MAX / 2 - 7];      // { dg-error "size of array" }
     p = new char [2][MAX / 2 - 8];      // { dg-error "size of array" }
 
-    p = new char [MAX][MAX];            // { dg-error "size of unnamed array" }
-    p = new char [MAX][MAX - 1];        // { dg-error "size of unnamed array" }
-    p = new char [MAX][MAX - 2];        // { dg-error "size of unnamed array" }
+    p = new char [MAX][MAX];            // { dg-error "size of (unnamed )?array" }
+    p = new char [MAX][MAX - 1];        // { dg-error "size of (unnamed )?array" }
+    p = new char [MAX][MAX - 2];        // { dg-error "size of (unnamed )?array" }
     p = new char [MAX][MAX / 2];        // { dg-error "size of array" }
     p = new char [MAX][MAX / 2 - 1];    // { dg-error "size of array" }
     p = new char [MAX][MAX / 2 - 2];    // { dg-error "size of array" }
@@ -142,10 +142,10 @@ test_two_dim_char_array ()
 static __attribute__ ((used)) void
 test_three_dim_char_array ()
 {
-    p = new char [1][1][MAX];           // { dg-error "size of unnamed array" }
-    p = new char [1][1][MAX - 1];       // { dg-error "size of unnamed array" }
-    p = new char [1][1][MAX - 2];       // { dg-error "size of unnamed array" }
-    p = new char [1][1][MAX - 99];      // { dg-error "size of unnamed array" }
+    p = new char [1][1][MAX];           // { dg-error "size of (unnamed )?array" }
+    p = new char [1][1][MAX - 1];       // { dg-error "size of (unnamed )?array" }
+    p = new char [1][1][MAX - 2];       // { dg-error "size of (unnamed )?array" }
+    p = new char [1][1][MAX - 99];      // { dg-error "size of (unnamed )?array" }
     p = new char [1][1][MAX / 2];       // { dg-error "size of array" }
     p = new char [1][1][MAX / 2 - 1];   // { dg-error "size of array" }
     p = new char [1][1][MAX / 2 - 2];   // { dg-error "size of array" }
@@ -159,19 +159,19 @@ test_three_dim_char_array ()
     p = new char [1][1][MAX / 2 - 7];   // okay
     p = new char [1][1][MAX / 2 - 8];   // okay
 
-    p = new char [1][2][MAX];           // { dg-error "size of unnamed array" }
-    p = new char [1][2][MAX - 1];       // { dg-error "size of unnamed array" }
-    p = new char [1][2][MAX - 2];       // { dg-error "size of unnamed array" }
-    p = new char [1][2][MAX - 99];      // { dg-error "size of unnamed array" }
-    p = new char [1][2][MAX / 2];       // { dg-error "size of unnamed array" }
-    p = new char [1][2][MAX / 2 - 1];   // { dg-error "size of unnamed array" }
-    p = new char [1][2][MAX / 2 - 2];   // { dg-error "size of unnamed array" }
-    p = new char [1][2][MAX / 2 - 3];   // { dg-error "size of unnamed array" }
-    p = new char [1][2][MAX / 2 - 4];   // { dg-error "size of unnamed array" }
-    p = new char [1][2][MAX / 2 - 5];   // { dg-error "size of unnamed array" }
-    p = new char [1][2][MAX / 2 - 6];   // { dg-error "size of unnamed array" }
-    p = new char [1][2][MAX / 2 - 7];   // { dg-error "size of unnamed array" }
-    p = new char [1][2][MAX / 2 - 8];   // { dg-error "size of unnamed array" }
+    p = new char [1][2][MAX];           // { dg-error "size of (unnamed )?array" }
+    p = new char [1][2][MAX - 1];       // { dg-error "size of (unnamed )?array" }
+    p = new char [1][2][MAX - 2];       // { dg-error "size of (unnamed )?array" }
+    p = new char [1][2][MAX - 99];      // { dg-error "size of (unnamed )?array" }
+    p = new char [1][2][MAX / 2];       // { dg-error "size of (unnamed )?array" }
+    p = new char [1][2][MAX / 2 - 1];   // { dg-error "size of (unnamed )?array" }
+    p = new char [1][2][MAX / 2 - 2];   // { dg-error "size of (unnamed )?array" }
+    p = new char [1][2][MAX / 2 - 3];   // { dg-error "size of (unnamed )?array" }
+    p = new char [1][2][MAX / 2 - 4];   // { dg-error "size of (unnamed )?array" }
+    p = new char [1][2][MAX / 2 - 5];   // { dg-error "size of (unnamed )?array" }
+    p = new char [1][2][MAX / 2 - 6];   // { dg-error "size of (unnamed )?array" }
+    p = new char [1][2][MAX / 2 - 7];   // { dg-error "size of (unnamed )?array" }
+    p = new char [1][2][MAX / 2 - 8];   // { dg-error "size of (unnamed )?array" }
     p = new char [1][2][MAX / 4];       // { dg-error "size of array" }
 
     // Avoid exercising data model-dependent expressions.
@@ -181,10 +181,10 @@ test_three_dim_char_array ()
     p = new char [1][2][MAX / 4 - 3];   // okay
     p = new char [1][2][MAX / 4 - 4];   // okay
 
-    p = new char [2][1][MAX];           // { dg-error "size of unnamed array" }
-    p = new char [2][1][MAX - 1];       // { dg-error "size of unnamed array" }
-    p = new char [2][1][MAX - 2];       // { dg-error "size of unnamed array" }
-    p = new char [2][1][MAX - 99];      // { dg-error "size of unnamed array" }
+    p = new char [2][1][MAX];           // { dg-error "size of (unnamed )?array" }
+    p = new char [2][1][MAX - 1];       // { dg-error "size of (unnamed )?array" }
+    p = new char [2][1][MAX - 2];       // { dg-error "size of (unnamed )?array" }
+    p = new char [2][1][MAX - 99];      // { dg-error "size of (unnamed )?array" }
     p = new char [2][1][MAX / 2];       // { dg-error "size of array" }
     p = new char [2][1][MAX / 2 - 1];   // { dg-error "size of array" }
     p = new char [2][1][MAX / 2 - 2];   // { dg-error "size of array" }
@@ -203,19 +203,19 @@ test_three_dim_char_array ()
     p = new char [2][1][MAX / 4 - 3];   // okay
     p = new char [2][1][MAX / 4 - 4];   // okay
 
-    p = new char [2][2][MAX];           // { dg-error "size of unnamed array" }
-    p = new char [2][2][MAX - 1];       // { dg-error "size of unnamed array" }
-    p = new char [2][2][MAX - 2];       // { dg-error "size of unnamed array" }
-    p = new char [2][2][MAX - 99];      // { dg-error "size of unnamed array" }
-    p = new char [2][2][MAX / 2];       // { dg-error "size of unnamed array" }
-    p = new char [2][2][MAX / 2 - 1];   // { dg-error "size of unnamed array" }
-    p = new char [2][2][MAX / 2 - 2];   // { dg-error "size of unnamed array" }
-    p = new char [2][2][MAX / 2 - 3];   // { dg-error "size of unnamed array" }
-    p = new char [2][2][MAX / 2 - 4];   // { dg-error "size of unnamed array" }
-    p = new char [2][2][MAX / 2 - 5];   // { dg-error "size of unnamed array" }
-    p = new char [2][2][MAX / 2 - 6];   // { dg-error "size of unnamed array" }
-    p = new char [2][2][MAX / 2 - 7];   // { dg-error "size of unnamed array" }
-    p = new char [2][2][MAX / 2 - 8];   // { dg-error "size of unnamed array" }
+    p = new char [2][2][MAX];           // { dg-error "size of (unnamed )?array" }
+    p = new char [2][2][MAX - 1];       // { dg-error "size of (unnamed )?array" }
+    p = new char [2][2][MAX - 2];       // { dg-error "size of (unnamed )?array" }
+    p = new char [2][2][MAX - 99];      // { dg-error "size of (unnamed )?array" }
+    p = new char [2][2][MAX / 2];       // { dg-error "size of (unnamed )?array" }
+    p = new char [2][2][MAX / 2 - 1];   // { dg-error "size of (unnamed )?array" }
+    p = new char [2][2][MAX / 2 - 2];   // { dg-error "size of (unnamed )?array" }
+    p = new char [2][2][MAX / 2 - 3];   // { dg-error "size of (unnamed )?array" }
+    p = new char [2][2][MAX / 2 - 4];   // { dg-error "size of (unnamed )?array" }
+    p = new char [2][2][MAX / 2 - 5];   // { dg-error "size of (unnamed )?array" }
+    p = new char [2][2][MAX / 2 - 6];   // { dg-error "size of (unnamed )?array" }
+    p = new char [2][2][MAX / 2 - 7];   // { dg-error "size of (unnamed )?array" }
+    p = new char [2][2][MAX / 2 - 8];   // { dg-error "size of (unnamed )?array" }
     p = new char [2][2][MAX / 4];       // { dg-error "size of array" }
     p = new char [2][2][MAX / 4 - 1];   // { dg-error "size of array" }
     p = new char [2][2][MAX / 4 - 2];   // { dg-error "size of array" }
@@ -227,19 +227,19 @@ test_three_dim_char_array ()
     p = new char [2][2][MAX / 8 - 2];
     p = new char [2][2][MAX / 8 - 3];
 
-    p = new char [2][MAX][2];           // { dg-error "size of unnamed array" }
-    p = new char [2][MAX - 1][2];       // { dg-error "size of unnamed array" }
-    p = new char [2][MAX - 2][2];       // { dg-error "size of unnamed array" }
-    p = new char [2][MAX - 99][2];      // { dg-error "size of unnamed array" }
-    p = new char [2][MAX / 2][2];       // { dg-error "size of unnamed array" }
-    p = new char [2][MAX / 2 - 1][2];   // { dg-error "size of unnamed array" }
-    p = new char [2][MAX / 2 - 2][2];   // { dg-error "size of unnamed array" }
-    p = new char [2][MAX / 2 - 3][2];   // { dg-error "size of unnamed array" }
-    p = new char [2][MAX / 2 - 4][2];   // { dg-error "size of unnamed array" }
-    p = new char [2][MAX / 2 - 5][2];   // { dg-error "size of unnamed array" }
-    p = new char [2][MAX / 2 - 6][2];   // { dg-error "size of unnamed array" }
-    p = new char [2][MAX / 2 - 7][2];   // { dg-error "size of unnamed array" }
-    p = new char [2][MAX / 2 - 8][2];   // { dg-error "size of unnamed array" }
+    p = new char [2][MAX][2];           // { dg-error "size of (unnamed )?array" }
+    p = new char [2][MAX - 1][2];       // { dg-error "size of (unnamed )?array" }
+    p = new char [2][MAX - 2][2];       // { dg-error "size of (unnamed )?array" }
+    p = new char [2][MAX - 99][2];      // { dg-error "size of (unnamed )?array" }
+    p = new char [2][MAX / 2][2];       // { dg-error "size of (unnamed )?array" }
+    p = new char [2][MAX / 2 - 1][2];   // { dg-error "size of (unnamed )?array" }
+    p = new char [2][MAX / 2 - 2][2];   // { dg-error "size of (unnamed )?array" }
+    p = new char [2][MAX / 2 - 3][2];   // { dg-error "size of (unnamed )?array" }
+    p = new char [2][MAX / 2 - 4][2];   // { dg-error "size of (unnamed )?array" }
+    p = new char [2][MAX / 2 - 5][2];   // { dg-error "size of (unnamed )?array" }
+    p = new char [2][MAX / 2 - 6][2];   // { dg-error "size of (unnamed )?array" }
+    p = new char [2][MAX / 2 - 7][2];   // { dg-error "size of (unnamed )?array" }
+    p = new char [2][MAX / 2 - 8][2];   // { dg-error "size of (unnamed )?array" }
     p = new char [2][MAX / 4][2];       // { dg-error "size of array" }
     p = new char [2][MAX / 4 - 1][2];   // { dg-error "size of array" }
     p = new char [2][MAX / 4 - 2][2];   // { dg-error "size of array" }
@@ -275,11 +275,11 @@ test_three_dim_char_array ()
     p = new char [MAX / 8 - 2][2][2];
     p = new char [MAX / 8 - 3][2][2];
 
-    p = new char [MAX][MAX][MAX];         // { dg-error "size of unnamed array" }
-    p = new char [MAX][MAX][MAX / 2];     // { dg-error "size of unnamed array" }
-    p = new char [MAX][MAX / 2][MAX];     // { dg-error "size of unnamed array" }
-    p = new char [MAX][MAX / 2][MAX / 2]; // { dg-error "size of unnamed array" }
-    p = new char [MAX / 2][MAX / 2][MAX / 2]; // { dg-error "size of unnamed array" }
+    p = new char [MAX][MAX][MAX];         // { dg-error "size of (unnamed )?array" }
+    p = new char [MAX][MAX][MAX / 2];     // { dg-error "size of (unnamed )?array" }
+    p = new char [MAX][MAX / 2][MAX];     // { dg-error "size of (unnamed )?array" }
+    p = new char [MAX][MAX / 2][MAX / 2]; // { dg-error "size of (unnamed )?array" }
+    p = new char [MAX / 2][MAX / 2][MAX / 2]; // { dg-error "size of (unnamed )?array" }
 }
 
 // Exercise new expression with N-dimensional arrays where N is
@@ -342,10 +342,10 @@ test_one_dim_byte_array (void *p)
 static void __attribute__ ((used))
 test_placement_two_dim_byte_struct_array (void *p)
 {
-    p = new (p) B [1][MAX];             // { dg-error "size of unnamed array" }
-    p = new (p) B [1][MAX - 1];         // { dg-error "size of unnamed array" }
-    p = new (p) B [1][MAX - 2];         // { dg-error "size of unnamed array" }
-    p = new (p) B [1][MAX - 99];        // { dg-error "size of unnamed array" }
+    p = new (p) B [1][MAX];             // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [1][MAX - 1];         // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [1][MAX - 2];         // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [1][MAX - 99];        // { dg-error "size of (unnamed )?array" }
     p = new (p) B [1][MAX / 2];         // { dg-error "size of array" }
     p = new (p) B [1][MAX / 2 - 1];     // { dg-error "size of array" }
     p = new (p) B [1][MAX / 2 - 2];     // { dg-error "size of array" }
@@ -359,18 +359,18 @@ test_placement_two_dim_byte_struct_array (void *p)
     p = new (p) B [1][MAX / 2 - 7];      // okay
     p = new (p) B [1][MAX / 2 - 8];      // okay
 
-    p = new (p) B [2][MAX];             // { dg-error "size of unnamed array" }
-    p = new (p) B [2][MAX - 1];         // { dg-error "size of unnamed array" }
-    p = new (p) B [2][MAX - 2];         // { dg-error "size of unnamed array" }
+    p = new (p) B [2][MAX];             // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [2][MAX - 1];         // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [2][MAX - 2];         // { dg-error "size of (unnamed )?array" }
     p = new (p) B [2][MAX / 2];         // { dg-error "size of array" }
     p = new (p) B [2][MAX / 2 - 1];     // { dg-error "size of array" }
     p = new (p) B [2][MAX / 2 - 2];     // { dg-error "size of array" }
     p = new (p) B [2][MAX / 2 - 7];     // { dg-error "size of array" }
     p = new (p) B [2][MAX / 2 - 8];     // { dg-error "size of array" }
 
-    p = new (p) B [MAX][MAX];           // { dg-error "size of unnamed array" }
-    p = new (p) B [MAX][MAX - 1];       // { dg-error "size of unnamed array" }
-    p = new (p) B [MAX][MAX - 2];       // { dg-error "size of unnamed array" }
+    p = new (p) B [MAX][MAX];           // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [MAX][MAX - 1];       // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [MAX][MAX - 2];       // { dg-error "size of (unnamed )?array" }
     p = new (p) B [MAX][MAX / 2];       // { dg-error "size of array" }
     p = new (p) B [MAX][MAX / 2 - 1];   // { dg-error "size of array" }
     p = new (p) B [MAX][MAX / 2 - 2];   // { dg-error "size of array" }
@@ -397,10 +397,10 @@ test_placement_two_dim_byte_struct_array (void *p)
 static __attribute__ ((used)) void
 test_placement_three_dim_byte_struct_array (void *p)
 {
-    p = new (p) B [1][1][MAX];          // { dg-error "size of unnamed array" }
-    p = new (p) B [1][1][MAX - 1];      // { dg-error "size of unnamed array" }
-    p = new (p) B [1][1][MAX - 2];      // { dg-error "size of unnamed array" }
-    p = new (p) B [1][1][MAX - 99];     // { dg-error "size of unnamed array" }
+    p = new (p) B [1][1][MAX];          // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [1][1][MAX - 1];      // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [1][1][MAX - 2];      // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [1][1][MAX - 99];     // { dg-error "size of (unnamed )?array" }
     p = new (p) B [1][1][MAX / 2];      // { dg-error "size of array" }
     p = new (p) B [1][1][MAX / 2 - 1];  // { dg-error "size of array" }
     p = new (p) B [1][1][MAX / 2 - 2];  // { dg-error "size of array" }
@@ -414,19 +414,19 @@ test_placement_three_dim_byte_struct_array (void *p)
     p = new (p) B [1][1][MAX / 2 - 7];   // okay
     p = new (p) B [1][1][MAX / 2 - 8];   // okay
 
-    p = new (p) B [1][2][MAX];          // { dg-error "size of unnamed array" }
-    p = new (p) B [1][2][MAX - 1];      // { dg-error "size of unnamed array" }
-    p = new (p) B [1][2][MAX - 2];      // { dg-error "size of unnamed array" }
-    p = new (p) B [1][2][MAX - 99];     // { dg-error "size of unnamed array" }
-    p = new (p) B [1][2][MAX / 2];      // { dg-error "size of unnamed array" }
-    p = new (p) B [1][2][MAX / 2 - 1];  // { dg-error "size of unnamed array" }
-    p = new (p) B [1][2][MAX / 2 - 2];  // { dg-error "size of unnamed array" }
-    p = new (p) B [1][2][MAX / 2 - 3];  // { dg-error "size of unnamed array" }
-    p = new (p) B [1][2][MAX / 2 - 4];  // { dg-error "size of unnamed array" }
-    p = new (p) B [1][2][MAX / 2 - 5];  // { dg-error "size of unnamed array" }
-    p = new (p) B [1][2][MAX / 2 - 6];  // { dg-error "size of unnamed array" }
-    p = new (p) B [1][2][MAX / 2 - 7];  // { dg-error "size of unnamed array" }
-    p = new (p) B [1][2][MAX / 2 - 8];  // { dg-error "size of unnamed array" }
+    p = new (p) B [1][2][MAX];          // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [1][2][MAX - 1];      // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [1][2][MAX - 2];      // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [1][2][MAX - 99];     // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [1][2][MAX / 2];      // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [1][2][MAX / 2 - 1];  // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [1][2][MAX / 2 - 2];  // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [1][2][MAX / 2 - 3];  // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [1][2][MAX / 2 - 4];  // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [1][2][MAX / 2 - 5];  // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [1][2][MAX / 2 - 6];  // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [1][2][MAX / 2 - 7];  // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [1][2][MAX / 2 - 8];  // { dg-error "size of (unnamed )?array" }
     p = new (p) B [1][2][MAX / 4];      // { dg-error "size of array" }
 
     // Avoid exercising data model-dependent expressions.
@@ -436,10 +436,10 @@ test_placement_three_dim_byte_struct_array (void *p)
     p = new (p) B [1][2][MAX / 4 - 3];   // okay
     p = new (p) B [1][2][MAX / 4 - 4];   // okay
 
-    p = new (p) B [2][1][MAX];          // { dg-error "size of unnamed array" }
-    p = new (p) B [2][1][MAX - 1];      // { dg-error "size of unnamed array" }
-    p = new (p) B [2][1][MAX - 2];      // { dg-error "size of unnamed array" }
-    p = new (p) B [2][1][MAX - 99];     // { dg-error "size of unnamed array" }
+    p = new (p) B [2][1][MAX];          // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [2][1][MAX - 1];      // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [2][1][MAX - 2];      // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [2][1][MAX - 99];     // { dg-error "size of (unnamed )?array" }
     p = new (p) B [2][1][MAX / 2];      // { dg-error "size of array" }
     p = new (p) B [2][1][MAX / 2 - 1];  // { dg-error "size of array" }
     p = new (p) B [2][1][MAX / 2 - 2];  // { dg-error "size of array" }
@@ -458,19 +458,19 @@ test_placement_three_dim_byte_struct_array (void *p)
     p = new (p) B [2][1][MAX / 4 - 3];   // okay
     p = new (p) B [2][1][MAX / 4 - 4];   // okay
 
-    p = new (p) B [2][2][MAX];          // { dg-error "size of unnamed array" }
-    p = new (p) B [2][2][MAX - 1];      // { dg-error "size of unnamed array" }
-    p = new (p) B [2][2][MAX - 2];      // { dg-error "size of unnamed array" }
-    p = new (p) B [2][2][MAX - 99];     // { dg-error "size of unnamed array" }
-    p = new (p) B [2][2][MAX / 2];      // { dg-error "size of unnamed array" }
-    p = new (p) B [2][2][MAX / 2 - 1];  // { dg-error "size of unnamed array" }
-    p = new (p) B [2][2][MAX / 2 - 2];  // { dg-error "size of unnamed array" }
-    p = new (p) B [2][2][MAX / 2 - 3];  // { dg-error "size of unnamed array" }
-    p = new (p) B [2][2][MAX / 2 - 4];  // { dg-error "size of unnamed array" }
-    p = new (p) B [2][2][MAX / 2 - 5];  // { dg-error "size of unnamed array" }
-    p = new (p) B [2][2][MAX / 2 - 6];  // { dg-error "size of unnamed array" }
-    p = new (p) B [2][2][MAX / 2 - 7];  // { dg-error "size of unnamed array" }
-    p = new (p) B [2][2][MAX / 2 - 8];  // { dg-error "size of unnamed array" }
+    p = new (p) B [2][2][MAX];          // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [2][2][MAX - 1];      // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [2][2][MAX - 2];      // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [2][2][MAX - 99];     // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [2][2][MAX / 2];      // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [2][2][MAX / 2 - 1];  // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [2][2][MAX / 2 - 2];  // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [2][2][MAX / 2 - 3];  // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [2][2][MAX / 2 - 4];  // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [2][2][MAX / 2 - 5];  // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [2][2][MAX / 2 - 6];  // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [2][2][MAX / 2 - 7];  // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [2][2][MAX / 2 - 8];  // { dg-error "size of (unnamed )?array" }
     p = new (p) B [2][2][MAX / 4];      // { dg-error "size of array" }
     p = new (p) B [2][2][MAX / 4 - 1];  // { dg-error "size of array" }
     p = new (p) B [2][2][MAX / 4 - 2];  // { dg-error "size of array" }
@@ -482,19 +482,19 @@ test_placement_three_dim_byte_struct_array (void *p)
     p = new (p) B [2][2][MAX / 8 - 2];
     p = new (p) B [2][2][MAX / 8 - 3];
 
-    p = new (p) B [2][MAX][2];          // { dg-error "size of unnamed array" }
-    p = new (p) B [2][MAX - 1][2];      // { dg-error "size of unnamed array" }
-    p = new (p) B [2][MAX - 2][2];      // { dg-error "size of unnamed array" }
-    p = new (p) B [2][MAX - 99][2];     // { dg-error "size of unnamed array" }
-    p = new (p) B [2][MAX / 2][2];      // { dg-error "size of unnamed array" }
-    p = new (p) B [2][MAX / 2 - 1][2];  // { dg-error "size of unnamed array" }
-    p = new (p) B [2][MAX / 2 - 2][2];  // { dg-error "size of unnamed array" }
-    p = new (p) B [2][MAX / 2 - 3][2];  // { dg-error "size of unnamed array" }
-    p = new (p) B [2][MAX / 2 - 4][2];  // { dg-error "size of unnamed array" }
-    p = new (p) B [2][MAX / 2 - 5][2];  // { dg-error "size of unnamed array" }
-    p = new (p) B [2][MAX / 2 - 6][2];  // { dg-error "size of unnamed array" }
-    p = new (p) B [2][MAX / 2 - 7][2];  // { dg-error "size of unnamed array" }
-    p = new (p) B [2][MAX / 2 - 8][2];  // { dg-error "size of unnamed array" }
+    p = new (p) B [2][MAX][2];          // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [2][MAX - 1][2];      // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [2][MAX - 2][2];      // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [2][MAX - 99][2];     // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [2][MAX / 2][2];      // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [2][MAX / 2 - 1][2];  // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [2][MAX / 2 - 2][2];  // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [2][MAX / 2 - 3][2];  // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [2][MAX / 2 - 4][2];  // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [2][MAX / 2 - 5][2];  // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [2][MAX / 2 - 6][2];  // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [2][MAX / 2 - 7][2];  // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [2][MAX / 2 - 8][2];  // { dg-error "size of (unnamed )?array" }
     p = new (p) B [2][MAX / 4][2];      // { dg-error "size of array" }
     p = new (p) B [2][MAX / 4 - 1][2];  // { dg-error "size of array" }
     p = new (p) B [2][MAX / 4 - 2][2];  // { dg-error "size of array" }
diff --git a/gcc/testsuite/g++.dg/init/pr83993-2.C b/gcc/testsuite/g++.dg/init/pr83993-2.C
new file mode 100644
index 00000000000..19f54081130
--- /dev/null
+++ b/gcc/testsuite/g++.dg/init/pr83993-2.C
@@ -0,0 +1,14 @@
+// PR c++/83993
+// { dg-do compile }
+// { dg-options "-w" }
+
+int a[5];
+extern int b[];
+int *const c = &a[6];
+int *const d = &b[1];
+
+int
+foo ()
+{
+  return c[-4] + d[-1];
+}
diff --git a/gcc/testsuite/g++.dg/init/struct2.C b/gcc/testsuite/g++.dg/init/struct2.C
index 85aacc6fa09..4396febdc46 100644
--- a/gcc/testsuite/g++.dg/init/struct2.C
+++ b/gcc/testsuite/g++.dg/init/struct2.C
@@ -15,7 +15,7 @@ void saveOrLoad() {
     };    
 
     SaveLoadEntry trackEntries = {
-	((long) (__SIZE_TYPE__) (&((Track *) 42)->soundName[0])) - 42,
+	((int) (__SIZE_TYPE__) (&((Track *) 42)->soundName[0])) - 42,
         0, 1
     };
     saveLoadEntries(&trackEntries);
diff --git a/gcc/testsuite/g++.dg/ipa/pr84658.C b/gcc/testsuite/g++.dg/ipa/pr84658.C
new file mode 100644
index 00000000000..6846e1832bd
--- /dev/null
+++ b/gcc/testsuite/g++.dg/ipa/pr84658.C
@@ -0,0 +1,30 @@
+/* PR ipa/84658 */
+/* { dg-do run } */
+/* { dg-options "-O2 -fmerge-all-constants -std=c++11" } */
+
+const int kTestCasesFoo[] = { 0, 1, 2, 3, 4, 5, 8, 15, 16, 17, 512, 1020, 1021, 1022, 1023, 1024 };
+const int kTestCasesBar[] = { 0, 1, 2, 3, 4, 5, 8, 15, 16, 17, 512, 1020, 1021, 1022, 1023, 1024 };
+
+void Foo() {
+    __builtin_printf("foo:");
+    for (int count : kTestCasesFoo) {
+        __builtin_printf("%d,", count);
+    }
+    __builtin_printf(";\n");
+}
+
+void Bar() {
+    __builtin_printf("bar:");
+    for (int count : kTestCasesBar) {
+        __builtin_printf("%d,", count);
+    }
+    __builtin_printf(";\n");
+}
+
+int main() {
+    Foo();
+    Bar();
+}
+
+/* { dg-output "foo:0,1,2,3,4,5,8,15,16,17,512,1020,1021,1022,1023,1024,;(\n|\n\r|\r)*" } */
+/* { dg-output "bar:0,1,2,3,4,5,8,15,16,17,512,1020,1021,1022,1023,1024,;(\n|\n\r|\r)*" } */
diff --git a/gcc/testsuite/g++.dg/opt/pr3698.C b/gcc/testsuite/g++.dg/opt/pr3698.C
new file mode 100644
index 00000000000..ebdf5731eb3
--- /dev/null
+++ b/gcc/testsuite/g++.dg/opt/pr3698.C
@@ -0,0 +1,21 @@
+// PR c++/3698
+// { dg-do link }
+// { dg-options "-O0" }
+
+struct X {
+  int i;
+};
+
+inline const int&
+OHashKey (const X& x)
+{
+  return x.i;
+}
+
+int
+main ()
+{
+ extern const int& OHashKey (const X& x);
+ X x;
+ return OHashKey (x);
+}
diff --git a/gcc/testsuite/g++.dg/opt/pr79085.C b/gcc/testsuite/g++.dg/opt/pr79085.C
new file mode 100644
index 00000000000..1d75d6a7300
--- /dev/null
+++ b/gcc/testsuite/g++.dg/opt/pr79085.C
@@ -0,0 +1,24 @@
+// PR c++/79085
+// { dg-do compile }
+// { dg-options "-Os" }
+// { dg-additional-options "-mstrict-align" { target { aarch64*-*-* powerpc*-*-linux* powerpc*-*-elf* } } }
+
+void *operator new (__SIZE_TYPE__, void *p) { return p; }
+
+struct S
+{
+  S ();
+  S (const S &);
+  ~S (void);
+  int i;
+};
+
+S foo ();
+
+static char buf [sizeof (S) + 1];
+
+S *
+bar ()
+{
+  return new (buf + 1) S (foo ());
+}
diff --git a/gcc/testsuite/g++.dg/opt/pr84272.C b/gcc/testsuite/g++.dg/opt/pr84272.C
new file mode 100644
index 00000000000..ad4b8a29cd7
--- /dev/null
+++ b/gcc/testsuite/g++.dg/opt/pr84272.C
@@ -0,0 +1,23 @@
+// PR target/84272
+// { dg-do compile }
+// { dg-options "-O2" }
+// { dg-additional-options "-march=armv8-a -mtune=cortex-a57" { target aarch64-*-* } }
+
+struct A
+{
+  float b, c;
+  A ();
+  A (float, float, float);
+  float operator * (A)
+  {
+    float d = b * b + c * c;
+    return d;
+  }
+};
+
+void
+foo ()
+{
+  A g[1];
+  A h (0, 0, h * g[2]);
+}
diff --git a/gcc/testsuite/g++.dg/opt/pr85196.C b/gcc/testsuite/g++.dg/opt/pr85196.C
new file mode 100644
index 00000000000..04d7abde4fa
--- /dev/null
+++ b/gcc/testsuite/g++.dg/opt/pr85196.C
@@ -0,0 +1,89 @@
+// PR target/85196
+// Testcase by Rainer Orth <ro@gcc.gnu.org>
+
+// { dg-do compile }
+// { dg-options "-O -fpermissive -w" }
+// { dg-additional-options "-fPIC" { target fpic } }
+
+class a;
+template <typename> class b;
+template <typename k> class d : public b<k> {};
+class e {};
+void f(int);
+template <class> class g {
+public:
+  h();
+  a i();
+};
+template <> class b<e> : public g<e> {};
+typedef (*j)(d<e>);
+template <class k> class l {
+public:
+  k operator->() { return 0; }
+};
+enum m { n, aa, o, ab, q, p };
+inline s(m ac) {
+  switch (ac) {
+  case n:
+  case aa:
+  case p:
+    return 1;
+  case o:
+  case ab:
+    return 2;
+  }
+}
+class D {
+  int ad;
+
+public:
+  *ae() { return &ad; }
+};
+class a {
+  l<D *> af;
+
+public:
+  *r() { return af->ae(); }
+  t(int *c) {
+    int *w = af->ae();
+    return w == c;
+  }
+};
+class F : a {
+public:
+  static int ah[];
+  static e v(F *);
+  unsigned long ai() const;
+};
+inline unsigned long F::ai() const {
+  m aj = r() - &ah[0];
+  return s(aj);
+}
+inline e F::v(F *ak) {
+  long al = ak->ai();
+  f(al);
+}
+template <typename> am() { return q; }
+class an : F {
+public:
+  static ao(d<e> u) {
+    int *ap;
+    m aq = am<unsigned>();
+    ap = &ah[aq];
+    return u.h() && u.i().t(ap);
+  }
+  template <e ar(F *)> static as() {
+    F at;
+    ar(&at);
+  }
+  template <e ar(F *)> static au(int *, unsigned, e *) {
+    j av = ao;
+    d<e> aw;
+    if (av(aw))
+      as<ar>();
+  }
+};
+int *ax;
+int ay;
+e az;
+ba() { an::au<an::v>(ax, ay, &az); }
diff --git a/gcc/testsuite/g++.dg/other/anon5.C b/gcc/testsuite/g++.dg/other/anon5.C
index 2a6f57f12bc..ee4601e270e 100644
--- a/gcc/testsuite/g++.dg/other/anon5.C
+++ b/gcc/testsuite/g++.dg/other/anon5.C
@@ -4,7 +4,7 @@
 // Ignore additional message on powerpc-ibm-aix
 // { dg-prune-output "obtain more information" } */
 // Ignore additional messages on Linux/x86 with PIE
-// { dg-prune-output "Bad value" } */
+// { dg-prune-output "\[Bb\]ad value" } */
 
 namespace {
   struct c
diff --git a/gcc/testsuite/g++.dg/other/vthunk1.C b/gcc/testsuite/g++.dg/other/thunk1.C
similarity index 100%
rename from gcc/testsuite/g++.dg/other/vthunk1.C
rename to gcc/testsuite/g++.dg/other/thunk1.C
diff --git a/gcc/testsuite/g++.dg/other/thunk2a.C b/gcc/testsuite/g++.dg/other/thunk2a.C
new file mode 100644
index 00000000000..8e5ebd4960d
--- /dev/null
+++ b/gcc/testsuite/g++.dg/other/thunk2a.C
@@ -0,0 +1,15 @@
+// { dg-do compile { target arm*-*-* } }
+// { dg-options "-mlong-calls -ffunction-sections" }
+
+class a {
+public:
+  virtual ~a();
+};
+
+class b : virtual a {};
+
+class c : b {
+  ~c();
+};
+
+c::~c() {}
diff --git a/gcc/testsuite/g++.dg/other/thunk2b.C b/gcc/testsuite/g++.dg/other/thunk2b.C
new file mode 100644
index 00000000000..c8f4570923d
--- /dev/null
+++ b/gcc/testsuite/g++.dg/other/thunk2b.C
@@ -0,0 +1,16 @@
+// { dg-do compile { target arm*-*-* } }
+// { dg-options "-mlong-calls -ffunction-sections" }
+// { dg-additional-options "-fPIC" { target fpic } }
+
+class a {
+public:
+  virtual ~a();
+};
+
+class b : virtual a {};
+
+class c : b {
+  ~c();
+};
+
+c::~c() {}
diff --git a/gcc/testsuite/g++.dg/parse/array-size2.C b/gcc/testsuite/g++.dg/parse/array-size2.C
index 3c833472d69..d0bc47fe746 100644
--- a/gcc/testsuite/g++.dg/parse/array-size2.C
+++ b/gcc/testsuite/g++.dg/parse/array-size2.C
@@ -15,6 +15,6 @@ void
 foo (void)
 {
   char g[(char *) &((struct S *) 0)->b - (char *) 0]; // { dg-error "constant" }
-  char h[(__SIZE_TYPE__) &((struct S *) 8)->b];	      // { dg-error "constant" "" { xfail *-*-* } }
+  char h[(__SIZE_TYPE__) &((struct S *) 8)->b];	      // { dg-error "constant" }
   bar (g, h);
 }
diff --git a/gcc/testsuite/g++.dg/parse/crash67.C b/gcc/testsuite/g++.dg/parse/crash67.C
index 51773ccef53..dbd828e2eee 100644
--- a/gcc/testsuite/g++.dg/parse/crash67.C
+++ b/gcc/testsuite/g++.dg/parse/crash67.C
@@ -2,4 +2,4 @@
 
 class x0;
 template <x1> x2() {  // { dg-error "declared|type" }
-x0 x3 = x3.  // { dg-error "expected" }
+x0 x3 = x3.  // { dg-error "expected|incomplete type" }
diff --git a/gcc/testsuite/g++.dg/pr58372.C b/gcc/testsuite/g++.dg/pr58372.C
new file mode 100644
index 00000000000..865f88e987d
--- /dev/null
+++ b/gcc/testsuite/g++.dg/pr58372.C
@@ -0,0 +1,10 @@
+/* PR target/58372 */
+/* { dg-do compile { target { i?86-*-* x86_64-*-* } } } */
+/* { dg-options "-O2" } */
+/* { dg-require-effective-target c++14 } */
+
+__attribute__ ((__target__ ("rdrnd")))
+void f (unsigned int *b) noexcept
+{
+  __builtin_ia32_rdrand32_step (b);
+}
diff --git a/gcc/testsuite/g++.dg/pr84279.C b/gcc/testsuite/g++.dg/pr84279.C
new file mode 100644
index 00000000000..a88d3fb8470
--- /dev/null
+++ b/gcc/testsuite/g++.dg/pr84279.C
@@ -0,0 +1,35 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "" { powerpc*-*-darwin* } } */
+/* { dg-require-effective-target powerpc_p8vector_ok } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
+/* { dg-options "-O3 -mcpu=power8 -g -fPIC -fvisibility=hidden -fstack-protector-strong" } */
+
+template <typename, typename T> struct E { T e; };
+struct J {
+  unsigned k, l;
+  J (unsigned x, unsigned y) : k(x), l(y) {}
+};
+typedef struct A {
+  J n, p;
+  A ();
+  A (J x, J y) : n(x), p(y) {}
+} *S;
+S t;
+struct B {
+  struct C {
+    S q, r;
+    int u, v;
+    bool m1 (S, A &);
+    J m2 () const;
+    J m3 () const;
+    A m4 () const;
+  };
+  typedef E<unsigned, S> D;
+  void m5 (D *);
+  void m6 (unsigned, A);
+};
+bool B::C::m1 (S, A &x) { bool o; x = m4 (); return o; }
+J B::C::m2 () const { unsigned g (u == 0); unsigned h (v); return J (g, h); }
+J B::C::m3 () const { unsigned g (q != t); unsigned h (r != t); return J (g, h); }
+A B::C::m4 () const { return A (m2 (), m3 ()); }
+void B::m5 (D *c) { unsigned x; C ar; A am; if (ar.m1 (c->e, am)) m6 (x, am); }
diff --git a/gcc/testsuite/g++.dg/pr85026.C b/gcc/testsuite/g++.dg/pr85026.C
new file mode 100644
index 00000000000..e1e3ccd2e35
--- /dev/null
+++ b/gcc/testsuite/g++.dg/pr85026.C
@@ -0,0 +1,61 @@
+/* PR target/85026.  */
+/* { dg-do assemble } */
+/* { dg-options "-O2 -std=gnu++11" } */
+
+template <class> class a;
+class b;
+struct c {
+  typedef a<b> &g;
+};
+template <typename d> struct e { typedef typename d::f iter; };
+class h {
+public:
+  void __attribute__((noreturn)) i();
+} ab;
+template <class> class a {
+public:
+  typedef b *f;
+  b &operator[](unsigned m) {
+    if (ac)
+      ab.i();
+    return ad[m];
+  }
+  f n() { return ad; }
+  f m_fn3();
+  b *ad;
+  unsigned ac;
+};
+class b {
+public:
+  short j;
+  short k;
+  signed l;
+} __attribute__((__packed__));
+void o(a<b> &m, b &p2, b &p) {
+  p2 = p = m[0];
+  if (bool at = false)
+    ;
+  else
+    for (c::g au(m);; at = true)
+      if (bool av = false)
+        ;
+      else
+        for (e<a<int>>::iter aw = au.n(), ax = au.m_fn3(); ax;
+             av ? (void)0 : (void)0)
+          if (bool ay = 0)
+            ;
+          else
+            for (b az = *aw; !ay; ay = true) {
+              if (p2.j)
+                p2.j = az.j;
+              else if (p.j)
+                p.j = az.j;
+              if (p2.k)
+                p2.k = az.k;
+              else if (az.k > p.k)
+                p.k = az.k;
+              if (az.l < p2.l)
+                if (az.l > p.l)
+                  p.l = az.l;
+            }
+}
diff --git a/gcc/testsuite/g++.dg/pr88998.C b/gcc/testsuite/g++.dg/pr88998.C
new file mode 100644
index 00000000000..d2ffac52acc
--- /dev/null
+++ b/gcc/testsuite/g++.dg/pr88998.C
@@ -0,0 +1,31 @@
+// PR target/88998
+// { dg-do run { target { { x86_64-*-* i?86-*-* } && sse2_runtime } } }
+// { dg-options "-O2 -msse2 -mfpmath=387" }
+// { dg-require-effective-target c++11 }
+
+#include <cassert>
+#include <unordered_map>
+#include <x86intrin.h>
+
+double
+__attribute__((noinline))
+prepare (int a, int b)
+{
+  __m128i is = _mm_setr_epi32 (a, b, 0, 0);
+  __m128d ds = _mm_cvtepi32_pd (is);
+  return ds[0] + ds[1];
+}
+
+int
+main (int, char **)
+{
+  double d = prepare (1, 2);
+
+  std::unordered_map < int, int >m;
+  m.insert ({0, 0});
+  m.insert ({1, 1});
+  assert (m.load_factor () <= m.max_load_factor ());
+
+  assert (d == 3.0);
+  return 0;
+}
diff --git a/gcc/testsuite/g++.dg/template/dependent-base3.C b/gcc/testsuite/g++.dg/template/dependent-base3.C
new file mode 100644
index 00000000000..e38b968e774
--- /dev/null
+++ b/gcc/testsuite/g++.dg/template/dependent-base3.C
@@ -0,0 +1,26 @@
+// PR c++/85060
+// { dg-do compile { target c++14 } }
+
+struct CA {
+  constexpr int foo() const { return 42; }
+};
+
+template <class T>
+struct CB : CA { };
+
+template <class T>
+struct CC : CB<T> {
+  constexpr int bar() const {
+    const int m = CA::foo();
+    return m;
+  }
+
+  constexpr int baz() const {
+    const T m = CA::foo();
+    return m;
+  }
+};
+
+constexpr CC<double> c;
+
+static_assert( c.bar() == 42, "" );
diff --git a/gcc/testsuite/g++.dg/template/incomplete11.C b/gcc/testsuite/g++.dg/template/incomplete11.C
new file mode 100644
index 00000000000..38c92e3d337
--- /dev/null
+++ b/gcc/testsuite/g++.dg/template/incomplete11.C
@@ -0,0 +1,10 @@
+// PR c++/84082
+// { dg-do compile }
+// { dg-options "" }
+
+struct A;
+
+template<typename> void foo()
+{
+  static int a[A().operator=(A())];	// { dg-error "invalid use of incomplete type 'struct A'" }
+}
diff --git a/gcc/testsuite/g++.dg/template/nontype-fn1.C b/gcc/testsuite/g++.dg/template/nontype-fn1.C
new file mode 100644
index 00000000000..12d29a91a54
--- /dev/null
+++ b/gcc/testsuite/g++.dg/template/nontype-fn1.C
@@ -0,0 +1,11 @@
+// PR c++/82664
+
+template < typename > struct target_disambiguator;
+template < typename R, typename A1 > struct target_disambiguator< R(A1) > {
+  typedef A1 type;
+  template < R (&)() > struct layout;
+};
+
+int main() {
+  typedef target_disambiguator< void (int) > ::type target_type ;
+}
diff --git a/gcc/testsuite/g++.dg/torture/pr44295.C b/gcc/testsuite/g++.dg/torture/pr44295.C
index 8169bb0a873..3db249b4156 100644
--- a/gcc/testsuite/g++.dg/torture/pr44295.C
+++ b/gcc/testsuite/g++.dg/torture/pr44295.C
@@ -1,4 +1,6 @@
 /* { dg-do compile } */
+/* { dg-skip-if "no pthread_barrier" { *-*-darwin* } } */
+
 extern "C" {
   typedef __SIZE_TYPE__ size_t;
   typedef struct   {
diff --git a/gcc/testsuite/g++.dg/torture/pr77745-2.C b/gcc/testsuite/g++.dg/torture/pr77745-2.C
new file mode 100644
index 00000000000..7861089a817
--- /dev/null
+++ b/gcc/testsuite/g++.dg/torture/pr77745-2.C
@@ -0,0 +1,4 @@
+// { dg-do run }
+
+#define NOINLINE __attribute__((noinline))
+#include "pr77745.C"
diff --git a/gcc/testsuite/g++.dg/torture/pr77745.C b/gcc/testsuite/g++.dg/torture/pr77745.C
index 59d86b5c501..6285bc14a43 100644
--- a/gcc/testsuite/g++.dg/torture/pr77745.C
+++ b/gcc/testsuite/g++.dg/torture/pr77745.C
@@ -1,8 +1,12 @@
 // { dg-do run }
 
+#ifndef NOINLINE
+#define NOINLINE /* */
+#endif
+
 inline void* operator new(__SIZE_TYPE__, void* __p) noexcept { return __p; }
 
-long foo(char *c1, char *c2)
+long NOINLINE foo(char *c1, char *c2)
 {
   long *p1 = new (c1) long;
   *p1 = 100;
diff --git a/gcc/testsuite/g++.dg/torture/pr83659.C b/gcc/testsuite/g++.dg/torture/pr83659.C
new file mode 100644
index 00000000000..bdcdca230ec
--- /dev/null
+++ b/gcc/testsuite/g++.dg/torture/pr83659.C
@@ -0,0 +1,18 @@
+// PR c++/83659
+// { dg-do compile }
+
+typedef int V __attribute__ ((__vector_size__ (16)));
+V a;
+V b[2];
+
+int
+foo ()
+{
+  return reinterpret_cast <int *> (&a)[-1] += 1;
+}
+
+int
+bar ()
+{
+  return reinterpret_cast <int *> (&a[1])[-1];
+}
diff --git a/gcc/testsuite/g++.dg/torture/pr84190.C b/gcc/testsuite/g++.dg/torture/pr84190.C
new file mode 100644
index 00000000000..a7bab944365
--- /dev/null
+++ b/gcc/testsuite/g++.dg/torture/pr84190.C
@@ -0,0 +1,20 @@
+// { dg-do compile }
+// For slim LTO there's no optimized dump
+// { dg-skip-if "" { *-*-* } { "-flto" } { "" } }
+// { dg-additional-options "-fdump-tree-optimized" }
+
+typedef double T;
+static int equalfn (volatile T* x, volatile T* y);
+T gx, gy;
+int main ()
+{
+  T x = gx, y = gy;
+  return equalfn (&x, &y);
+}
+static int equalfn (volatile T* x, volatile T* y)
+{
+  return (*x == *y);
+}
+
+// There should be exactly two volatile accesses (ignoring clobbers).
+// { dg-final { scan-tree-dump-times " ={v} \[^\{\]" 2 "optimized" } }
diff --git a/gcc/testsuite/g++.dg/torture/pr84233.C b/gcc/testsuite/g++.dg/torture/pr84233.C
new file mode 100644
index 00000000000..d45a830bf63
--- /dev/null
+++ b/gcc/testsuite/g++.dg/torture/pr84233.C
@@ -0,0 +1,25 @@
+// { dg-do compile }
+// { dg-additional-options "-w" }
+
+void a(const char *, int, const char *, const char *);
+template <typename b> void c(b);
+struct d {
+    long e;
+    template <typename> union f;
+    template <typename h> union f<h *> {
+	f(h *i) : j(i) {}
+	h *j;
+	long bits;
+    };
+    static int k(volatile long &i) { return *(int *)f<volatile long *>(&i).bits; }
+    typedef long g;
+    operator g() volatile {
+	int l = k(e);
+	c(l);
+    }
+};
+struct : d {
+	 } m, n;
+bool o;
+void p() { (o ? m : n) ? (void)0 : a("", 5, "", ""); }
+
diff --git a/gcc/testsuite/g++.dg/torture/pr84961-1.C b/gcc/testsuite/g++.dg/torture/pr84961-1.C
new file mode 100644
index 00000000000..6a72ad5134f
--- /dev/null
+++ b/gcc/testsuite/g++.dg/torture/pr84961-1.C
@@ -0,0 +1,24 @@
+// PR c++/84961
+// { dg-do compile }
+
+short a;
+volatile int b;
+int c, d;
+
+void
+foo ()
+{
+  asm volatile ("" : "=r" (b = a));
+}
+
+void
+bar ()
+{
+  asm volatile ("" : "=r" (++c, ++d, b = a));
+}
+
+void
+baz ()
+{
+  asm volatile ("" : "=r" (--b));
+}
diff --git a/gcc/testsuite/g++.dg/torture/pr84961-2.C b/gcc/testsuite/g++.dg/torture/pr84961-2.C
new file mode 100644
index 00000000000..0909eedb7f9
--- /dev/null
+++ b/gcc/testsuite/g++.dg/torture/pr84961-2.C
@@ -0,0 +1,24 @@
+// PR c++/84961
+// { dg-do compile }
+
+short a;
+volatile int b;
+int c, d;
+
+void
+foo ()
+{
+  asm volatile ("" : : "m" (b = a));
+}
+
+void
+bar ()
+{
+  asm volatile ("" : : "m" (++c, ++d, b = a));
+}
+
+void
+baz ()
+{
+  asm volatile ("" : : "m" (--b));
+}
diff --git a/gcc/testsuite/g++.dg/torture/pr85496.C b/gcc/testsuite/g++.dg/torture/pr85496.C
new file mode 100644
index 00000000000..3f504a37791
--- /dev/null
+++ b/gcc/testsuite/g++.dg/torture/pr85496.C
@@ -0,0 +1,18 @@
+// PR middle-end/85496
+// Reported by Marek Polacek <mpolacek@gcc.gnu.org>
+
+template <typename> class complex;
+template <typename _Tp> complex<_Tp> operator*(complex<_Tp>, complex<_Tp>);
+template <> struct complex<float> { _Complex float _M_value; };
+class A {
+  complex<float> _f0, _f1;
+
+public:
+  complex<float> &m_fn1() { return _f1; }
+};
+complex<float> a;
+void cos() {
+  A b;
+  complex<float> c;
+  b.m_fn1() = c * a;
+}
diff --git a/gcc/testsuite/g++.dg/torture/pr86763.C b/gcc/testsuite/g++.dg/torture/pr86763.C
new file mode 100644
index 00000000000..8455ac9ce12
--- /dev/null
+++ b/gcc/testsuite/g++.dg/torture/pr86763.C
@@ -0,0 +1,37 @@
+// { dg-do run { target { *-*-linux* } } }
+// { dg-additional-options "-fschedule-insns2 -fstrict-aliasing" }
+// { dg-additional-options "-lrt" }
+
+#include <cstdint>
+#include <cassert>
+#include <time.h>
+struct ID {
+  uint64_t value;
+};
+uint64_t value(ID id) { return id.value; }
+uint64_t gen { 1000 };
+struct Msg {
+  uint64_t time;
+  ID id;
+};
+struct V {
+  V() { }
+  V(Msg const & msg) : msg(msg) { }
+  Msg & get() { return msg; }
+  Msg msg;
+  char pad[237 - sizeof(Msg)];
+};
+struct T : V { using V::V; };
+Msg init_msg() {
+  Msg msg;
+  timespec t;
+  clock_gettime(CLOCK_REALTIME, &t);
+  msg.time = t.tv_sec + t.tv_nsec;
+  msg.id.value = ++gen;
+  return msg;
+}
+int main() {
+  T t;
+  t = init_msg();
+  assert(value(t.get().id) == 1001);
+}
diff --git a/gcc/testsuite/g++.dg/torture/pr87014.C b/gcc/testsuite/g++.dg/torture/pr87014.C
new file mode 100644
index 00000000000..614954ef464
--- /dev/null
+++ b/gcc/testsuite/g++.dg/torture/pr87014.C
@@ -0,0 +1,37 @@
+// { dg-do run }
+
+void
+fillstack ()
+{
+  long long foo[] =
+    {
+      -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+    };
+}
+
+void
+f (long long=-1,long long=-1,long long=-1,long long=-1,
+   long long=-1,long long=-1,long long arg7_on_stack=-1)
+{
+  throw 0;
+}
+
+void
+g()
+{
+  try
+    {
+      f ();
+    }
+  catch (int)
+    {
+    }
+}
+
+int
+main()
+{
+  fillstack ();
+  g ();
+  return 0;
+}
diff --git a/gcc/testsuite/g++.dg/tree-ssa/volatile1.C b/gcc/testsuite/g++.dg/tree-ssa/volatile1.C
new file mode 100644
index 00000000000..00f04a07d84
--- /dev/null
+++ b/gcc/testsuite/g++.dg/tree-ssa/volatile1.C
@@ -0,0 +1,28 @@
+// PR c++/84151
+// { dg-additional-options "-fdump-tree-gimple" }
+// { dg-final { scan-tree-dump-not {\*this} "gimple" } }
+
+struct A {
+  static int& bar(int& a) {
+    return a;
+  }
+  static int i;
+
+  int foo() volatile {
+    int v = c;
+    return i + bar(v);
+  }
+
+  int c;
+};
+
+int A::i = 0;
+
+A a;
+
+int main() {
+  a.c = 2;
+  a.foo();
+
+  return 0;
+}
diff --git a/gcc/testsuite/g++.dg/tree-ssa/volatile2.C b/gcc/testsuite/g++.dg/tree-ssa/volatile2.C
new file mode 100644
index 00000000000..bec60442477
--- /dev/null
+++ b/gcc/testsuite/g++.dg/tree-ssa/volatile2.C
@@ -0,0 +1,20 @@
+// PR c++/84686
+// { dg-additional-options -fdump-tree-gimple }
+// { dg-final { scan-tree-dump-times "= i" 10 "gimple" } }
+
+volatile int i;
+
+int main()
+{
+  i; //evaluated (a load is performed)
+  (i); //unevaluated => the load shall be performed
+
+  (void)i; //evaluated (a load is performed)
+  (void)(i); //unevaluated => the load shall be performed
+
+  (void)i; //evaluated (a load is performed)
+  (void)(i); //unevaluated => the load shall be performed
+
+  (i,i); // the two subexpression are evaluated
+  ((i),(i)); // no evaluation, => two loads shall happen
+}
diff --git a/gcc/testsuite/g++.dg/ubsan/pr83987-2.C b/gcc/testsuite/g++.dg/ubsan/pr83987-2.C
new file mode 100644
index 00000000000..a70b7b2850b
--- /dev/null
+++ b/gcc/testsuite/g++.dg/ubsan/pr83987-2.C
@@ -0,0 +1,24 @@
+// PR sanitizer/83987
+// { dg-do compile { target fopenmp } }
+// { dg-options "-fopenmp -fsanitize=vptr" }
+
+struct A
+{
+  int i;
+};
+
+struct B : virtual A
+{
+  void foo();
+};
+
+void B::foo()
+{
+#pragma omp parallel
+  {
+  #pragma omp sections lastprivate (i)
+    {
+      i = 0;
+    }
+  }
+}
diff --git a/gcc/testsuite/g++.dg/ubsan/pr83987.C b/gcc/testsuite/g++.dg/ubsan/pr83987.C
new file mode 100644
index 00000000000..7ba7952b293
--- /dev/null
+++ b/gcc/testsuite/g++.dg/ubsan/pr83987.C
@@ -0,0 +1,15 @@
+// PR sanitizer/83987
+// { dg-do compile { target fopenmp } }
+// { dg-options "-fopenmp -fsanitize=vptr -O0" }
+
+struct A { int i; };
+struct B : virtual A { void foo (); };
+
+void
+B::foo ()
+{
+#pragma omp sections lastprivate (i)
+  {
+    i = 0;
+  }
+}
diff --git a/gcc/testsuite/g++.dg/vec-init-1.C b/gcc/testsuite/g++.dg/vec-init-1.C
new file mode 100644
index 00000000000..f35d39c35ed
--- /dev/null
+++ b/gcc/testsuite/g++.dg/vec-init-1.C
@@ -0,0 +1,26 @@
+/* On S/390 this ends up calling the vec_init RTL expander with a
+   parallel of two symbol_refs.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O3 -fPIC" } */
+
+
+struct test
+{
+    struct base
+    {
+       int key;
+    };
+    struct derived : public base
+    {
+       int key;
+    };
+
+    derived core;
+    derived &dRef;
+    base &bRef;
+
+    test() : dRef (core), bRef (core) {}
+};
+
+test test;
diff --git a/gcc/testsuite/g++.dg/vect/pr84556.cc b/gcc/testsuite/g++.dg/vect/pr84556.cc
new file mode 100644
index 00000000000..e0655536f7a
--- /dev/null
+++ b/gcc/testsuite/g++.dg/vect/pr84556.cc
@@ -0,0 +1,21 @@
+// PR c++/84556
+// { dg-do run { target c++11 } }
+// { dg-options "-O2 -fopenmp-simd" }
+// { dg-additional-options "-mavx" { target avx_runtime } }
+
+int
+main ()
+{
+  int y[8] = { 1, 2, 3, 4, 5, 6, 7, 8 };
+  auto x = [&y] ()
+  {
+    #pragma omp simd
+    for (int i = 0; i < 8; ++i)
+      y[i]++;
+  };
+  x ();
+  x ();
+  for (int i = 0; i < 8; ++i)
+    if (y[i] != i + 3)
+      __builtin_abort ();
+}
diff --git a/gcc/testsuite/g++.dg/warn/Wformat-2.C b/gcc/testsuite/g++.dg/warn/Wformat-2.C
new file mode 100644
index 00000000000..ff8b54b4899
--- /dev/null
+++ b/gcc/testsuite/g++.dg/warn/Wformat-2.C
@@ -0,0 +1,17 @@
+// PR c++/84076
+// { dg-do compile }
+// { dg-options "-Wformat" }
+
+struct S { ~S (); };
+struct T { T (); T (const T &); };
+
+void
+foo ()
+{
+  S s;
+  T t;
+  __builtin_printf ("%s\n", s);	// { dg-warning "format '%s' expects argument of type 'char\\*', but argument 2 has type 'S'" }
+  __builtin_printf ("%s\n", t);	// { dg-warning "format '%s' expects argument of type 'char\\*', but argument 2 has type 'T'" }
+  __builtin_printf ("%s\n", &s);// { dg-warning "format '%s' expects argument of type 'char\\*', but argument 2 has type 'S\\*'" }
+  __builtin_printf ("%s\n", &t);// { dg-warning "format '%s' expects argument of type 'char\\*', but argument 2 has type 'T\\*'" }
+}
diff --git a/gcc/testsuite/g++.dg/warn/Wnonnull4.C b/gcc/testsuite/g++.dg/warn/Wnonnull4.C
new file mode 100644
index 00000000000..d07a4452ddb
--- /dev/null
+++ b/gcc/testsuite/g++.dg/warn/Wnonnull4.C
@@ -0,0 +1,21 @@
+// PR c++/86210
+// { dg-do compile }
+// { dg-options "-Wnonnull" }
+
+void *declared_not_defined (void *p) __attribute__((nonnull));
+
+inline void *declared_and_defined (void *p) __attribute__((nonnull));
+
+int
+main ()
+{
+  int *const p = 0;
+  declared_not_defined (p);	// { dg-warning "null argument where non-null required" }
+  declared_and_defined (p);	// { dg-warning "null argument where non-null required" }
+}
+
+void *
+declared_and_defined (void *p)
+{
+  return p;
+}
diff --git a/gcc/testsuite/g++.dg/warn/Wunused-function4.C b/gcc/testsuite/g++.dg/warn/Wunused-function4.C
new file mode 100644
index 00000000000..00d5d70fc90
--- /dev/null
+++ b/gcc/testsuite/g++.dg/warn/Wunused-function4.C
@@ -0,0 +1,21 @@
+// PR c++/80598
+// { dg-do compile }
+// { dg-options "-Wunused-function" }
+
+static void
+foo ()		// { dg-bogus "defined but not used" }
+{
+}
+
+static void
+bar ()		// { dg-warning "defined but not used" }
+{
+}
+
+template <class T>
+int
+baz (T x)
+{
+  foo ();
+  return 0;
+}
diff --git a/gcc/testsuite/g++.dg/warn/Wunused-var-33.C b/gcc/testsuite/g++.dg/warn/Wunused-var-33.C
new file mode 100644
index 00000000000..5f10d781082
--- /dev/null
+++ b/gcc/testsuite/g++.dg/warn/Wunused-var-33.C
@@ -0,0 +1,37 @@
+// PR c++/85952
+// { dg-do compile { target c++11 } }
+// { dg-options "-Wunused-but-set-variable" }
+
+int
+foo ()
+{
+  int a[2] = {1, 2};	// { dg-bogus "set but not used" } */
+  auto [x, y] = a;	// { dg-warning "decomposition declaration only available with" "" { target c++14_down } }
+  return x + y;
+}
+
+struct S { int d, e; };
+
+int
+bar ()
+{
+  S a = {1, 2};
+  auto [x, y] = a;	// { dg-warning "decomposition declaration only available with" "" { target c++14_down } }
+  return x + y;
+}
+
+int
+baz ()
+{
+  S a = {1, 2};
+  auto & [x, y] = a;	// { dg-warning "decomposition declaration only available with" "" { target c++14_down } }
+  return x + y;
+}
+
+int
+qux ()
+{
+  int a[2] = {1, 2};
+  auto & [x, y] = a;	// { dg-warning "decomposition declaration only available with" "" { target c++14_down } }
+  return x + y;
+}
diff --git a/gcc/testsuite/g++.dg/warn/deprecated-13.C b/gcc/testsuite/g++.dg/warn/deprecated-13.C
new file mode 100644
index 00000000000..ef05b95f026
--- /dev/null
+++ b/gcc/testsuite/g++.dg/warn/deprecated-13.C
@@ -0,0 +1,44 @@
+// PR c++/84222
+// { dg-do compile }
+
+struct __attribute__((deprecated)) C {		// { dg-message "declared here" }
+  C () {}
+  C (const C &);				// { dg-bogus "'C' is deprecated" }
+  C (const C &x, const C &y) { C z = x; }	// { dg-bogus "'C' is deprecated" }
+  void foo (const C &x, const C &y);		// { dg-bogus "'C' is deprecated" }
+};
+
+void
+C::foo (const C &x, const C &y)			// { dg-bogus "'C' is deprecated" }
+{
+  C z = x;					// { dg-bogus "'C' is deprecated" }
+}
+
+void
+bar (const C &x, const C &y)			// { dg-warning "'C' is deprecated" }
+{
+  C z = x;					// { dg-warning "'C' is deprecated" }
+}
+
+template <int N>
+struct __attribute__((deprecated)) D {		// { dg-message "declared here" }
+  D () {}
+  D (const D &);				// { dg-bogus "is deprecated" }
+  D (const D &x, const D &y) { D z = x; }	// { dg-bogus "is deprecated" }
+  void foo (const D &x, const D &y);		// { dg-bogus "is deprecated" }
+};
+
+template <int N>
+void
+D<N>::foo					// { dg-bogus "is deprecated" "" { xfail *-*-* } }
+(const D &x, const D &y)			// { dg-bogus "is deprecated" }
+{
+  D z = x;					// { dg-bogus "is deprecated" }
+}
+
+template <int N>
+void
+bar (const D<N> &x, const D<N> &y)		// { dg-warning "is deprecated" }
+{
+  D<N> z = x;					// { dg-warning "is deprecated" }
+}
diff --git a/gcc/testsuite/g++.dg/warn/deprecated-6.C b/gcc/testsuite/g++.dg/warn/deprecated-6.C
index ad9eb3d4820..682e9b226ca 100644
--- a/gcc/testsuite/g++.dg/warn/deprecated-6.C
+++ b/gcc/testsuite/g++.dg/warn/deprecated-6.C
@@ -98,7 +98,7 @@ T *p3;				// { dg-warning "'T' is deprecated: Please avoid T" }
 
 inline void T::member1(int) {}
 
-int T::member3(T *p)		// { dg-warning "'T' is deprecated: Please avoid T" }
+int T::member3(T *p)		// { dg-bogus "'T' is deprecated: Please avoid T" }
 {
   p->member1(1);			/* { dg-warning "'void T::member1\\(int\\)' is deprecated: Please avoid member1" "" } */
   (*p).member1(2);			/* { dg-warning "'void T::member1\\(int\\)' is deprecated: Please avoid member1" "" } */
diff --git a/gcc/testsuite/g++.dg/warn/deprecated.C b/gcc/testsuite/g++.dg/warn/deprecated.C
index a5b2aee03e3..0420a6afd22 100644
--- a/gcc/testsuite/g++.dg/warn/deprecated.C
+++ b/gcc/testsuite/g++.dg/warn/deprecated.C
@@ -102,7 +102,7 @@ T *p3;				// { dg-warning "'T' is deprecated" }
 
 inline void T::member1(int) {}
 
-int T::member3(T *p)		// { dg-warning "'T' is deprecated" }
+int T::member3(T *p)		// { dg-bogus "'T' is deprecated" }
 {
   p->member1(1);			/* { dg-warning "'void T::member1\\(int\\)' is deprecated" "" } */
   (*p).member1(2);			/* { dg-warning "'void T::member1\\(int\\)' is deprecated" "" } */
@@ -113,5 +113,3 @@ int T::member3(T *p)		// { dg-warning "'T' is deprecated" }
   return f1(); 				/* { dg-warning "'INT1 f1\\(\\)' is deprecated" "" } */
 }
 #endif
-
-
diff --git a/gcc/testsuite/gcc.c-torture/compile/pr82096.c b/gcc/testsuite/gcc.c-torture/compile/pr82096.c
new file mode 100644
index 00000000000..d144b70585f
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/pr82096.c
@@ -0,0 +1,11 @@
+/* { dg-require-effective-target arm_arch_v5t_ok { target arm*-*-* } } */
+/* { dg-skip-if "Do not combine float-abi values" { arm*-*-* } { "-mfloat-abi=*" } { "-mfloat-abi=soft" } } */
+/* { dg-additional-options "-march=armv5t -mthumb -mfloat-abi=soft" { target arm*-*-* } } */
+
+static long long AL[24];
+
+int
+check_ok (void)
+{
+  return (__sync_bool_compare_and_swap (AL+1, 0x200000003ll, 0x1234567890ll));
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/pr84425.c b/gcc/testsuite/gcc.c-torture/compile/pr84425.c
new file mode 100644
index 00000000000..5d3d325aa23
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/pr84425.c
@@ -0,0 +1,17 @@
+/* PR ipa/84425 */
+
+void bar (int);
+
+void
+foo (int x)
+{
+  if (x < 5)
+    bar (x);
+}
+
+__attribute__((optimize(0))) void
+bar (int x)
+{
+  if (x > 10)
+    foo (x);
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/pr84860.c b/gcc/testsuite/gcc.c-torture/compile/pr84860.c
new file mode 100644
index 00000000000..002737c71b5
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/pr84860.c
@@ -0,0 +1,11 @@
+/* PR target/84860 */
+
+void
+foo (int x, int y)
+{
+  while (x < 1)
+    {
+      x = y;
+      y = ((float)1 / 0) ? 2 : 0;
+    }
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/pr85945.c b/gcc/testsuite/gcc.c-torture/compile/pr85945.c
new file mode 100644
index 00000000000..93b2023f25c
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/pr85945.c
@@ -0,0 +1,16 @@
+/* PR target/85945 */
+
+typedef float V __attribute__((vector_size(16)));
+union U { V v; float f[4]; };
+int f;
+float g[4];
+
+void
+foo (void)
+{
+  V d;
+  union U i;
+  i.v = d;
+  for (f = 0; f < 4; f++)
+    g[f] = i.f[f];
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/pr87473.c b/gcc/testsuite/gcc.c-torture/compile/pr87473.c
new file mode 100644
index 00000000000..0ca5e302b97
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/pr87473.c
@@ -0,0 +1,19 @@
+/* PR87473: SLSR ICE on hidden basis with |increment| > 1.  */
+/* { dg-additional-options "-fno-tree-ch" } */
+
+void
+t6 (int qz, int wh)
+{
+  int jl = wh;
+
+  while (1.0 / 0 < 1)
+    {
+      qz = wh * (wh + 2);
+
+      while (wh < 1)
+        jl = 0;
+    }
+
+  while (qz < 1)
+    qz = jl * wh;
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/20180131-1.c b/gcc/testsuite/gcc.c-torture/execute/20180131-1.c
new file mode 100644
index 00000000000..76e264bf967
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/20180131-1.c
@@ -0,0 +1,28 @@
+/* PR rtl-optimization/84071 */
+/* Reported by Wilco <wilco@gcc.gnu.org> */
+
+extern void abort (void);
+
+typedef union 
+{
+  signed short ss;
+  unsigned short us;
+  int x;
+} U;
+
+int f(int x, int y, int z, int a, U u) __attribute__((noclone, noinline));
+
+int f(int x, int y, int z, int a, U u)
+{
+  return (u.ss <= 0) + u.us;
+}
+
+int main (void)
+{
+  U u = { .ss = -1 };
+
+  if (f (0, 0, 0, 0, u) != (1 << sizeof (short) * 8))
+    abort ();
+
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/20180226-1.c b/gcc/testsuite/gcc.c-torture/execute/20180226-1.c
new file mode 100644
index 00000000000..e2b678c8fc7
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/20180226-1.c
@@ -0,0 +1,31 @@
+/* PR rtl-optimization/83496 */
+/* Reported by Hauke Mehrtens <gcc@hauke-m.de> */
+
+extern void abort (void);
+
+typedef unsigned long mp_digit;
+
+typedef struct { int used, alloc, sign; mp_digit *dp; } mp_int;
+
+int mytest(mp_int *a, mp_digit b) __attribute__((noclone, noinline));
+
+int mytest(mp_int *a, mp_digit b)
+{
+  if (a->sign == 1)
+    return -1;
+  if (a->used > 1)
+    return 1;
+  if (a->dp[0] > b)
+    return 1;
+  if (a->dp[0] < b)
+    return -1;
+  return 0;
+}
+
+int main (void)
+{
+  mp_int i = { 2, 0, -1 };
+  if (mytest (&i, 0) != 1)
+    abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/20181120-1.c b/gcc/testsuite/gcc.c-torture/execute/20181120-1.c
new file mode 100644
index 00000000000..da3d4552a2f
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/20181120-1.c
@@ -0,0 +1,28 @@
+/* PR rtl-optimization/85925 */
+/* { dg-require-effective-target int32plus } */
+/* Testcase by <sudi@gcc.gnu.org> */
+
+int a, c, d;
+volatile int b;
+int *e = &d;
+
+union U1 {
+  unsigned f0;
+  unsigned f1 : 15;
+};
+volatile union U1 u = { 0x4030201 };
+
+int main (void)
+{
+  for (c = 0; c <= 1; c++) {
+    union U1 f = {0x4030201};
+    if (c == 1)
+      b;
+    *e = f.f1;
+  }
+
+  if (d != u.f1)
+    __builtin_abort ();
+
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/pr82210.c b/gcc/testsuite/gcc.c-torture/execute/pr82210.c
new file mode 100644
index 00000000000..48fb715570a
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/pr82210.c
@@ -0,0 +1,26 @@
+/* PR c/82210 */
+
+void
+foo (int size)
+{
+  int i;
+  struct S {
+    __attribute__((aligned (16))) struct T { short c; } a[size];
+    int b[size];
+  } s;
+
+  for (i = 0; i < size; i++)
+    s.a[i].c = 0x1234;
+  for (i = 0; i < size; i++)
+    s.b[i] = 0;
+  for (i = 0; i < size; i++)
+    if (s.a[i].c != 0x1234 || s.b[i] != 0)
+      __builtin_abort ();
+}
+
+int
+main ()
+{
+  foo (15);
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/pr84524.c b/gcc/testsuite/gcc.c-torture/execute/pr84524.c
new file mode 100644
index 00000000000..ba20ad87a5a
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/pr84524.c
@@ -0,0 +1,41 @@
+/* PR target/84524 */
+
+__attribute__((noinline,noclone)) void
+foo (unsigned short *x)
+{
+  unsigned short i, v;
+  unsigned char j;
+  for (i = 0; i < 256; i++)
+    {
+      v = i << 8;
+      for (j = 0; j < 8; j++)
+	if (v & 0x8000)
+	  v = (v << 1) ^ 0x1021;
+	else
+	  v = v << 1;
+      x[i] = v;
+    }
+}
+
+int
+main ()
+{
+  unsigned short a[256];
+
+  foo (a);
+  for (int i = 0; i < 256; i++)
+    {
+      unsigned short v = i << 8;
+      for (int j = 0; j < 8; j++)
+	{
+	  asm volatile ("" : "+r" (v));
+	  if (v & 0x8000)
+	    v = (v << 1) ^ 0x1021;
+	  else
+	    v = v << 1;
+	}
+      if (a[i] != v)
+	__builtin_abort ();
+    }
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/pr84748.c b/gcc/testsuite/gcc.c-torture/execute/pr84748.c
new file mode 100644
index 00000000000..9572ab285c6
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/pr84748.c
@@ -0,0 +1,34 @@
+/* { dg-require-effective-target int128 } */
+
+typedef unsigned __int128 u128;
+
+int a, c, d;
+u128 b;
+
+unsigned long long g0, g1;
+
+void
+store (unsigned long long a0, unsigned long long a1)
+{
+  g0 = a0;
+  g1 = a1;
+}
+
+void
+foo (void)
+{
+  b += a;
+  c = d != 84347;
+  b /= c;
+  u128 x = b;
+  store (x >> 0, x >> 64);
+}
+
+int
+main (void)
+{
+  foo ();
+  if (g0 != 0 || g1 != 0)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/pr85095.c b/gcc/testsuite/gcc.c-torture/execute/pr85095.c
new file mode 100644
index 00000000000..abcb1785a16
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/pr85095.c
@@ -0,0 +1,52 @@
+/* PR target/85095 */
+
+__attribute__((noinline, noclone)) unsigned long
+f1 (unsigned long a, unsigned long b)
+{
+  unsigned long i = __builtin_add_overflow (a, b, &a);
+  return a + i;
+}
+
+__attribute__((noinline, noclone)) unsigned long
+f2 (unsigned long a, unsigned long b)
+{
+  unsigned long i = __builtin_add_overflow (a, b, &a);
+  return a - i;
+}
+
+__attribute__((noinline, noclone)) unsigned long
+f3 (unsigned int a, unsigned int b)
+{
+  unsigned int i = __builtin_add_overflow (a, b, &a);
+  return a + i;
+}
+
+__attribute__((noinline, noclone)) unsigned long
+f4 (unsigned int a, unsigned int b)
+{
+  unsigned int i = __builtin_add_overflow (a, b, &a);
+  return a - i;
+}
+
+int
+main ()
+{
+  if (f1 (16UL, -18UL) != -2UL
+      || f1 (16UL, -17UL) != -1UL
+      || f1 (16UL, -16UL) != 1UL
+      || f1 (16UL, -15UL) != 2UL
+      || f2 (24UL, -26UL) != -2UL
+      || f2 (24UL, -25UL) != -1UL
+      || f2 (24UL, -24UL) != -1UL
+      || f2 (24UL, -23UL) != 0UL
+      || f3 (32U, -34U) != -2U
+      || f3 (32U, -33U) != -1U
+      || f3 (32U, -32U) != 1U
+      || f3 (32U, -31U) != 2U
+      || f4 (35U, -37U) != -2U
+      || f4 (35U, -36U) != -1U
+      || f4 (35U, -35U) != -1U
+      || f4 (35U, -34U) != 0U)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/pr85529-1.c b/gcc/testsuite/gcc.c-torture/execute/pr85529-1.c
new file mode 100644
index 00000000000..83d5cdd997e
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/pr85529-1.c
@@ -0,0 +1,28 @@
+/* PR tree-optimization/85529 */
+
+struct S { int a; };
+
+int b, c = 1, d, e, f;
+static int g;
+volatile struct S s;
+
+signed char
+foo (signed char i, int j)
+{
+  return i < 0 ? i : i << j;
+}
+
+int
+main ()
+{
+  signed char k = -83;
+  if (!d)
+    goto L;
+  k = e || f;
+L:
+  for (; b < 1; b++)
+    s.a != (k < foo (k, 2) && (c = k = g));
+  if (c != 1)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/pr85529-2.c b/gcc/testsuite/gcc.c-torture/execute/pr85529-2.c
new file mode 100644
index 00000000000..727280de061
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/pr85529-2.c
@@ -0,0 +1,25 @@
+/* PR tree-optimization/85529 */
+
+__attribute__((noinline, noclone)) int
+foo (int x)
+{
+  x &= 63;
+  x -= 50;
+  x |= 1;
+  if (x < 0)
+    return 1;
+  int y = x >> 2;
+  if (x >= y)
+    return 1;
+  return 0;
+}
+
+int
+main ()
+{
+  int i;
+  for (i = 0; i < 63; i++)
+    if (foo (i) != 1)
+      __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/pr86231.c b/gcc/testsuite/gcc.c-torture/execute/pr86231.c
new file mode 100644
index 00000000000..1eafe794dd3
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/pr86231.c
@@ -0,0 +1,30 @@
+/* PR tree-optimization/86231 */
+
+#define ONE ((void *) 1)
+#define TWO ((void *) 2)
+
+__attribute__((noinline, noclone)) int
+foo (void *p, int x)
+{
+  if (p == ONE) return 0;
+  if (!p)
+    p = x ? TWO : ONE;
+  return p == ONE ? 0 : 1;
+}
+
+int v[8];
+
+int
+main ()
+{
+  if (foo ((void *) 0, 0) != 0
+      || foo ((void *) 0, 1) != 1
+      || foo (ONE, 0) != 0
+      || foo (ONE, 1) != 0
+      || foo (TWO, 0) != 1
+      || foo (TWO, 1) != 1
+      || foo (&v[7], 0) != 1
+      || foo (&v[7], 1) != 1)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/pr87623.c b/gcc/testsuite/gcc.c-torture/execute/pr87623.c
new file mode 100644
index 00000000000..54d8b5e4571
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/pr87623.c
@@ -0,0 +1,34 @@
+/* PR middle-end/87623 */
+/* Testcase by George Thopas <george.thopas@gmail.com> */
+
+struct be {
+    unsigned short pad[1];
+    unsigned char  a;
+    unsigned char  b;
+} __attribute__((scalar_storage_order("big-endian")));
+
+typedef struct be t_be;
+
+struct le {
+    unsigned short pad[3];
+    unsigned char  a;
+    unsigned char  b;
+};
+
+typedef struct le t_le;
+
+int a_or_b_different(t_be *x,t_le *y)
+{
+   return (x->a != y->a) || (x->b != y->b);
+}
+
+int main (void)
+{
+   t_be x = { .a=1, .b=2  };
+   t_le y = { .a=1, .b=2  };
+  
+   if (a_or_b_different(&x,&y))
+       __builtin_abort ();
+
+   return 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/pr88739.c b/gcc/testsuite/gcc.c-torture/execute/pr88739.c
new file mode 100644
index 00000000000..d4b32fbfc2d
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/pr88739.c
@@ -0,0 +1,59 @@
+/* PR tree-optimization/88739 */
+#if __SIZEOF_SHORT__ == 2 &&  __SIZEOF_INT__ == 4 && __CHAR_BIT__ == 8
+struct A
+{
+  unsigned int a, b, c;
+  unsigned int d : 30;
+  unsigned int e : 2;
+};
+
+union U
+{
+  struct A f;
+  unsigned int g[4];
+  unsigned short h[8];
+  unsigned char i[16];
+};
+volatile union U v = { .f.d = 0x4089 };
+
+__attribute__((noipa)) void
+bar (int x)
+{
+  static int i;
+  switch (i++)
+    {
+    case 0: if (x != v.f.d) __builtin_abort (); break;
+    case 1: if (x != v.f.e) __builtin_abort (); break;
+    case 2: if (x != v.g[3]) __builtin_abort (); break;
+    case 3: if (x != v.h[6]) __builtin_abort (); break;
+    case 4: if (x != v.h[7]) __builtin_abort (); break;
+    default: __builtin_abort (); break;
+    }
+}
+
+void
+foo (unsigned int x)
+{
+  union U u;
+  u.f.d = x >> 2;
+  u.f.e = 0;
+  bar (u.f.d);
+  bar (u.f.e);
+  bar (u.g[3]);
+  bar (u.h[6]);
+  bar (u.h[7]);
+}
+
+int
+main ()
+{
+  foo (0x10224);
+  return 0;
+}
+#else
+int
+main ()
+{
+  return 0;
+}
+#endif
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/dump-noaddr.x b/gcc/testsuite/gcc.c-torture/unsorted/dump-noaddr.x
index d14d4945709..e86f36a1861 100644
--- a/gcc/testsuite/gcc.c-torture/unsorted/dump-noaddr.x
+++ b/gcc/testsuite/gcc.c-torture/unsorted/dump-noaddr.x
@@ -9,14 +9,14 @@ proc dump_compare { src options } {
 
     # loop through all the options
     foreach option $option_list {
-	file delete -force dump1
-	file mkdir dump1
+	file delete -force $tmpdir/dump1
+	file mkdir $tmpdir/dump1
 	c-torture-compile $src "$option $options -dumpbase dump1/$dumpbase -DMASK=1 -x c --param ggc-min-heapsize=1 -fdump-ipa-all -fdump-rtl-all -fdump-tree-all -fdump-noaddr"
-	file delete -force dump2
-	file mkdir dump2
+	file delete -force $tmpdir/dump2
+	file mkdir $tmpdir/dump2
 	c-torture-compile $src "$option $options -dumpbase dump2/$dumpbase -DMASK=2 -x c -fdump-ipa-all -fdump-rtl-all -fdump-tree-all -fdump-noaddr"
-	foreach dump1 [lsort [glob -nocomplain dump1/*]] {
-	    regsub dump1/ $dump1 dump2/ dump2
+	foreach dump1 [lsort [glob -nocomplain $tmpdir/dump1/*]] {
+	    set dump2 "$tmpdir/dump2/[file tail $dump1]"
 	    set dumptail "gcc.c-torture/unsorted/[file tail $dump1]"
 	    regsub {\.\d+((t|r|i)\.[^.]+)$} $dumptail {.*\1} dumptail
 	    set tmp [ diff "$dump1" "$dump2" ]
@@ -29,8 +29,8 @@ proc dump_compare { src options } {
 	    }
 	}
     }
-    file delete -force dump1
-    file delete -force dump2
+    file delete -force $tmpdir/dump1
+    file delete -force $tmpdir/dump2
 }
 
 dump_compare $src $options
diff --git a/gcc/testsuite/gcc.dg/Walloc-size-larger-than-1.c b/gcc/testsuite/gcc.dg/Walloc-size-larger-than-1.c
new file mode 100644
index 00000000000..2e0b76554f9
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/Walloc-size-larger-than-1.c
@@ -0,0 +1,19 @@
+/* PR middle-end/82063 - issues with arguments enabled by -Wall
+   { dg-do compile }
+   { dg-options "-O -Walloc-size-larger-than=1KB -ftrack-macro-expansion=0" } */
+
+void sink (void*);
+
+#define T(x) sink (x)
+
+void f (void)
+{
+  unsigned n = 0;
+  T (__builtin_malloc (n));
+
+  n = 1024;   /* 1 kibibyte (KB or KiB) */
+  T (__builtin_malloc (n));
+
+  n = 1025;
+  T (__builtin_malloc (n));   /* { dg-warning "argument 1 value .1025. exceeds maximum object size 1024" } */
+}
diff --git a/gcc/testsuite/gcc.dg/Walloc-size-larger-than-10.c b/gcc/testsuite/gcc.dg/Walloc-size-larger-than-10.c
new file mode 100644
index 00000000000..559309d5531
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/Walloc-size-larger-than-10.c
@@ -0,0 +1,27 @@
+/* PR middle-end/82063 - issues with arguments enabled by -Wall
+   { dg-do compile { target lp64 } }
+   { dg-options "-O -Walloc-size-larger-than=1PiB -ftrack-macro-expansion=0" } */
+
+typedef __SIZE_TYPE__ size_t;
+
+void sink (void*);
+
+#define T(x) sink (x)
+
+void f (void)
+{
+  size_t n = 0;
+  T (__builtin_malloc (n));
+
+  n = (size_t)1024 * 1024 * 1024 * 1024 * 1024;   /* 1 pebibyte (PiB) */
+  T (__builtin_malloc (n));
+
+  n += 1;
+  T (__builtin_malloc (n));   /* { dg-warning "argument 1 value .1125899906842625. exceeds maximum object size 1125899906842624" } */
+
+  n = __PTRDIFF_MAX__;
+  T (__builtin_malloc (n));   /* { dg-warning "exceeds maximum object size" } */
+
+  n = __SIZE_MAX__;
+  T (__builtin_malloc (n));   /* { dg-warning "exceeds maximum object size" } */
+}
diff --git a/gcc/testsuite/gcc.dg/Walloc-size-larger-than-11.c b/gcc/testsuite/gcc.dg/Walloc-size-larger-than-11.c
new file mode 100644
index 00000000000..41e523c6958
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/Walloc-size-larger-than-11.c
@@ -0,0 +1,27 @@
+/* PR middle-end/82063 - issues with arguments enabled by -Wall
+   { dg-do compile { target lp64 } }
+   { dg-options "-O -Walloc-size-larger-than=1PB -ftrack-macro-expansion=0" } */
+
+typedef __SIZE_TYPE__ size_t;
+
+void sink (void*);
+
+#define T(x) sink (x)
+
+void f (void)
+{
+  size_t n = 0;
+  T (__builtin_malloc (n));
+
+  n = (size_t)1000 * 1000 * 1000 * 1000 * 1000;   /* 1 petabyte (PB) */
+  T (__builtin_malloc (n));
+
+  n += 1;
+  T (__builtin_malloc (n));   /* { dg-warning "argument 1 value .1000000000000001. exceeds maximum object size 1000000000000000" } */
+
+  n = __PTRDIFF_MAX__;
+  T (__builtin_malloc (n));   /* { dg-warning "exceeds maximum object size" } */
+
+  n = __SIZE_MAX__;
+  T (__builtin_malloc (n));   /* { dg-warning "exceeds maximum object size" } */
+}
diff --git a/gcc/testsuite/gcc.dg/Walloc-size-larger-than-12.c b/gcc/testsuite/gcc.dg/Walloc-size-larger-than-12.c
new file mode 100644
index 00000000000..24269a8a102
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/Walloc-size-larger-than-12.c
@@ -0,0 +1,27 @@
+/* PR middle-end/82063 - issues with arguments enabled by -Wall
+   { dg-do compile { target lp64 } }
+   { dg-options "-O -Walloc-size-larger-than=1EiB -ftrack-macro-expansion=0" } */
+
+typedef __SIZE_TYPE__ size_t;
+
+void sink (void*);
+
+#define T(x) sink (x)
+
+void f (void)
+{
+  size_t n = 0;
+  T (__builtin_malloc (n));
+
+  n = (size_t)1024 * 1024 * 1024 * 1024 * 1024 * 1024;   /* 1 exbibyte (EiB) */
+  T (__builtin_malloc (n));
+
+  n += 1;
+  T (__builtin_malloc (n));   /* { dg-warning "argument 1 value .1152921504606846977. exceeds maximum object size 1152921504606846976" } */
+
+  n = __PTRDIFF_MAX__;
+  T (__builtin_malloc (n));   /* { dg-warning "exceeds maximum object size" } */
+
+  n = __SIZE_MAX__;
+  T (__builtin_malloc (n));   /* { dg-warning "exceeds maximum object size" } */
+}
diff --git a/gcc/testsuite/gcc.dg/Walloc-size-larger-than-13.c b/gcc/testsuite/gcc.dg/Walloc-size-larger-than-13.c
new file mode 100644
index 00000000000..b96e3892bd8
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/Walloc-size-larger-than-13.c
@@ -0,0 +1,27 @@
+/* PR middle-end/82063 - issues with arguments enabled by -Wall
+   { dg-do compile { target lp64 } }
+   { dg-options "-O -Walloc-size-larger-than=1EB -ftrack-macro-expansion=0" } */
+
+typedef __SIZE_TYPE__ size_t;
+
+void sink (void*);
+
+#define T(x) sink (x)
+
+void f (void)
+{
+  size_t n = 0;
+  T (__builtin_malloc (n));
+
+  n = (size_t)1000 * 1000 * 1000 * 1000 * 1000 * 1000;   /* 1 exabyte (EB) */
+  T (__builtin_malloc (n));
+
+  n += 1;
+  T (__builtin_malloc (n));   /* { dg-warning "argument 1 value .1000000000000000001. exceeds maximum object size 1000000000000000000" } */
+
+  n = __PTRDIFF_MAX__;
+  T (__builtin_malloc (n));   /* { dg-warning "exceeds maximum object size" } */
+
+  n = __SIZE_MAX__;
+  T (__builtin_malloc (n));   /* { dg-warning "exceeds maximum object size" } */
+}
diff --git a/gcc/testsuite/gcc.dg/Walloc-size-larger-than-14.c b/gcc/testsuite/gcc.dg/Walloc-size-larger-than-14.c
new file mode 100644
index 00000000000..e632e2236a3
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/Walloc-size-larger-than-14.c
@@ -0,0 +1,30 @@
+/* PR middle-end/82063 - issues with arguments enabled by -Wall
+   { dg-do compile }
+   { dg-options "-O -Walloc-size-larger-than=123456789123456789123456789123456789 -ftrack-macro-expansion=0" } */
+
+typedef __SIZE_TYPE__ size_t;
+
+void sink (void*);
+
+#define T(x) sink (x)
+
+/* Verify that an exceedingly large -Walloc-size-larger-than argument
+   with no suffix is accepted and treated as infinite.  */
+
+void f (void)
+{
+  size_t n = 0;
+  T (__builtin_malloc (n));
+
+  n = __PTRDIFF_MAX__;
+  T (__builtin_malloc (n));
+
+  n += 1;
+  T (__builtin_malloc (n));
+
+  n = __SIZE_MAX__ - 1;
+  T (__builtin_malloc (n));
+
+  n = __SIZE_MAX__;
+  T (__builtin_malloc (n));
+}
diff --git a/gcc/testsuite/gcc.dg/Walloc-size-larger-than-15.c b/gcc/testsuite/gcc.dg/Walloc-size-larger-than-15.c
new file mode 100644
index 00000000000..b699cc09c22
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/Walloc-size-larger-than-15.c
@@ -0,0 +1,30 @@
+/* PR middle-end/82063 - issues with arguments enabled by -Wall
+   { dg-do compile }
+   { dg-options "-O -Walloc-size-larger-than=123456789123456789123456789123456789gb -ftrack-macro-expansion=0" } */
+
+typedef __SIZE_TYPE__ size_t;
+
+void sink (void*);
+
+#define T(x) sink (x)
+
+/* Verify that an exceeingly large -Walloc-size-larger-than argument
+   with a valid suffic is accepted and treated as infinite.  */
+
+void f (void)
+{
+  size_t n = 0;
+  T (__builtin_malloc (n));
+
+  n = __PTRDIFF_MAX__;
+  T (__builtin_malloc (n));
+
+  n += 1;
+  T (__builtin_malloc (n));
+
+  n = __SIZE_MAX__ - 1;
+  T (__builtin_malloc (n));
+
+  n = __SIZE_MAX__;
+  T (__builtin_malloc (n));
+}
diff --git a/gcc/testsuite/gcc.dg/Walloc-size-larger-than-16.c b/gcc/testsuite/gcc.dg/Walloc-size-larger-than-16.c
new file mode 100644
index 00000000000..837b69a36d8
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/Walloc-size-larger-than-16.c
@@ -0,0 +1,32 @@
+/* PR middle-end/82063 - issues with arguments enabled by -Wall
+   { dg-do compile }
+   { dg-options "-O -Walloc-size-larger-than=1zb -ftrack-macro-expansion=0" } */
+
+typedef __SIZE_TYPE__ size_t;
+
+void sink (void*);
+
+#define T(x) sink (x)
+
+/* Verify that an invalid -Walloc-size-larger-than argument is diagnosed
+   and rejected without changing the default setting of PTRDIFF_MAX.  */
+
+void f (void)
+{
+  size_t n = 0;
+  T (__builtin_malloc (n));
+
+  n = __PTRDIFF_MAX__;
+  T (__builtin_malloc (n));
+
+  n += 1;
+  T (__builtin_malloc (n));   /* { dg-warning "exceeds maximum object size" } */
+
+  n = __SIZE_MAX__ - 1;
+  T (__builtin_malloc (n));   /* { dg-warning "exceeds maximum object size" } */
+
+  n = __SIZE_MAX__;
+  T (__builtin_malloc (n));   /* { dg-warning "exceeds maximum object size" } */
+}
+
+/* { dg-warning "invalid argument .1zb. to .-Walloc-size-larger-than=." "" { target *-*-* } 0 } */
diff --git a/gcc/testsuite/gcc.dg/Walloc-size-larger-than-2.c b/gcc/testsuite/gcc.dg/Walloc-size-larger-than-2.c
new file mode 100644
index 00000000000..1ded37b0b5c
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/Walloc-size-larger-than-2.c
@@ -0,0 +1,20 @@
+/* PR middle-end/82063 - issues with arguments enabled by -Wall
+   { dg-do compile }
+   { dg-options "-O -Walloc-size-larger-than=1KiB -ftrack-macro-expansion=0" }
+*/
+
+void sink (void*);
+
+#define T(x) sink (x)
+
+void f (void)
+{
+  unsigned n = 0;
+  T (__builtin_malloc (n));
+
+  n = 1024;   /* 1 kibibyte (KB or KiB) */
+  T (__builtin_malloc (n));
+
+  n = 1025;
+  T (__builtin_malloc (n));   /* { dg-warning "argument 1 value .1025. exceeds maximum object size 1024" } */
+}
diff --git a/gcc/testsuite/gcc.dg/Walloc-size-larger-than-3.c b/gcc/testsuite/gcc.dg/Walloc-size-larger-than-3.c
new file mode 100644
index 00000000000..500ddbf7c74
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/Walloc-size-larger-than-3.c
@@ -0,0 +1,19 @@
+/* PR middle-end/82063 - issues with arguments enabled by -Wall
+   { dg-do compile }
+   { dg-options "-O -Walloc-size-larger-than=1kB -ftrack-macro-expansion=0" } */
+
+void sink (void*);
+
+#define T(x) sink (x)
+
+void f (void)
+{
+  unsigned n = 0;
+  T (__builtin_malloc (n));
+
+  n = 1000;   /* 1 kilobyte (kB, not to be confused with KB or KiB) */
+  T (__builtin_malloc (n));
+
+  n = 1001;
+  T (__builtin_malloc (n));   /* { dg-warning "argument 1 value .1001. exceeds maximum object size 1000" } */
+}
diff --git a/gcc/testsuite/gcc.dg/Walloc-size-larger-than-4.c b/gcc/testsuite/gcc.dg/Walloc-size-larger-than-4.c
new file mode 100644
index 00000000000..e4fde5a8eb9
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/Walloc-size-larger-than-4.c
@@ -0,0 +1,19 @@
+/* PR middle-end/82063 - issues with arguments enabled by -Wall
+   { dg-do compile }
+   { dg-options "-O -Walloc-size-larger-than=1MiB -ftrack-macro-expansion=0" } */
+
+void sink (void*);
+
+#define T(x) sink (x)
+
+void f (void)
+{
+  unsigned n = 0;
+  T (__builtin_malloc (n));
+
+  n = 1024 * 1024;   /* 1 mebibyte (MiB) */
+  T (__builtin_malloc (n));
+
+  n += 1;
+  T (__builtin_malloc (n));   /* { dg-warning "argument 1 value .1048577. exceeds maximum object size 1048576" } */
+}
diff --git a/gcc/testsuite/gcc.dg/Walloc-size-larger-than-5.c b/gcc/testsuite/gcc.dg/Walloc-size-larger-than-5.c
new file mode 100644
index 00000000000..bfea259e0ad
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/Walloc-size-larger-than-5.c
@@ -0,0 +1,25 @@
+/* PR middle-end/82063 - issues with arguments enabled by -Wall
+   { dg-do compile }
+   { dg-options "-O -Walloc-size-larger-than=1MB -ftrack-macro-expansion=0" } */
+
+void sink (void*);
+
+#define T(x) sink (x)
+
+void f (void)
+{
+  __SIZE_TYPE__ n = 0;
+  T (__builtin_malloc (n));
+
+  n = 1000 * 1000;   /* 1 megabyte (MB) */
+  T (__builtin_malloc (n));
+
+  n += 1;
+  T (__builtin_malloc (n));   /* { dg-warning "argument 1 value .1000001. exceeds maximum object size 1000000" } */
+
+  n = __PTRDIFF_MAX__;
+  T (__builtin_malloc (n));   /* { dg-warning "exceeds maximum object size 1000000" } */
+
+  n = __SIZE_MAX__;
+  T (__builtin_malloc (n));   /* { dg-warning "exceeds maximum object size 1000000" } */
+}
diff --git a/gcc/testsuite/gcc.dg/Walloc-size-larger-than-6.c b/gcc/testsuite/gcc.dg/Walloc-size-larger-than-6.c
new file mode 100644
index 00000000000..1eb83a5f613
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/Walloc-size-larger-than-6.c
@@ -0,0 +1,25 @@
+/* PR middle-end/82063 - issues with arguments enabled by -Wall
+   { dg-do compile }
+   { dg-options "-O -Walloc-size-larger-than=1GiB -ftrack-macro-expansion=0" } */
+
+void sink (void*);
+
+#define T(x) sink (x)
+
+void f (void)
+{
+  __SIZE_TYPE__ n = 0;
+  T (__builtin_malloc (n));
+
+  n = 1024 * 1024 * 1024;   /* 1 gigibyte (GiB) */
+  T (__builtin_malloc (n));
+
+  n += 1;
+  T (__builtin_malloc (n));   /* { dg-warning "argument 1 value .1073741825. exceeds maximum object size 1073741824" } */
+
+  n = __PTRDIFF_MAX__;
+  T (__builtin_malloc (n));   /* { dg-warning "exceeds maximum object size" } */
+
+  n = __SIZE_MAX__;
+  T (__builtin_malloc (n));   /* { dg-warning "exceeds maximum object size" } */
+}
diff --git a/gcc/testsuite/gcc.dg/Walloc-size-larger-than-7.c b/gcc/testsuite/gcc.dg/Walloc-size-larger-than-7.c
new file mode 100644
index 00000000000..5188203337d
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/Walloc-size-larger-than-7.c
@@ -0,0 +1,25 @@
+/* PR middle-end/82063 - issues with arguments enabled by -Wall
+   { dg-do compile }
+   { dg-options "-O -Walloc-size-larger-than=1GB -ftrack-macro-expansion=0" } */
+
+void sink (void*);
+
+#define T(x) sink (x)
+
+void f (void)
+{
+  __SIZE_TYPE__ n = 0;
+  T (__builtin_malloc (n));
+
+  n = 1000 * 1000 * 1000;   /* 1 gigabyte (GB) */
+  T (__builtin_malloc (n));
+
+  n += 1;
+  T (__builtin_malloc (n));   /* { dg-warning "argument 1 value .1000000001. exceeds maximum object size 1000000000" } */
+
+  n = __PTRDIFF_MAX__;
+  T (__builtin_malloc (n));   /* { dg-warning "exceeds maximum object size" } */
+
+  n = __SIZE_MAX__;
+  T (__builtin_malloc (n));   /* { dg-warning "exceeds maximum object size" } */
+}
diff --git a/gcc/testsuite/gcc.dg/Walloc-size-larger-than-8.c b/gcc/testsuite/gcc.dg/Walloc-size-larger-than-8.c
new file mode 100644
index 00000000000..4f84a027d79
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/Walloc-size-larger-than-8.c
@@ -0,0 +1,27 @@
+/* PR middle-end/82063 - issues with arguments enabled by -Wall
+   { dg-do compile { target lp64 } }
+   { dg-options "-O -Walloc-size-larger-than=1TiB -ftrack-macro-expansion=0" } */
+
+typedef __SIZE_TYPE__ size_t;
+
+void sink (void*);
+
+#define T(x) sink (x)
+
+void f (void)
+{
+  size_t n = 0;
+  T (__builtin_malloc (n));
+
+  n = (size_t)1024 * 1024 * 1024 * 1024;   /* 1 tebibyte (TiB) */
+  T (__builtin_malloc (n));
+
+  n += 1;
+  T (__builtin_malloc (n));   /* { dg-warning "argument 1 value .1099511627777. exceeds maximum object size 1099511627776" } */
+
+  n = __PTRDIFF_MAX__;
+  T (__builtin_malloc (n));   /* { dg-warning "exceeds maximum object size" } */
+
+  n = __SIZE_MAX__;
+  T (__builtin_malloc (n));   /* { dg-warning "exceeds maximum object size" } */
+}
diff --git a/gcc/testsuite/gcc.dg/Walloc-size-larger-than-9.c b/gcc/testsuite/gcc.dg/Walloc-size-larger-than-9.c
new file mode 100644
index 00000000000..f3927f1456e
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/Walloc-size-larger-than-9.c
@@ -0,0 +1,27 @@
+/* PR middle-end/82063 - issues with arguments enabled by -Wall
+   { dg-do compile { target lp64 } }
+   { dg-options "-O -Walloc-size-larger-than=1TB -ftrack-macro-expansion=0" } */
+
+typedef __SIZE_TYPE__ size_t;
+
+void sink (void*);
+
+#define T(x) sink (x)
+
+void f (void)
+{
+  size_t n = 0;
+  T (__builtin_malloc (n));
+
+  n = (size_t)1000 * 1000 * 1000 * 1000;   /* 1 terabyte (TB) */
+  T (__builtin_malloc (n));
+
+  n += 1;
+  T (__builtin_malloc (n));   /* { dg-warning "argument 1 value .1000000000001. exceeds maximum object size 1000000000000" } */
+
+  n = __PTRDIFF_MAX__;
+  T (__builtin_malloc (n));   /* { dg-warning "exceeds maximum object size" } */
+
+  n = __SIZE_MAX__;
+  T (__builtin_malloc (n));   /* { dg-warning "exceeds maximum object size" } */
+}
diff --git a/gcc/testsuite/gcc.dg/Walloc-size-larger-than.c b/gcc/testsuite/gcc.dg/Walloc-size-larger-than.c
new file mode 100644
index 00000000000..8096ff1d3dd
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/Walloc-size-larger-than.c
@@ -0,0 +1,13 @@
+/* PR middle-end/82063 - issues with arguments enabled by -Wall
+   { dg-do compile }
+   { dg-options "-Walloc-size-larger-than=0 -ftrack-macro-expansion=0" } */
+
+void sink (void*);
+
+#define T(x) sink (x)
+
+void f (void)
+{
+  T (__builtin_malloc (0));
+  T (__builtin_malloc (1));   /* { dg-warning "argument 1 value .1. exceeds maximum object size 0" } */
+}
diff --git a/gcc/testsuite/gcc.dg/asan/pr81923.c b/gcc/testsuite/gcc.dg/asan/pr81923.c
index f81d512c96e..dd9db728ce9 100644
--- a/gcc/testsuite/gcc.dg/asan/pr81923.c
+++ b/gcc/testsuite/gcc.dg/asan/pr81923.c
@@ -1,7 +1,10 @@
 /* PR sanitizer/81923 */
 /* { dg-do link } */
 
-int foobar __asm (__USER_LABEL_PREFIX__ "barbaz") = 34;
+#define STR1(X) #X
+#define STR2(X) STR1(X)
+
+int foobar __asm (STR2(__USER_LABEL_PREFIX__) "barbaz") = 34;
 
 int
 main ()
diff --git a/gcc/testsuite/gcc.dg/asm-qual-1.c b/gcc/testsuite/gcc.dg/asm-qual-1.c
index 5ec9a29a910..4982a6b7f05 100644
--- a/gcc/testsuite/gcc.dg/asm-qual-1.c
+++ b/gcc/testsuite/gcc.dg/asm-qual-1.c
@@ -1,4 +1,4 @@
-/* Test that qualifiers other than volatile are ignored on asm.  */
+/* Test that qualifiers other than volatile are disallowed on asm.  */
 /* Origin: Joseph Myers <joseph@codesourcery.com> */
 /* { dg-do compile } */
 /* { dg-options "-std=gnu99" } */
@@ -7,6 +7,8 @@ void
 f (void)
 {
   asm volatile ("");
-  asm const (""); /* { dg-warning "const qualifier ignored on asm" } */
-  asm restrict (""); /* { dg-warning "restrict qualifier ignored on asm" } */
+
+  asm const (""); /* { dg-warning {'const' is not an asm qualifier} } */
+
+  asm restrict (""); /* { dg-warning {'restrict' is not an asm qualifier} } */
 }
diff --git a/gcc/testsuite/gcc.dg/asm-qual-2.c b/gcc/testsuite/gcc.dg/asm-qual-2.c
new file mode 100644
index 00000000000..79135c3d2f2
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/asm-qual-2.c
@@ -0,0 +1,46 @@
+/* Test that qualifiers on asm are allowed in any order.  */
+/* { dg-do compile } */
+/* { dg-options "-std=gnu99" } */
+
+void
+f (void)
+{
+  asm volatile goto ("" :::: lab);
+  asm volatile inline ("" :::);
+  asm inline volatile ("" :::);
+  asm inline goto ("" :::: lab);
+  asm goto volatile ("" :::: lab);
+  asm goto inline ("" :::: lab);
+
+  asm volatile inline goto ("" :::: lab);
+  asm volatile goto inline ("" :::: lab);
+  asm inline volatile goto ("" :::: lab);
+  asm inline goto volatile ("" :::: lab);
+  asm goto volatile inline ("" :::: lab);
+  asm goto inline volatile ("" :::: lab);
+
+  /* Duplicates are not allowed.  */
+  asm goto volatile volatile ("" :::: lab);  /* { dg-error "" } */
+  asm volatile goto volatile ("" :::: lab);  /* { dg-error "" } */
+  asm volatile volatile goto ("" :::: lab);  /* { dg-error "" } */
+  asm goto goto volatile ("" :::: lab);  /* { dg-error "" } */
+  asm goto volatile goto ("" :::: lab);  /* { dg-error "" } */
+  asm volatile goto goto ("" :::: lab);  /* { dg-error "" } */
+
+  asm inline volatile volatile ("" :::);  /* { dg-error "" } */
+  asm volatile inline volatile ("" :::);  /* { dg-error "" } */
+  asm volatile volatile inline ("" :::);  /* { dg-error "" } */
+  asm inline inline volatile ("" :::);  /* { dg-error "" } */
+  asm inline volatile inline ("" :::);  /* { dg-error "" } */
+  asm volatile inline inline ("" :::);  /* { dg-error "" } */
+
+  asm goto inline inline ("" :::: lab);  /* { dg-error "" } */
+  asm inline goto inline ("" :::: lab);  /* { dg-error "" } */
+  asm inline inline goto ("" :::: lab);  /* { dg-error "" } */
+  asm goto goto inline ("" :::: lab);  /* { dg-error "" } */
+  asm goto inline goto ("" :::: lab);  /* { dg-error "" } */
+  asm inline goto goto ("" :::: lab);  /* { dg-error "" } */
+
+lab:
+  ;
+}
diff --git a/gcc/testsuite/gcc.dg/asm-qual-3.c b/gcc/testsuite/gcc.dg/asm-qual-3.c
new file mode 100644
index 00000000000..f85d8bff898
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/asm-qual-3.c
@@ -0,0 +1,9 @@
+/* Test that asm-qualifiers are not allowed on toplevel asm.  */
+/* { dg-do compile } */
+/* { dg-options "-std=gnu99" } */
+
+asm const ("");    /* { dg-error {expected '\(' before 'const'} } */
+asm volatile (""); /* { dg-error {expected '\(' before 'volatile'} } */
+asm restrict (""); /* { dg-error {expected '\(' before 'restrict'} } */
+asm inline ("");   /* { dg-error {expected '\(' before 'inline'} } */
+asm goto ("");     /* { dg-error {expected '\(' before 'goto'} } */
diff --git a/gcc/testsuite/gcc.dg/cpp/trad/pr69869.c b/gcc/testsuite/gcc.dg/cpp/trad/pr69869.c
new file mode 100644
index 00000000000..78bc3cdce39
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/cpp/trad/pr69869.c
@@ -0,0 +1,8 @@
+/* PR preprocessor/69869 */
+/* { dg-do preprocess } */
+/* { dg-options "-traditional-cpp" } */
+
+#define C(a,b)a/**/b
+C (foo/,**/)
+C (foo/,*)
+/* { dg-error "unterminated comment" "" {target "*-*-*"} .-1 } */
diff --git a/gcc/testsuite/gcc.dg/debug/dwarf2/prod-options.c b/gcc/testsuite/gcc.dg/debug/dwarf2/prod-options.c
index 6577eff3548..19457173eb3 100644
--- a/gcc/testsuite/gcc.dg/debug/dwarf2/prod-options.c
+++ b/gcc/testsuite/gcc.dg/debug/dwarf2/prod-options.c
@@ -3,9 +3,8 @@
    the build not reproducible.  Other skipped options could be tested here
    as well.  */
 /* { dg-do compile } */
-/* { dg-options "-O2 -gdwarf -dA -fdebug-prefix-map=a=b" } */
-/* { dg-final { scan-assembler "DW_AT_producer: \"GNU C" { target { { { ! *-*-solaris2* } || gas } && { { ! hppa*64*-*-* } && { ! powerpc-ibm-aix* } } } } } } */
-/* { dg-final { scan-assembler "\"GNU C\[^\\n\\r\]+ DW_AT_producer" { target { { *-*-solaris2* && { ! gas } } || { hppa*64*-*-* } } } } } */
+/* { dg-options "-O2 -gdwarf -dA -fno-merge-debug-strings -fdebug-prefix-map=a=b" } */
+/* { dg-final { scan-assembler "\"GNU C\[^\\n\\r\]+ DW_AT_producer" } } */
 /* { dg-final { scan-assembler-not "debug-prefix-map" } } */
 
 void func (void)
diff --git a/gcc/testsuite/gcc.dg/debug/pr85252.c b/gcc/testsuite/gcc.dg/debug/pr85252.c
new file mode 100644
index 00000000000..6e5ca85bc86
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/debug/pr85252.c
@@ -0,0 +1,11 @@
+/* PR debug/85252 */
+/* { dg-do compile } */
+
+void
+foo (void)
+{
+  static char a[0] = "";
+  static char b[0] = "b";	/* { dg-warning "initializer-string for array of chars is too long" } */
+  static char c[1] = "c";
+  static char d[1] = "de";	/* { dg-warning "initializer-string for array of chars is too long" } */
+}
diff --git a/gcc/testsuite/gcc.dg/gomp/pr88105.c b/gcc/testsuite/gcc.dg/gomp/pr88105.c
new file mode 100644
index 00000000000..9680fdd19f6
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/gomp/pr88105.c
@@ -0,0 +1,30 @@
+/* { dg-do compile } */
+/* { dg-options "-fopenmp -O -fexceptions -fnon-call-exceptions -fno-tree-fre" } */
+
+int
+s0 (void)
+{
+  int g6, oh = 0;
+  int *a6 = &g6;
+
+  (void) a6;
+
+#pragma omp parallel for
+  for (g6 = 0; g6 < 1; ++g6)
+    {
+      int zk;
+
+      for (zk = 0; zk < 1; ++zk)
+        {
+          oh += zk / (zk + 1);
+
+          for (;;)
+            {
+            }
+        }
+
+      a6 = &zk;
+    }
+
+  return oh;
+}
diff --git a/gcc/testsuite/gcc.dg/graphite/pr84552.c b/gcc/testsuite/gcc.dg/graphite/pr84552.c
new file mode 100644
index 00000000000..15cbb0848f4
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/graphite/pr84552.c
@@ -0,0 +1,23 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -floop-nest-optimize -fno-tree-copy-prop -fno-tree-fre -fno-tree-loop-ivcanon" } */
+
+int cx;
+
+int
+e6 (int pj, int xe)
+{
+  for (cx = 0; cx < 2; ++cx)
+    while (xe < 1)
+      {
+	for (cx = 0; cx < 2; ++cx)
+	  pj *= 2;
+
+	if (cx != 0)
+	  goto o3;
+
+	++xe;
+      }
+
+o3:
+  return pj;
+}
diff --git a/gcc/testsuite/gcc.dg/inline-40.c b/gcc/testsuite/gcc.dg/inline-40.c
new file mode 100644
index 00000000000..d0fdaeef34a
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/inline-40.c
@@ -0,0 +1,49 @@
+/* Test inline functions declared in inner scopes.  Bugs 88720 and 88726.  */
+/* { dg-do compile } */
+/* { dg-options "" } */
+
+void
+inline_1 (void)
+{
+}
+
+void
+inline_2 (void)
+{
+}
+
+static void
+inline_static_1 (void)
+{
+}
+
+static void
+inline_static_2 (void)
+{
+}
+
+static void inline_static_3 (void);
+static void inline_static_4 (void);
+
+static void
+test (void)
+{
+  inline void inline_1 (void);
+  extern inline void inline_2 (void);
+  inline void inline_3 (void);
+  extern inline void inline_4 (void);
+  inline void inline_static_1 (void);
+  extern inline void inline_static_2 (void);
+  inline void inline_static_3 (void);
+  extern inline void inline_static_4 (void);
+}
+
+void
+inline_3 (void)
+{
+}
+
+void
+inline_4 (void)
+{
+}
diff --git a/gcc/testsuite/gcc.dg/inline-41.c b/gcc/testsuite/gcc.dg/inline-41.c
new file mode 100644
index 00000000000..1511aeebd58
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/inline-41.c
@@ -0,0 +1,49 @@
+/* Test inline functions declared in inner scopes.  Bugs 88720 and 88726.  */
+/* { dg-do compile } */
+/* { dg-options "-fgnu89-inline" } */
+
+void
+inline_1 (void)
+{
+}
+
+void
+inline_2 (void)
+{
+}
+
+static void
+inline_static_1 (void)
+{
+}
+
+static void
+inline_static_2 (void)
+{
+}
+
+static void inline_static_3 (void);
+static void inline_static_4 (void);
+
+static void
+test (void)
+{
+  inline void inline_1 (void);
+  extern inline void inline_2 (void);
+  inline void inline_3 (void);
+  extern inline void inline_4 (void);
+  inline void inline_static_1 (void);
+  extern inline void inline_static_2 (void);
+  inline void inline_static_3 (void);
+  extern inline void inline_static_4 (void);
+}
+
+void
+inline_3 (void)
+{
+}
+
+void
+inline_4 (void)
+{
+}
diff --git a/gcc/testsuite/gcc.dg/ipa/ipcp-5.c b/gcc/testsuite/gcc.dg/ipa/ipcp-5.c
new file mode 100644
index 00000000000..6786c514543
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/ipa/ipcp-5.c
@@ -0,0 +1,45 @@
+/* Test that estimated local cloning time benefit of extern inline functions is
+   zero.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O3 -fdump-ipa-cp -fno-early-inlining"  } */
+/* { dg-add-options bind_pic_locally } */
+
+extern int get_int (void);
+extern void use_stuff (int);
+
+int arr[10];
+
+inline void
+f (int a)
+{
+  arr[0] += a + 5;
+  arr[1] += a + 50;
+  arr[2] += a - 3;
+  arr[3] += a;
+  arr[4] += a + 21;
+  arr[5] += a + 900;
+  arr[6] += a + 2;
+  arr[7] += a + 3456;
+  arr[8] += a + 3;
+  arr[9] += a + 32;
+  use_stuff (a);
+}
+
+
+int
+entry (void)
+{
+  int i;
+  for (i = 0; i < 100; i++)
+    f (7);
+  for (i = 0; i < 100; i++)
+    f (get_int ());
+  return 0;
+}
+
+
+/* { dg-final { scan-ipa-dump "loc_time: 0" "cp" } } */
+/* { dg-final { scan-ipa-dump-not "replacing param.*with const" "cp"  } } */
+
+
diff --git a/gcc/testsuite/gcc.dg/ipa/pr88214.c b/gcc/testsuite/gcc.dg/ipa/pr88214.c
new file mode 100644
index 00000000000..4daa9829e75
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/ipa/pr88214.c
@@ -0,0 +1,10 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+void i();
+  short a;
+  void b(e) char * e;
+  {
+    i();
+    b(a);
+  }
diff --git a/gcc/testsuite/gcc.dg/lto/pr81440.h b/gcc/testsuite/gcc.dg/lto/pr81440.h
new file mode 100644
index 00000000000..d9e6c3da645
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/lto/pr81440.h
@@ -0,0 +1,4 @@
+typedef struct {
+  int i;
+  int ints[];
+} struct_t;
diff --git a/gcc/testsuite/gcc.dg/lto/pr81440_0.c b/gcc/testsuite/gcc.dg/lto/pr81440_0.c
new file mode 100644
index 00000000000..07f2a87da21
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/lto/pr81440_0.c
@@ -0,0 +1,9 @@
+/* { dg-lto-do link } */
+
+#include "pr81440.h"
+
+extern struct_t my_struct;
+
+int main() {
+ return my_struct.ints[0];
+}
diff --git a/gcc/testsuite/gcc.dg/lto/pr81440_1.c b/gcc/testsuite/gcc.dg/lto/pr81440_1.c
new file mode 100644
index 00000000000..d03533029c1
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/lto/pr81440_1.c
@@ -0,0 +1,6 @@
+#include "pr81440.h"
+
+struct_t my_struct = {
+ 20,
+ { 1, 2 }
+};
diff --git a/gcc/testsuite/gcc.dg/lto/pr83954.h b/gcc/testsuite/gcc.dg/lto/pr83954.h
new file mode 100644
index 00000000000..e0155402504
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/lto/pr83954.h
@@ -0,0 +1,3 @@
+struct foo;
+extern struct foo *FOO_PTR_ARR[1];
+
diff --git a/gcc/testsuite/gcc.dg/lto/pr83954_0.c b/gcc/testsuite/gcc.dg/lto/pr83954_0.c
new file mode 100644
index 00000000000..065a31dab80
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/lto/pr83954_0.c
@@ -0,0 +1,8 @@
+/* { dg-lto-do link } */
+#include "pr83954.h"
+
+int main() {
+  // just to prevent symbol removal
+  FOO_PTR_ARR[1] = 0;
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/lto/pr83954_1.c b/gcc/testsuite/gcc.dg/lto/pr83954_1.c
new file mode 100644
index 00000000000..61b40fc7759
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/lto/pr83954_1.c
@@ -0,0 +1,7 @@
+#include "pr83954.h"
+
+struct foo {
+ int x;
+};
+struct foo *FOO_PTR_ARR[1] = { 0 };
+
diff --git a/gcc/testsuite/gcc.dg/lto/pr85248_0.c b/gcc/testsuite/gcc.dg/lto/pr85248_0.c
new file mode 100644
index 00000000000..902f4b6620c
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/lto/pr85248_0.c
@@ -0,0 +1,50 @@
+/* PR lto/85248 */
+/* { dg-lto-do run } */
+/* { dg-lto-options { { -flto -O2 } } } */
+
+#define STR1(X) #X
+#define STR2(X) STR1(X)
+
+extern void test_alias (int s, int e) 
+  __asm__ (STR2(__USER_LABEL_PREFIX__) "test");
+extern void test_noreturn (int s, int e)
+  __asm__ (STR2(__USER_LABEL_PREFIX__)  "test")
+  __attribute__ ((__noreturn__));
+
+extern inline __attribute__ ((__always_inline__, __gnu_inline__)) void
+test (int s, int e)
+{
+  if (__builtin_constant_p (s) && s != 0)
+    test_noreturn (s, e);
+  else
+    test_alias (s, e);
+}
+
+int
+foo (void)
+{
+  static volatile int a;
+  return a;
+}
+
+static void
+bar (void)
+{
+  test (0, 1);
+  __builtin_exit (0);
+}
+
+static void
+baz ()
+{
+  test (1, 0);
+}
+
+int
+main ()
+{
+  if (foo ())
+    baz ();
+  bar ();
+  __builtin_abort ();
+}
diff --git a/gcc/testsuite/gcc.dg/lto/pr85248_1.c b/gcc/testsuite/gcc.dg/lto/pr85248_1.c
new file mode 100644
index 00000000000..5ce257181fb
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/lto/pr85248_1.c
@@ -0,0 +1,9 @@
+/* { dg-options "-fno-lto" } */
+
+void
+test (int s, int e)
+{
+  asm volatile ("" : "+g" (s), "+g" (e) : : "memory");
+  if (s)
+    __builtin_abort ();
+}
diff --git a/gcc/testsuite/gcc.dg/memcmp-1.c b/gcc/testsuite/gcc.dg/memcmp-1.c
index 828a0caf135..549fc838d04 100644
--- a/gcc/testsuite/gcc.dg/memcmp-1.c
+++ b/gcc/testsuite/gcc.dg/memcmp-1.c
@@ -8,8 +8,13 @@
 #include <string.h>
 #include <stdint.h>
 
-int lib_memcmp(const void *a, const void *b, size_t n) asm("memcmp");
-int lib_strncmp(const char *a, const char *b, size_t n) asm("strncmp");
+#define STR1(X) #X
+#define STR2(X) STR1(X)
+
+int lib_memcmp(const void *a, const void *b, size_t n)
+ asm(STR2(__USER_LABEL_PREFIX__) "memcmp");
+int lib_strncmp(const char *a, const char *b, size_t n)
+ asm(STR2(__USER_LABEL_PREFIX__) "strncmp");
 
 #ifndef NRAND
 #define NRAND 10000
diff --git a/gcc/testsuite/gcc.dg/nested-func-11.c b/gcc/testsuite/gcc.dg/nested-func-11.c
new file mode 100644
index 00000000000..2ebc27261b4
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/nested-func-11.c
@@ -0,0 +1,34 @@
+/* { dg-do run } */
+/* { dg-options "-O2 -fno-omit-frame-pointer" } */
+
+int __attribute__((noclone,noinline)) foo (int i)
+{
+  int a;
+
+  void __attribute__((noclone,noinline)) nested2 (int i)
+  {
+    a = i;
+  }
+
+  void  __attribute__((noclone,noinline)) nested1 (int i)
+  {
+    int b[32];
+
+    for (int j = 0; j < 32; j++)
+      b[j] = i + j;
+
+    nested2 (b[i]);
+  }
+
+  nested1 (i);
+
+  return a;
+}
+
+int main (void)
+{
+  if (foo (4) != 8)
+    __builtin_abort ();
+
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/pr81228.c b/gcc/testsuite/gcc.dg/pr81228.c
new file mode 100644
index 00000000000..f7eecc510ad
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr81228.c
@@ -0,0 +1,21 @@
+/* PR target/81228.  */
+/* { dg-do compile } */
+/* { dg-options "-O3 -fdump-tree-ssa" } */
+
+void *a;
+
+void b ()
+{
+  char c;
+  long d;
+  char *e = a;
+  for (; d; d++)
+  {
+    double f, g;
+    c = g < f || g > f;
+    e[d] = c;
+  }
+}
+
+/* Let's make sure we do have a LTGT.  */
+/* { dg-final { scan-tree-dump "<>" "ssa" } } */
diff --git a/gcc/testsuite/gcc.dg/pr81661.c b/gcc/testsuite/gcc.dg/pr81661.c
new file mode 100644
index 00000000000..d8d27304ddb
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr81661.c
@@ -0,0 +1,12 @@
+/* PR tree-optimization/81661 */
+/* { dg-do compile } */
+/* { dg-options "-O3 -ftrapv" } */
+
+int a, b, c;
+
+void
+foo (void)
+{
+  while (a + c > b)
+    a--;
+}
diff --git a/gcc/testsuite/gcc.dg/pr82916.c b/gcc/testsuite/gcc.dg/pr82916.c
new file mode 100644
index 00000000000..9b1610ba57b
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr82916.c
@@ -0,0 +1,47 @@
+/* PR bootstrap/82916 */
+/* { dg-do run } */
+/* { dg-options "-O2 -fno-tree-dse" } */
+
+struct A { struct A *next; };
+struct C
+{
+  int *of;
+  struct C *parent, *prev, *next;
+  int depth;
+  int min;
+  struct C *min_occ;
+};
+
+__attribute__((noinline, noclone)) struct C *
+foo (int *node)
+{
+  struct A *p = __builtin_malloc (sizeof (struct C));
+  if (!p)
+    return 0;
+  p->next = 0;
+  /* Originally placement new.  */
+  struct C *nw = (struct C *)(void *)p;
+  nw->of = node;
+  nw->parent = 0;
+  nw->prev = 0;
+  nw->next = 0;
+  nw->depth = 0;
+  nw->min_occ = nw;
+  nw->min = 0;
+  return nw;
+}
+
+int
+main ()
+{
+  int o;
+  struct C *p = foo (&o);
+  if (p)
+    {
+      if (p->of != &o || p->parent || p->prev || p->next || p->depth
+	  || p->min || p->min_occ != p)
+	__builtin_abort ();
+    }
+  __builtin_free (p);
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/pr83605.c b/gcc/testsuite/gcc.dg/pr83605.c
new file mode 100644
index 00000000000..c680f0ce91f
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr83605.c
@@ -0,0 +1,20 @@
+/* PR tree-optimization/83605 */
+/* { dg-do compile } */
+/* { dg-options "-O1 -ftrapv -fexceptions -fnon-call-exceptions" } */
+
+int a;
+
+int
+foo (int x)
+{
+  int b = a;
+  {
+    int c;
+    int *d = (x == 0) ? &c : &b;
+
+    for (a = 0; a < 2; ++a)
+      c = (x + b) < a;
+
+    return *d;
+  }
+}
diff --git a/gcc/testsuite/gcc.dg/pr83930.c b/gcc/testsuite/gcc.dg/pr83930.c
new file mode 100644
index 00000000000..8a079af3fb4
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr83930.c
@@ -0,0 +1,17 @@
+/* PR target/83930 */
+/* { dg-do compile } */
+/* { dg-options "-Og -fno-tree-ccp -w" } */
+
+unsigned __attribute__ ((__vector_size__ (16))) v;
+
+static inline void
+bar (unsigned char d)
+{
+  v /= d;
+}
+
+__attribute__ ((always_inline)) void
+foo (void)
+{
+  bar (4);
+}
diff --git a/gcc/testsuite/gcc.dg/pr83985.c b/gcc/testsuite/gcc.dg/pr83985.c
new file mode 100644
index 00000000000..51cfc49a193
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr83985.c
@@ -0,0 +1,25 @@
+/* PR rtl-optimization/83985 */
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+/* { dg-additional-options "-mcpu=e300c3 -mtune=e300c3" { target { powerpc*-*-* && ilp32 } } } */
+
+long long int v;
+
+void
+foo (int x)
+{
+  if (x == 0)
+    return;
+
+  while (v < 2)
+    {
+      signed char *a;
+      v /= x;
+      a = v == 0 ? (signed char *) &x : (signed char *) &v;
+      ++*a;
+      ++v;
+    }
+
+  while (1)
+    ;
+}
diff --git a/gcc/testsuite/gcc.dg/pr83986.c b/gcc/testsuite/gcc.dg/pr83986.c
new file mode 100644
index 00000000000..31a53d93616
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr83986.c
@@ -0,0 +1,14 @@
+/* PR rtl-optimization/83986 */
+/* { dg-do compile } */
+/* { dg-options "-g -O2 -fsched2-use-superblocks -funwind-tables --param max-pending-list-length=1" } */
+
+int v;
+
+int
+foo (int x)
+{
+  v &= !!v && !!x;
+  if (v != 0)
+    foo (0);
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/pr84503-1.c b/gcc/testsuite/gcc.dg/pr84503-1.c
new file mode 100644
index 00000000000..03fb2fbd9a5
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr84503-1.c
@@ -0,0 +1,68 @@
+/* PR tree-optimization/84503 */
+/* { dg-do run } */
+/* { dg-options "-O3" } */
+
+typedef __SIZE_TYPE__ size_t;
+typedef __UINTPTR_TYPE__ uintptr_t;
+
+struct S { int a; unsigned short b; int c, d, e; long f, g, h; int i, j; };
+static struct S *k;
+static size_t l = 0;
+int m;
+
+static int
+bar (void)
+{
+  unsigned i;
+  int j;
+  if (k[0].c == 0)
+    {
+      ++m;
+      size_t n = l * 2;
+      struct S *o;
+      o = (struct S *) __builtin_realloc (k, sizeof (struct S) * n);
+      if (!o)
+	__builtin_exit (0);
+      k = o;
+      for (i = l; i < n; i++)
+	{
+	  void *p = (void *) &k[i];
+	  int q = 0;
+	  size_t r = sizeof (struct S);
+	  if ((((uintptr_t) p) % __alignof__ (long)) == 0
+	      && r % sizeof (long) == 0)
+	    {
+	      long __attribute__ ((may_alias)) *s = (long *) p;
+	      long *t = (long *) ((char *) s + r);
+	      while (s < t)
+		*s++ = 0;
+	    }
+	  else
+	    __builtin_memset (p, q, r);
+	  k[i].c = i + 1;
+	  k[i].a = -1;
+	}
+      k[n - 1].c = 0;
+      k[0].c = l;
+      l = n;
+    }
+  j = k[0].c;
+  k[0].c = k[j].c;
+  return j;
+}
+
+int
+main ()
+{
+  k = (struct S *) __builtin_malloc (sizeof (struct S));
+  if (!k)
+    __builtin_exit (0);
+  __builtin_memset (k, '\0', sizeof (struct S));
+  k->a = -1;
+  l = 1;
+  for (int i = 0; i < 15; ++i)
+    bar ();
+  if (m != 4)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/pr84503-2.c b/gcc/testsuite/gcc.dg/pr84503-2.c
new file mode 100644
index 00000000000..76701f07938
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr84503-2.c
@@ -0,0 +1,5 @@
+/* PR tree-optimization/84503 */
+/* { dg-do run } */
+/* { dg-options "-O3 -fno-tree-vectorize -fno-ivopts" } */
+
+#include "pr84503-1.c"
diff --git a/gcc/testsuite/gcc.dg/pr84607.c b/gcc/testsuite/gcc.dg/pr84607.c
new file mode 100644
index 00000000000..710ee94f729
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr84607.c
@@ -0,0 +1,16 @@
+/* { dg-do run } */
+
+extern void exit(int);
+extern void abort(void);
+int a[10];
+int foo()
+{
+  exit (0);
+  return 0;
+}
+int main()
+{
+  if (&a[foo()])
+    abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/pr84628.c b/gcc/testsuite/gcc.dg/pr84628.c
new file mode 100644
index 00000000000..b8eb53c7dc0
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr84628.c
@@ -0,0 +1,8 @@
+/* PR ipa/84628 */
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+int f0 (void);
+__attribute__((error ("err"))) void f1 (void) { f0 (); f0 (); }
+__attribute__((error ("err"))) void f2 (void) { f0 (); f0 (); }
+/* { dg-bogus "declared with attribute error" "" { target *-*-* } 0 } */
diff --git a/gcc/testsuite/gcc.dg/pr84739.c b/gcc/testsuite/gcc.dg/pr84739.c
new file mode 100644
index 00000000000..9864f990b0c
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr84739.c
@@ -0,0 +1,26 @@
+/* PR tree-optimization/84739 */
+/* { dg-do compile } */
+/* { dg-require-weak "" } */
+/* { dg-options "-O2 -w" } */
+
+static void baz (void) __attribute__((weakref("bar")));
+
+int
+foo (int x, int y)
+{
+  if (x)
+    y = 0;
+  if (y)
+    goto lab;
+  y = 0;
+lab:
+  return y;
+}
+
+void
+bar (int x, int y)
+{
+  y = foo (x, y);
+  if (y != 0)
+    baz ();
+}
diff --git a/gcc/testsuite/gcc.dg/pr84772.c b/gcc/testsuite/gcc.dg/pr84772.c
new file mode 100644
index 00000000000..1241d212350
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr84772.c
@@ -0,0 +1,13 @@
+/* PR target/84772 */
+/* { dg-do compile } */
+/* { dg-options "-O -Wuninitialized" } */
+
+#include <stdarg.h>
+
+void
+foo (int *x, int y, va_list ap)
+{
+  __builtin_memset (x, 0, sizeof (int));
+  for (int i = 0; i < y; i++)
+    va_arg (ap, long double);			/* { dg-bogus "uninitialized" } */  
+}
diff --git a/gcc/testsuite/gcc.dg/pr84834.c b/gcc/testsuite/gcc.dg/pr84834.c
new file mode 100644
index 00000000000..38c056bb4ca
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr84834.c
@@ -0,0 +1,15 @@
+/* PR middle-end/84834 */
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+_Complex int
+foo (int a)
+{
+  return a < 0;
+}
+
+_Complex int
+bar (int a)
+{
+  return (a & 8) ? (_Complex int) 16 : (_Complex int) 0;
+}
diff --git a/gcc/testsuite/gcc.dg/pr84841.c b/gcc/testsuite/gcc.dg/pr84841.c
new file mode 100644
index 00000000000..4f7422a659f
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr84841.c
@@ -0,0 +1,9 @@
+/* PR tree-optimization/84841 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -fassociative-math -frounding-math -fno-signed-zeros -fno-trapping-math -fno-tree-forwprop" } */
+
+double
+foo (double x)
+{
+  return -x * 0.1 * 0.1;
+}
diff --git a/gcc/testsuite/gcc.dg/pr84853.c b/gcc/testsuite/gcc.dg/pr84853.c
new file mode 100644
index 00000000000..c74526369a4
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr84853.c
@@ -0,0 +1,19 @@
+/* PR c/84853 */
+/* { dg-do compile } */
+
+typedef float V __attribute__((__vector_size__ (16)));
+typedef int W __attribute__((__vector_size__ (16)));
+
+void
+foo (int x, V *y, V *z, W *w)
+{
+  *y = *y << x;		/* { dg-error "invalid operands to binary <<" } */
+  *z = *z << *w;	/* { dg-error "invalid operands to binary <<" } */
+}
+
+void
+bar (int x, V *y, V *z, W *w)
+{
+  *y = *y >> x;		/* { dg-error "invalid operands to binary >>" } */
+  *z = *z >> *w;	/* { dg-error "invalid operands to binary >>" } */
+}
diff --git a/gcc/testsuite/gcc.dg/pr84875.c b/gcc/testsuite/gcc.dg/pr84875.c
new file mode 100644
index 00000000000..257176de205
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr84875.c
@@ -0,0 +1,28 @@
+/* PR debug/84875 */
+/* { dg-do compile } */
+/* { dg-options "-Os" } */
+/* { dg-additional-options "-fpie" { target pie } } */
+/* { dg-additional-options "-march=z196" { target s390*-*-* } } */
+
+static long *a[100];
+static int b[100];
+long *c;
+int d;
+void foo (long *);
+
+void
+bar ()
+{
+  long *g = c;
+  g--;
+  d = *g;
+  if (d)
+    if (b[d] < 8)
+      {
+	*(void **)g = a[d];
+	a[d] = g;
+	b[d]++;
+	return;
+      }
+  foo (g);
+}
diff --git a/gcc/testsuite/gcc.dg/pr84899.c b/gcc/testsuite/gcc.dg/pr84899.c
new file mode 100644
index 00000000000..0706fecada3
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr84899.c
@@ -0,0 +1,12 @@
+/* PR target/84899 */
+/* { dg-do compile } */
+/* { dg-options "-O -funroll-all-loops -fno-move-loop-invariants" } */
+
+void
+foo (int x)
+{
+  int a = 1 / x, b = 0;
+
+  while ((a + b + 1) < x)
+    b = __INT_MAX__;
+}
diff --git a/gcc/testsuite/gcc.dg/pr84941.c b/gcc/testsuite/gcc.dg/pr84941.c
new file mode 100644
index 00000000000..6f4674e54f0
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr84941.c
@@ -0,0 +1,10 @@
+/* PR inline-asm/84941 */
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+void
+foo (void)
+{
+  short *b[1] = { 0 };
+  asm volatile ("" : "=m,m" (b), "=r,r" (b) : "1,p" (b));
+}
diff --git a/gcc/testsuite/gcc.dg/pr84953.c b/gcc/testsuite/gcc.dg/pr84953.c
new file mode 100644
index 00000000000..723a8a67dda
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr84953.c
@@ -0,0 +1,11 @@
+/* PR c/84953 */
+/* { dg-do compile } */
+
+char *strpbrk (const char *, const char *);
+
+char *
+test (char *p)
+{
+  p = strpbrk (p, "");	/* { dg-bogus "assignment discards 'const' qualifier from pointer target type" } */
+  return p;
+}
diff --git a/gcc/testsuite/gcc.dg/pr84956.c b/gcc/testsuite/gcc.dg/pr84956.c
new file mode 100644
index 00000000000..055a749d635
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr84956.c
@@ -0,0 +1,27 @@
+/* { dg-options "-O2 -ftree-tail-merge" } */
+
+char a;
+int c;
+unsigned b ();
+
+unsigned
+setjmp ()
+{
+}
+
+static void
+d ()
+{
+  if (b ())
+    c = 3;
+}
+
+void
+e ()
+{
+  d ();
+  a && ({ setjmp (); });
+  a && ({ setjmp (); });
+  a && ({ setjmp (); });
+}
+
diff --git a/gcc/testsuite/gcc.dg/pr85167.c b/gcc/testsuite/gcc.dg/pr85167.c
new file mode 100644
index 00000000000..e4277e3ef72
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr85167.c
@@ -0,0 +1,16 @@
+/* PR rtl-optimization/85167 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -w" } */
+
+struct A { long b; };
+int c, d, e;
+int bar (void);
+
+int
+foo (void)
+{
+  long g;
+  for (; g == c ? 0 : (e = 1); g = ((struct A *)g)->b)
+    if (bar ())
+      return d;
+}
diff --git a/gcc/testsuite/gcc.dg/pr85257.c b/gcc/testsuite/gcc.dg/pr85257.c
new file mode 100644
index 00000000000..75fafd96fd3
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr85257.c
@@ -0,0 +1,20 @@
+/* PR tree-optimization/85257 */
+/* { dg-do run { target int128 } } */
+/* { dg-options "-O2 -fno-tree-ccp" } */
+
+typedef __int128 V __attribute__ ((__vector_size__ (16 * sizeof (__int128))));
+
+__int128 __attribute__ ((noinline, noclone))
+foo (void)
+{
+  V v = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 };
+  return v[5];
+}
+
+int
+main ()
+{
+  if (foo () != 6)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/pr85300.c b/gcc/testsuite/gcc.dg/pr85300.c
new file mode 100644
index 00000000000..87a30b8d419
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr85300.c
@@ -0,0 +1,16 @@
+/* PR rtl-optimization/85300 */
+/* { dg-do compile } */
+/* { dg-options "-O1 -g -funroll-all-loops -fno-tree-ter -fno-web" } */
+
+void
+foo (double x, unsigned char y)
+{
+  while ((int) x < 1)
+    {
+      float a;
+
+      a = y | 0x100;
+      y = 0;
+      x = a;
+    }
+}
diff --git a/gcc/testsuite/gcc.dg/pr85430.c b/gcc/testsuite/gcc.dg/pr85430.c
new file mode 100644
index 00000000000..7b58a3cd567
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr85430.c
@@ -0,0 +1,12 @@
+/* PR target/85430 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -fno-tree-ccp -fno-tree-fre" } */
+
+typedef char V __attribute__((vector_size (4)));
+
+V
+foo (V v)
+{
+  v[(V){}[0]] <<= 1;
+  return v;
+}
diff --git a/gcc/testsuite/gcc.dg/pr85529.c b/gcc/testsuite/gcc.dg/pr85529.c
new file mode 100644
index 00000000000..0b732284749
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr85529.c
@@ -0,0 +1,27 @@
+/* PR tree-optimization/85529 */
+/* { dg-do run } */
+/* { dg-options "-O2 -fno-ssa-phiopt" } */
+
+__attribute__((noinline, noclone)) int
+foo (int x)
+{
+  x &= 31;
+  x -= 25;
+  x *= 2;
+  if (x < 0)
+    return 1;
+  int y = x >> 2;
+  if (x >= y)
+    return 1;
+  return 0;
+}
+
+int
+main ()
+{
+  int i;
+  for (i = 0; i < 63; i++)
+    if (foo (i) != 1)
+      __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/pr85859.c b/gcc/testsuite/gcc.dg/pr85859.c
new file mode 100644
index 00000000000..96eb9671137
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr85859.c
@@ -0,0 +1,19 @@
+/* { dg-do run } */
+/* { dg-options "-ftree-tail-merge -Wno-div-by-zero -O2 -fno-dce -fno-isolate-erroneous-paths-dereference -fno-tree-dce -fno-tree-vrp" } */
+
+int b, c, d, e;
+
+__attribute__ ((noinline, noclone))
+int foo (short f)
+{
+  f %= 0;
+  return f;
+}
+
+int
+main (void)
+{
+  b = (unsigned char) __builtin_parity (d);
+  e ? foo (0) : (long) &c;
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/pr86076.c b/gcc/testsuite/gcc.dg/pr86076.c
new file mode 100644
index 00000000000..390ca47ba12
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr86076.c
@@ -0,0 +1,26 @@
+/* { dg-do compile { target pthread } }  */
+/* { dg-options "-O2 -ftree-parallelize-loops=2 -fno-tree-dce -fno-tree-pre -fno-tree-vrp --param max-loop-header-insns=1" } */
+
+int __attribute__ ((noinline))
+lv (int tm)
+{
+  (void) tm;
+
+  return 0;
+}
+
+void
+o7 (int uu)
+{
+  while (uu < 1)
+    while (uu != 0)
+      {
+	short int ca;
+
+	ca = lv (0);
+	(void) ca;
+	++uu;
+      }
+
+  lv (lv (0));
+}
diff --git a/gcc/testsuite/gcc.dg/pr86314.c b/gcc/testsuite/gcc.dg/pr86314.c
new file mode 100644
index 00000000000..8962a3cf2ff
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr86314.c
@@ -0,0 +1,20 @@
+// PR target/86314
+// { dg-do run { target sync_int_long } }
+// { dg-options "-O2" }
+
+__attribute__((noinline, noclone)) unsigned long
+foo (unsigned long *p)
+{
+  unsigned long m = 1UL << ((*p & 1) ? 1 : 0);
+  unsigned long n = __atomic_fetch_or (p, m, __ATOMIC_SEQ_CST);
+  return (n & m) == 0;
+}
+
+int
+main ()
+{
+  unsigned long v = 1;
+  if (foo (&v) != 1)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/pr87024.c b/gcc/testsuite/gcc.dg/pr87024.c
new file mode 100644
index 00000000000..a8a58aafc26
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr87024.c
@@ -0,0 +1,14 @@
+/* { dg-do compile } */
+/* { dg-options "-O -fno-tree-dce" } */
+
+static inline void __attribute__((always_inline))
+mp ()
+{
+  (void) __builtin_va_arg_pack_len ();
+}
+
+void
+ui (void)
+{
+  mp ();
+}
diff --git a/gcc/testsuite/gcc.dg/pr89037.c b/gcc/testsuite/gcc.dg/pr89037.c
new file mode 100644
index 00000000000..551136741d7
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr89037.c
@@ -0,0 +1,24 @@
+/* { dg-do run { target int128 } } */
+/* { dg-options "" } */
+
+struct s
+{
+  __int128 y : 66;
+};
+typedef struct s T;
+T a[] = { 1, 10000, 0x12345, 0xff000001, 1ULL << 63, (__int128) 1 << 64,
+	  ((__int128) 1 << 64) | 1 };
+
+int
+main (void)
+{
+  if (a[0].y != 1
+      || a[1].y != 10000
+      || a[2].y != 0x12345
+      || a[3].y != 0xff000001
+      || a[4].y != (1ULL << 63)
+      || a[5].y != ((__int128) 1 << 64)
+      || a[6].y != (((__int128) 1 << 64) | 1))
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/rtl/x86_64/final.c b/gcc/testsuite/gcc.dg/rtl/x86_64/final.c
index 3e37ce2cd9e..de13df47c69 100644
--- a/gcc/testsuite/gcc.dg/rtl/x86_64/final.c
+++ b/gcc/testsuite/gcc.dg/rtl/x86_64/final.c
@@ -1,5 +1,5 @@
 /* { dg-do compile { target { { i?86-*-* x86_64-*-* } && lp64 } } } */
-/* { dg-options "-fdump-rtl-final" } */
+/* { dg-options "-fdwarf2-cfi-asm -fdump-rtl-final" } */
 
 /* Lightly-modified dump of test.c.304r.dwarf2 for x86_64 target,
    with various NOTE_INSN_CFI deleted by hand for now.  */
diff --git a/gcc/testsuite/gcc.dg/tls/pr83945.c b/gcc/testsuite/gcc.dg/tls/pr83945.c
new file mode 100644
index 00000000000..dade2388eea
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/tls/pr83945.c
@@ -0,0 +1,21 @@
+/* PR middle-end/83945 */
+/* { dg-do compile { target tls } } */
+/* { dg-options "-O2" } */
+
+struct S { int a[1]; };
+__thread struct T { int c; } e;
+int f;
+void bar (int);
+
+void
+foo (int f, int x)
+{
+  struct S *h = (struct S *) &e.c;
+  for (;;)
+    {
+      int *a = h->a, i;
+      for (i = x; i; i--)
+	bar (a[f]);
+      bar (a[f]);
+    }
+}
diff --git a/gcc/testsuite/gcc.dg/torture/neon-immediate-timode.c b/gcc/testsuite/gcc.dg/torture/neon-immediate-timode.c
new file mode 100644
index 00000000000..35f7d2cd32c
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/neon-immediate-timode.c
@@ -0,0 +1,10 @@
+union a {
+  char b;
+  long long c;
+};
+union a d;
+int g(int, union a, union a);
+void e() {
+  union a f[2] = {-1L};
+  g(0, d, f[0]);
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr57656.c b/gcc/testsuite/gcc.dg/torture/pr57656.c
index 4f3645e4693..02490140105 100644
--- a/gcc/testsuite/gcc.dg/torture/pr57656.c
+++ b/gcc/testsuite/gcc.dg/torture/pr57656.c
@@ -1,5 +1,5 @@
 /* { dg-do run } */
-/* { dg-options "-fstrict-overflow" } */
+/* { dg-additional-options "-fstrict-overflow" } */
 
 int main (void)
 {
diff --git a/gcc/testsuite/gcc.dg/torture/pr68037-1.c b/gcc/testsuite/gcc.dg/torture/pr68037-1.c
index 23d7c6f397a..a50fd4dc1e5 100644
--- a/gcc/testsuite/gcc.dg/torture/pr68037-1.c
+++ b/gcc/testsuite/gcc.dg/torture/pr68037-1.c
@@ -1,4 +1,5 @@
 /* { dg-do run { target i?86-*-* x86_64-*-* } } */
+/* { dg-skip-if "PR81210 sp not aligned to 16 bytes" { *-*-darwin* } } */
 /* { dg-options "-mgeneral-regs-only" } */
 
 extern void exit (int);
diff --git a/gcc/testsuite/gcc.dg/torture/pr68037-2.c b/gcc/testsuite/gcc.dg/torture/pr68037-2.c
index 18f98442ceb..77492ac083a 100644
--- a/gcc/testsuite/gcc.dg/torture/pr68037-2.c
+++ b/gcc/testsuite/gcc.dg/torture/pr68037-2.c
@@ -1,4 +1,5 @@
 /* { dg-do run { target i?86-*-* x86_64-*-* } } */
+/* { dg-skip-if "PR81210 sp not aligned to 16 bytes" { *-*-darwin* } } */
 /* { dg-options "-mgeneral-regs-only" } */
 
 extern void exit (int);
diff --git a/gcc/testsuite/gcc.dg/torture/pr68037-3.c b/gcc/testsuite/gcc.dg/torture/pr68037-3.c
index 86324f1a8fb..a985d26a7be 100644
--- a/gcc/testsuite/gcc.dg/torture/pr68037-3.c
+++ b/gcc/testsuite/gcc.dg/torture/pr68037-3.c
@@ -1,4 +1,5 @@
 /* { dg-do run { target i?86-*-* x86_64-*-* } } */
+/* { dg-skip-if "PR81210 sp not aligned to 16 bytes" { *-*-darwin* } } */
 /* { dg-options "-mgeneral-regs-only" } */
 
 #include <stddef.h>
diff --git a/gcc/testsuite/gcc.dg/torture/pr68264.c b/gcc/testsuite/gcc.dg/torture/pr68264.c
index 9294d5aedb7..3557a5ffc86 100644
--- a/gcc/testsuite/gcc.dg/torture/pr68264.c
+++ b/gcc/testsuite/gcc.dg/torture/pr68264.c
@@ -1,4 +1,5 @@
 /* { dg-do run } */
+/* { dg-skip-if "PR68356 no math-errno on darwin" { "*-*-darwin*" } } */
 /* { dg-add-options ieee } */
 /* { dg-require-effective-target fenv_exceptions } */
 
diff --git a/gcc/testsuite/gcc.dg/torture/pr79351.c b/gcc/testsuite/gcc.dg/torture/pr79351.c
new file mode 100644
index 00000000000..d5d0271c376
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr79351.c
@@ -0,0 +1,26 @@
+/* { dg-do run } */
+
+static struct state {
+    int k;
+    int dummy;
+} states[256];
+
+__attribute((noinline))
+static void
+ismatch(int n)
+{
+  for (int j=0; j<n; j++) {
+      states[j] = (struct state){0};
+      for (int i = 0; i <= j; i++) {
+	  states[i].k++;
+      }
+  }
+}
+
+int
+main()
+{
+  ismatch(2);
+  if (states[0].k != 2)
+    __builtin_abort();
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr85168.c b/gcc/testsuite/gcc.dg/torture/pr85168.c
new file mode 100644
index 00000000000..cc5e6648c7e
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr85168.c
@@ -0,0 +1,30 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target indirect_jumps } */
+
+typedef struct {
+    struct {
+	char a;
+    } b;
+} c;
+
+int d, f;
+c *e;
+
+extern void i(void);
+extern void sejtmp () __attribute__((returns_twice));
+
+void g(void)
+{
+  c *h = e;
+  if (f)
+    {
+      i();
+      h--;
+      if (d)
+	if (h->b.a)
+	  i();
+    }
+  if (h->b.a)
+    sejtmp();
+  e = h;
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr85244-1.c b/gcc/testsuite/gcc.dg/torture/pr85244-1.c
new file mode 100644
index 00000000000..44716aa9e04
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr85244-1.c
@@ -0,0 +1,19 @@
+/* { dg-do run } */
+/* { dg-additional-sources "pr85244-2.c" } */
+
+struct s {
+ long a;
+ int b;
+ int tab[];
+};
+
+extern const struct s val;
+extern int idx;
+extern void abort (void);
+
+int main()
+{
+  if (val.tab[0] != 42 || val.tab[1] != 1337 || val.tab[idx] != 1337)
+    abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr85244-2.c b/gcc/testsuite/gcc.dg/torture/pr85244-2.c
new file mode 100644
index 00000000000..d57cb712420
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr85244-2.c
@@ -0,0 +1,8 @@
+struct s {
+    long a;
+    int b;
+    int tab[];
+};
+
+int idx = 1;
+const struct s val = { 0, 0, { 42, 1337 } };
diff --git a/gcc/testsuite/gcc.dg/torture/pr85284.c b/gcc/testsuite/gcc.dg/torture/pr85284.c
new file mode 100644
index 00000000000..80e2c5b247b
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr85284.c
@@ -0,0 +1,20 @@
+/* { dg-do run } */
+
+static int p[48], v;
+
+int
+main ()
+{
+  p[32] = 1;
+  for (int i = 48; i--;)
+    {
+      if (!p[i])
+	continue;
+      if ((i & 7) > 2)
+	break;
+      v = i & 1;
+    }
+  if (v != 0)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr85567.c b/gcc/testsuite/gcc.dg/torture/pr85567.c
new file mode 100644
index 00000000000..f20c69f4201
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr85567.c
@@ -0,0 +1,16 @@
+/* { dg-do compile } */
+
+extern void sincos(double x, double *sinx, double *cosx);
+
+void apply(void (*f)(double, double *, double *),
+	   double x, double *sinx, double *cosx)
+{
+  f(x, sinx, cosx);
+  return;
+}
+
+void apply_sincos(double x, double *sinx, double *cosx)
+{
+  apply(sincos, x, sinx, cosx);
+  return;
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr85588.c b/gcc/testsuite/gcc.dg/torture/pr85588.c
new file mode 100644
index 00000000000..5d95c96bc35
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr85588.c
@@ -0,0 +1,4 @@
+/* { dg-do run } */
+/* { dg-additional-options "-fwrapv" } */
+
+#include "pr57656.c"
diff --git a/gcc/testsuite/gcc.dg/torture/pr85989.c b/gcc/testsuite/gcc.dg/torture/pr85989.c
new file mode 100644
index 00000000000..5cfd7016fb5
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr85989.c
@@ -0,0 +1,31 @@
+/* { dg-do run } */
+
+#define N 9
+
+void __attribute__((noinline, noclone))
+f (double x, double y, double *res)
+{
+  y = -y;
+  for (int i = 0; i < N; ++i)
+    {
+      double tmp = y;
+      y = x;
+      x = tmp;
+      res[i] = i;
+    }
+  res[N] = y * y;
+  res[N + 1] = x;
+}
+
+int
+main (void)
+{
+  double res[N + 2];
+  f (10, 20, res);
+  for (int i = 0; i < N; ++i)
+    if (res[i] != i)
+      __builtin_abort ();
+  if (res[N] != 100 || res[N + 1] != -20)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr86505.c b/gcc/testsuite/gcc.dg/torture/pr86505.c
new file mode 100644
index 00000000000..db102d308e6
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr86505.c
@@ -0,0 +1,32 @@
+/* { dg-do run } */
+
+static inline __attribute__(( __always_inline__)) int 
+funA(unsigned int param, ...) 
+{ 
+  return __builtin_va_arg_pack_len(); 
+}
+
+static inline __attribute__(( __always_inline__)) int
+funB(unsigned int param, ...)
+{ 
+  return funA(param,  2, 4, __builtin_va_arg_pack()); 
+}
+
+int 
+testBuiltin(void) 
+{ 
+  int rc = funB(0,1,2); 
+  if (rc != 4)
+    return 1;
+  return 0;
+}
+
+int
+main()
+{
+  int rc = testBuiltin();
+  if (rc == 1)
+    __builtin_abort ();
+
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr86554-1.c b/gcc/testsuite/gcc.dg/torture/pr86554-1.c
new file mode 100644
index 00000000000..64f851e896e
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr86554-1.c
@@ -0,0 +1,35 @@
+/* { dg-do run } */
+
+struct foo
+{
+  unsigned x;
+};
+typedef struct foo foo;
+
+static inline int zot(foo *f)
+{
+  int ret;
+
+  if (f->x > 0x7FFFFFFF)
+    ret = (int)(f->x - 0x7FFFFFFF);
+  else
+    ret = (int)f->x - 0x7FFFFFFF;
+  return ret;
+}
+
+void __attribute__((noinline,noclone)) bar(foo *f)
+{
+  int ret = zot(f);
+  volatile int x = ret;
+  if (ret < 1)
+    __builtin_abort ();
+}
+
+int main()
+{
+  foo f;
+  f.x = 0x800003f8;
+
+  bar(&f);
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr86554-2.c b/gcc/testsuite/gcc.dg/torture/pr86554-2.c
new file mode 100644
index 00000000000..9e57a9ca725
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr86554-2.c
@@ -0,0 +1,49 @@
+/* { dg-do run } */
+/* { dg-require-effective-target int32plus } */
+
+struct s { __INT64_TYPE__ e; };
+
+static void f (struct s *ps)
+{
+  volatile __INT64_TYPE__ m = 9223372036854775807;
+  const char *str = "11E";
+  int r;
+  __INT64_TYPE__ sum;
+
+  ps->e = 0;
+
+  for (;;)
+    {
+      if (*str++ != '1')
+	break;
+      ps->e ++;
+    }
+
+  r = 1;
+  sum = m;
+
+  if (sum >= 0 && ps->e >= 0)
+    {
+      __UINT64_TYPE__ uc;
+      uc = (__UINT64_TYPE__) sum + (__UINT64_TYPE__) ps->e;
+      if (uc > 9223372036854775807)
+	r = 2;
+      else
+	sum = 17;
+    }
+  else
+    sum = sum + ps->e;
+
+  if (sum != 9223372036854775807)
+    __builtin_abort ();
+  if (r != 2)
+    __builtin_abort ();
+  ps->e = sum;
+}
+
+int main (void)
+{
+  struct s s;
+  f (&s);
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr87645.c b/gcc/testsuite/gcc.dg/torture/pr87645.c
new file mode 100644
index 00000000000..5360e380080
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr87645.c
@@ -0,0 +1,21 @@
+/* { dg-do compile } */
+
+typedef unsigned a[8];
+a b, g;
+int c, d, e, f;
+int h() {
+    unsigned i = 2;
+    for (; i < 8; i++)
+      b[i] = 0;
+    for (; f;) {
+	d = 1;
+	for (; d < 14; d += 3) {
+	    e = 0;
+	    for (; e < 8; e++) {
+		i = 2;
+		for (; i < 8; i++)
+		  b[i] = 5 - (c - g[e] + b[i]);
+	    }
+	}
+    }
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr87665.c b/gcc/testsuite/gcc.dg/torture/pr87665.c
new file mode 100644
index 00000000000..6f5e968b628
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr87665.c
@@ -0,0 +1,27 @@
+/* { dg-do run } */
+
+struct X { long x; long y; };
+
+struct X a[1024], b[1024];
+
+void foo ()
+{
+  for (int i = 0; i < 1024; ++i)
+    {
+      long tem = a[i].x;
+      a[i].x = 0;
+      b[i].x = tem;
+      b[i].y = a[i].y;
+    }
+}
+
+int main()
+{
+  for (int i = 0; i < 1024; ++i)
+    a[i].x = i;
+  foo ();
+  for (int i = 0; i < 1024; ++i)
+    if (b[i].x != i)
+      __builtin_abort();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr89008.c b/gcc/testsuite/gcc.dg/torture/pr89008.c
new file mode 100644
index 00000000000..aa13f94a44e
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr89008.c
@@ -0,0 +1,27 @@
+/* { dg-do run } */
+/* { dg-require-effective-target int32plus } */
+
+unsigned long a, c;
+unsigned b;
+int d, e;
+long f()
+{
+  unsigned long g = 0;
+  for (d = 0; d < 5; d += 2)
+    for (e = 0; e < 5; e += 3)
+      {
+	c = 4 + b;
+	g = -b - b;
+	b = 5 * (b << 24);
+      }
+  a = g;
+  return 0;
+}
+
+int main()
+{
+  f();
+  if (a)
+    __builtin_abort();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr89223.c b/gcc/testsuite/gcc.dg/torture/pr89223.c
new file mode 100644
index 00000000000..1e828118ecb
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr89223.c
@@ -0,0 +1,10 @@
+/* { dg-do compile { target int128 } } */
+
+int a[5];
+unsigned __int128 b;
+void c()
+{
+  b = 4;
+  for (;; b--)
+    a[b] = ({ a[b + b]; });
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr89505.c b/gcc/testsuite/gcc.dg/torture/pr89505.c
new file mode 100644
index 00000000000..6fca475ad9d
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr89505.c
@@ -0,0 +1,22 @@
+/* { dg-do run } */
+
+struct S { int i; void *p; int j; };
+int a;
+int __attribute__((noinline))
+foo (struct S * __restrict p, int q)
+{
+  int *x = &p->j;
+  if (q)
+    x = &a;
+  p->j = 1;
+  *x = 2;
+  return p->j;
+}
+
+int main()
+{
+  struct S s;
+  if (foo (&s, 0) != 2)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/torture/restrict-6.c b/gcc/testsuite/gcc.dg/torture/restrict-6.c
new file mode 100644
index 00000000000..9fe12a68850
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/restrict-6.c
@@ -0,0 +1,24 @@
+/* { dg-do run } */
+
+extern void abort (void);
+
+void __attribute__((noinline)) g(int **a, int *b)
+{
+  *a = b;
+}
+
+int foo(int * restrict p, int *q)
+{
+  g(&q, p);
+  *p = 1;
+  *q = 2;
+  return *p + *q;
+}
+
+int main()
+{
+  int x, y;
+  if (foo(&x, &y) != 4)
+    abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/tree-prof/section-attr-1.c b/gcc/testsuite/gcc.dg/tree-prof/section-attr-1.c
index ee6662ea6e5..1f99b3128cc 100644
--- a/gcc/testsuite/gcc.dg/tree-prof/section-attr-1.c
+++ b/gcc/testsuite/gcc.dg/tree-prof/section-attr-1.c
@@ -13,7 +13,11 @@ const char *buf_cold;
 
 void foo (int path);
 
+#ifdef __APPLE__
+__attribute__ ((section ("__TEXT,__text")))
+#else
 __attribute__((section(".text")))
+#endif
 int
 main (int argc, char *argv[])
 {
@@ -43,3 +47,4 @@ foo (int path)
 }
 
 /* { dg-final-use { scan-assembler "\.section\[\t \]*\.text\.unlikely\[\\n\\r\]+\[\t \]*\.size\[\t \]*foo\.cold\.0" { target *-*-linux* *-*-gnu* } } } */
+/* { dg-final-use { scan-assembler "\.section\[\t \]*__TEXT,__text_cold\.\*\[\\n\\r\]+_foo\.cold\.0" { target *-*-darwin* } } } */
diff --git a/gcc/testsuite/gcc.dg/tree-prof/section-attr-2.c b/gcc/testsuite/gcc.dg/tree-prof/section-attr-2.c
index 898a395cd7e..9bdc63a1b0a 100644
--- a/gcc/testsuite/gcc.dg/tree-prof/section-attr-2.c
+++ b/gcc/testsuite/gcc.dg/tree-prof/section-attr-2.c
@@ -28,7 +28,11 @@ main (int argc, char *argv[])
 void NOINLINE
 foo (int path)
 {
+#ifdef __APPLE__
+  static int i __attribute__ ((section ("__DATA,__data")));
+#else
   static int i __attribute__((section(".data")));
+#endif
   if (path)
     {
       for (i = 0; i < SIZE; i++)
@@ -42,3 +46,4 @@ foo (int path)
 }
 
 /* { dg-final-use { scan-assembler "\.section\[\t \]*\.text\.unlikely\[\\n\\r\]+\[\t \]*\.size\[\t \]*foo\.cold\.0" { target *-*-linux* *-*-gnu* } } } */
+/* { dg-final-use { scan-assembler "\.section\[\t \]*__TEXT,__text_cold\.\*\[\\n\\r\]+_foo\.cold\.0:" { target *-*-darwin* } } } */
diff --git a/gcc/testsuite/gcc.dg/tree-prof/section-attr-3.c b/gcc/testsuite/gcc.dg/tree-prof/section-attr-3.c
index 36829dcb7a0..29eee4587d6 100644
--- a/gcc/testsuite/gcc.dg/tree-prof/section-attr-3.c
+++ b/gcc/testsuite/gcc.dg/tree-prof/section-attr-3.c
@@ -9,7 +9,11 @@
 #define NOINLINE __attribute__((noinline)) __attribute__ ((noclone))
 
 const char *sarr[SIZE];
+#ifdef __APPLE__
+const char *buf_hot __attribute__ ((section ("__DATA,__data")));
+#else
 const char *buf_hot __attribute__ ((section (".data")));
+#endif
 const char *buf_cold;
 
 void foo (int path);
@@ -43,3 +47,4 @@ foo (int path)
 }
 
 /* { dg-final-use { scan-assembler "\.section\[\t \]*\.text\.unlikely\[\\n\\r\]+\[\t \]*\.size\[\t \]*foo\.cold\.0" { target *-*-linux* *-*-gnu* } } } */
+/* { dg-final-use { scan-assembler "\.section\[\t \]*__TEXT,__text_cold\.\*\[\\n\\r\]+_foo\.cold\.0:" { target *-*-darwin* } } } */
diff --git a/gcc/testsuite/gcc.dg/tree-ssa/vrp119.c b/gcc/testsuite/gcc.dg/tree-ssa/vrp119.c
new file mode 100644
index 00000000000..92c490e542c
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/tree-ssa/vrp119.c
@@ -0,0 +1,20 @@
+/* PR tree-optimization/86231 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-vrp1" } */
+/* { dg-final { scan-tree-dump-not "link_error" "vrp1" } } */
+
+int bar (int);
+void link_error (void);
+
+int
+foo (int x, int y, int z)
+{
+  if (x < 4 || x > 8) __builtin_unreachable ();
+  if (y >= 2 && y <= 6) __builtin_unreachable ();
+  /* x is [4, 8], y is ~[2, 6], resulting range of e should be ~[2, 3].  */
+  int e = (z ? x : y);
+  bar (bar (bar (bar (bar (bar (bar (bar (bar (bar (bar (bar (e))))))))))));
+  if (e == 2 || e == 3)
+    link_error ();
+  return e;
+}
diff --git a/gcc/testsuite/gcc.dg/ubsan/bounds-3.c b/gcc/testsuite/gcc.dg/ubsan/bounds-3.c
index 50ad67389f8..c9d896d1903 100644
--- a/gcc/testsuite/gcc.dg/ubsan/bounds-3.c
+++ b/gcc/testsuite/gcc.dg/ubsan/bounds-3.c
@@ -1,6 +1,7 @@
 /* PR sanitizer/70875 */
 /* { dg-do run } */
-/* { dg-options "-fsanitize=bounds" } */
+/* { dg-options "-fsanitize=bounds -fno-sanitize-recover=bounds" } */
+/* { dg-shouldfail "ubsan" } */
 
 int
 foo (int n, int k)
diff --git a/gcc/testsuite/gcc.dg/vect/pr84485.c b/gcc/testsuite/gcc.dg/vect/pr84485.c
new file mode 100644
index 00000000000..ad25d3642c8
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/vect/pr84485.c
@@ -0,0 +1,34 @@
+/* { dg-do run } */
+
+#include "tree-vect.h"
+
+#define N 256
+
+void __attribute__ ((noinline, noclone))
+f (unsigned long incx, unsigned long incy,
+   float *restrict dx, float *restrict dy)
+{
+  unsigned long ix = 0, iy = 0;
+  for (unsigned long i = 0; i < N; ++i)
+    {
+      dy[iy] += dx[ix];
+      ix += incx;
+      iy += incy;
+    }
+}
+
+float a = 0.0;
+float b[N];
+
+int
+main (void)
+{
+  check_vect ();
+
+  for (int i = 0; i < N; ++i)
+    b[i] = i;
+  f (1, 0, b, &a);
+  if (a != N * (N - 1) / 2)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/vect/pr85597.c b/gcc/testsuite/gcc.dg/vect/pr85597.c
new file mode 100644
index 00000000000..cf615f9c464
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/vect/pr85597.c
@@ -0,0 +1,26 @@
+/* { dg-do compile } */
+/* { dg-options "-O3" } */
+/* { dg-additional-options "-mfma" { target { x86_64-*-* i?86-*-* } } } */
+
+extern double fma (double, double, double);
+
+static inline void
+bar (int i, double *D, double *S)
+{
+  while (i-- > 0)
+    {
+      D[0] = fma (1, S[0], D[0]);
+      D[1] = fma (1, S[1], D[1]);
+      D[2] = fma (1, S[2], D[2]);
+      D[3] = fma (1, S[3], D[3]);
+      D += 4;
+      S += 4;
+    }
+}
+
+void
+foo (double *d, double *s)
+{
+  bar (10, d, s);
+}
+
diff --git a/gcc/testsuite/gcc.target/aarch64/pr63304_1.c b/gcc/testsuite/gcc.target/aarch64/pr63304_1.c
index c917f81c022..fa0fb56d9e1 100644
--- a/gcc/testsuite/gcc.target/aarch64/pr63304_1.c
+++ b/gcc/testsuite/gcc.target/aarch64/pr63304_1.c
@@ -1,5 +1,5 @@
 /* { dg-do assemble } */
-/* { dg-options "-O1 --save-temps -mno-fix-cortex-a53-843419" } */
+/* { dg-options "-O1 --save-temps" } */
 #pragma GCC push_options
 #pragma GCC target ("+nothing+simd, cmodel=small")
 
diff --git a/gcc/testsuite/gcc.target/aarch64/pr81647.c b/gcc/testsuite/gcc.target/aarch64/pr81647.c
new file mode 100644
index 00000000000..2d764030dc8
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/pr81647.c
@@ -0,0 +1,45 @@
+/* { dg-do run } */
+/* { dg-options "-O3 -fdump-tree-ssa" } */
+/* { dg-require-effective-target fenv_exceptions } */
+
+#include <fenv.h>
+
+double x[28], y[28];
+int res[28];
+
+int
+main (void)
+{
+  int i;
+  for (i = 0; i < 28; ++i)
+    {
+      x[i] = __builtin_nan ("");
+      y[i] = i;
+    }
+  __asm__ volatile ("" ::: "memory");
+  feclearexcept (FE_ALL_EXCEPT);
+  for (i = 0; i < 4; ++i)
+    res[i] = __builtin_isgreater (x[i], y[i]);
+  for (i = 4; i < 8; ++i)
+    res[i] = __builtin_isgreaterequal (x[i], y[i]);
+  for (i = 8; i < 12; ++i)
+    res[i] = __builtin_isless (x[i], y[i]);
+  for (i = 12; i < 16; ++i)
+    res[i] = __builtin_islessequal (x[i], y[i]);
+  for (i = 16; i < 20; ++i)
+    res[i] = __builtin_islessgreater (x[i], y[i]);
+  for (i = 20; i < 24; ++i)
+    res[i] = __builtin_isunordered (x[i], y[i]);
+  for (i = 24; i < 28; ++i)
+    res[i] = !(__builtin_isunordered (x[i], y[i]));
+  __asm__ volatile ("" ::: "memory");
+  return fetestexcept (FE_ALL_EXCEPT) != 0;
+}
+
+/* { dg-final { scan-tree-dump " u> " "ssa" } } */
+/* { dg-final { scan-tree-dump " u>= " "ssa" } } */
+/* { dg-final { scan-tree-dump " u< " "ssa" } } */
+/* { dg-final { scan-tree-dump " u<= " "ssa" } } */
+/* { dg-final { scan-tree-dump " u== " "ssa" } } */
+/* { dg-final { scan-tree-dump " unord " "ssa" } } */
+/* { dg-final { scan-tree-dump " ord " "ssa" } } */
diff --git a/gcc/testsuite/gcc.target/aarch64/pr83370.c b/gcc/testsuite/gcc.target/aarch64/pr83370.c
new file mode 100644
index 00000000000..001373c4d39
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/pr83370.c
@@ -0,0 +1,22 @@
+/* { dg-do run } */
+/* { dg-options "-O2" } */
+
+typedef void (*fun) (void);
+
+void
+f (fun x1)
+{
+  register fun x2 asm ("x16");
+  int arr[5000];
+  int *volatile ptr = arr;
+  asm ("mov %0, %1" : "=r" (x2) : "r" (x1));
+  x2 ();
+}
+
+void g (void) {}
+
+int
+main (void)
+{
+  f (g);
+}
diff --git a/gcc/testsuite/gcc.target/aarch64/pr87511.c b/gcc/testsuite/gcc.target/aarch64/pr87511.c
new file mode 100644
index 00000000000..98064701594
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/pr87511.c
@@ -0,0 +1,16 @@
+/* { dg-do assemble } */
+/* { dg-options "-Os" } */
+
+int a, d;
+struct {
+  signed f5 : 26;
+  signed f6 : 12;
+} b;
+signed char c;
+void fn1() {
+  signed char *e = &c;
+  d = a * 10;
+  *e = d;
+  b.f6 = c;
+  b.f5 = 8 <= 3;
+}
diff --git a/gcc/testsuite/gcc.target/aarch64/pr90075.c b/gcc/testsuite/gcc.target/aarch64/pr90075.c
new file mode 100644
index 00000000000..cae7e618fc0
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/pr90075.c
@@ -0,0 +1,21 @@
+/* { dg-do compile } */
+/* { dg-additional-options "-O1" } */
+
+typedef struct {
+  float one, two;
+} twofloats;
+
+float
+bug (twofloats tf)
+{
+  float f1, f2;
+  union {
+    twofloats tfloats;
+    float arr[2];
+  } utfloats;
+
+  utfloats.tfloats = tf;
+  f1 = utfloats.arr[1];
+  f2 = __builtin_copysignf (0, f1);
+  return f2;
+}
diff --git a/gcc/testsuite/gcc.target/arm/arm-soft-strd-even.c b/gcc/testsuite/gcc.target/arm/arm-soft-strd-even.c
new file mode 100644
index 00000000000..4ef3dd8be39
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/arm-soft-strd-even.c
@@ -0,0 +1,19 @@
+/* { dg-do assemble } */
+/* { dg-require-effective-target arm_arm_ok } */
+/* { dg-skip-if "do not override -mfloat-abi" { *-*-* } { "-mfloat-abi=*" } {"-mfloat-abi=soft" } } */
+/* { dg-options "-O2 -marm -mfloat-abi=soft" } */
+
+/* Check that we don't try to emit STRD in ARM state with
+   odd starting register.  */
+
+struct S {
+  double M0;
+} __attribute((aligned)) __attribute((packed));
+
+void bar(void *);
+
+void foo(int x, struct S y) {
+  asm("" : : : "r1", "r8", "r7", "r4");
+  y.M0 ?: bar(0);
+  bar(__builtin_alloca(8));
+}
diff --git a/gcc/testsuite/gcc.target/arm/cmse/cmse-1.c b/gcc/testsuite/gcc.target/arm/cmse/cmse-1.c
index c13272eed68..f764153cb17 100644
--- a/gcc/testsuite/gcc.target/arm/cmse/cmse-1.c
+++ b/gcc/testsuite/gcc.target/arm/cmse/cmse-1.c
@@ -71,6 +71,20 @@ baz (void)
 {
   return cmse_nonsecure_caller ();
 }
+/* { dg-final { scan-assembler "baz:" } } */
+/* { dg-final { scan-assembler "__acle_se_baz:" } } */
+/* { dg-final { scan-assembler-not "\tcmse_nonsecure_caller" } } */
+/* Look for an andsi of 1 with a register in function baz, ie.
+
+;; Function baz<anything>
+<any line without '('>
+(insn <anything but '('> (set (reg<any register modifier>:SI <anything but ')'>)
+     (and:SI (reg<any register modifier>:SI <anything but ')'>)
+	     (const_int 1 <anything but ')'>)<anything but '('>
+   <optional: (nil)<anything but '('>>
+(insn
+*/
+/* { dg-final { scan-rtl-dump "\n;; Function baz\[^\n\]*\[^(\]+\[^;\]*\n\\(insn \[^(\]+ \\(set \\(reg\[^:\]*:SI \[^)\]+\\)\[^(\]*\\(and:SI \\(reg\[^:\]*:SI \[^)\]+\\)\[^(\]*\\((const_int 1|reg\[^:\]*:SI) \[^)\]+\\)\[^(\]+(\\(nil\\)\[^(\]+)?\\(insn" expand } } */
 
 typedef int __attribute__ ((cmse_nonsecure_call)) (int_nsfunc_t) (void);
 
@@ -86,6 +100,11 @@ qux (int_nsfunc_t * callback)
 {
   fp = cmse_nsfptr_create (callback);
 }
+/* { dg-final { scan-assembler "qux:" } } */
+/* { dg-final { scan-assembler "__acle_se_qux:" } } */
+/* { dg-final { scan-assembler "bic" } } */
+/* { dg-final { scan-assembler "push\t\{r4, r5, r6" } } */
+/* { dg-final { scan-assembler "msr\tAPSR_nzcvq" } } */
 
 int call_callback (void)
 {
@@ -94,13 +113,4 @@ int call_callback (void)
   else
     return default_callback ();
 }
-/* { dg-final { scan-assembler "baz:" } } */
-/* { dg-final { scan-assembler "__acle_se_baz:" } } */
-/* { dg-final { scan-assembler "qux:" } } */
-/* { dg-final { scan-assembler "__acle_se_qux:" } } */
-/* { dg-final { scan-assembler-not "\tcmse_nonsecure_caller" } } */
-/* { dg-final { scan-rtl-dump "and.*reg.*const_int 1" expand } } */
-/* { dg-final { scan-assembler "bic" } } */
-/* { dg-final { scan-assembler "push\t\{r4, r5, r6" } } */
-/* { dg-final { scan-assembler "msr\tAPSR_nzcvq" } } */
 /* { dg-final { scan-assembler-times "bl\\s+__gnu_cmse_nonsecure_call" 1 } } */
diff --git a/gcc/testsuite/gcc.target/arm/cmse/cmse-16.c b/gcc/testsuite/gcc.target/arm/cmse/cmse-16.c
new file mode 100644
index 00000000000..3fb0380afaa
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/cmse/cmse-16.c
@@ -0,0 +1,18 @@
+/* { dg-do run } */
+/* { dg-options "-Os -mcmse" }  */
+
+#include <arm_cmse.h>
+
+int
+foo (void)
+{
+  return cmse_nonsecure_caller ();
+}
+
+int
+main (void)
+{
+  /* Return success (0) if main is secure, ie if cmse_nonsecure_caller/foo
+     returns false (0).  */
+  return foo ();
+}
diff --git a/gcc/testsuite/gcc.target/arm/cmse/cmse-1c99.c b/gcc/testsuite/gcc.target/arm/cmse/cmse-1c99.c
new file mode 100644
index 00000000000..0f99dd341b7
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/cmse/cmse-1c99.c
@@ -0,0 +1,4 @@
+/* { dg-do compile } */
+/* { dg-options "-Os -mcmse -std=c99" }  */
+/* This is a copy of cmse-1.c to test arm_mve.h ISO C compatibility.  */
+#include "cmse-1.c"
diff --git a/gcc/testsuite/gcc.target/arm/f16_f64_conv_no_dp.c b/gcc/testsuite/gcc.target/arm/f16_f64_conv_no_dp.c
new file mode 100644
index 00000000000..2620e570004
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/f16_f64_conv_no_dp.c
@@ -0,0 +1,16 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_fp16_ok } */
+/* { dg-skip-if "do not override fpu" { *-*-* } { "-mfpu=*" } { "-mfpu=fpv5-sp-d16" } } */
+/* { dg-skip-if "do not disable fpu" { *-*-* } { "-mfloat-abi=soft" } { * } } */
+/* { dg-skip-if "do not override fp16-format" { *-*-* } { "-mfp16-format=*" } { "-mfp16-format=ieee" } } */
+/* { dg-options "-O1 -mfpu=fpv5-sp-d16 -mfloat-abi=hard -mfp16-format=ieee" } */
+
+__fp16 foo (double a)
+{
+  return a;
+}
+
+double bar (__fp16 a)
+{
+  return a;
+}
diff --git a/gcc/testsuite/gcc.target/arm/fpscr.c b/gcc/testsuite/gcc.target/arm/fpscr.c
index 7b4d71d72d8..4c3eaf7fcf7 100644
--- a/gcc/testsuite/gcc.target/arm/fpscr.c
+++ b/gcc/testsuite/gcc.target/arm/fpscr.c
@@ -6,11 +6,14 @@
 /* { dg-add-options arm_fp } */
 
 void
-test_fpscr ()
+test_fpscr (void)
 {
-  volatile unsigned int status = __builtin_arm_get_fpscr ();
+  unsigned status;
+
+  __builtin_arm_set_fpscr (0);
+  status = __builtin_arm_get_fpscr ();
   __builtin_arm_set_fpscr (status);
 }
 
 /* { dg-final { scan-assembler "mrc\tp10, 7, r\[0-9\]+, cr1, cr0, 0" } } */
-/* { dg-final { scan-assembler "mcr\tp10, 7, r\[0-9\]+, cr1, cr0, 0" } } */
+/* { dg-final { scan-assembler-times "mcr\tp10, 7, r\[0-9\]+, cr1, cr0, 0" 2 } } */
diff --git a/gcc/testsuite/gcc.target/arm/pr82518.c b/gcc/testsuite/gcc.target/arm/pr82518.c
new file mode 100644
index 00000000000..ce820b78a8d
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/pr82518.c
@@ -0,0 +1,29 @@
+/* { dg-do run } */
+/* { dg-require-effective-target arm_neon_hw } */
+/* { dg-additional-options "-O3 -fno-inline -std=gnu99" } */
+/* { dg-add-options arm_neon } */
+
+typedef struct { int x, y; } X;
+
+void f4(X *p, int n)
+{
+  for (int i = 0; i < n; i++)
+  { p[i].x = i;
+    p[i].y = i + 1;
+  }
+}
+
+__attribute ((aligned (16))) X arr[100];
+
+int main(void)
+{
+  volatile int fail = 0;
+  f4 (arr, 100);
+  for (int i = 0; i < 100; i++)
+    if (arr[i].y != i+1 || arr[i].x != i)
+      fail = 1;
+  if (fail)
+     __builtin_abort ();
+
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/arm/pr82989.c b/gcc/testsuite/gcc.target/arm/pr82989.c
new file mode 100644
index 00000000000..8519c3fdc82
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/pr82989.c
@@ -0,0 +1,33 @@
+/* PR target/82989.  */
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_neon_ok } */
+/* { dg-skip-if "avoid conflicts with multilib options" { *-*-* } { "-mcpu=*" } { "-mcpu=cortex-a8" } } */
+/* { dg-skip-if "avoid conflicts with multilib options" { *-*-* } { "-mfpu=*" } { "-mfpu=neon" } } */
+/* { dg-skip-if "avoid conflicts with multilib options" { *-*-* } { "-mfloat-abi=*" } { "-mfloat-abi=hard" } } */
+/* { dg-options "-O2 -mcpu=cortex-a8 -mfpu=neon -mfloat-abi=hard" } */
+/* { dg-add-options arm_neon } */
+
+typedef unsigned long long uint64_t;
+
+void f_shr_imm (uint64_t *a)
+{
+  *a += *a >> 32;
+}
+
+void f_shr_reg (uint64_t *a, uint64_t b)
+{
+  *a += *a >> b;
+}
+
+void f_shl_imm (uint64_t *a)
+{
+  *a += *a << 32;
+}
+
+void f_shl_reg (uint64_t *a, uint64_t b)
+{
+  *a += *a << b;
+}
+/* { dg-final { scan-assembler-not "vshl*" } } */
+/* { dg-final { scan-assembler-not "vshr*" } } */
+/* { dg-final { scan-assembler-not "vmov*" } } */
diff --git a/gcc/testsuite/gcc.target/arm/pr84826.c b/gcc/testsuite/gcc.target/arm/pr84826.c
new file mode 100644
index 00000000000..563ce51b76f
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/pr84826.c
@@ -0,0 +1,16 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_thumb2_ok } */
+/* { dg-options "-Ofast -fstack-check" } */
+
+void d (void *);
+
+void a ()
+{
+  int b;
+  void bar (int c)
+  {
+    if (__builtin_expect (c, 0))
+      ++b;
+  }
+  d (bar);
+}
diff --git a/gcc/testsuite/gcc.target/arm/pr88648-asm-syntax-unified.c b/gcc/testsuite/gcc.target/arm/pr88648-asm-syntax-unified.c
new file mode 100644
index 00000000000..251b4d5bc9d
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/pr88648-asm-syntax-unified.c
@@ -0,0 +1,14 @@
+/* Test for unified syntax assembly generation.  */
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_arch_v7a_ok } */
+/* { dg-add-options arm_arch_v7a } */
+/* { dg-options "-marm -march=armv7-a -masm-syntax-unified" } */
+
+void test ()
+{
+  asm("nop");
+}
+
+/* { dg-final { scan-assembler-times {\.syntax\sunified} 3 } } */
+/* { dg-final { scan-assembler-not {\.syntax\sdivided} } } */
+
diff --git a/gcc/testsuite/gcc.target/avr/pr88253.c b/gcc/testsuite/gcc.target/avr/pr88253.c
new file mode 100644
index 00000000000..7fa7e4efc69
--- /dev/null
+++ b/gcc/testsuite/gcc.target/avr/pr88253.c
@@ -0,0 +1,16 @@
+/* { dg-do compile } */
+/* { dg-options "-Os -w" } */
+ 
+static int aRead() __attribute__((always_inline));
+static int aRead() {
+    unsigned char h,l;
+    l = (*(volatile unsigned char *)(0x78)) ;
+    h = (*(volatile unsigned char *)(0x79)) ;
+    return (h<<8) | l;
+}
+ 
+int main() {
+    volatile unsigned char x;
+     x = aRead()^42;
+ }
+ /* { dg-final { scan-assembler "lds r\\d+,121" } } */
diff --git a/gcc/testsuite/gcc.target/i386/avx512bw-pr84524.c b/gcc/testsuite/gcc.target/i386/avx512bw-pr84524.c
new file mode 100644
index 00000000000..536e81e17db
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/avx512bw-pr84524.c
@@ -0,0 +1,14 @@
+/* PR target/84524 */
+/* { dg-do run { target avx512bw } } */
+/* { dg-options "-O3 -mavx512bw" } */
+
+#include "avx512bw-check.h"
+
+#define main() do_main()
+#include "../../gcc.c-torture/execute/pr84524.c"
+
+static void
+avx512bw_test (void)
+{
+  do_main ();
+}
diff --git a/gcc/testsuite/gcc.target/i386/avx512f-abspd-1.c b/gcc/testsuite/gcc.target/i386/avx512f-abspd-1.c
index 14ed0374444..1b6872151d8 100644
--- a/gcc/testsuite/gcc.target/i386/avx512f-abspd-1.c
+++ b/gcc/testsuite/gcc.target/i386/avx512f-abspd-1.c
@@ -6,11 +6,11 @@
 
 #include "avx512f-helper.h"
 
-#define SIZE (AVX512F_LEN / 32)
+#define SIZE (AVX512F_LEN / 64)
 #include "avx512f-mask-type.h"
 
 static void
-CALC (float *i1, float *r)
+CALC (double *i1, double *r)
 {
   int i;
 
@@ -24,27 +24,27 @@ CALC (float *i1, float *r)
 void
 TEST (void)
 {
-  float ck[SIZE];
+  double ck[SIZE];
   int i;
-  UNION_TYPE (AVX512F_LEN, ) s, d, dm;
+  UNION_TYPE (AVX512F_LEN, d) s, d, dm;
   MASK_TYPE mask = MASK_VALUE;
 
   for (i = 0; i < SIZE; i++)
     {
-      s.a[i] = i * ((i & 1) ? 3.5f : -7.5f);
+      s.a[i] = i * ((i & 1) ? 3.5 : -7.5);
       d.a[i] = DEFAULT_VALUE;
       dm.a[i] = DEFAULT_VALUE;
     }
 
   CALC (s.a, ck);
 
-  d.x = INTRINSIC (_abs_ps) (s.x);
-  dm.x = INTRINSIC (_mask_abs_ps) (dm.x, mask, s.x);
+  d.x = INTRINSIC (_abs_pd) (s.x);
+  dm.x = INTRINSIC (_mask_abs_pd) (dm.x, mask, s.x);
 
-  if (UNION_CHECK (AVX512F_LEN, ) (d, ck))
+  if (UNION_CHECK (AVX512F_LEN, d) (d, ck))
     abort ();
 
-  MASK_MERGE () (ck, mask, SIZE);
-  if (UNION_CHECK (AVX512F_LEN, ) (dm, ck))
+  MASK_MERGE (d) (ck, mask, SIZE);
+  if (UNION_CHECK (AVX512F_LEN, d) (dm, ck))
     abort ();
 }
diff --git a/gcc/testsuite/gcc.target/i386/avx512f-pr84786-1.c b/gcc/testsuite/gcc.target/i386/avx512f-pr84786-1.c
new file mode 100644
index 00000000000..d57b53b7e36
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/avx512f-pr84786-1.c
@@ -0,0 +1,25 @@
+/* PR target/84786 */
+/* { dg-do run { target { ! ia32 } } } */
+/* { dg-options "-mavx512f -mno-avx512vl -O2" } */
+/* { dg-require-effective-target avx512f } */
+
+#include "avx512f-check.h"
+
+typedef double V __attribute__((vector_size (16)));
+
+__attribute__((noinline, noclone)) V
+foo (V x, double y)
+{
+  register double z __asm ("xmm18");
+  asm volatile ("" : "=v" (z) : "0" (y));
+  x[1] = z;
+  return x;
+}
+
+static void
+avx512f_test (void)
+{
+  V a = foo ((V) { 1.0, 2.0 }, 3.0);
+  if (a[0] != 1.0 || a[1] != 3.0)
+    abort ();
+}
diff --git a/gcc/testsuite/gcc.target/i386/avx512f-pr84786-2.c b/gcc/testsuite/gcc.target/i386/avx512f-pr84786-2.c
new file mode 100644
index 00000000000..5ac28aa4a47
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/avx512f-pr84786-2.c
@@ -0,0 +1,16 @@
+/* PR target/84786 */
+/* { dg-do compile { target { ! ia32 } } } */
+/* { dg-options "-mavx512f -mno-avx512vl -O2" } */
+
+typedef double V __attribute__((vector_size (16)));
+
+__attribute__((noinline, noclone)) V
+foo (V x, double y)
+{
+  register double z __asm ("xmm18");
+  asm volatile ("" : "=v" (z) : "0" (y));
+  x[1] = z;
+  return x;
+}
+
+/* { dg-final { scan-assembler-not "vunpcklpd\[\^\n\r]*xmm(1\[6-9]|\[23]\[0-9])" } } */
diff --git a/gcc/testsuite/gcc.target/i386/avx512f-pr84786-3.c b/gcc/testsuite/gcc.target/i386/avx512f-pr84786-3.c
new file mode 100644
index 00000000000..4d125b9933f
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/avx512f-pr84786-3.c
@@ -0,0 +1,50 @@
+/* PR target/84786 */
+/* { dg-do compile { target { ! ia32 } } } */
+/* { dg-options "-mavx512f -mno-avx512vl -O2" } */
+
+#include <x86intrin.h>
+
+__m512i v;
+__m128i w;
+
+__m128i
+foo (__m128i x, int y)
+{
+  __m128i z;
+#define A(n) register __m512i zmm##n __asm ("zmm" #n);
+#define B A(1) A(2) A(3) A(4) A(5) A(6) A(7) \
+	  A(8) A(9) A(10) A(11) A(12) A(13) A(14)
+  B
+#undef A
+#define A(n) asm volatile ("" : "=v" (zmm##n) : "0" (v));
+  B
+  asm volatile ("" : "=x" (z) : "0" (w));
+  x = _mm_srli_epi16 (x, y);
+  asm volatile ("" : : "x" (z));
+#undef A
+#define A(n) asm volatile ("" : : "v" (zmm##n));
+  B
+  return x;
+}
+
+__m256i
+bar (__m256i x, int y)
+{
+  __m128i z;
+#undef A
+#define A(n) register __m512i zmm##n __asm ("zmm" #n);
+  B
+#undef A
+#define A(n) asm volatile ("" : "=v" (zmm##n) : "0" (v));
+  B
+  asm volatile ("" : "=x" (z) : "0" (w));
+  x = _mm256_slli_epi16 (x, y);
+  asm volatile ("" : : "x" (z));
+#undef A
+#define A(n) asm volatile ("" : : "v" (zmm##n));
+  B
+  return x;
+}
+
+/* { dg-final { scan-assembler-not "vpsrlw\[\^\n\r]*xmm(1\[6-9]|\[23]\[0-9])" } } */
+/* { dg-final { scan-assembler-not "vpsllw\[\^\n\r]*xmm(1\[6-9]|\[23]\[0-9])" } } */
diff --git a/gcc/testsuite/gcc.target/i386/avx512f-vcvtusi2sd64-1.c b/gcc/testsuite/gcc.target/i386/avx512f-vcvtusi2sd64-1.c
index 8675450f0c4..66476c3013f 100644
--- a/gcc/testsuite/gcc.target/i386/avx512f-vcvtusi2sd64-1.c
+++ b/gcc/testsuite/gcc.target/i386/avx512f-vcvtusi2sd64-1.c
@@ -1,7 +1,7 @@
 /* { dg-do compile { target { ! ia32 } } } */
 /* { dg-options "-mavx512f -O2" } */
-/* { dg-final { scan-assembler-times "vcvtusi2sd\[ \\t\]+\[^\{\n\]*%xmm\[0-9\]+(?:\n|\[ \\t\]+#)" 1 } } */
-/* { dg-final { scan-assembler-times "vcvtusi2sd\[ \\t\]+\[^%\n\]*%r\[^\{\n\]*\{ru-sae\}\[^\{\n\]*%xmm\[0-9\]+(?:\n|\[ \\t\]+#)" 1 } } */
+/* { dg-final { scan-assembler-times "vcvtusi2sdq\[ \\t\]+\[^\{\n\]*%xmm\[0-9\]+(?:\n|\[ \\t\]+#)" 1 } } */
+/* { dg-final { scan-assembler-times "vcvtusi2sdq\[ \\t\]+\[^%\n\]*%r\[^\{\n\]*\{ru-sae\}\[^\{\n\]*%xmm\[0-9\]+(?:\n|\[ \\t\]+#)" 1 } } */
 
 #include <immintrin.h>
 
diff --git a/gcc/testsuite/gcc.target/i386/avx512f-vcvtusi2ss64-1.c b/gcc/testsuite/gcc.target/i386/avx512f-vcvtusi2ss64-1.c
index 38ecf39ad65..f4dae536873 100644
--- a/gcc/testsuite/gcc.target/i386/avx512f-vcvtusi2ss64-1.c
+++ b/gcc/testsuite/gcc.target/i386/avx512f-vcvtusi2ss64-1.c
@@ -1,7 +1,7 @@
 /* { dg-do compile { target { ! ia32 } } } */
 /* { dg-options "-mavx512f -O2" } */
-/* { dg-final { scan-assembler-times "vcvtusi2ss\[ \\t\]+\[^\{\n\]*%xmm\[0-9\]+(?:\n|\[ \\t\]+#)" 1 } } */
-/* { dg-final { scan-assembler-times "vcvtusi2ss\[ \\t\]+\[^%\n\]*%r\[^\{\n\]*\{rz-sae\}\[^\{\n\]*%xmm\[0-9\]+(?:\n|\[ \\t\]+#)" 1 } } */
+/* { dg-final { scan-assembler-times "vcvtusi2ssq\[ \\t\]+\[^\{\n\]*%xmm\[0-9\]+(?:\n|\[ \\t\]+#)" 1 } } */
+/* { dg-final { scan-assembler-times "vcvtusi2ssq\[ \\t\]+\[^%\n\]*%r\[^\{\n\]*\{rz-sae\}\[^\{\n\]*%xmm\[0-9\]+(?:\n|\[ \\t\]+#)" 1 } } */
 
 #include <immintrin.h>
 
diff --git a/gcc/testsuite/gcc.target/i386/avx512f-vpermd-2.c b/gcc/testsuite/gcc.target/i386/avx512f-vpermd-2.c
index dbd4544c39e..b36a9c2da0a 100644
--- a/gcc/testsuite/gcc.target/i386/avx512f-vpermd-2.c
+++ b/gcc/testsuite/gcc.target/i386/avx512f-vpermd-2.c
@@ -41,18 +41,14 @@ TEST (void)
       res3.a[i] = DEFAULT_VALUE;
     }
 
-#if AVX512F_LEN == 512
   res1.x = INTRINSIC (_permutexvar_epi32) (src1.x, src2.x);
-#endif
   res2.x = INTRINSIC (_maskz_permutexvar_epi32) (mask, src1.x, src2.x);
   res3.x = INTRINSIC (_mask_permutexvar_epi32) (res3.x, mask, src1.x, src2.x);
 
   CALC (src1.a, src2.a, res_ref);
 
-#if AVX512F_LEN == 512
   if (UNION_CHECK (AVX512F_LEN, i_d) (res1, res_ref))
     abort ();
-#endif
 
   MASK_ZERO (i_d) (res_ref, mask, SIZE);
   if (UNION_CHECK (AVX512F_LEN, i_d) (res2, res_ref))
diff --git a/gcc/testsuite/gcc.target/i386/avx512f-vpermq-imm-2.c b/gcc/testsuite/gcc.target/i386/avx512f-vpermq-imm-2.c
index 770d5623f5f..dd88cd46c0b 100644
--- a/gcc/testsuite/gcc.target/i386/avx512f-vpermq-imm-2.c
+++ b/gcc/testsuite/gcc.target/i386/avx512f-vpermq-imm-2.c
@@ -40,18 +40,14 @@ TEST (void)
       res3.a[i] = DEFAULT_VALUE;
     }
 
-#if AVX512F_LEN == 512
   res1.x = INTRINSIC (_permutex_epi64) (src1.x, IMM_MASK);
-#endif
   res2.x = INTRINSIC (_maskz_permutex_epi64) (mask, src1.x, IMM_MASK);
   res3.x = INTRINSIC (_mask_permutex_epi64) (res3.x, mask, src1.x, IMM_MASK);
 
   CALC (src1.a, IMM_MASK, res_ref);
 
-#if AVX512F_LEN == 512
   if (UNION_CHECK (AVX512F_LEN, i_q) (res1, res_ref))
     abort ();
-#endif
 
   MASK_ZERO (i_q) (res_ref, mask, SIZE);
   if (UNION_CHECK (AVX512F_LEN, i_q) (res2, res_ref))
diff --git a/gcc/testsuite/gcc.target/i386/avx512f-vpermq-var-2.c b/gcc/testsuite/gcc.target/i386/avx512f-vpermq-var-2.c
index c596b1d9c40..6c222888e88 100644
--- a/gcc/testsuite/gcc.target/i386/avx512f-vpermq-var-2.c
+++ b/gcc/testsuite/gcc.target/i386/avx512f-vpermq-var-2.c
@@ -41,18 +41,14 @@ TEST (void)
       res3.a[i] = DEFAULT_VALUE;
     }
 
-#if AVX512F_LEN == 512
   res1.x = INTRINSIC (_permutexvar_epi64) (src1.x, src2.x);
-#endif
   res2.x = INTRINSIC (_maskz_permutexvar_epi64) (mask, src1.x, src2.x);
   res3.x = INTRINSIC (_mask_permutexvar_epi64) (res3.x, mask, src1.x, src2.x);
 
   CALC (src1.a, src2.a, res_ref);
 
-#if AVX512F_LEN == 512
   if (UNION_CHECK (AVX512F_LEN, i_q) (res1, res_ref))
     abort ();
-#endif
 
   MASK_ZERO (i_q) (res_ref, mask, SIZE);
   if (UNION_CHECK (AVX512F_LEN, i_q) (res2, res_ref))
diff --git a/gcc/testsuite/gcc.target/i386/avx512vl-vpermd-1.c b/gcc/testsuite/gcc.target/i386/avx512vl-vpermd-1.c
index fa1aaa390ab..069bb5d6c63 100644
--- a/gcc/testsuite/gcc.target/i386/avx512vl-vpermd-1.c
+++ b/gcc/testsuite/gcc.target/i386/avx512vl-vpermd-1.c
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
 /* { dg-options "-mavx512vl -O2" } */
+/* { dg-final { scan-assembler-times "vpermd\[ \\t\]+\[^\{\n\]*%ymm\[0-9\](?:\n|\[ \\t\]+#)" 1 } } */
 /* { dg-final { scan-assembler-times "vpermd\[ \\t\]+\[^\{\n\]*%ymm\[0-9\]+\{%k\[1-7\]\}\{z\}(?:\n|\[ \\t\]+#)" 1 } } */
 /* { dg-final { scan-assembler-times "vpermd\[ \\t\]+\[^\{\n\]*%ymm\[0-9\]+\{%k\[1-7\]\}(?:\n|\[ \\t\]+#)" 1 } } */
 
@@ -11,6 +12,7 @@ volatile __mmask8 m;
 void extern
 avx512vl_test (void)
 {
+  x = _mm256_permutexvar_epi32 (x, x);
   x = _mm256_maskz_permutexvar_epi32 (m, x, x);
   x = _mm256_mask_permutexvar_epi32 (x, m, x, x);
 }
diff --git a/gcc/testsuite/gcc.target/i386/avx512vl-vpermq-imm-1.c b/gcc/testsuite/gcc.target/i386/avx512vl-vpermq-imm-1.c
index c74c8ce96c7..2340a6d9993 100644
--- a/gcc/testsuite/gcc.target/i386/avx512vl-vpermq-imm-1.c
+++ b/gcc/testsuite/gcc.target/i386/avx512vl-vpermq-imm-1.c
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
 /* { dg-options "-mavx512vl -O2" } */
+/* { dg-final { scan-assembler-times "vpermq\[ \\t\]+\[^\{\n\]*%ymm\[0-9\](?:\n|\[ \\t\]+#)" 1 } } */
 /* { dg-final { scan-assembler-times "vpermq\[ \\t\]+\[^\{\n\]*%ymm\[0-9\]+\{%k\[1-7\]\}(?:\n|\[ \\t\]+#)" 1 } } */
 /* { dg-final { scan-assembler-times "vpermq\[ \\t\]+\[^\{\n\]*%ymm\[0-9\]+\{%k\[1-7\]\}\{z\}(?:\n|\[ \\t\]+#)" 1 } } */
 
@@ -11,6 +12,7 @@ volatile __mmask8 m;
 void extern
 avx512vl_test (void)
 {
+  x = _mm256_permutex_epi64 (x, 13);
   x = _mm256_mask_permutex_epi64 (x, m, x, 13);
   x = _mm256_maskz_permutex_epi64 (m, x, 13);
 }
diff --git a/gcc/testsuite/gcc.target/i386/avx512vl-vpermq-var-1.c b/gcc/testsuite/gcc.target/i386/avx512vl-vpermq-var-1.c
index 43ccad3d6c1..69185e50f76 100644
--- a/gcc/testsuite/gcc.target/i386/avx512vl-vpermq-var-1.c
+++ b/gcc/testsuite/gcc.target/i386/avx512vl-vpermq-var-1.c
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
 /* { dg-options "-mavx512vl -O2" } */
+/* { dg-final { scan-assembler-times "vpermq\[ \\t\]+\[^\{\n\]*%ymm\[0-9\](?:\n|\[ \\t\]+#)" 1 } } */
 /* { dg-final { scan-assembler-times "vpermq\[ \\t\]+\[^\{\n\]*%ymm\[0-9\]+\{%k\[1-7\]\}\{z\}(?:\n|\[ \\t\]+#)" 1 } } */
 /* { dg-final { scan-assembler-times "vpermq\[ \\t\]+\[^\{\n\]*%ymm\[0-9\]+\{%k\[1-7\]\}(?:\n|\[ \\t\]+#)" 1 } } */
 
@@ -11,6 +12,7 @@ volatile __mmask8 m;
 void extern
 avx512vl_test (void)
 {
+  x = _mm256_permutexvar_epi64 (x, x);
   x = _mm256_maskz_permutexvar_epi64 (m, x, x);
   x = _mm256_mask_permutexvar_epi64 (x, m, x, x);
 }
diff --git a/gcc/testsuite/gcc.target/i386/i386.exp b/gcc/testsuite/gcc.target/i386/i386.exp
index eae253192ad..ec13306b1ed 100644
--- a/gcc/testsuite/gcc.target/i386/i386.exp
+++ b/gcc/testsuite/gcc.target/i386/i386.exp
@@ -241,18 +241,6 @@ proc check_effective_target_rtm { } {
     } "-mrtm" ]
 }
 
-# Return 1 if avx512f instructions can be compiled.
-proc check_effective_target_avx512f { } {
-    return [check_no_compiler_messages avx512f object {
-	typedef long long __v8di __attribute__ ((__vector_size__ (64)));
-	__v8di
-	mm512_and_epi64  (__v8di __X, __v8di __Y)
-	{
-            return __builtin_ia32_pandq512_mask (__X, __Y, __X, -1);
-	}
-    } "-mavx512f" ]
-}
-
 # Return 1 if avx512vl instructions can be compiled.
 proc check_effective_target_avx512vl { } {
     return [check_no_compiler_messages avx512vl object {
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-1.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-1.c
index 60d09881a99..6e94d2c4865 100644
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-1.c
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-1.c
@@ -11,9 +11,8 @@ male_indirect_jump (long offset)
   dispatch(offset);
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*_?dispatch" { target { { ! x32 } && *-*-linux* } } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk" { target { ! x32 } } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk_(r|e)ax" { target x32 } } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
 /* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler {\tpause} } } */
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-2.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-2.c
index aac75163794..3c467078964 100644
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-2.c
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-2.c
@@ -11,9 +11,8 @@ male_indirect_jump (long offset)
   dispatch[offset](offset);
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*_?dispatch" { target { { ! x32 } && *-*-linux* } } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk" { target { ! x32 } } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk_(r|e)ax" { target x32 } } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
 /* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler {\tpause} } } */
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-3.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-3.c
index 9e24a385387..2c7fb52b59d 100644
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-3.c
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-3.c
@@ -12,9 +12,8 @@ male_indirect_jump (long offset)
   return 0;
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*_?dispatch" { target { { ! x32 } && *-*-linux* } } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk" { target { ! x32 } } } } */
-/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" { target x32 } } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
 /* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler {\tpause} } } */
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-4.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-4.c
index 127b5d94523..0d3f895009d 100644
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-4.c
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-4.c
@@ -12,9 +12,8 @@ male_indirect_jump (long offset)
   return 0;
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*_?dispatch" { target { { ! x32 } && *-*-linux* } } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk" { target { ! x32 } } } } */
-/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" { target x32 } } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
 /* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler {\tpause} } } */
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-5.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-5.c
index fcaa18d10b7..fb26c005e80 100644
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-5.c
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-5.c
@@ -9,8 +9,10 @@ foo (void)
   bar ();
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*bar@GOT" } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk" } } */
+/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*bar@GOT" { target x32 } } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk" { target x32 } } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*bar@GOT" { target { ! x32 } } } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk_(r|e)ax" { target { ! x32 } } } } */
 /* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler {\tpause} } } */
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-6.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-6.c
index e4649283d10..aa03fbd8446 100644
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-6.c
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-6.c
@@ -10,9 +10,13 @@ foo (void)
   return 0;
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*bar@GOT" } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk" } } */
-/* { dg-final { scan-assembler-times "jmp\[ \t\]*\.LIND" 2 } } */
-/* { dg-final { scan-assembler-times "call\[ \t\]*\.LIND" 2 } } */
+/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*bar@GOT" { target x32 } } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk" { target x32 } } } */
+/* { dg-final { scan-assembler-times "jmp\[ \t\]*\.LIND" 2 { target x32 } } } */
+/* { dg-final { scan-assembler-times "call\[ \t\]*\.LIND" 2 { target x32 } } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*bar@GOT" { target { ! x32 } } } } */
+/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" { target { ! x32 } } } } */
+/* { dg-final { scan-assembler-times "jmp\[ \t\]*\.LIND" 1 { target { ! x32 } } } } */
+/* { dg-final { scan-assembler-times "call\[ \t\]*\.LIND" 1 { target { ! x32 } } } } */
 /* { dg-final { scan-assembler {\tpause} } } */
 /* { dg-final { scan-assembler {\tlfence} } } */
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-7.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-7.c
index 17c2d0faf88..53868f46558 100644
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-7.c
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-7.c
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk -fno-pic -fjump-tables" } */
 
 void func0 (void);
 void func1 (void);
@@ -35,9 +35,8 @@ bar (int i)
     }
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*\.L\[0-9\]+\\(,%" { target { { ! x32 } && *-*-linux* } } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk" { target { ! x32 } } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk_(r|e)ax" { target x32 } } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*\.L\[0-9\]+\\(,%" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
 /* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler {\tpause} } } */
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-1.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-1.c
index 9194ccf3cbc..7106407b83d 100644
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-1.c
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-1.c
@@ -14,9 +14,8 @@ male_indirect_jump (long offset)
   dispatch(offset);
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*_?dispatch" { target { { ! x32 } && *-*-linux* } } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk" { target { ! x32 } } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk_(r|e)ax" { target x32 } } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
 /* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler {\tpause} } } */
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-2.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-2.c
index e51f261a612..27c7e5b029b 100644
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-2.c
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-2.c
@@ -12,9 +12,8 @@ male_indirect_jump (long offset)
   dispatch[offset](offset);
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*_?dispatch" { target { { ! x32 } && *-*-linux* } } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk" { target { ! x32 } } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk_(r|e)ax" { target x32 } } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
 /* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler {\tpause} } } */
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-3.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-3.c
index 4aeec1833cd..89a2bac8403 100644
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-3.c
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-3.c
@@ -14,10 +14,9 @@ male_indirect_jump (long offset)
   return 0;
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*_?dispatch" { target { { ! x32 } && *-*-linux* } } } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
 /* { dg-final { scan-assembler-times "jmp\[ \t\]*\.LIND" 2 } } */
 /* { dg-final { scan-assembler-times "call\[ \t\]*\.LIND" 2 } } */
 /* { dg-final { scan-assembler {\tpause} } } */
 /* { dg-final { scan-assembler {\tlfence} } } */
 /* { dg-final { scan-assembler-not "__x86_indirect_thunk" } } */
-/* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" { target x32 } } } */
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-4.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-4.c
index ac0e5999f63..3eb83c3779a 100644
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-4.c
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-4.c
@@ -13,10 +13,9 @@ male_indirect_jump (long offset)
   return 0;
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*_?dispatch" { target { { ! x32 } && *-*-linux* } } } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
 /* { dg-final { scan-assembler-times "jmp\[ \t\]*\.LIND" 2 } } */
 /* { dg-final { scan-assembler-times "call\[ \t\]*\.LIND" 2 } } */
 /* { dg-final { scan-assembler {\tpause} } } */
 /* { dg-final { scan-assembler {\tlfence} } } */
 /* { dg-final { scan-assembler-not "__x86_indirect_thunk" } } */
-/* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" { target x32 } } } */
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-5.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-5.c
index 573cf1ef09e..0098dd1133d 100644
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-5.c
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-5.c
@@ -14,9 +14,8 @@ male_indirect_jump (long offset)
   return 0;
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*_?dispatch" { target { { ! x32 } && *-*-linux* } } } } */
-/* { dg-final { scan-assembler-times "jmp\[ \t\]*\.LIND" 1 { target { ! x32 } } } } */
-/* { dg-final { scan-assembler-times "call\[ \t\]*\.LIND" 1 { target { ! x32 } } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk" { target { ! x32 } } } } */
-/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" { target x32 } } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
 /* { dg-final { scan-assembler-not {\t(lfence|pause)} } } */
+/* { dg-final { scan-assembler-not "jmp\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler-not "call\[ \t\]*\.LIND" } } */
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-6.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-6.c
index b2b37fc6e2e..ece8de15a4b 100644
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-6.c
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-6.c
@@ -13,9 +13,8 @@ male_indirect_jump (long offset)
   return 0;
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*_?dispatch" { target { { ! x32 } && *-*-linux* } } } } */
-/* { dg-final { scan-assembler-times "jmp\[ \t\]*\.LIND" 1 { target { ! x32 } } } } */
-/* { dg-final { scan-assembler-times "call\[ \t\]*\.LIND" 1 { target { ! x32 } } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk" { target { ! x32 } } } } */
-/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" { target x32 } } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
 /* { dg-final { scan-assembler-not {\t(lfence|pause)} } } */
+/* { dg-final { scan-assembler-not "jmp\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler-not "call\[ \t\]*\.LIND" } } */
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-7.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-7.c
index 4a43e199931..d53fc887dcc 100644
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-7.c
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-7.c
@@ -36,9 +36,8 @@ bar (int i)
     }
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*\.L\[0-9\]+\\(,%" { target { { ! x32 } && *-*-linux* } } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk_(r|e)ax" { target x32 } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk" } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*\.L\[0-9\]+\\(,%" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
 /* { dg-final { scan-assembler-not {\t(lfence|pause)} } } */
 /* { dg-final { scan-assembler-not "jmp\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler-not "call\[ \t\]*\.LIND" } } */
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-bnd-1.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-bnd-1.c
index ac84ab623fa..73d16baddc7 100644
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-bnd-1.c
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-bnd-1.c
@@ -10,9 +10,9 @@ foo (void)
   dispatch (buf);
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*_?dispatch" { target { { ! x32 } && *-*-linux* } } } } */
-/* { dg-final { scan-assembler "pushq\[ \t\]%rax" { target x32 } } } */
-/* { dg-final { scan-assembler "bnd jmp\[ \t\]*__x86_indirect_thunk_bnd" } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler "bnd jmp\[ \t\]*__x86_indirect_thunk_bnd_rax" { target lp64 } } } */
+/* { dg-final { scan-assembler "bnd call\[ \t\]*__x86_indirect_thunk_bnd_eax" { target ia32 } } } */
 /* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler "bnd call\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler "bnd ret" } } */
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-bnd-2.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-bnd-2.c
index ce655e8be1c..856751ac224 100644
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-bnd-2.c
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-bnd-2.c
@@ -11,10 +11,8 @@ foo (void)
   return 0;
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*_?dispatch" { target { { ! x32 } && *-*-linux* } } } } */
-/* { dg-final { scan-assembler "pushq\[ \t\]%rax" { target x32 } } } */
-/* { dg-final { scan-assembler "bnd jmp\[ \t\]*__x86_indirect_thunk_bnd" } } */
-/* { dg-final { scan-assembler "bnd jmp\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler "bnd call\[ \t\]*__x86_indirect_thunk_bnd_(r|e)ax" } } */
 /* { dg-final { scan-assembler "bnd call\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler "bnd ret" } } */
 /* { dg-final { scan-assembler {\tpause} } } */
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-bnd-3.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-bnd-3.c
index d34485a0010..42312f65588 100644
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-bnd-3.c
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-bnd-3.c
@@ -10,8 +10,9 @@ foo (void)
   bar (buf);
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*bar@GOT" } } */
-/* { dg-final { scan-assembler "bnd jmp\[ \t\]*__x86_indirect_thunk_bnd" } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*bar@GOT" } } */
+/* { dg-final { scan-assembler "bnd jmp\[ \t\]*__x86_indirect_thunk_bnd_rax" { target lp64 } } } */
+/* { dg-final { scan-assembler "bnd call\[ \t\]*__x86_indirect_thunk_bnd_eax" { target ia32 } } } */
 /* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler "bnd call\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler "bnd ret" } } */
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-bnd-4.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-bnd-4.c
index 0e19830de4d..c8ca102c8df 100644
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-bnd-4.c
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-bnd-4.c
@@ -11,10 +11,9 @@ foo (void)
   return 0;
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*bar@GOT" } } */
-/* { dg-final { scan-assembler "bnd jmp\[ \t\]*__x86_indirect_thunk" } } */
-/* { dg-final { scan-assembler "bnd jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler-times "bnd call\[ \t\]*\.LIND" 2 } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*bar@GOT" } } */
+/* { dg-final { scan-assembler "bnd call\[ \t\]*__x86_indirect_thunk_bnd_(r|e)ax" } } */
+/* { dg-final { scan-assembler-times "bnd call\[ \t\]*\.LIND" 1 } } */
 /* { dg-final { scan-assembler "bnd ret" } } */
 /* { dg-final { scan-assembler {\tpause} } } */
 /* { dg-final { scan-assembler {\tlfence} } } */
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-1.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-1.c
index 579441f250e..c09dd0afd2d 100644
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-1.c
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-1.c
@@ -11,9 +11,8 @@ male_indirect_jump (long offset)
   dispatch(offset);
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*_?dispatch" { target { { ! x32 } && *-*-linux* } } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk" { target { ! x32 } } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk_(r|e)ax" { target x32 } } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
 /* { dg-final { scan-assembler-not {\t(lfence|pause)} } } */
 /* { dg-final { scan-assembler-not "jmp\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler-not "call\[ \t\]*\.LIND" } } */
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-2.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-2.c
index c92e6f2b02d..826425a5115 100644
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-2.c
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-2.c
@@ -11,9 +11,8 @@ male_indirect_jump (long offset)
   dispatch[offset](offset);
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*_?dispatch" { target { { ! x32 } && *-*-linux* } } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk" { target { ! x32 } } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk_(r|e)ax" { target x32 } } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
 /* { dg-final { scan-assembler-not {\t(lfence|pause)} } } */
 /* { dg-final { scan-assembler-not "jmp\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler-not "call\[ \t\]*\.LIND" } } */
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-3.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-3.c
index d9964c25bbd..385626850a2 100644
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-3.c
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-3.c
@@ -12,9 +12,8 @@ male_indirect_jump (long offset)
   return 0;
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*_?dispatch" { target { { ! x32 } && *-*-linux* } } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk" { target { ! x32 } } } } */
-/* { dg-final { scan-assembler-times "jmp\[ \t\]*\.LIND" 1 { target { ! x32 } } } } */
-/* { dg-final { scan-assembler-times "call\[ \t\]*\.LIND" 1 { target { ! x32 } } } } */
-/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" { target x32 } } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
 /* { dg-final { scan-assembler-not {\t(lfence|pause)} } } */
+/* { dg-final { scan-assembler-not "jmp\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler-not "call\[ \t\]*\.LIND" } } */
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-4.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-4.c
index d4dca4dc5fe..1ae49b137ca 100644
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-4.c
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-4.c
@@ -12,9 +12,7 @@ male_indirect_jump (long offset)
   return 0;
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*_?dispatch" { target { { ! x32 } && *-*-linux* } } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk" { target { ! x32 } } } } */
-/* { dg-final { scan-assembler-times "jmp\[ \t\]*\.LIND" 1 { target { ! x32 } } } } */
-/* { dg-final { scan-assembler-times "call\[ \t\]*\.LIND" 1 { target { ! x32 } } } } */
 /* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" { target x32 } } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
 /* { dg-final { scan-assembler-not {\t(lfence|pause)} } } */
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-5.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-5.c
index 5c07e02df6a..53282390977 100644
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-5.c
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-5.c
@@ -9,8 +9,10 @@ foo (void)
   bar ();
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*bar@GOT" } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk" } } */
+/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*bar@GOT" { target x32 } } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk" { target x32 } } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*bar@GOT" { target { ! x32 } } } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk_(r|e)ax" { target { ! x32 } } } } */
 /* { dg-final { scan-assembler-not {\t(lfence|pause)} } } */
 /* { dg-final { scan-assembler-not "jmp\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler-not "call\[ \t\]*\.LIND" } } */
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-6.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-6.c
index 3eb440693a0..8ae43482d0c 100644
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-6.c
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-6.c
@@ -10,8 +10,8 @@ foo (void)
   return 0;
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*bar@GOT" } } */
-/* { dg-final { scan-assembler-times "jmp\[ \t\]*\.LIND" 1 } } */
-/* { dg-final { scan-assembler-times "call\[ \t\]*\.LIND" 1 } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk" } } */
+/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*bar@GOT" { target x32 } } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk" { target x32 } } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*bar@GOT" { target { ! x32 } } } } */
+/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" { target { ! x32 } } } } */
 /* { dg-final { scan-assembler-not {\t(lfence|pause)} } } */
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-7.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-7.c
index aece9383697..bc185fe98af 100644
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-7.c
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-7.c
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk-extern -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk-extern -fno-pic -fjump-tables" } */
 
 void func0 (void);
 void func1 (void);
@@ -35,9 +35,8 @@ bar (int i)
     }
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*\.L\[0-9\]+\\(,%" { target { { ! x32 } && *-*-linux* } } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk" { target { ! x32 } } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk_(r|e)ax" { target x32 } } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*\.L\[0-9\]+\\(,%" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
 /* { dg-final { scan-assembler-not {\t(lfence|pause)} } } */
 /* { dg-final { scan-assembler-not "jmp\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler-not "call\[ \t\]*\.LIND" } } */
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-1.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-1.c
index 3aba5e8c81f..869d9040838 100644
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-1.c
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-1.c
@@ -11,7 +11,7 @@ male_indirect_jump (long offset)
   dispatch(offset);
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*_?dispatch" { target { { ! x32 } && *-*-linux* } } } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
 /* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler {\tpause} } } */
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-2.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-2.c
index 0f0181d6672..c5c16ed8bd8 100644
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-2.c
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-2.c
@@ -11,7 +11,7 @@ male_indirect_jump (long offset)
   dispatch[offset](offset);
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*_?dispatch" { target { { ! x32 } && *-*-linux* } } } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
 /* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler {\tpause} } } */
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-3.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-3.c
index 2eef6f35a75..4a63ebed8ab 100644
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-3.c
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-3.c
@@ -12,7 +12,7 @@ male_indirect_jump (long offset)
   return 0;
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*_?dispatch" { target { { ! x32 } && *-*-linux* } } } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
 /* { dg-final { scan-assembler-times "jmp\[ \t\]*\.LIND" 2 } } */
 /* { dg-final { scan-assembler-times "call\[ \t\]*\.LIND" 2 } } */
 /* { dg-final { scan-assembler-times {\tpause} 1 } } */
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-4.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-4.c
index e825a10f14c..a395ffca018 100644
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-4.c
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-4.c
@@ -12,7 +12,7 @@ male_indirect_jump (long offset)
   return 0;
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*_?dispatch" { target { { ! x32 } && *-*-linux* } } } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
 /* { dg-final { scan-assembler-times "jmp\[ \t\]*\.LIND" 2 } } */
 /* { dg-final { scan-assembler-times "call\[ \t\]*\.LIND" 2 } } */
 /* { dg-final { scan-assembler-times {\tpause} 1 } } */
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-5.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-5.c
index c6d77e10352..21cbfd39582 100644
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-5.c
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-5.c
@@ -9,7 +9,8 @@ foo (void)
   bar ();
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*bar@GOT" } } */
+/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*bar@GOT" { target x32 } } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*bar@GOT" { target { ! x32 } } } } */
 /* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler {\tpause} } } */
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-6.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-6.c
index 6454827b780..d1300f18dc7 100644
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-6.c
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-6.c
@@ -10,7 +10,8 @@ foo (void)
   return 0;
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*bar@GOT" } } */
+/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*bar@GOT" { target x32 } } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*bar@GOT" { target { ! x32 } } } } */
 /* { dg-final { scan-assembler-times "jmp\[ \t\]*\.LIND" 2 } } */
 /* { dg-final { scan-assembler-times "call\[ \t\]*\.LIND" 2 } } */
 /* { dg-final { scan-assembler-times {\tpause} 1 } } */
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-7.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-7.c
index c67066cf197..e6f064959a1 100644
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-7.c
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-7.c
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk-inline -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk-inline -fno-pic -fjump-tables" } */
 
 void func0 (void);
 void func1 (void);
@@ -35,8 +35,8 @@ bar (int i)
     }
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*\.L\[0-9\]+\\(,%" { target { { ! x32 } && *-*-linux* } } } } */
-/* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" { target x32 } } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*\.L\[0-9\]+\\(,%" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler-not "pushq\[ \t\]%(r|e)ax" } } */
 /* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler {\tpause} } } */
diff --git a/gcc/testsuite/gcc.target/i386/pr82795.c b/gcc/testsuite/gcc.target/i386/pr82795.c
new file mode 100644
index 00000000000..9e7fec74699
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr82795.c
@@ -0,0 +1,23 @@
+/* { dg-do compile } */
+/* { dg-options "-O3 -mavx2" } */
+
+void
+sj (int qh, int rn, int *by)
+{
+  for (;;)
+    if (qh != 0)
+      {
+	int dc;
+
+	for (dc = 0; dc < 17; ++dc)
+	  {
+	    int nn;
+
+	    nn = (rn != 0) ? qh : dc;
+	    if (nn != 0)
+	      qh = nn;
+	    else
+	      qh = (qh != 0) ? *by : dc;
+	  }
+      }
+}
diff --git a/gcc/testsuite/gcc.target/i386/pr84310-2.c b/gcc/testsuite/gcc.target/i386/pr84310-2.c
new file mode 100644
index 00000000000..dbf5db6ff87
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr84310-2.c
@@ -0,0 +1,10 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -malign-loops=16" } */
+/* { dg-warning "is obsolete" "" { target *-*-* } 0 } */
+
+void
+c (void)
+{
+  for (;;)
+    ;
+}
diff --git a/gcc/testsuite/gcc.target/i386/pr84310.c b/gcc/testsuite/gcc.target/i386/pr84310.c
new file mode 100644
index 00000000000..f82327e45f3
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr84310.c
@@ -0,0 +1,8 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -falign-functions=100000" } */
+/* { dg-error "is not between 0 and 65536" "" { target *-*-* } 0 } */
+
+void
+test_func (void)
+{
+}
diff --git a/gcc/testsuite/gcc.target/i386/pr84625.c b/gcc/testsuite/gcc.target/i386/pr84625.c
new file mode 100644
index 00000000000..600a6f15a9a
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr84625.c
@@ -0,0 +1,12 @@
+/* PR inline-asm/84625 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -msse2" } */
+
+typedef int V __attribute__((vector_size (16)));
+
+void
+foo (void)
+{
+  asm volatile ("# %0" : : "X" ((V) { 1, 2, 3, 4 }));	// { dg-error "invalid vector immediate" }
+  asm volatile ("# %0" : : "" ((V) { 2, 3, 4, 5 }));	// { dg-error "invalid vector immediate" }
+}
diff --git a/gcc/testsuite/gcc.target/i386/pr84827.c b/gcc/testsuite/gcc.target/i386/pr84827.c
new file mode 100644
index 00000000000..003258c8204
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr84827.c
@@ -0,0 +1,21 @@
+/* PR target/84827 */
+/* { dg-do compile } */
+/* { dg-options "-Ofast -fno-fp-int-builtin-inexact -ftrapping-math -fno-associative-math -mfpmath=387" } */
+
+double
+f1 (double a)
+{
+  return __builtin_round (a);
+}
+
+float
+f2 (float a)
+{
+  return __builtin_roundf (a);
+}
+
+long double
+f3 (long double a)
+{
+  return __builtin_roundl (a);
+}
diff --git a/gcc/testsuite/gcc.target/i386/pr84829.c b/gcc/testsuite/gcc.target/i386/pr84829.c
new file mode 100644
index 00000000000..a63a49b1317
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr84829.c
@@ -0,0 +1,7 @@
+/* { dg-do link } */
+/* { dg-options "-mieee-fp" } */
+
+int main()
+{
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/i386/pr85034.c b/gcc/testsuite/gcc.target/i386/pr85034.c
new file mode 100644
index 00000000000..4a35b112174
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr85034.c
@@ -0,0 +1,11 @@
+/* PR inline-asm/85034 */
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+void
+foo (void)
+{
+  volatile float a;
+  struct S { char a; } b = { 0 };
+  asm volatile ("" : "=r" (a) : "0ir" (b));
+}
diff --git a/gcc/testsuite/gcc.target/i386/pr85095-1.c b/gcc/testsuite/gcc.target/i386/pr85095-1.c
new file mode 100644
index 00000000000..4c882e0ed9d
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr85095-1.c
@@ -0,0 +1,33 @@
+/* PR target/85095 *
+/* { dg-do compile } */
+/* { dg-options "-O2 -masm=att" } */
+
+unsigned int
+foo (unsigned int a, unsigned int b)
+{
+  a += b;
+  if (a < b) a++;
+  return a;
+}
+
+#ifdef __x86_64__
+unsigned long long
+bar (unsigned long long a, unsigned long long b)
+{
+  a += b;
+  if (a < b) a++;
+  return a;
+}
+
+unsigned long long
+baz (unsigned int a, unsigned int b)
+{
+  a += b;
+  if (a < b) a++;
+  return a;
+}
+#endif
+
+/* { dg-final { scan-assembler-times "adcl\t\\\$0," 1 { target ia32 } } } */
+/* { dg-final { scan-assembler-times "adcl\t\\\$0," 2 { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler-times "adcq\t\\\$0," 1 { target { ! ia32 } } } } */
diff --git a/gcc/testsuite/gcc.target/i386/pr85095-2.c b/gcc/testsuite/gcc.target/i386/pr85095-2.c
new file mode 100644
index 00000000000..fbd7992bf4f
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr85095-2.c
@@ -0,0 +1,54 @@
+/* PR target/85095 *
+/* { dg-do compile } */
+/* { dg-options "-O2 -masm=att" } */
+
+unsigned int
+f1 (unsigned int a, unsigned int b)
+{
+  unsigned int i = __builtin_add_overflow (a, b, &a);
+  return a + i;
+}
+
+unsigned int
+f2 (unsigned int a, unsigned int b)
+{
+  unsigned int i = __builtin_add_overflow (a, b, &a);
+  return a - i;
+}
+
+#ifdef __x86_64__
+unsigned long long
+f3 (unsigned long long a, unsigned long long b)
+{
+  unsigned long long i = __builtin_add_overflow (a, b, &a);
+  return a + i;
+}
+
+unsigned long long
+f4 (unsigned long long a, unsigned long long b)
+{
+  unsigned long long i = __builtin_add_overflow (a, b, &a);
+  return a - i;
+}
+
+unsigned long long
+f5 (unsigned int a, unsigned int b)
+{
+  unsigned int i = __builtin_add_overflow (a, b, &a);
+  return a + i;
+}
+
+unsigned long long
+f6 (unsigned int a, unsigned int b)
+{
+  unsigned int i = __builtin_add_overflow (a, b, &a);
+  return a - i;
+}
+#endif
+
+/* { dg-final { scan-assembler-times "adcl\t\\\$0," 1 { target ia32 } } } */
+/* { dg-final { scan-assembler-times "sbbl\t\\\$0," 1 { target ia32 } } } */
+/* { dg-final { scan-assembler-times "adcl\t\\\$0," 2 { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler-times "sbbl\t\\\$0," 2 { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler-times "adcq\t\\\$0," 1 { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler-times "sbbq\t\\\$0," 1 { target { ! ia32 } } } } */
diff --git a/gcc/testsuite/gcc.target/i386/pr85193.c b/gcc/testsuite/gcc.target/i386/pr85193.c
new file mode 100644
index 00000000000..98e3dafc7ae
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr85193.c
@@ -0,0 +1,17 @@
+/* { dg-do compile } */
+/* { dg-options "-Wno-psabi -O2 -fno-tree-ccp -fno-tree-fre -mno-sse" } */
+
+typedef unsigned char U __attribute__((vector_size(16)));
+typedef unsigned int V __attribute__((vector_size(16)));
+typedef unsigned long long W __attribute__((vector_size(16)));
+
+extern void bar(U, U);
+
+V v;
+
+void
+foo(U f)
+{
+  f[0] = f[0] << (unsigned char)~v[0] | f[~((W)(U){0, 0, 0, 0, 0, 0, 0, 0, 5})[1] & 5] >> (-(unsigned char)~v[0] & 7);
+  bar(f, (U){});
+}
diff --git a/gcc/testsuite/gcc.target/i386/pr86627.c b/gcc/testsuite/gcc.target/i386/pr86627.c
new file mode 100644
index 00000000000..5aefbed0a0b
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr86627.c
@@ -0,0 +1,28 @@
+/* PR middle-end/86627 */
+/* { dg-do compile { target int128 } } */
+/* { dg-options "-O2" } */
+/* { dg-final { scan-assembler-not "call\[^\n\r]*__divti3" } } */
+
+__int128_t
+f1 (__int128_t a)
+{
+  return a / 2;
+}
+
+__int128_t
+f2 (__int128_t a)
+{
+  return a / -2;
+}
+
+__int128_t
+f3 (__int128_t a)
+{
+  return a / 0x4000000000000000LL;
+}
+
+__int128_t
+f4 (__int128_t a)
+{
+  return a / -0x4000000000000000LL;
+}
diff --git a/gcc/testsuite/gcc.target/i386/pr86952.c b/gcc/testsuite/gcc.target/i386/pr86952.c
new file mode 100644
index 00000000000..004e167add0
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr86952.c
@@ -0,0 +1,23 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -mindirect-branch=thunk" } */
+
+int global;
+
+int
+foo (int x)
+{
+  switch (x & 7)
+    {
+      case 0: ; return 1722;
+      case 1: global += 1; return 1060;
+      case 2: ; return 1990;
+      case 3: ; return 1242;
+      case 4: ; return 1466;
+      case 5: ; return 894;
+      case 6: ; return 570;
+      case 7: ; return 572;
+      default: return 0;
+    }
+}
+
+/* { dg-final { scan-assembler-not "jmp\[ \t\]\\*" } } */
diff --git a/gcc/testsuite/gcc.target/i386/pr87065.c b/gcc/testsuite/gcc.target/i386/pr87065.c
new file mode 100644
index 00000000000..f1cc6f92679
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr87065.c
@@ -0,0 +1,22 @@
+/* PR rtl-optimization/87065 */
+/* { dg-do compile } */
+/* { dg-options "-O3 -mxop -mprefer-avx128" } */
+
+int a, c, d, e;
+short *b;
+
+void
+foo (void)
+{
+  short *g = b;
+  int h = 1;
+  unsigned i;
+  for (; h <= 1; h++)
+    g = (short *) &c;
+  for (; c; c++)
+    {
+      for (; i <= 1; i++)
+	;
+      a ^= (a > 0 <= i) + ((e += d) == 0 ?: (*g = 8));
+    }
+}
diff --git a/gcc/testsuite/gcc.target/i386/pr87370.c b/gcc/testsuite/gcc.target/i386/pr87370.c
new file mode 100644
index 00000000000..c7b6295a33b
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr87370.c
@@ -0,0 +1,39 @@
+/* { dg-do compile { target { ! ia32 } } } */
+/* { dg-options "-O2" } */
+
+struct A
+{
+  int b[4];
+};
+struct B
+{
+  char a[12];
+  int b;
+};
+struct C
+{
+  char a[16];
+};
+
+struct A
+f1 (void)
+{
+  struct A x = {};
+  return x;
+}
+
+struct B
+f2 (void)
+{
+  struct B x = {};
+  return x;
+}
+
+struct C
+f3 (void)
+{
+  struct C x = {};
+  return x;
+}
+
+/* { dg-final { scan-assembler-not "xmm" } } */
diff --git a/gcc/testsuite/gcc.target/i386/pr87550.c b/gcc/testsuite/gcc.target/i386/pr87550.c
new file mode 100644
index 00000000000..ef77e321d6e
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr87550.c
@@ -0,0 +1,21 @@
+/* PR target/87550 */
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+#include <x86intrin.h>
+
+int
+foo (int x)
+{
+  return __rdtsc () + __rdtsc ();
+}
+
+/* { dg-final { scan-assembler-times "\trdtsc\[\n\r]" 2 } } */
+
+int
+bar (int x)
+{
+  return __rdpmc (0) + __rdpmc (0);
+}
+
+/* { dg-final { scan-assembler-times "\trdpmc\[\n\r]" 2 } } */
diff --git a/gcc/testsuite/gcc.target/i386/pr87928.c b/gcc/testsuite/gcc.target/i386/pr87928.c
new file mode 100644
index 00000000000..5edaa5f0676
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr87928.c
@@ -0,0 +1,23 @@
+/* { dg-do compile { target lp64 } } */
+/* { dg-options "-O1 -mstackrealign -mabi=ms" } */
+
+struct foo
+{
+  int a;
+  int b;
+  int c;
+  int d;
+};
+
+__attribute__ ((sysv_abi))
+struct foo bar (void)
+{
+  struct foo retval;
+
+  retval.a = 1;
+  retval.b = 2;
+  retval.c = 3;
+  retval.d = 4;
+
+  return retval;
+}
diff --git a/gcc/testsuite/gcc.target/i386/pr88418.c b/gcc/testsuite/gcc.target/i386/pr88418.c
new file mode 100644
index 00000000000..3c044430c25
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr88418.c
@@ -0,0 +1,15 @@
+/* PR target/88418 */
+/* { dg-do compile } */
+/* { dg-options "-O1 -fpack-struct -msse4.1 -mno-avx" } */
+
+typedef long long v2di __attribute__ ((__vector_size__ (16)));
+
+union df {
+  v2di se[2];
+};
+
+void
+qg (union df *jz, union df *pl)
+{
+  jz->se[0] = jz->se[0] == pl->se[0];
+}
diff --git a/gcc/testsuite/gcc.target/i386/pr88938.c b/gcc/testsuite/gcc.target/i386/pr88938.c
new file mode 100644
index 00000000000..1314ebb1f35
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr88938.c
@@ -0,0 +1,5 @@
+/* PR target/88938 */
+/* { dg-do compile } */
+/* { dg-options "-Og -fno-tree-ccp -fno-tree-fre -mtbm" } */
+
+#include "tbm-bextri-1.c"
diff --git a/gcc/testsuite/gcc.target/i386/pr88948.c b/gcc/testsuite/gcc.target/i386/pr88948.c
new file mode 100644
index 00000000000..5b50803b60b
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr88948.c
@@ -0,0 +1,5 @@
+/* PR rtl-optimization/88948 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -fgcse-sm -msse3 -mfpmath=387" } */
+
+#include "../../gcc.c-torture/execute/stdarg-3.c"
diff --git a/gcc/testsuite/gcc.target/i386/pr89523-1a.c b/gcc/testsuite/gcc.target/i386/pr89523-1a.c
new file mode 100644
index 00000000000..0d0edab0363
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr89523-1a.c
@@ -0,0 +1,24 @@
+/* { dg-do compile { target { ! ia32 } } } */
+/* { dg-require-effective-target maybe_x32 } */
+/* { dg-options "-maddress-mode=short -mx32 -Ofast -funroll-loops -march=haswell" } */
+/* { dg-final { scan-assembler-not "\tvgather" } } */
+/* { dg-final { scan-assembler "addr32 vgather" } } */
+
+void foo (void);
+
+extern float *ncost;
+
+float
+bar (int type, int num)
+{
+  int i;
+  float cost;
+
+  cost = 0;
+  for (i = 0; i < num; i++)
+    if (type)
+      cost += ncost[i];
+    else
+      foo ();
+  return (cost);
+}
diff --git a/gcc/testsuite/gcc.target/i386/pr89523-1b.c b/gcc/testsuite/gcc.target/i386/pr89523-1b.c
new file mode 100644
index 00000000000..6a5c1d43625
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr89523-1b.c
@@ -0,0 +1,7 @@
+/* { dg-do compile { target { ! ia32 } } } */
+/* { dg-require-effective-target maybe_x32 } */
+/* { dg-options "-maddress-mode=long -mx32 -Ofast -funroll-loops -march=haswell" } */
+/* { dg-final { scan-assembler-not "\tvgather" } } */
+/* { dg-final { scan-assembler "addr32 vgather" } } */
+
+#include "pr89523-1a.c"
diff --git a/gcc/testsuite/gcc.target/i386/pr89523-2.c b/gcc/testsuite/gcc.target/i386/pr89523-2.c
new file mode 100644
index 00000000000..2ffbffe5e40
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr89523-2.c
@@ -0,0 +1,37 @@
+/* { dg-do compile { target { ! ia32 } } } */
+/* { dg-require-effective-target maybe_x32 } */
+/* { dg-options "-mx32 -O2 -march=haswell" } */
+/* { dg-final { scan-assembler "\tvgather" } } */
+/* { dg-final { scan-assembler-not "addr32 vgather" } } */
+
+typedef double __v2df __attribute__ ((__vector_size__ (16)));
+typedef int __v4si __attribute__ ((__vector_size__ (16)));
+typedef long long __v2di __attribute__ ((__vector_size__ (16)));
+
+typedef long long __m128i __attribute__ ((__vector_size__ (16), __may_alias__));
+typedef double __m128d __attribute__ ((__vector_size__ (16), __may_alias__));
+
+extern __inline __m128d
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+_mm_i32gather_pd (double const *__base, __m128i __index, const int __scale)
+{
+  __v2df __zero = { 0.0, 0.0 };
+  __v2df __mask = __builtin_ia32_cmpeqpd (__zero, __zero);
+  __v2df x = x;
+
+  return (__m128d) __builtin_ia32_gathersiv2df (x,
+						__base,
+						(__v4si)__index,
+						__mask,
+						__scale);
+}
+
+__m128d x;
+double *base;
+__m128i idx;
+
+void extern
+avx2_test (void)
+{
+  x = _mm_i32gather_pd (base, idx, 1);
+}
diff --git a/gcc/testsuite/gcc.target/i386/pr89523-3.c b/gcc/testsuite/gcc.target/i386/pr89523-3.c
new file mode 100644
index 00000000000..fc3631b694b
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr89523-3.c
@@ -0,0 +1,36 @@
+/* { dg-do compile { target { ! ia32 } } } */
+/* { dg-require-effective-target maybe_x32 } */
+/* { dg-options "-mx32 -O2 -march=haswell" } */
+/* { dg-final { scan-assembler "\tvgather" } } */
+/* { dg-final { scan-assembler-not "addr32 vgather" } } */
+
+typedef double __v2df __attribute__ ((__vector_size__ (16)));
+typedef int __v4si __attribute__ ((__vector_size__ (16)));
+typedef long long __v2di __attribute__ ((__vector_size__ (16)));
+
+typedef long long __m128i __attribute__ ((__vector_size__ (16), __may_alias__));
+typedef double __m128d __attribute__ ((__vector_size__ (16), __may_alias__));
+
+extern __inline __m128d
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+_mm_i64gather_pd (double const *__base, __m128i __index, const int __scale)
+{
+  __v2df __zero = { 0.0, 0.0 };
+  __v2df __mask = __builtin_ia32_cmpeqpd (__zero, __zero);
+
+  return (__m128d) __builtin_ia32_gatherdiv2df (__zero,
+						__base,
+						(__v2di)__index,
+						__mask,
+						__scale);
+}
+
+__m128d x;
+double *base;
+__m128i idx;
+
+void extern
+avx2_test (void)
+{
+  x = _mm_i64gather_pd (base, idx, 1);
+}
diff --git a/gcc/testsuite/gcc.target/i386/pr89523-4.c b/gcc/testsuite/gcc.target/i386/pr89523-4.c
new file mode 100644
index 00000000000..3436e5dcae3
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr89523-4.c
@@ -0,0 +1,36 @@
+/* { dg-do compile { target { ! ia32 } } } */
+/* { dg-require-effective-target maybe_x32 } */
+/* { dg-options "-mx32 -O2 -march=haswell" } */
+/* { dg-final { scan-assembler-not "\tvgather" } } */
+/* { dg-final { scan-assembler "addr32 vgather" } } */
+
+typedef double __v2df __attribute__ ((__vector_size__ (16)));
+typedef int __v4si __attribute__ ((__vector_size__ (16)));
+typedef long long __v2di __attribute__ ((__vector_size__ (16)));
+
+typedef long long __m128i __attribute__ ((__vector_size__ (16), __may_alias__));
+typedef double __m128d __attribute__ ((__vector_size__ (16), __may_alias__));
+
+extern __inline __m128d
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+_mm_i32gather_pd (double const *__base, __m128i __index, const int __scale)
+{
+  __v2df __zero = { 0.0, 0.0 };
+  __v2df __mask = __builtin_ia32_cmpeqpd (__zero, __zero);
+  __v2df x = x;
+
+  return (__m128d) __builtin_ia32_gathersiv2df (x,
+						__base,
+						(__v4si)__index,
+						__mask,
+						__scale);
+}
+
+__m128d x;
+__m128i idx;
+
+void extern
+avx2_test (void)
+{
+  x = _mm_i32gather_pd ((void *) 0, idx, 1);
+}
diff --git a/gcc/testsuite/gcc.target/i386/pr89523-5.c b/gcc/testsuite/gcc.target/i386/pr89523-5.c
new file mode 100644
index 00000000000..6a769c7a249
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr89523-5.c
@@ -0,0 +1,39 @@
+/* { dg-do compile { target { ! ia32 } } } */
+/* { dg-require-effective-target maybe_x32 } */
+/* { dg-options "-mx32 -O2 -mavx512pf" } */
+/* { dg-final { scan-assembler "\tvgather" } } */
+/* { dg-final { scan-assembler-not "addr32 vgather" } } */
+
+typedef int __v8si __attribute__ ((__vector_size__ (32)));
+typedef long long __m256i __attribute__ ((__vector_size__ (32),
+					  __may_alias__));
+typedef unsigned char  __mmask8;
+
+extern __inline void
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+_mm512_prefetch_i32gather_pd (__m256i __index, void const *__addr,
+			      int __scale, int __hint)
+{
+  __builtin_ia32_gatherpfdpd ((__mmask8) 0xFF, (__v8si) __index, __addr,
+			      __scale, __hint);
+}
+
+extern __inline void
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+_mm512_mask_prefetch_i32gather_pd (__m256i __index, __mmask8 __mask,
+				   void const *__addr, int __scale, int __hint)
+{
+  __builtin_ia32_gatherpfdpd (__mask, (__v8si) __index, __addr, __scale,
+			      __hint);
+}
+
+volatile __m256i idx;
+volatile __mmask8 m8;
+void *base;
+
+void extern
+avx512pf_test (void)
+{
+  _mm512_prefetch_i32gather_pd (idx, base, 8, 3);
+  _mm512_mask_prefetch_i32gather_pd (idx, m8, base, 8, 3);
+}
diff --git a/gcc/testsuite/gcc.target/i386/pr89523-6.c b/gcc/testsuite/gcc.target/i386/pr89523-6.c
new file mode 100644
index 00000000000..82f795e085c
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr89523-6.c
@@ -0,0 +1,38 @@
+/* { dg-do compile { target { ! ia32 } } } */
+/* { dg-require-effective-target maybe_x32 } */
+/* { dg-options "-mx32 -O2 -mavx512pf" } */
+/* { dg-final { scan-assembler-not "\tvgather" } } */
+/* { dg-final { scan-assembler "addr32 vgather" } } */
+
+typedef int __v8si __attribute__ ((__vector_size__ (32)));
+typedef long long __m256i __attribute__ ((__vector_size__ (32),
+					  __may_alias__));
+typedef unsigned char  __mmask8;
+
+extern __inline void
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+_mm512_prefetch_i32gather_pd (__m256i __index, void const *__addr,
+			      int __scale, int __hint)
+{
+  __builtin_ia32_gatherpfdpd ((__mmask8) 0xFF, (__v8si) __index, __addr,
+			      __scale, __hint);
+}
+
+extern __inline void
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+_mm512_mask_prefetch_i32gather_pd (__m256i __index, __mmask8 __mask,
+				   void const *__addr, int __scale, int __hint)
+{
+  __builtin_ia32_gatherpfdpd (__mask, (__v8si) __index, __addr, __scale,
+			      __hint);
+}
+
+volatile __m256i idx;
+volatile __mmask8 m8;
+
+void extern
+avx512pf_test (void)
+{
+  _mm512_prefetch_i32gather_pd (idx, (void *) 0, 8, 3);
+  _mm512_mask_prefetch_i32gather_pd (idx, m8, (void *) 0, 8, 3);
+}
diff --git a/gcc/testsuite/gcc.target/i386/pr89523-7.c b/gcc/testsuite/gcc.target/i386/pr89523-7.c
new file mode 100644
index 00000000000..030b00d268a
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr89523-7.c
@@ -0,0 +1,42 @@
+/* { dg-do compile { target { ! ia32 } } } */
+/* { dg-require-effective-target maybe_x32 } */
+/* { dg-options "-mx32 -O2 -mavx512f" } */
+/* { dg-final { scan-assembler "\tvscatter" } } */
+/* { dg-final { scan-assembler-not "addr32 vscatter" } } */
+
+typedef int __v8si __attribute__ ((__vector_size__ (32)));
+typedef double __v8df __attribute__ ((__vector_size__ (64)));
+typedef long long __m256i __attribute__ ((__vector_size__ (32),
+					  __may_alias__));
+typedef double __m512d __attribute__ ((__vector_size__ (64), __may_alias__));
+typedef unsigned char  __mmask8;
+
+extern __inline void
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+_mm512_i32scatter_pd (void *__addr, __m256i __index, __m512d __v1,
+		      int __scale)
+{
+  __builtin_ia32_scattersiv8df (__addr, (__mmask8) 0xFF,
+				(__v8si) __index, (__v8df) __v1, __scale);
+}
+
+extern __inline void
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+_mm512_mask_i32scatter_pd (void *__addr, __mmask8 __mask,
+			   __m256i __index, __m512d __v1, int __scale)
+{
+  __builtin_ia32_scattersiv8df (__addr, __mask, (__v8si) __index,
+				(__v8df) __v1, __scale);
+}
+
+volatile __m512d src;
+volatile __m256i idx;
+volatile __mmask8 m8;
+double *addr;
+
+void extern
+avx512f_test (void)
+{
+  _mm512_i32scatter_pd (addr, idx, src, 8);
+  _mm512_mask_i32scatter_pd (addr, m8, idx, src, 8);
+}
diff --git a/gcc/testsuite/gcc.target/i386/pr89523-8.c b/gcc/testsuite/gcc.target/i386/pr89523-8.c
new file mode 100644
index 00000000000..465c985c2b7
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr89523-8.c
@@ -0,0 +1,41 @@
+/* { dg-do compile { target { ! ia32 } } } */
+/* { dg-require-effective-target maybe_x32 } */
+/* { dg-options "-mx32 -O2 -mavx512f" } */
+/* { dg-final { scan-assembler "\tvscatter" } } */
+/* { dg-final { scan-assembler-not "addr32 vscatter" } } */
+
+typedef long long __v8di __attribute__ ((__vector_size__ (64)));
+typedef double __v8df __attribute__ ((__vector_size__ (64)));
+typedef long long __m512i __attribute__ ((__vector_size__ (64), __may_alias__));
+typedef double __m512d __attribute__ ((__vector_size__ (64), __may_alias__));
+typedef unsigned char  __mmask8;
+
+extern __inline void
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+_mm512_i64scatter_pd (void *__addr, __m512i __index, __m512d __v1,
+		      int __scale)
+{
+  __builtin_ia32_scatterdiv8df (__addr, (__mmask8) 0xFF,
+				(__v8di) __index, (__v8df) __v1, __scale);
+}
+
+extern __inline void
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+_mm512_mask_i64scatter_pd (void *__addr, __mmask8 __mask,
+			   __m512i __index, __m512d __v1, int __scale)
+{
+  __builtin_ia32_scatterdiv8df (__addr, __mask, (__v8di) __index,
+				(__v8df) __v1, __scale);
+}
+
+volatile __m512d src;
+volatile __m512i idx;
+volatile __mmask8 m8;
+double *addr;
+
+void extern
+avx512f_test (void)
+{
+  _mm512_i64scatter_pd (addr, idx, src, 8);
+  _mm512_mask_i64scatter_pd (addr, m8, idx, src, 8);
+}
diff --git a/gcc/testsuite/gcc.target/i386/pr89523-9.c b/gcc/testsuite/gcc.target/i386/pr89523-9.c
new file mode 100644
index 00000000000..e9323126bd6
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr89523-9.c
@@ -0,0 +1,30 @@
+/* { dg-do compile { target { ! ia32 } } } */
+/* { dg-require-effective-target maybe_x32 } */
+/* { dg-options "-mx32 -O2 -mavx512f" } */
+/* { dg-final { scan-assembler-not "\tvscatter" } } */
+/* { dg-final { scan-assembler "addr32 vscatter" } } */
+
+typedef int __v8si __attribute__ ((__vector_size__ (32)));
+typedef double __v8df __attribute__ ((__vector_size__ (64)));
+typedef long long __m256i __attribute__ ((__vector_size__ (32),
+					  __may_alias__));
+typedef double __m512d __attribute__ ((__vector_size__ (64), __may_alias__));
+typedef unsigned char  __mmask8;
+
+extern __inline void
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+_mm512_i32scatter_pd (void *__addr, __m256i __index, __m512d __v1,
+		      int __scale)
+{
+  __builtin_ia32_scattersiv8df (__addr, (__mmask8) 0xFF,
+				(__v8si) __index, (__v8df) __v1, __scale);
+}
+
+volatile __m512d src;
+volatile __m256i idx;
+
+void extern
+avx512f_test (void)
+{
+  _mm512_i32scatter_pd ((void *) 0, idx, src, 8);
+}
diff --git a/gcc/testsuite/gcc.target/i386/pr89945.c b/gcc/testsuite/gcc.target/i386/pr89945.c
new file mode 100644
index 00000000000..39e864a9d65
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr89945.c
@@ -0,0 +1,21 @@
+/* PR target/89945 */
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+void
+foo ()
+{
+  void *g[] = {&&a, &&b};
+
+  for (unsigned c = 0x1F;; c >>= 1)
+    {
+      unsigned d = (long)"a";
+      long e = 8;
+
+      while (e)
+        {
+          a: goto *g[c&d];
+          b: e--;
+        }
+    }
+}
diff --git a/gcc/testsuite/gcc.target/i386/ret-thunk-10.c b/gcc/testsuite/gcc.target/i386/ret-thunk-10.c
index e6fea84a4d9..af9023af613 100644
--- a/gcc/testsuite/gcc.target/i386/ret-thunk-10.c
+++ b/gcc/testsuite/gcc.target/i386/ret-thunk-10.c
@@ -15,9 +15,6 @@ foo (void)
 /* { dg-final { scan-assembler-not "jmp\[ \t\]*__x86_return_thunk" } } */
 /* { dg-final { scan-assembler-times {\tpause} 2 } } */
 /* { dg-final { scan-assembler-times {\tlfence} 2 } } */
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*_?bar" { target { { ! x32 } && *-*-linux* } } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk" { target { ! x32 } }  } } */
-/* { dg-final { scan-assembler "__x86_indirect_thunk:" { target { ! x32 } }  } } */
-/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" { target { x32 } }  } } */
-/* { dg-final { scan-assembler "__x86_indirect_thunk_(r|e)ax:" { target { x32 } }  } } */
-/* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" { target x32 } } } */
+/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
+/* { dg-final { scan-assembler "__x86_indirect_thunk_(r|e)ax:" } } */
+/* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" } } */
diff --git a/gcc/testsuite/gcc.target/i386/ret-thunk-11.c b/gcc/testsuite/gcc.target/i386/ret-thunk-11.c
index e239ec4542f..ba467c59b36 100644
--- a/gcc/testsuite/gcc.target/i386/ret-thunk-11.c
+++ b/gcc/testsuite/gcc.target/i386/ret-thunk-11.c
@@ -15,9 +15,6 @@ foo (void)
 /* { dg-final { scan-assembler-times {\tlfence} 1 } } */
 /* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*_?bar" { target { { ! x32 } && *-*-linux* } } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk" { target { ! x32 } } } } */
-/* { dg-final { scan-assembler "__x86_indirect_thunk:" { target { ! x32 } }  } } */
-/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" { target { x32 } }  } } */
-/* { dg-final { scan-assembler "__x86_indirect_thunk_(r|e)ax:" { target { x32 } }  } } */
-/* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" { target x32 } } } */
+/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
+/* { dg-final { scan-assembler "__x86_indirect_thunk_(r|e)ax:" } } */
+/* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" } } */
diff --git a/gcc/testsuite/gcc.target/i386/ret-thunk-12.c b/gcc/testsuite/gcc.target/i386/ret-thunk-12.c
index fa3181303c9..43e57cac2c3 100644
--- a/gcc/testsuite/gcc.target/i386/ret-thunk-12.c
+++ b/gcc/testsuite/gcc.target/i386/ret-thunk-12.c
@@ -15,8 +15,6 @@ foo (void)
 /* { dg-final { scan-assembler-times {\tlfence} 1 } } */
 /* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk" { target { ! x32 } } } } */
-/* { dg-final { scan-assembler "__x86_indirect_thunk:" { target { ! x32 } }  } } */
-/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" { target { x32 } }  } } */
-/* { dg-final { scan-assembler "__x86_indirect_thunk_(r|e)ax:" { target { x32 } }  } } */
-/* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" { target x32 } } } */
+/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
+/* { dg-final { scan-assembler "__x86_indirect_thunk_(r|e)ax:" } } */
+/* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" } } */
diff --git a/gcc/testsuite/gcc.target/i386/ret-thunk-13.c b/gcc/testsuite/gcc.target/i386/ret-thunk-13.c
index fd5b41fdd3f..55f156c4376 100644
--- a/gcc/testsuite/gcc.target/i386/ret-thunk-13.c
+++ b/gcc/testsuite/gcc.target/i386/ret-thunk-13.c
@@ -14,9 +14,8 @@ foo (void)
 /* { dg-final { scan-assembler "jmp\[ \t\]*__x86_return_thunk" } } */
 /* { dg-final { scan-assembler-times {\tpause} 2 } } */
 /* { dg-final { scan-assembler-times {\tlfence} 2 } } */
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*_?bar" { target { { ! x32 } && *-*-linux* } } } } */
 /* { dg-final { scan-assembler-times "jmp\[ \t\]*\.LIND" 3 } } */
 /* { dg-final { scan-assembler-times "call\[ \t\]*\.LIND" 3 } } */
 /* { dg-final { scan-assembler-not "jmp\[ \t\]*__x86_indirect_thunk" } } */
-/* { dg-final { scan-assembler-not "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" { target { x32 } }  } } */
-/* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" { target x32 } } } */
+/* { dg-final { scan-assembler-not "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
+/* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" } } */
diff --git a/gcc/testsuite/gcc.target/i386/ret-thunk-14.c b/gcc/testsuite/gcc.target/i386/ret-thunk-14.c
index d606373ead1..1c790436a53 100644
--- a/gcc/testsuite/gcc.target/i386/ret-thunk-14.c
+++ b/gcc/testsuite/gcc.target/i386/ret-thunk-14.c
@@ -16,7 +16,6 @@ foo (void)
 /* { dg-final { scan-assembler-not "jmp\[ \t\]*__x86_return_thunk" } } */
 /* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*_?bar" { target { { ! x32 } && *-*-linux* } } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk" { target { ! x32 } } } } */
-/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" { target { x32 } }  } } */
-/* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" { target x32 } } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?bar" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
+/* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" } } */
diff --git a/gcc/testsuite/gcc.target/i386/ret-thunk-15.c b/gcc/testsuite/gcc.target/i386/ret-thunk-15.c
index 75e45e226b8..58aba319cba 100644
--- a/gcc/testsuite/gcc.target/i386/ret-thunk-15.c
+++ b/gcc/testsuite/gcc.target/i386/ret-thunk-15.c
@@ -16,7 +16,6 @@ foo (void)
 /* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler-times {\tpause} 1 } } */
 /* { dg-final { scan-assembler-times {\tlfence} 1 } } */
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*_?bar" { target { { ! x32 } && *-*-linux* } } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk" { target { ! x32 } } } } */
-/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" { target x32 } } } */
-/* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" { target x32 } } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?bar" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
+/* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" } } */
diff --git a/gcc/testsuite/gcc.target/i386/ret-thunk-22.c b/gcc/testsuite/gcc.target/i386/ret-thunk-22.c
new file mode 100644
index 00000000000..89e086de97b
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/ret-thunk-22.c
@@ -0,0 +1,15 @@
+/* PR target/r84530 */
+/* { dg-do compile { target ia32 } } */
+/* { dg-options "-O2 -mfunction-return=thunk" } */
+
+struct s { _Complex unsigned short x; };
+struct s gs = { 100 + 200i };
+struct s __attribute__((noinline)) foo (void) { return gs; }
+
+/* { dg-final { scan-assembler-times "popl\[\\t \]*%ecx" 1 } } */
+/* { dg-final { scan-assembler "lea\[l\]?\[\\t \]*4\\(%esp\\), %esp" } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_return_thunk_ecx" } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler {\tpause} } } */
+/* { dg-final { scan-assembler {\tlfence} } } */
diff --git a/gcc/testsuite/gcc.target/i386/ret-thunk-23.c b/gcc/testsuite/gcc.target/i386/ret-thunk-23.c
new file mode 100644
index 00000000000..43f0ccaa854
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/ret-thunk-23.c
@@ -0,0 +1,15 @@
+/* PR target/r84530 */
+/* { dg-do compile { target ia32 } } */
+/* { dg-options "-O2 -mfunction-return=thunk-extern" } */
+
+struct s { _Complex unsigned short x; };
+struct s gs = { 100 + 200i };
+struct s __attribute__((noinline)) foo (void) { return gs; }
+
+/* { dg-final { scan-assembler-times "popl\[\\t \]*%ecx" 1 } } */
+/* { dg-final { scan-assembler "lea\[l\]?\[\\t \]*4\\(%esp\\), %esp" } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_return_thunk_ecx" } } */
+/* { dg-final { scan-assembler-not "jmp\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler-not "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler-not {\tpause} } } */
+/* { dg-final { scan-assembler-not {\tlfence} } } */
diff --git a/gcc/testsuite/gcc.target/i386/ret-thunk-24.c b/gcc/testsuite/gcc.target/i386/ret-thunk-24.c
new file mode 100644
index 00000000000..8729e35147e
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/ret-thunk-24.c
@@ -0,0 +1,15 @@
+/* PR target/r84530 */
+/* { dg-do compile { target ia32 } } */
+/* { dg-options "-O2 -mfunction-return=thunk-inline" } */
+
+struct s { _Complex unsigned short x; };
+struct s gs = { 100 + 200i };
+struct s __attribute__((noinline)) foo (void) { return gs; }
+
+/* { dg-final { scan-assembler-times "popl\[\\t \]*%ecx" 1 } } */
+/* { dg-final { scan-assembler "lea\[l\]?\[\\t \]*4\\(%esp\\), %esp" } } */
+/* { dg-final { scan-assembler-not "jmp\[ \t\]*__x86_return_thunk_ecx" } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler {\tpause} } } */
+/* { dg-final { scan-assembler {\tlfence} } } */
diff --git a/gcc/testsuite/gcc.target/i386/ret-thunk-25.c b/gcc/testsuite/gcc.target/i386/ret-thunk-25.c
new file mode 100644
index 00000000000..f73553c9a9f
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/ret-thunk-25.c
@@ -0,0 +1,15 @@
+/* PR target/r84530 */
+/* { dg-do compile { target ia32 } } */
+/* { dg-options "-O2 -mfunction-return=thunk -fcheck-pointer-bounds -mmpx -fno-pic" } */
+
+struct s { _Complex unsigned short x; };
+struct s gs = { 100 + 200i };
+struct s __attribute__((noinline)) foo (void) { return gs; }
+
+/* { dg-final { scan-assembler-times "popl\[\\t \]*%ecx" 1 } } */
+/* { dg-final { scan-assembler "lea\[l\]?\[\\t \]*4\\(%esp\\), %esp" } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_return_thunk_bnd_ecx" } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler {\tpause} } } */
+/* { dg-final { scan-assembler {\tlfence} } } */
diff --git a/gcc/testsuite/gcc.target/i386/ret-thunk-26.c b/gcc/testsuite/gcc.target/i386/ret-thunk-26.c
new file mode 100644
index 00000000000..9144e988735
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/ret-thunk-26.c
@@ -0,0 +1,40 @@
+/* PR target/r84530 */
+/* { dg-do run } */
+/* { dg-options "-Os -mfunction-return=thunk" } */
+
+struct S { int i; };
+__attribute__((const, noinline, noclone))
+struct S foo (int x)
+{
+  struct S s;
+  s.i = x;
+  return s;
+}
+
+int a[2048], b[2048], c[2048], d[2048];
+struct S e[2048];
+
+__attribute__((noinline, noclone)) void
+bar (void)
+{
+  int i;
+  for (i = 0; i < 1024; i++)
+    {
+      e[i] = foo (i);
+      a[i+2] = a[i] + a[i+1];
+      b[10] = b[10] + i;
+      c[i] = c[2047 - i];
+      d[i] = d[i + 1];
+    }
+}
+
+int
+main ()
+{
+  int i;
+  bar ();
+  for (i = 0; i < 1024; i++)
+    if (e[i].i != i)
+      __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/i386/ret-thunk-9.c b/gcc/testsuite/gcc.target/i386/ret-thunk-9.c
index d1db41cc128..eee230ca2f6 100644
--- a/gcc/testsuite/gcc.target/i386/ret-thunk-9.c
+++ b/gcc/testsuite/gcc.target/i386/ret-thunk-9.c
@@ -13,12 +13,9 @@ foo (void)
 /* { dg-final { scan-assembler "jmp\[ \t\]*__x86_return_thunk" } } */
 /* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "__x86_indirect_thunk:" } } */
-/* { dg-final { scan-assembler-times {\tpause} 1 { target { ! x32 } } } } */
-/* { dg-final { scan-assembler-times {\tlfence} 1 { target { ! x32 } } } } */
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*_?bar" { target { { ! x32 } && *-*-linux* } } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk" { target { ! x32 } } } } */
-/* { dg-final { scan-assembler-times {\tpause} 2 { target { x32 } } } } */
-/* { dg-final { scan-assembler-times {\tlfence} 2 { target { x32 } } } } */
-/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" { target { x32 } } } } */
-/* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" { target x32 } } } */
+/* { dg-final { scan-assembler "__x86_return_thunk:" } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?bar" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler-times {\tpause} 2 } } */
+/* { dg-final { scan-assembler-times {\tlfence} 2 } } */
+/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
+/* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" } } */
diff --git a/gcc/testsuite/gcc.target/msp430/pr79242.c b/gcc/testsuite/gcc.target/msp430/pr79242.c
new file mode 100644
index 00000000000..d7ff8d38a3f
--- /dev/null
+++ b/gcc/testsuite/gcc.target/msp430/pr79242.c
@@ -0,0 +1,11 @@
+/* { dg-do compile } */
+/* { dg-skip-if "" { "*-*-*" } { "-mcpu=msp430" "-msmall" } { "" } } */
+/* { dg-options "-mcpu=msp430x" } */
+
+typedef _Complex __int20 C;
+
+C
+foo (C x, C y)
+{
+  return x + y;
+}
diff --git a/gcc/testsuite/gcc.target/msp430/pr86662.c b/gcc/testsuite/gcc.target/msp430/pr86662.c
new file mode 100644
index 00000000000..1144b3e8394
--- /dev/null
+++ b/gcc/testsuite/gcc.target/msp430/pr86662.c
@@ -0,0 +1,13 @@
+/* PR/86662 */
+
+/* { dg-do link } */
+/* -nostdlib prevents link errors due to mismatched code models for
+   libgloss objects.  */
+/* { dg-options "-mlarge -flto -nostdlib" } */
+/* { dg-skip-if "" { *-*-* } { "-mcpu=msp430" } } */
+
+int main(void)
+{
+  __int20 n = 5;
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/nvptx/indirect_call.c b/gcc/testsuite/gcc.target/nvptx/indirect_call.c
new file mode 100644
index 00000000000..39992a7137b
--- /dev/null
+++ b/gcc/testsuite/gcc.target/nvptx/indirect_call.c
@@ -0,0 +1,19 @@
+/* { dg-options "-O2 -msoft-stack" } */
+/* { dg-do run } */
+
+int
+f1 (int a)
+{
+  return a + 1;
+}
+  
+int (*f2)(int) = f1;
+
+int
+main ()
+{
+  if (f2 (100) != 101)
+    __builtin_abort();
+
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/nvptx/pr85056.c b/gcc/testsuite/gcc.target/nvptx/pr85056.c
new file mode 100644
index 00000000000..2471cb83b9e
--- /dev/null
+++ b/gcc/testsuite/gcc.target/nvptx/pr85056.c
@@ -0,0 +1,21 @@
+/* { dg-do run } */
+/* { dg-additional-sources "pr85056a.c" } */
+
+extern void abort ();
+
+extern int a[];
+
+int
+main ()
+{
+  int i, sum;
+
+  sum = 0;
+  for (i = 0; i < 10; i++)
+    sum += a[i];
+
+  if (sum != 55)
+    abort ();
+
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/nvptx/pr85056a.c b/gcc/testsuite/gcc.target/nvptx/pr85056a.c
new file mode 100644
index 00000000000..a45a5f2b07f
--- /dev/null
+++ b/gcc/testsuite/gcc.target/nvptx/pr85056a.c
@@ -0,0 +1,3 @@
+/* { dg-skip-if "" { *-*-* } } */
+
+int a[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
diff --git a/gcc/testsuite/gcc.target/powerpc/altivec-13.c b/gcc/testsuite/gcc.target/powerpc/altivec-13.c
index 22ff951b830..31ff5092014 100644
--- a/gcc/testsuite/gcc.target/powerpc/altivec-13.c
+++ b/gcc/testsuite/gcc.target/powerpc/altivec-13.c
@@ -1,21 +1,77 @@
 /* { dg-do compile { target powerpc*-*-* } } */
 /* { dg-require-effective-target powerpc_altivec_ok } */
 /* { dg-options "-maltivec" } */
+
 /* Author: Ziemowit Laski  <zlaski@apple.com>  */
 
 /* This test case exercises intrinsic/argument combinations that,
    while not in the Motorola AltiVec PIM, have nevertheless crept
    into the AltiVec vernacular over the years.  */
 
+/* Tests requiring VSX support (vector long long and vector double) have
+   been moved over to vsx-13.c.  */
+
 #include <altivec.h>
 
-void foo (void) 
+void foo (void)
 {
   vector bool int boolVec1 = (vector bool int) vec_splat_u32(3);
   vector bool short boolVec2 = (vector bool short) vec_splat_u16(3);
   vector bool char boolVec3 = (vector bool char) vec_splat_u8(3);
-
+  vector signed char vsc1, vsc2, vscz;
+  vector unsigned char vuc1, vuc2, vucz;
+  vector signed short int vssi1, vssi2, vssiz;
+  vector signed int vsi1, vsi2, vsiz;
+  vector unsigned int vui1, vui2, vuiz;
+  vector unsigned short int vusi1, vusi2, vusiz;
+  vector pixel vp1, vp2, vpz;
+  vector float vf1, vf2, vfz;
+  
   boolVec1 = vec_sld( boolVec1, boolVec1, 4 );
   boolVec2 = vec_sld( boolVec2, boolVec2, 2 );
   boolVec3 = vec_sld( boolVec3, boolVec3, 1 );
+
+  vscz = vec_sld( vsc1, vsc2, 1 );
+  vucz = vec_sld( vuc1, vuc2, 1 );
+  vsiz = vec_sld( vsi1, vsi2, 1 );
+  vuiz = vec_sld( vui1, vui2, 1 );
+  vssiz = vec_sld( vssi1, vssi2, 1 );
+  vusiz = vec_sld( vusi1, vusi2, 1 );
+  
+  vfz = vec_sld( vf1, vf2, 1 );
+
+  vpz = vec_sld( vp1, vp2, 1 );
+
+  vucz = vec_srl(vuc1, vuc2);
+  vsiz = vec_srl(vsi1, vuc2);
+  vuiz = vec_srl(vui1, vuc2);
+  vpz = vec_srl(vp1, vuc2);
+  vssiz = vec_srl(vssi1, vuc2);
+  vusiz = vec_srl(vusi1, vuc2);
+
+  vscz = vec_sro(vsc1, vsc2);
+  vscz = vec_sro(vsc1, vuc2);
+  vucz = vec_sro(vuc1, vsc2);
+  vucz = vec_sro(vuc1, vuc2);
+  vsiz = vec_sro(vsi1, vsc2);
+  vsiz = vec_sro(vsi1, vuc2);
+  vuiz = vec_sro(vui1, vsc2);
+  vuiz = vec_sro(vui1, vuc2);
+  vpz = vec_sro(vp1, vsc2);
+  vpz = vec_sro(vp1, vuc2);
+  vssiz = vec_sro(vssi1, vsc2);
+  vssiz = vec_sro(vssi1, vuc2);
+  vusiz = vec_sro(vusi1, vsc2);
+  vusiz = vec_sro(vusi1, vuc2);
+  vfz = vec_sro(vf1, vsc2);
+  vfz = vec_sro(vf1, vuc2);
 }
+
+/* Expected results:
+   vec_sld          vsldoi
+   vec_srl          vsr
+   vec_sro          vsro  */
+
+/* { dg-final { scan-assembler-times "vsldoi" 11 } } */
+/* { dg-final { scan-assembler-times "vsr " 6 } } */
+/* { dg-final { scan-assembler-times "vsro" 16 } } */
diff --git a/gcc/testsuite/gcc.target/powerpc/altivec-7.c b/gcc/testsuite/gcc.target/powerpc/altivec-7.h
similarity index 87%
rename from gcc/testsuite/gcc.target/powerpc/altivec-7.c
rename to gcc/testsuite/gcc.target/powerpc/altivec-7.h
index 30a1ee52062..4dedcd81469 100644
--- a/gcc/testsuite/gcc.target/powerpc/altivec-7.c
+++ b/gcc/testsuite/gcc.target/powerpc/altivec-7.h
@@ -1,8 +1,8 @@
 /* Origin: Aldy Hernandez  <aldyh@redhat.com>  */
 
-/* { dg-do compile { target powerpc*-*-* } } */
-/* { dg-require-effective-target powerpc_altivec_ok } */
-/* { dg-options "-maltivec" } */
+/* This test code is included into altivec-7-be.c and altivec-7-le.c.  
+   The two files have the tests for the number of instructions generated for
+   LE versus BE.  */
 
 #include <altivec.h>
 
@@ -26,6 +26,7 @@ int main ()
   *vecfloat++ = vec_vxor(vecfloat[0], (vector bool int)vecint[1]);
   *varpixel++ = vec_packpx(vecuint[0], vecuint[1]);
   *varpixel++ = vec_vpkpx(vecuint[0], vecuint[1]);
+  *vecshort++ = vec_vmulesb(vecchar[0], vecchar[1]);
   *vecshort++ = vec_vmulosb(vecchar[0], vecchar[1]);
   *vecint++ = vec_ld(var_int[0], intp[1]);
   *vecint++ = vec_lde(var_int[0], intp[1]);
diff --git a/gcc/testsuite/gcc.target/powerpc/altivec_vld_vst_addr-1.c b/gcc/testsuite/gcc.target/powerpc/altivec_vld_vst_addr-1.c
new file mode 100644
index 00000000000..eb6d1ebd40f
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/altivec_vld_vst_addr-1.c
@@ -0,0 +1,184 @@
+/* { dg-require-effective-target powerpc_altivec_ok } */
+/* { dg-options "-maltivec" } */
+
+/* Test vec_ld and vec_st can support both scalar and vector
+   type address points, the list is:
+     - address of unsigned char/short/int
+     - address of signed char/short/int
+     - address of float
+     - address of vector unsigned char/short/int
+     - address of vector signed char/short/int
+     - address of vector float */
+#include <altivec.h>
+
+/* Test vec_ld can allow scalar and vector type address. */
+vector unsigned char
+test_vld_scalar_uc (const unsigned char *address)
+{
+  return __builtin_vec_ld (0, address);
+}
+
+vector unsigned short
+test_vld_scalar_us (const unsigned short *address)
+{
+  return __builtin_vec_ld (0, address);
+}
+
+vector unsigned int
+test_vld_scalar_ui (const unsigned int *address)
+{
+  return __builtin_vec_ld (0, address);
+}
+
+vector signed char
+test_vld_scalar_sc (const signed char *address)
+{
+  return __builtin_vec_ld (0, address);
+}
+
+vector signed short
+test_vld_scalar_ss (const signed short *address)
+{
+  return __builtin_vec_ld (0, address);
+}
+
+vector signed int
+test_vld_scalar_si (const signed int *address)
+{
+  return __builtin_vec_ld (0, address);
+}
+
+vector float
+test_vld_scalar_f (const float *address)
+{
+  return __builtin_vec_ld (0, address);
+}
+
+vector unsigned char
+test_vld_vector_uc (const vector unsigned char *address)
+{
+  return __builtin_vec_ld (0, address);
+}
+
+vector unsigned short
+test_vld_vector_us (const vector unsigned short *address)
+{
+  return __builtin_vec_ld (0, address);
+}
+
+vector unsigned int
+test_vld_vector_ui (const vector unsigned int *address)
+{
+  return __builtin_vec_ld (0, address);
+}
+
+vector signed char
+test_vld_vector_sc (const vector signed char *address)
+{
+  return __builtin_vec_ld (0, address);
+}
+
+vector signed short
+test_vld_vector_ss (const vector signed short *address)
+{
+  return __builtin_vec_ld (0, address);
+}
+
+vector signed int
+test_vld_vector_si (const vector signed int *address)
+{
+  return __builtin_vec_ld (0, address);
+}
+
+vector float
+test_vld_vector_f (const vector float *address)
+{
+  return __builtin_vec_ld (0, address);
+}
+
+/* Test vec_st can allow scalar and vector type address. */
+
+void
+test_vst_scalar_uc (vector unsigned char v, unsigned char *address)
+{
+  __builtin_vec_st (v, 0, address);
+}
+
+void
+test_vst_scalar_us (vector unsigned short v, unsigned short *address)
+{
+  __builtin_vec_st (v, 0, address);
+}
+
+void
+test_vst_scalar_ui (vector unsigned int v, unsigned int *address)
+{
+  __builtin_vec_st (v, 0, address);
+}
+
+void
+test_vst_scalar_sc (vector signed char v, signed char *address)
+{
+  __builtin_vec_st (v, 0, address);
+}
+
+void
+test_vst_scalar_ss (vector signed short v, signed short *address)
+{
+  __builtin_vec_st (v, 0, address);
+}
+
+void
+test_vst_scalar_si (vector signed int v, signed int *address)
+{
+  __builtin_vec_st (v, 0, address);
+}
+
+void
+test_vst_scalar_f (vector float v, float *address)
+{
+  __builtin_vec_st (v, 0, address);
+}
+
+void
+test_vst_vector_uc (vector unsigned char v, vector unsigned char *address)
+{
+  __builtin_vec_st (v, 0, address);
+}
+
+void
+test_vst_vector_us (vector unsigned short v, vector unsigned short *address)
+{
+  __builtin_vec_st (v, 0, address);
+}
+
+void
+test_vst_vector_ui (vector unsigned int v, vector unsigned int *address)
+{
+  __builtin_vec_st (v, 0, address);
+}
+
+void
+test_vst_vector_sc (vector signed char v, vector signed char *address)
+{
+  __builtin_vec_st (v, 0, address);
+}
+
+void
+test_vst_vector_ss (vector signed short v, vector signed short *address)
+{
+  __builtin_vec_st (v, 0, address);
+}
+
+void
+test_vst_vector_si (vector signed int v, vector signed int *address)
+{
+  __builtin_vec_st (v, 0, address);
+}
+
+void
+test_vst_vector_f (vector float v, vector float *address)
+{
+  __builtin_vec_st (v, 0, address);
+}
+
diff --git a/gcc/testsuite/gcc.target/powerpc/altivec_vld_vst_addr-2.c b/gcc/testsuite/gcc.target/powerpc/altivec_vld_vst_addr-2.c
new file mode 100644
index 00000000000..aecccd0c7d2
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/altivec_vld_vst_addr-2.c
@@ -0,0 +1,92 @@
+/* { dg-require-effective-target powerpc_vsx_ok } */
+/* { dg-options "-mvsx" } */
+
+/* Note that vector long long and vector double type require vsx support. */
+
+/* Test vec_ld and vec_st can support both scalar and vector
+   type address points, the list is:
+     - address of unsigned long long
+     - address of signed long long
+     - address of double
+     - address of vector unsigned long long
+     - address of vector signed long long
+     - address of vector double */
+#include <altivec.h>
+
+/* Test vec_ld can allow scalar and vector type address. */
+
+vector unsigned long long
+test_vld_scalar_ul (const unsigned long long *address)
+{
+  return __builtin_vec_ld (0, address);
+}
+
+vector signed long long
+test_vld_scalar_sl (const signed long long *address)
+{
+  return __builtin_vec_ld (0, address);
+}
+
+vector double
+test_vld_scalar_d (const double *address)
+{
+  return __builtin_vec_ld (0, address);
+}
+
+vector unsigned long long
+test_vld_vector_ul (const vector unsigned long long *address)
+{
+  return __builtin_vec_ld (0, address);
+}
+
+vector signed long long
+test_vld_vector_sl (const vector signed long long *address)
+{
+  return __builtin_vec_ld (0, address);
+}
+
+vector double
+test_vld_vector_d (const vector double *address)
+{
+  return __builtin_vec_ld (0, address);
+}
+
+/* Test vec_st can allow scalar and vector type address. */
+
+void
+test_vst_scalar_ul (vector unsigned long long v, unsigned long long *address)
+{
+  __builtin_vec_st (v, 0, address);
+}
+
+void
+test_vst_scalar_sl (vector signed long long v, signed long long *address)
+{
+  __builtin_vec_st (v, 0, address);
+}
+
+void
+test_vst_scalar_d (vector double v, double *address)
+{
+  __builtin_vec_st (v, 0, address);
+}
+
+void
+test_vst_vector_ul (vector unsigned long long v,
+		    vector unsigned long long *address)
+{
+  __builtin_vec_st (v, 0, address);
+}
+
+void
+test_vst_vector_sl (vector signed long long v, vector signed long long *address)
+{
+  __builtin_vec_st (v, 0, address);
+}
+
+void
+test_vst_vector_d (vector double v, vector double *address)
+{
+  __builtin_vec_st (v, 0, address);
+}
+
diff --git a/gcc/testsuite/gcc.target/powerpc/builtins-1.c b/gcc/testsuite/gcc.target/powerpc/builtins-1.c
index 8d0b7c9b19a..6289302a2b5 100644
--- a/gcc/testsuite/gcc.target/powerpc/builtins-1.c
+++ b/gcc/testsuite/gcc.target/powerpc/builtins-1.c
@@ -165,3 +165,6 @@ int main ()
 
   return 0;
 }
+
+/* Translation of vec_packsu (unsigned long long, unsigned long long) */
+/* { dg-final { scan-assembler-times {\mvpkudus\M} 1 } } */
diff --git a/gcc/testsuite/gcc.target/powerpc/builtins-3-p8.c b/gcc/testsuite/gcc.target/powerpc/builtins-3-p8.c
index 90e573d2654..41715ca8880 100644
--- a/gcc/testsuite/gcc.target/powerpc/builtins-3-p8.c
+++ b/gcc/testsuite/gcc.target/powerpc/builtins-3-p8.c
@@ -1,6 +1,7 @@
 /* { dg-do compile } */
 /* { dg-require-effective-target powerpc_p8vector_ok } */
 /* { dg-options "-mcpu=power8" } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
 
 #include <altivec.h>
 
@@ -16,6 +17,34 @@ test_pack_float (vector double x, vector double y)
   return vec_pack (x, y);
 }
 
+vector unsigned char
+test_vsi_packs_vusi_vusi (vector unsigned short x,
+                          vector unsigned short y)
+{
+  return vec_packs (x, y);
+}
+
+vector signed char
+test_vsi_packs_vssi_vssi (vector signed short x,
+                          vector signed short y)
+{
+  return vec_packs (x, y);
+}
+
+vector signed short int
+test_vsi_packs_vsi_vsi (vector signed int x,
+			vector signed int y)
+{
+  return vec_packs (x, y);
+}
+
+vector unsigned short int
+test_vsi_packs_vui_vui (vector unsigned int x,
+			vector unsigned int y)
+{
+  return vec_packs (x, y);
+}
+
 vector long long
 test_nabs_long_long (vector long long x)
 {
@@ -36,13 +65,57 @@ test_vui_packs_vull_vull (vector unsigned long long x,
   return vec_packs (x, y);
 }
 
+vector unsigned char
+test_vsi_packsu_vssi_vssi (vector signed short x,
+			   vector signed short y)
+{
+  return vec_packsu (x, y);
+}
+
+vector unsigned char
+test_vsi_packsu_vusi_vusi (vector unsigned short x,
+			   vector unsigned short y)
+{
+  return vec_packsu (x, y);
+}
+
+vector unsigned int
+test_vsi_packsu_vsll_vsll (vector signed long long x,
+			   vector signed long long y)
+{
+  return vec_packsu (x, y);
+}
+
+vector unsigned int
+test_vsi_packsu_vull_vull (vector unsigned long long x,
+			   vector unsigned long long y)
+{
+  return vec_packsu (x, y);
+}
+
+vector unsigned short int
+test_vsi_packsu_vsi_vsi (vector signed int x,
+			 vector signed int y)
+{
+  return vec_packsu (x, y);
+}
+
+vector unsigned short int
+test_vsi_packsu_vui_vui (vector unsigned int x,
+			 vector unsigned int y)
+{
+  return vec_packsu (x, y);
+}
+
 /* Expected test results:
 
      test_eq_long_long          1 vcmpequd inst
      test_pack_float            1 vpkudum inst
      test_nabs_long_long        1 vspltisw, 1 vsubudm, 1 vminsd
      test_vsi_packs_vsll_vsll   1 vpksdss
-     test_vui_packs_vull_vull   1 vpkudus */
+     test_vui_packs_vull_vull   1 vpkudus
+     test_vui_packs_vssi_vssi   1 vpkshss
+     test_vsi_packsu_vssi_vssi  1 vpkshus */
 
 /* { dg-final { scan-assembler-times "vcmpequd" 1 } } */
 /* { dg-final { scan-assembler-times "vpkudum"  1 } } */
@@ -50,4 +123,9 @@ test_vui_packs_vull_vull (vector unsigned long long x,
 /* { dg-final { scan-assembler-times "vsubudm"  1 } } */
 /* { dg-final { scan-assembler-times "vminsd"   1 } } */
 /* { dg-final { scan-assembler-times "vpksdss"  1 } } */
-/* { dg-final { scan-assembler-times "vpkudus"  1 } } */  
+/* { dg-final { scan-assembler-times "vpkudus"  2 } } */  
+/* { dg-final { scan-assembler-times "vpkuhus"  2 } } */
+/* { dg-final { scan-assembler-times "vpkshss"  1 } } */
+/* { dg-final { scan-assembler-times "vpkshus"  1 } } */
+/* { dg-final { scan-assembler-times "vpksdus"  1 } } */
+/* { dg-final { scan-assembler-times "vpkuwus"  2 } } */
diff --git a/gcc/testsuite/gcc.target/powerpc/builtins-3-p9-runnable.c b/gcc/testsuite/gcc.target/powerpc/builtins-3-p9-runnable.c
new file mode 100644
index 00000000000..24589b55639
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/builtins-3-p9-runnable.c
@@ -0,0 +1,35 @@
+/* { dg-do run { target { powerpc64*-*-* && { lp64 && p9vector_hw } } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-options "-mcpu=power9 -O2 -mupper-regs-di" } */
+
+#include <altivec.h> // vector
+
+void abort (void);
+
+int main() {
+   int i;
+   vector float vfr, vfexpt;
+   vector unsigned short vusha;
+
+   /* 1.0, -2.0, 0.0, 8.5, 1.5, 0.5, 1.25, -0.25 */
+   vusha = (vector unsigned short){0B011110000000000, 0B1100000000000000,
+                                   0B000000000000000, 0B0100100001000000,
+                                   0B011111000000000, 0B0011100000000000,
+                                   0B011110100000000, 0B1011010000000000};
+   
+   vfexpt = (vector float){1.0, -2.0, 0.0, 8.5};
+   vfr = vec_extract_fp_from_shorth(vusha);
+
+   for (i=0; i<4; i++) {
+      if (vfr[i] != vfexpt[i])
+         abort();
+   }
+
+   vfexpt = (vector float){1.5, 0.5, 1.25, -0.25};
+   vfr = vec_extract_fp_from_shortl(vusha);
+
+   for (i=0; i<4; i++) {
+      if (vfr[i] != vfexpt[i])
+         abort();
+   }
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/builtins-3-p9.c b/gcc/testsuite/gcc.target/powerpc/builtins-3-p9.c
index e3db2da655c..25a94bca612 100644
--- a/gcc/testsuite/gcc.target/powerpc/builtins-3-p9.c
+++ b/gcc/testsuite/gcc.target/powerpc/builtins-3-p9.c
@@ -1,6 +1,7 @@
 /* { dg-do compile } */
 /* { dg-require-effective-target powerpc_p9vector_ok } */
 /* { dg-options "-mcpu=power9" } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
 
 #include <altivec.h>
 
diff --git a/gcc/testsuite/gcc.target/powerpc/builtins-3.c b/gcc/testsuite/gcc.target/powerpc/builtins-3.c
index bddd0ac91cc..fd5e62e9264 100644
--- a/gcc/testsuite/gcc.target/powerpc/builtins-3.c
+++ b/gcc/testsuite/gcc.target/powerpc/builtins-3.c
@@ -1,6 +1,7 @@
 /* { dg-do compile } */
 /* { dg-require-effective-target powerpc_vsx_ok } */
-/* { dg-options "-maltivec -mvsx" } */
+/* { dg-options "-O2 -mvsx -mcpu=power6" } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power6" } } */
 
 #include <altivec.h>
 
@@ -58,6 +59,170 @@ test_nabs_double (vector double x)
 	return vec_nabs (x);
 }
 
+vector signed char
+test_sll_vsc_vsc_vsuc (vector signed char x, vector unsigned char y)
+{
+	return vec_sll (x, y);
+}
+
+vector unsigned char
+test_sll_vuc_vuc_vuc (vector unsigned char x, vector unsigned char y)
+{
+	return vec_sll (x, y);
+}
+
+vector signed int
+test_sll_vsi_vsi_vuc (vector signed int x, vector unsigned char y)
+{
+	return vec_sll (x, y);
+}
+
+vector unsigned int
+test_sll_vui_vui_vuc (vector unsigned int x, vector unsigned char y)
+{
+	return vec_sll (x, y);
+}
+
+vector bool long long
+test_sll_vbll_vbll_vuc (vector bool long long x,
+			vector unsigned char y)
+{
+	return vec_sll (x, y);
+}
+
+vector bool long long
+test_sll_vbll_vbll_vull (vector bool long long x,
+			vector unsigned long long y)
+{
+	return vec_sll (x, y);
+}
+
+vector bool long long
+test_sll_vbll_vbll_vus (vector bool long long x,
+			vector unsigned short y)
+{
+	return vec_sll (x, y);
+}
+vector pixel
+test_sll_vp_vp_vuc (vector pixel x, vector unsigned char y)
+{
+	return vec_sll (x, y);
+}
+
+vector signed short int
+test_sll_vssi_vssi_vuc (vector signed short x, vector unsigned char y)
+{
+	return vec_sll (x, y);
+}
+
+vector unsigned short int
+test_sll_vusi_vusi_vuc (vector unsigned short x, vector unsigned char y)
+{
+	return vec_sll (x, y);
+}
+
+vector signed char
+test_slo_vsc_vsc_vsc (vector signed char x, vector signed char y)
+{
+	return vec_slo (x, y);
+}
+
+vector signed char
+test_slo_vsc_vsc_vuc (vector signed char x, vector unsigned char y)
+{
+	return vec_slo (x, y);
+}
+
+vector unsigned char
+test_slo_vuc_vuc_vsc (vector unsigned char x, vector signed char y)
+{
+	return vec_slo (x, y);
+}
+
+vector unsigned char
+test_slo_vuc_vuc_vuc (vector unsigned char x, vector unsigned char y)
+{
+	return vec_slo (x, y);
+}
+
+vector signed int
+test_slo_vsi_vsi_vsc (vector signed int x, vector signed char y)
+{
+	return vec_slo (x, y);
+}
+
+vector signed int
+test_slo_vsi_vsi_vuc (vector signed int x, vector unsigned char y)
+{
+	return vec_slo (x, y);
+}
+
+vector unsigned int
+test_slo_vui_vui_vsc (vector unsigned int x, vector signed char y)
+{
+	return vec_slo (x, y);
+}
+
+vector unsigned int
+test_slo_vui_vui_vuc (vector unsigned int x, vector unsigned char y)
+{
+	return vec_slo (x, y);
+}
+
+vector pixel
+test_slo_vp_vp_vsc (vector pixel int x, vector signed char y)
+{
+	return vec_slo (x, y);
+}
+
+vector pixel
+test_slo_vp_vp_vuc (vector pixel int x, vector unsigned char y)
+{
+	return vec_slo (x, y);
+}
+
+vector signed short int
+test_slo_vssi_vssi_vsc (vector signed short int x, vector signed char y)
+{
+	return vec_slo (x, y);
+}
+
+vector signed short int
+test_slo_vssi_vssi_vuc (vector signed short int x, vector unsigned char y)
+{
+	return vec_slo (x, y);
+}
+
+vector unsigned short int
+test_slo_vusi_vusi_vsc (vector unsigned short int x, vector signed char y)
+{
+	return vec_slo (x, y);
+}
+
+vector unsigned short int
+test_slo_vusi_vusi_vuc (vector unsigned short int x, vector unsigned char y)
+{
+	return vec_slo (x, y);
+}
+
+vector float
+test_slo_vf_vf_vsc (vector float x, vector signed char y)
+{
+	return vec_slo (x, y);
+}
+
+vector float
+test_slo_vf_vf_vuc (vector float x, vector unsigned char y)
+ {
+ 	return vec_slo (x, y);
+ }
+
+vector int
+test_cmpb_float (vector float x, vector float y)
+{
+	return vec_cmpb (x, y);
+}
+
 /* Expected test results:
 
      test_eq_char              1 vcmpequb inst
@@ -68,7 +233,8 @@ test_nabs_double (vector double x)
      test_nabs_short           1 vspltisw, 1 vsubuhm, 1 vminsh
      test_nabs_int             1 vspltisw, 1 vsubuwm, 1 vminsw
      test_nabs_float           1 xvnabssp
-     test_nabs_double          1 xvnabsdp */
+     test_nabs_double          1 xvnabsdp
+     test_cmpb_float           1 vcmpbfp */
 
 /* { dg-final { scan-assembler-times "vcmpequb" 1 } } */
 /* { dg-final { scan-assembler-times "vcmpequh" 1 } } */
@@ -83,4 +249,5 @@ test_nabs_double (vector double x)
 /* { dg-final { scan-assembler-times "vspltisw" 3 } } */
 /* { dg-final { scan-assembler-times "xvnabssp" 1 } } */
 /* { dg-final { scan-assembler-times "xvnabsdp" 1 } } */
+/* { dg-final { scan-assembler-times "vcmpbfp"  1 } } */
 
diff --git a/gcc/testsuite/gcc.target/powerpc/builtins-7-p9-runnable.c b/gcc/testsuite/gcc.target/powerpc/builtins-7-p9-runnable.c
new file mode 100644
index 00000000000..137b46b052a
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/builtins-7-p9-runnable.c
@@ -0,0 +1,169 @@
+/* { dg-do run { target { powerpc*-*-* && p9vector_hw } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-options "-mcpu=power9 -O2" } */
+
+#include <altivec.h>
+#define TRUE 1
+#define FALSE 0
+
+#ifdef DEBUG
+#include <stdio.h>
+#endif
+
+#define EXTRACT 0
+
+void abort (void);
+
+int result_wrong_ull (vector unsigned long long vec_expected,
+		      vector unsigned long long vec_actual)
+{
+  int i;
+
+  for (i = 0; i < 2; i++)
+    if (vec_expected[i] != vec_actual[i])
+      return TRUE;
+
+  return FALSE;
+}
+
+int result_wrong_uc (vector unsigned char vec_expected,
+		     vector unsigned char vec_actual)
+{
+  int i;
+
+  for (i = 0; i < 16; i++)
+    if (vec_expected[i] != vec_actual[i])
+      return TRUE;
+
+  return FALSE;
+}
+
+#ifdef DEBUG
+void print_ull (vector unsigned long long vec_expected,
+		vector unsigned long long vec_actual)
+{
+  int i;
+
+  printf("expected unsigned long long data\n");
+  for (i = 0; i < 2; i++)
+    printf(" %lld,", vec_expected[i]);
+
+  printf("\nactual signed char data\n");
+  for (i = 0; i < 2; i++)
+    printf(" %lld,", vec_actual[i]);
+  printf("\n");
+}
+
+void print_uc (vector unsigned char vec_expected,
+	       vector unsigned char vec_actual)
+{
+  int i;
+
+  printf("expected unsigned char data\n");
+  for (i = 0; i < 16; i++)
+    printf(" %d,", vec_expected[i]);
+
+  printf("\nactual unsigned char data\n");
+  for (i = 0; i < 16; i++)
+    printf(" %d,", vec_actual[i]);
+  printf("\n");
+}
+#endif
+
+#if EXTRACT
+vector unsigned long long
+vext (vector unsigned char *vc)
+{
+  return vextract_si_vchar (*vc, 5);
+}
+#endif
+
+int main()
+{
+   vector signed int vsi_arg;
+   vector unsigned char vec_uc_arg, vec_uc_result, vec_uc_expected;
+   vector unsigned long long vec_ull_result, vec_ull_expected;
+   unsigned long long ull_result, ull_expected;
+
+   vec_uc_arg = (vector unsigned char){1, 2, 3, 4,
+				       5, 6, 7, 8,
+				       9, 10, 11, 12,
+				       13, 14, 15, 16};
+
+   vsi_arg = (vector signed int){0xA, 0xB, 0xC, 0xD};
+
+   vec_uc_expected = (vector unsigned char){0xC, 0, 0, 0,
+					    5, 6, 7, 8,
+					    9, 10, 11, 12,
+					    13, 14, 15, 16};
+   /* Test vec_insert4b() */
+   /* Insert into char 0 location */
+   vec_uc_result = vec_insert4b (vsi_arg, vec_uc_arg, 0);
+
+   if (result_wrong_uc(vec_uc_expected, vec_uc_result))
+     {
+#ifdef DEBUG
+        printf("Error: vec_insert4b pos 0, result does not match expected result\n");
+	print_uc (vec_uc_expected, vec_uc_result);
+#else
+        abort();
+#endif
+      }
+
+   /* insert into char 4 location */
+   vec_uc_expected = (vector unsigned char){1, 2, 3, 4,
+					    0xC, 0, 0, 0,
+					    9, 10, 11, 12,
+					    13, 14, 15, 16};
+   vec_uc_result = vec_insert4b (vsi_arg, vec_uc_arg, 4);
+
+   if (result_wrong_uc(vec_uc_expected, vec_uc_result))
+     {
+#ifdef DEBUG
+        printf("Error: vec_insert4b pos 4, result does not match expected result\n");
+	print_uc (vec_uc_expected, vec_uc_result);
+#else
+        abort();
+#endif
+      }
+
+   /* Test vec_extract4b() */
+   /* Extract 4b, from char 0 location */
+   vec_uc_arg = (vector unsigned char){10, 0, 0, 0,
+				       20, 0, 0, 0,
+				       30, 0, 0, 0,
+				       40, 0, 0, 0};
+
+   vec_ull_expected = (vector unsigned long long){0, 10};
+   vec_ull_result = vec_extract4b(vec_uc_arg, 0);
+
+   if (result_wrong_ull(vec_ull_expected, vec_ull_result))
+     {
+#ifdef DEBUG
+        printf("Error: vec_extract4b pos 0, result does not match expected result\n");
+	print_ull (vec_ull_expected, vec_ull_result);
+#else
+        abort();
+#endif
+      }
+
+   /* Extract 4b, from char 12 location */
+   vec_uc_arg = (vector unsigned char){10, 0, 0, 0,
+				       20, 0, 0, 0,
+				       30, 0, 0, 0,
+				       40, 0, 0, 0};
+
+   vec_ull_expected = (vector unsigned long long){0, 40};
+   vec_ull_result = vec_extract4b(vec_uc_arg, 12);
+
+   if (result_wrong_ull(vec_ull_expected, vec_ull_result))
+     {
+#ifdef DEBUG
+        printf("Error: vec_extract4b pos 12, result does not match expected result\n");
+	print_ull (vec_ull_expected, vec_ull_result);
+#else
+        abort();
+#endif
+      }
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/crypto-builtin-1-runnable.c b/gcc/testsuite/gcc.target/powerpc/crypto-builtin-1-runnable.c
new file mode 100644
index 00000000000..25c27bf9a37
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/crypto-builtin-1-runnable.c
@@ -0,0 +1,109 @@
+/* { dg-do run { target { powerpc*-*-* && p8vector_hw } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
+/* { dg-options "-mcpu=power8 -O2 " } */
+
+/* Make sure the test case compiled with -O2 generates the same expected
+   results.  The expected results were generated with -O0.  */
+
+#include <altivec.h>
+#define TRUE 1
+#define FALSE 0
+
+#define DEBUG 1
+
+#ifdef DEBUG
+#include <stdio.h>
+#endif
+
+void abort (void);
+
+typedef vector unsigned long long	crypto_t;
+typedef vector unsigned long long	v2di_t;
+typedef vector unsigned int		v4si_t;
+typedef vector unsigned short		v8hi_t;
+typedef vector unsigned char		v16qi_t;
+
+v16qi_t crypto6a (v16qi_t a, v16qi_t b, v16qi_t c)
+{
+  return __builtin_crypto_vpermxor (a, b, c);
+}
+
+v8hi_t crypto6b (v8hi_t a, v8hi_t b, v8hi_t c)
+{
+  return __builtin_crypto_vpermxor (a, b, c);
+}
+
+v4si_t crypto6c (v4si_t a, v4si_t b, v4si_t c)
+{
+  return __builtin_crypto_vpermxor (a, b, c);
+}
+
+v2di_t crypto6d (v2di_t a, v2di_t b, v2di_t c)
+{
+  return __builtin_crypto_vpermxor (a, b, c);
+}
+
+int main()
+{
+  int i;
+  v16qi_t expected_v16qi, result_v16qi;
+  v8hi_t expected_v8hi, result_v8hi;
+  v4si_t expected_v4si, result_v4si;
+  v2di_t expected_v2di, result_v2di;
+  v16qi_t v16qi_arg_a, v16qi_arg_b, v16qi_arg_c;
+  v8hi_t v8hi_arg_a, v8hi_arg_b, v8hi_arg_c;
+  v4si_t v4si_arg_a, v4si_arg_b, v4si_arg_c;
+  v2di_t v2di_arg_a, v2di_arg_b, v2di_arg_c;
+
+  v16qi_arg_a = (vector unsigned char){ 7, 6, 5, 4, 3, 2, 1, 0,
+					1, 2, 3, 4, 5, 6, 7, 8 };
+  v16qi_arg_b = (vector unsigned char){ 1, 2, 3, 4, 5, 6, 7, 8,
+					7, 6, 5, 4, 3, 2, 1, 0 };
+  v16qi_arg_c = (vector unsigned char){ 7, 2, 5, 4, 3, 6, 1, 8,
+					1, 6, 3, 4, 5, 2, 7, 0 };
+  expected_v16qi = (vector unsigned char){ 15, 10, 13, 12, 11, 14, 9, 0,
+					   9, 14, 11, 12, 13, 10, 15, 8 };
+		
+  result_v16qi = crypto6a (v16qi_arg_a, v16qi_arg_b, v16qi_arg_c);
+				      
+  for (i = 0; i < 16; i++)
+    if (expected_v16qi[i] != result_v16qi[i])
+      printf("crypto6a: result_v16qi[%d] =  %d, expected = %d\n",
+	     i, result_v16qi[i], expected_v16qi[i]);
+
+  v8hi_arg_a = (vector unsigned short int){ 7, 6, 5, 4, 3, 2, 1, 0};
+  v8hi_arg_b = (vector unsigned short int){ 1, 2, 3, 4, 5, 6, 7, 8};
+  v8hi_arg_c = (vector unsigned short int){ 7, 2, 5, 4, 3, 6, 1, 8};
+  expected_v8hi = (vector unsigned short int){ 5, 0, 6, 0, 7, 0, 8};
+		
+  result_v8hi = crypto6b (v8hi_arg_a, v8hi_arg_b, v8hi_arg_c);
+				      
+  for (i = 0; i < 8; i++)
+    if (expected_v8hi[i] != result_v8hi[i])
+      printf("crypto6a: result_v8hi[%d] =  %d, expected = %d\n",
+	     i, result_v8hi[i], expected_v8hi[i]);
+
+  v4si_arg_a = (vector unsigned int){ 7, 6, 5, 4};
+  v4si_arg_b = (vector unsigned int){ 15, 6, 7, 8};
+  v4si_arg_c = (vector unsigned int){ 7, 14, 3, 6};
+  expected_v4si = (vector unsigned int){ 7, 0, 8, 0};
+		
+  result_v4si = crypto6c (v4si_arg_a, v4si_arg_b, v4si_arg_c);
+				      
+  for (i = 0; i < 4; i++)
+    if (expected_v4si[i] != result_v4si[i])
+      printf("crypto6a: result_v4si[%d] =  %d, expected = %d\n",
+	     i, result_v4si[i], expected_v4si[i]);
+
+  v2di_arg_a = (vector unsigned long long int){ 7, 6, };
+  v2di_arg_b = (vector unsigned long long int){ 15, 6, };
+  v2di_arg_c = (vector unsigned long long int){ 7, 14};
+  expected_v2di = (vector unsigned long long int){ 6, 0};
+		
+  result_v2di = crypto6d (v2di_arg_a, v2di_arg_b, v2di_arg_c);
+				      
+  for (i = 0; i < 2; i++)
+    if (expected_v2di[i] != result_v2di[i])
+      printf("crypto6a: result_v2di[%d] =  %d, expected = %d\n",
+	     i, result_v2di[i], expected_v2di[i]);
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/crypto-builtin-1.c b/gcc/testsuite/gcc.target/powerpc/crypto-builtin-1.c
index e4b460e6f67..941f11dda1f 100644
--- a/gcc/testsuite/gcc.target/powerpc/crypto-builtin-1.c
+++ b/gcc/testsuite/gcc.target/powerpc/crypto-builtin-1.c
@@ -4,37 +4,63 @@
 /* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
 /* { dg-options "-mcpu=power8 -O2 -ftree-vectorize -fvect-cost-model=dynamic -fno-unroll-loops -fno-unroll-all-loops" } */
 
+#include <altivec.h>
 typedef vector unsigned long long	crypto_t;
 typedef vector unsigned long long	v2di_t;
 typedef vector unsigned int		v4si_t;
 typedef vector unsigned short		v8hi_t;
 typedef vector unsigned char		v16qi_t;
 
-crypto_t crpyto1 (crypto_t a)
+crypto_t crypto1 (crypto_t a)
 {
   return __builtin_crypto_vsbox (a);
 }
 
+v16qi_t crypto1_be (v16qi_t a)
+{
+  return vec_sbox_be (a);
+}
+
 crypto_t crypto2 (crypto_t a, crypto_t b)
 {
   return __builtin_crypto_vcipher (a, b);
 }
 
+v16qi_t crypto2_be (v16qi_t a, v16qi_t b)
+{
+  return vec_cipher_be (a, b);
+}
+
 crypto_t crypto3 (crypto_t a, crypto_t b)
 {
   return __builtin_crypto_vcipherlast (a, b);
 }
 
+v16qi_t crypto3_be (v16qi_t a, v16qi_t b)
+{
+  return vec_cipherlast_be (a, b);
+}
+
 crypto_t crypto4 (crypto_t a, crypto_t b)
 {
   return __builtin_crypto_vncipher (a, b);
 }
 
+v16qi_t crypto4_be (v16qi_t a, v16qi_t b)
+{
+  return vec_ncipher_be (a, b);
+}
+
 crypto_t crypto5 (crypto_t a, crypto_t b)
 {
   return __builtin_crypto_vncipherlast (a, b);
 }
 
+v16qi_t crypto5_be (v16qi_t a, v16qi_t b)
+{
+  return vec_ncipherlast_be (a, b);
+}
+
 v16qi_t crypto6a (v16qi_t a, v16qi_t b, v16qi_t c)
 {
   return __builtin_crypto_vpermxor (a, b, c);
@@ -117,15 +143,15 @@ v4si_t crypto8d (v4si_t a)
 
 /* Note space is used after the instruction so that vcipherlast does not match
    vcipher.  */
-/* { dg-final { scan-assembler-times "vcipher "      1 } } */
-/* { dg-final { scan-assembler-times "vcipherlast "  1 } } */
-/* { dg-final { scan-assembler-times "vncipher "     1 } } */
-/* { dg-final { scan-assembler-times "vncipherlast " 1 } } */
+/* { dg-final { scan-assembler-times "vcipher "      2 } } */
+/* { dg-final { scan-assembler-times "vcipherlast "  2 } } */
+/* { dg-final { scan-assembler-times "vncipher "     2 } } */
+/* { dg-final { scan-assembler-times "vncipherlast " 2 } } */
 /* { dg-final { scan-assembler-times "vpermxor "     4 } } */
 /* { dg-final { scan-assembler-times "vpmsumb "      2 } } */
 /* { dg-final { scan-assembler-times "vpmsumd "      2 } } */
 /* { dg-final { scan-assembler-times "vpmsumh "      2 } } */
 /* { dg-final { scan-assembler-times "vpmsumw "      2 } } */
-/* { dg-final { scan-assembler-times "vsbox "        1 } } */
+/* { dg-final { scan-assembler-times "vsbox "        2 } } */
 /* { dg-final { scan-assembler-times "vshasigmad "   2 } } */
 /* { dg-final { scan-assembler-times "vshasigmaw "   2 } } */
diff --git a/gcc/testsuite/gcc.target/powerpc/extend-divide-1.c b/gcc/testsuite/gcc.target/powerpc/extend-divide-1.c
index 365dead9fac..aaf9b40fc24 100644
--- a/gcc/testsuite/gcc.target/powerpc/extend-divide-1.c
+++ b/gcc/testsuite/gcc.target/powerpc/extend-divide-1.c
@@ -5,9 +5,7 @@
 /* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power7" } } */
 /* { dg-options "-mcpu=power7 -O2" } */
 /* { dg-final { scan-assembler-times "divwe "   1 } } */
-/* { dg-final { scan-assembler-times "divweo "  1 } } */
 /* { dg-final { scan-assembler-times "divweu "  1 } } */
-/* { dg-final { scan-assembler-times "divweuo " 1 } } */
 /* { dg-final { scan-assembler-not    "bl __builtin" } } */
 
 int
@@ -16,20 +14,8 @@ div_we (int a, int b)
   return __builtin_divwe (a, b);
 }
 
-int
-div_weo (int a, int b)
-{
-  return __builtin_divweo (a, b);
-}
-
 unsigned int
 div_weu (unsigned int a, unsigned int b)
 {
   return __builtin_divweu (a, b);
 }
-
-unsigned int
-div_weuo (unsigned int a, unsigned int b)
-{
-  return __builtin_divweuo (a, b);
-}
diff --git a/gcc/testsuite/gcc.target/powerpc/extend-divide-2.c b/gcc/testsuite/gcc.target/powerpc/extend-divide-2.c
index 829cd40cae8..92e494aa136 100644
--- a/gcc/testsuite/gcc.target/powerpc/extend-divide-2.c
+++ b/gcc/testsuite/gcc.target/powerpc/extend-divide-2.c
@@ -5,9 +5,7 @@
 /* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power7" } } */
 /* { dg-options "-mcpu=power7 -O2" } */
 /* { dg-final { scan-assembler-times "divde "   1 } } */
-/* { dg-final { scan-assembler-times "divdeo "  1 } } */
 /* { dg-final { scan-assembler-times "divdeu "  1 } } */
-/* { dg-final { scan-assembler-times "divdeuo " 1 } } */
 /* { dg-final { scan-assembler-not    "bl __builtin" } } */
 
 long
@@ -16,20 +14,8 @@ div_de (long a, long b)
   return __builtin_divde (a, b);
 }
 
-long
-div_deo (long a, long b)
-{
-  return __builtin_divdeo (a, b);
-}
-
 unsigned long
 div_deu (unsigned long a, unsigned long b)
 {
   return __builtin_divdeu (a, b);
 }
-
-unsigned long
-div_deuo (unsigned long a, unsigned long b)
-{
-  return __builtin_divdeuo (a, b);
-}
diff --git a/gcc/testsuite/gcc.target/powerpc/fold-vec-mult-int128-p8.c b/gcc/testsuite/gcc.target/powerpc/fold-vec-mult-int128-p8.c
index a133c5d90fe..b1cf0a78628 100644
--- a/gcc/testsuite/gcc.target/powerpc/fold-vec-mult-int128-p8.c
+++ b/gcc/testsuite/gcc.target/powerpc/fold-vec-mult-int128-p8.c
@@ -4,7 +4,9 @@
 /* { dg-do compile } */
 /* { dg-require-effective-target powerpc_p8vector_ok } */
 /* { dg-require-effective-target int128 } */
-/* { dg-options "-maltivec -mvsx -mpower8-vector" } */
+/* { dg-require-effective-target lp64 } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
+/* { dg-options "-mpower8-vector -mcpu=power8 -O2" } */
 /* { dg-additional-options "-maix64" { target powerpc-ibm-aix* } } */
 
 #include "altivec.h"
@@ -21,5 +23,5 @@ test2 (vector unsigned __int128 x, vector unsigned __int128 y)
   return vec_mul (x, y);
 }
 
-/* { dg-final { scan-assembler-times "\[ \t\]mulld " 6 } } */
-/* { dg-final { scan-assembler-times "\[ \t\]mulhdu" 2 } } */
+/* { dg-final { scan-assembler-times {\mmulld\M} 6 } } */
+/* { dg-final { scan-assembler-times {\mmulhdu\M} 2 } } */
diff --git a/gcc/testsuite/gcc.target/powerpc/fold-vec-mult-int128-p9.c b/gcc/testsuite/gcc.target/powerpc/fold-vec-mult-int128-p9.c
index 96c9d019682..657188435d4 100644
--- a/gcc/testsuite/gcc.target/powerpc/fold-vec-mult-int128-p9.c
+++ b/gcc/testsuite/gcc.target/powerpc/fold-vec-mult-int128-p9.c
@@ -2,10 +2,10 @@
    inputs produce the right results.  */
 
 /* { dg-do compile } */
-/* { dg-require-effective-target powerpc_float128_hw_ok } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
 /* { dg-require-effective-target int128 } */
 /* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
-/* { dg-options "-maltivec -mvsx -mcpu=power9 -O2" } */
+/* { dg-options "-mpower9-vector -mcpu=power9 -O2" } */
 /* { dg-additional-options "-maix64" { target powerpc-ibm-aix* } } */
 
 #include "altivec.h"
@@ -22,4 +22,5 @@ test2 (vector unsigned __int128 x, vector unsigned __int128 y)
   return vec_mul (x, y);
 }
 
-/* { dg-final { scan-assembler-times "\[ \t\]xsmulqp" 2 } } */
+/* { dg-final { scan-assembler-times {\mmulld\M} 4 } } */
+/* { dg-final { scan-assembler-times {\mmulhdu\M} 2 } } */
diff --git a/gcc/testsuite/gcc.target/powerpc/lvsl-lvsr.c b/gcc/testsuite/gcc.target/powerpc/lvsl-lvsr.c
index 71dd0a24ae1..6a7baf31b43 100644
--- a/gcc/testsuite/gcc.target/powerpc/lvsl-lvsr.c
+++ b/gcc/testsuite/gcc.target/powerpc/lvsl-lvsr.c
@@ -6,7 +6,7 @@
 /* { dg-options "-O0 -Wno-deprecated" } */
 /* { dg-final { scan-assembler-times "lvsl" 2 } } */
 /* { dg-final { scan-assembler-times "lvsr" 2 } } */
-/* { dg-final { scan-assembler-times "lxvd2x" 2 } } */
+/* { dg-final { scan-assembler-times {\mlxvd2x\M|\mlxv\M} 2 } } */
 /* { dg-final { scan-assembler-times "vperm" 2 } } */
 
 
diff --git a/gcc/testsuite/gcc.target/powerpc/p8vector-builtin-2.c b/gcc/testsuite/gcc.target/powerpc/p8vector-builtin-2.c
index 13df1485cba..b57277992cf 100644
--- a/gcc/testsuite/gcc.target/powerpc/p8vector-builtin-2.c
+++ b/gcc/testsuite/gcc.target/powerpc/p8vector-builtin-2.c
@@ -9,6 +9,14 @@
 typedef vector long long		v_sign;
 typedef vector unsigned long long	v_uns;
 typedef vector bool long long		v_bool;
+typedef vector bool char		v_bchar;
+typedef vector bool int 		v_bint;
+typedef vector bool short		v_bshort;
+typedef vector signed int		v_sint;
+typedef vector unsigned int		v_uint;
+typedef vector signed char		v_schar;
+typedef vector unsigned char		v_uchar;
+typedef vector float			v_float;
 
 v_sign sign_add_1 (v_sign a, v_sign b)
 {
@@ -191,15 +199,88 @@ v_sign sign_sra_3 (v_sign a, v_uns b)
   return vec_vsrad (a, b);
 }
 
+v_bchar vbchar_eq (v_bchar a, v_bchar b)
+{
+  return vec_cmpeq (a, b);
+}
+
+v_bchar vbschar_eq (v_schar a, v_schar b)
+{
+  return vec_cmpeq (a, b);
+}
+
+v_bchar vuchar_eq (v_uchar a, v_uchar b)
+{
+  return vec_cmpeq (a, b);
+}
+
+v_bint vbint_eq (v_bint a, v_bint b)
+{
+  return vec_cmpeq (a, b);
+}
+
+v_bint vsint_eq (v_sint a, v_sint b)
+{
+  return vec_cmpeq (a, b);
+}
+
+v_bint vuint_eq (v_uint a, v_uint b)
+{
+  return vec_cmpeq (a, b);
+}
+
+v_bool vbool_eq (v_bool a, v_bool b)
+{
+  return vec_cmpeq (a, b);
+}
+
+v_bint vbint_ne (v_bint a, v_bint b)
+{
+  return vec_cmpne (a, b);
+}
+
+v_bint vsint_ne (v_sint a, v_sint b)
+{
+  return vec_cmpne (a, b);
+}
+
+v_bint vuint_ne (v_uint a, v_uint b)
+{
+  return vec_cmpne (a, b);
+}
+
+v_bool vbool_ne (v_bool a, v_bool b)
+{
+  return vec_cmpne (a, b);
+}
+
+v_bool vsign_ne (v_sign a, v_sign b)
+{
+  return vec_cmpne (a, b);
+}
+
+v_bool vuns_ne (v_uns a, v_uns b)
+{
+  return vec_cmpne (a, b);
+}
+
+v_bshort vbshort_ne (v_bshort a, v_bshort b)
+{
+  return vec_cmpne (a, b);
+}
+
+
 /* { dg-final { scan-assembler-times "vaddudm" 	5 } } */
 /* { dg-final { scan-assembler-times "vsubudm" 	6 } } */
 /* { dg-final { scan-assembler-times "vmaxsd"  	4 } } */
 /* { dg-final { scan-assembler-times "vminsd"  	3 } } */
 /* { dg-final { scan-assembler-times "vmaxud"  	2 } } */
 /* { dg-final { scan-assembler-times "vminud"  	2 } } */
-/* { dg-final { scan-assembler-times "vcmpequd" 2 } } */
+/* { dg-final { scan-assembler-times "vcmpequd" 6 } } */
 /* { dg-final { scan-assembler-times "vcmpgtsd" 1 } } */
 /* { dg-final { scan-assembler-times "vcmpgtud" 1 } } */
 /* { dg-final { scan-assembler-times "vrld"     3 } } */
 /* { dg-final { scan-assembler-times "vsld"     5 } } */
 /* { dg-final { scan-assembler-times "vsrad"    3 } } */
+/* { dg-final { scan-assembler-times "vcmpequb" 3 } } */
+/* { dg-final { scan-assembler-times "vcmpequw" 6 } } */
diff --git a/gcc/testsuite/gcc.target/powerpc/p9-vinsert4b-1.c b/gcc/testsuite/gcc.target/powerpc/p9-vinsert4b-1.c
deleted file mode 100644
index fa1ba754705..00000000000
--- a/gcc/testsuite/gcc.target/powerpc/p9-vinsert4b-1.c
+++ /dev/null
@@ -1,39 +0,0 @@
-/* { dg-do compile { target { powerpc64*-*-* && lp64 } } } */
-/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
-/* { dg-require-effective-target powerpc_p9vector_ok } */
-/* { dg-options "-mcpu=power9 -O2" } */
-
-#include <altivec.h>
-
-vector signed char
-vins_v4si (vector int *vi, vector signed char *vc)
-{
-  return vec_vinsert4b (*vi, *vc, 1);
-}
-
-vector unsigned char
-vins_di (long di, vector unsigned char *vc)
-{
-  return vec_vinsert4b (di, *vc, 2);
-}
-
-vector char
-vins_di2 (long *p_di, vector char *vc)
-{
-  return vec_vinsert4b (*p_di, *vc, 3);
-}
-
-vector unsigned char
-vins_di0 (vector unsigned char *vc)
-{
-  return vec_vinsert4b (0, *vc, 4);
-}
-
-long
-vext (vector signed char *vc)
-{
-  return vec_vextract4b (*vc, 5);
-}
-
-/* { dg-final { scan-assembler "xxextractuw\|vextuw\[lr\]x" } } */
-/* { dg-final { scan-assembler "xxinsertw" } } */
diff --git a/gcc/testsuite/gcc.target/powerpc/p9-vinsert4b-2.c b/gcc/testsuite/gcc.target/powerpc/p9-vinsert4b-2.c
deleted file mode 100644
index 3b5872ebec6..00000000000
--- a/gcc/testsuite/gcc.target/powerpc/p9-vinsert4b-2.c
+++ /dev/null
@@ -1,30 +0,0 @@
-/* { dg-do compile { target { powerpc64*-*-* && lp64 } } } */
-/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
-/* { dg-require-effective-target powerpc_p9vector_ok } */
-/* { dg-options "-mcpu=power9 -O2" } */
-
-#include <altivec.h>
-
-vector signed char
-ins_v4si (vector int vi, vector signed char vc)
-{
-  return vec_vinsert4b (vi, vc, 13);	/* { dg-error "vec_vinsert4b" } */
-}
-
-vector unsigned char
-ins_di (long di, vector unsigned char vc, long n)
-{
-  return vec_vinsert4b (di, vc, n);	/* { dg-error "vec_vinsert4b" } */
-}
-
-long
-vext1 (vector signed char vc)
-{
-  return vec_vextract4b (vc, 13);	/* { dg-error "vec_vextract4b" } */
-}
-
-long
-vextn (vector unsigned char vc, long n)
-{
-  return vec_vextract4b (vc, n);	/* { dg-error "vec_vextract4b" } */
-}
diff --git a/gcc/testsuite/gcc.target/powerpc/ppc-fortran/ppc-fortran.exp b/gcc/testsuite/gcc.target/powerpc/ppc-fortran/ppc-fortran.exp
index 82cbb210b92..320e2e09c81 100644
--- a/gcc/testsuite/gcc.target/powerpc/ppc-fortran/ppc-fortran.exp
+++ b/gcc/testsuite/gcc.target/powerpc/ppc-fortran/ppc-fortran.exp
@@ -36,7 +36,7 @@ proc dg-compile-aux-modules { args } {
     global gfortran_test_path
     global gfortran_aux_module_flags
     if { [llength $args] != 2 } {
-	error "dg-set-target-env-var: needs one argument"
+	error "dg-compile-aux-modules: needs one argument"
 	return
     }
 
diff --git a/gcc/testsuite/gcc.target/powerpc/ppc-sdata-2.c b/gcc/testsuite/gcc.target/powerpc/ppc-sdata-2.c
index 570c81f7e33..ee77456ca4f 100644
--- a/gcc/testsuite/gcc.target/powerpc/ppc-sdata-2.c
+++ b/gcc/testsuite/gcc.target/powerpc/ppc-sdata-2.c
@@ -5,6 +5,7 @@
 /* { dg-final { scan-assembler-not "\\.section\[ \t\]\\.sdata2," } } */
 /* { dg-final { scan-assembler "sdat@sdarel\\(13\\)" } } */
 /* { dg-final { scan-assembler "sdat2@sdarel\\(13\\)" } } */
+/* { dg-skip-if "" { *-*-* } { "-mno-readonly-in-sdata" } { "" } } */
 
 
 int sdat = 2;
diff --git a/gcc/testsuite/gcc.target/powerpc/pr79799-2.c b/gcc/testsuite/gcc.target/powerpc/pr79799-2.c
index 793e3b9b66c..b1a0b09cbf7 100644
--- a/gcc/testsuite/gcc.target/powerpc/pr79799-2.c
+++ b/gcc/testsuite/gcc.target/powerpc/pr79799-2.c
@@ -8,7 +8,7 @@
 /* Optimize x = vec_insert (vec_extract (v2, N), v1, M) for SFmode if N is the default
    scalar position.  */
 
-#if __ORDER_LITTLE_ENDIAN__
+#if __LITTLE_ENDIAN__
 #define ELE 2
 #else
 #define ELE 1
diff --git a/gcc/testsuite/gcc.target/powerpc/pr81572.c b/gcc/testsuite/gcc.target/powerpc/pr81572.c
new file mode 100644
index 00000000000..de00c187d62
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr81572.c
@@ -0,0 +1,13 @@
+/* { dg-do compile { target powerpc64*-*-* } } */
+/* { dg-options "-O2 -mcpu=power7" } */
+/* { dg-final { scan-assembler-not "xxlor" } } */
+
+#include <altivec.h>
+
+typedef __vector unsigned char nvec_t;
+
+long testz_and(nvec_t a, nvec_t b)
+{
+  nvec_t c = vec_andc(a, b);
+  return vec_all_eq(a, c);
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/pr83399.c b/gcc/testsuite/gcc.target/powerpc/pr83399.c
new file mode 100644
index 00000000000..96d9b382184
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr83399.c
@@ -0,0 +1,15 @@
+/* PR target/83399 */
+/* { dg-do compile } */
+/* { dg-require-effective-target powerpc_vsx_ok } */
+/* { dg-options "-O1 -mabi=elfv2 -mlittle -mvsx" } */
+
+typedef __attribute__((altivec(vector__))) int v4si_t;
+int
+foo (void)
+{
+  v4si_t a, u, v, y;
+  u = __builtin_altivec_lvx (32, ((void *) &a) - 32);
+  v = __builtin_altivec_lvx (64, ((void *) &a) - 32);
+  y = u + v;
+  return y[0];
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/pr83660.C b/gcc/testsuite/gcc.target/powerpc/pr83660.C
new file mode 100644
index 00000000000..60adcdacb4b
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr83660.C
@@ -0,0 +1,14 @@
+/* PR target/83660 */
+/* { dg-do compile } */
+/* { dg-options "-mcpu=power7" } */
+
+#include <altivec.h>
+
+typedef __vector unsigned int  uvec32_t  __attribute__((__aligned__(16)));
+
+unsigned get_word(uvec32_t v)
+{
+    return ({const unsigned _B1 = 32;
+            vec_extract((uvec32_t)v, 2);});
+}
+
diff --git a/gcc/testsuite/gcc.target/powerpc/pr83862.c b/gcc/testsuite/gcc.target/powerpc/pr83862.c
new file mode 100644
index 00000000000..ac97e6aa5b4
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr83862.c
@@ -0,0 +1,34 @@
+/* PR target/83862.c */
+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */
+/* { dg-require-effective-target ppc_float128_sw } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-options "-mpower9-vector -O2 -mfloat128" } */
+
+/* On little endian systems, optimizing signbit of IEEE 128-bit values from
+   memory could abort if the memory address was indexed (reg+reg).  The
+   optimization is only on 64-bit machines with direct move.
+
+   Compile with -g -O2 -mabi=ieeelongdouble -Wno-psabi.  */
+
+#ifndef TYPE
+#define TYPE __float128
+#endif
+
+int sbr (TYPE a) { return __builtin_signbit (a); }
+int sbm (TYPE *a) { return __builtin_signbit (*a); }
+int sbo (TYPE *a) { return __builtin_signbit (a[4]); }
+int sbi (TYPE *a, unsigned long n) { return __builtin_signbit (a[n]); }
+void sbs (int *p, TYPE a) { *p = __builtin_signbit (a); }
+
+/* On big endian systems, this will generate 2 LDs and 1 LDX, while on
+   little endian systems, this will generate 3 LDs and an ADD.  */
+
+/* { dg-final { scan-assembler-times {\mldx?\M}    3 } } */
+/* { dg-final { scan-assembler-times {\mmfvsrd\M}  2 } } */
+/* { dg-final { scan-assembler-times {\msrdi\M}    5 } } */
+/* { dg-final { scan-assembler-not   {\mmfvsrld\M}   } } */
+/* { dg-final { scan-assembler-not   {\mstxvx?\M}    } } */
+/* { dg-final { scan-assembler-not   {\mstxvw4x\M}   } } */
+/* { dg-final { scan-assembler-not   {\mstxvd2x\M}   } } */
+/* { dg-final { scan-assembler-not   {\mstvx\M}      } } */
+
diff --git a/gcc/testsuite/gcc.target/powerpc/pr83969.c b/gcc/testsuite/gcc.target/powerpc/pr83969.c
new file mode 100644
index 00000000000..fe61594be16
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr83969.c
@@ -0,0 +1,14 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=G5" } } */
+/* { dg-options "-O1 -mcpu=G5 -fno-split-wide-types -ftree-loop-vectorize" } */
+
+long long int
+n7 (int po, long long int r4)
+{
+  while (po < 1)
+    {
+      r4 |= 1;
+      ++po;
+    }
+  return r4;
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/pr84154-1.c b/gcc/testsuite/gcc.target/powerpc/pr84154-1.c
new file mode 100644
index 00000000000..c7c61be0def
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr84154-1.c
@@ -0,0 +1,55 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "" { powerpc*-*-darwin* } } */
+/* { dg-require-effective-target powerpc_p8vector_ok } */
+/* { dg-options "-mpower8-vector -O2" } */
+
+/* PR target/84154.  Make sure conversion to char/short does not generate a
+   store and a load on ISA 2.07 and newer systems.  */
+
+unsigned char
+double_to_uc (double x)
+{
+  return x;
+}
+
+signed char
+double_to_sc (double x)
+{
+  return x;
+}
+
+unsigned short
+double_to_us (double x)
+{
+  return x;
+}
+
+short
+double_to_ss (double x)
+{
+  return x;
+}
+
+unsigned int
+double_to_ui (double x)
+{
+  return x;
+}
+
+int
+double_to_si (double x)
+{
+  return x;
+}
+
+/* { dg-final { scan-assembler-times {\mextsb\M}                  1 } } */
+/* { dg-final { scan-assembler-times {\mextsh\M}                  1 } } */
+/* { dg-final { scan-assembler-times {\mfctiwuz\M|\mxscvdpuxws\M} 3 } } */
+/* { dg-final { scan-assembler-times {\mfctiwz\M|\mxscvdpsxws\M}  3 } } */
+/* { dg-final { scan-assembler-times {\mmfvsrwz\M}                6 } } */
+/* { dg-final { scan-assembler-times {\mrlwinm\M}                 2 } } */
+/* { dg-final { scan-assembler-not   {\mlbz\M}                      } } */
+/* { dg-final { scan-assembler-not   {\mlhz\M}                      } } */
+/* { dg-final { scan-assembler-not   {\mlha\M}                      } } */
+/* { dg-final { scan-assembler-not   {\mmfvsrd\M}                   } } */
+/* { dg-final { scan-assembler-not   {\mstw\M}                      } } */
diff --git a/gcc/testsuite/gcc.target/powerpc/pr84154-2.c b/gcc/testsuite/gcc.target/powerpc/pr84154-2.c
new file mode 100644
index 00000000000..619777ce8dd
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr84154-2.c
@@ -0,0 +1,58 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "" { powerpc*-*-darwin* } } */
+/* { dg-require-effective-target powerpc_p8vector_ok } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
+/* { dg-options "-mcpu=power8 -O2" } */
+
+/* PR target/84154.  Make sure on ISA 2.07 (power8) that we store the result of
+   a conversion to char/short using an offsettable address does not generate
+   direct moves for storing 32-bit integers, but does do a direct move for
+   8/16-bit integers.  */
+
+void
+double_to_uc (double x, unsigned char *p)
+{
+  p[3] = x;
+}
+
+void
+double_to_sc (double x, signed char *p)
+{
+  p[3] = x;
+}
+
+void
+double_to_us (double x, unsigned short *p)
+{
+  p[3] = x;
+}
+
+void
+double_to_ss (double x, short *p)
+{
+  p[3] = x;
+}
+
+void
+double_to_ui (double x, unsigned int *p)
+{
+  p[3] = x;
+}
+
+void
+double_to_si (double x, int *p)
+{
+  p[3] = x;
+}
+
+/* { dg-final { scan-assembler-times {\mfctiwuz\M|\mxscvdpuxws\M} 3 } } */
+/* { dg-final { scan-assembler-times {\mfctiwz\M|\mxscvdpsxws\M}  3 } } */
+/* { dg-final { scan-assembler-times {\mmfvsrwz\M}                4 } } */
+/* { dg-final { scan-assembler-times {\mstfiwx\M|\mstxsiwx\M}     2 } } */
+/* { dg-final { scan-assembler-times {\mstb\M}                    2 } } */
+/* { dg-final { scan-assembler-times {\msth\M}                    2 } } */
+/* { dg-final { scan-assembler-not   {\mlbz\M}                      } } */
+/* { dg-final { scan-assembler-not   {\mlhz\M}                      } } */
+/* { dg-final { scan-assembler-not   {\mlha\M}                      } } */
+/* { dg-final { scan-assembler-not   {\mmfvsrd\M}                   } } */
+/* { dg-final { scan-assembler-not   {\mstw\M}                      } } */
diff --git a/gcc/testsuite/gcc.target/powerpc/pr84154-3.c b/gcc/testsuite/gcc.target/powerpc/pr84154-3.c
new file mode 100644
index 00000000000..0361e2f1b51
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr84154-3.c
@@ -0,0 +1,60 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "" { powerpc*-*-darwin* } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-options "-mcpu=power9 -O2" } */
+
+/* PR target/84154.  Make sure on ISA 3.0 we store the result of a conversion
+   to char/short using an offsettable address does not generate direct moves
+   for storing 8/16/32-bit integers.  */
+
+void
+double_to_uc (double x, unsigned char *p)
+{
+  p[3] = x;
+}
+
+void
+double_to_sc (double x, signed char *p)
+{
+  p[3] = x;
+}
+
+void
+double_to_us (double x, unsigned short *p)
+{
+  p[3] = x;
+}
+
+void
+double_to_ss (double x, short *p)
+{
+  p[3] = x;
+}
+
+void
+double_to_ui (double x, unsigned int *p)
+{
+  p[3] = x;
+}
+
+void
+double_to_si (double x, int *p)
+{
+  p[3] = x;
+}
+
+/* { dg-final { scan-assembler-times {\maddi\M}                   6 } } */
+/* { dg-final { scan-assembler-times {\mfctiwuz\M|\mxscvdpuxws\M} 3 } } */
+/* { dg-final { scan-assembler-times {\mfctiwz\M|\mxscvdpsxws\M}  3 } } */
+/* { dg-final { scan-assembler-times {\mstfiwx\M|\mstxsiwx\M}     2 } } */
+/* { dg-final { scan-assembler-times {\mstxsibx\M}                2 } } */
+/* { dg-final { scan-assembler-times {\mstxsihx\M}                2 } } */
+/* { dg-final { scan-assembler-not   {\mlbz\M}                      } } */
+/* { dg-final { scan-assembler-not   {\mlhz\M}                      } } */
+/* { dg-final { scan-assembler-not   {\mlha\M}                      } } */
+/* { dg-final { scan-assembler-not   {\mmfvsrwz\M}                  } } */
+/* { dg-final { scan-assembler-not   {\mmfvsrd\M}                   } } */
+/* { dg-final { scan-assembler-not   {\mstw\M}                      } } */
+/* { dg-final { scan-assembler-not   {\mstb\M}                      } } */
+/* { dg-final { scan-assembler-not   {\msth\M}                      } } */
diff --git a/gcc/testsuite/gcc.target/powerpc/pr84700.c b/gcc/testsuite/gcc.target/powerpc/pr84700.c
new file mode 100644
index 00000000000..c89094a56d3
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr84700.c
@@ -0,0 +1,12 @@
+/* PR target/84700 */
+/* { dg-do compile } */
+/* { dg-options "-O1 -misel" } */
+
+long long int
+foo (long long int x)
+{
+  long long int a = x < 2;
+  int b = a >= 0;
+
+  return a + ((x == 0) ? a : b);
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/pr84878.c b/gcc/testsuite/gcc.target/powerpc/pr84878.c
new file mode 100644
index 00000000000..f96d3803d06
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr84878.c
@@ -0,0 +1,18 @@
+/* PR rtl-optimization/84878 */
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-require-effective-target powerpc_altivec_ok } */
+/* { dg-options "-O2 -maltivec -mno-vsx -fmodulo-sched -ftree-vectorize -funroll-loops -fassociative-math -fno-signed-zeros -fno-trapping-math" } */
+
+int ek;
+float zu;
+
+int
+k5 (int ks)
+{
+  while (ek < 1)
+    {
+      ks += (int)(0x1000000 + zu + !ek);
+      ++ek;
+    }
+  return ks;
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/pr85698.c b/gcc/testsuite/gcc.target/powerpc/pr85698.c
new file mode 100644
index 00000000000..294a5665b32
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr85698.c
@@ -0,0 +1,79 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power7" } } */
+/* { dg-options "-O3 -mcpu=power7" } */
+
+/* PR85698: Incorrect code generated on LE due to use of stxvw4x. */
+
+typedef unsigned char uint8_t;
+typedef short int16_t;
+extern void abort (void);
+extern int memcmp(const void *, const void *, __SIZE_TYPE__);
+
+uint8_t expected[128] =
+{14, 0, 4, 2, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21,
+ 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 28, 35, 33, 35, 36, 37, 38, 39, 40,
+ 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,
+ 60, 61, 62, 63, 66, 63, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78,
+ 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97, 96,
+ 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113,
+ 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127};
+
+static uint8_t x264_clip_uint8( int x )
+{
+  return x&(~255) ? (-x)>>31 : x;
+}
+void add4x4_idct( uint8_t *p_dst, int16_t dct[16])
+{
+  int16_t d[16];
+  int16_t tmp[16];
+  int i, y, x;
+  for( i = 0; i < 4; i++ )
+    {
+      int s02 =  dct[0*4+i]     +  dct[2*4+i];
+      int d02 =  dct[0*4+i]     -  dct[2*4+i];
+      int s13 =  dct[1*4+i]     + (dct[3*4+i]>>1);
+      int d13 = (dct[1*4+i]>>1) -  dct[3*4+i];
+      tmp[i*4+0] = s02 + s13;
+      tmp[i*4+1] = d02 + d13;
+      tmp[i*4+2] = d02 - d13;
+      tmp[i*4+3] = s02 - s13;
+    }
+  for( i = 0; i < 4; i++ )
+    {
+      int s02 =  tmp[0*4+i]     +  tmp[2*4+i];
+      int d02 =  tmp[0*4+i]     -  tmp[2*4+i];
+      int s13 =  tmp[1*4+i]     + (tmp[3*4+i]>>1);
+      int d13 = (tmp[1*4+i]>>1) -  tmp[3*4+i];
+      d[0*4+i] = ( s02 + s13 + 32 ) >> 6;
+      d[1*4+i] = ( d02 + d13 + 32 ) >> 6;
+      d[2*4+i] = ( d02 - d13 + 32 ) >> 6;
+      d[3*4+i] = ( s02 - s13 + 32 ) >> 6;
+    }
+  for( y = 0; y < 4; y++ )
+    {
+      for( x = 0; x < 4; x++ )
+        p_dst[x] = x264_clip_uint8( p_dst[x] + d[y*4+x] );
+      p_dst += 32;
+    }
+}
+
+int main()
+{
+  uint8_t dst[128];
+  int16_t dct[16];
+  int i;
+
+  for (i = 0; i < 16; i++)
+    dct[i] = i*10 + i;
+  for (i = 0; i < 128; i++)
+    dst[i] = i;
+
+  add4x4_idct(dst, dct);
+
+  if (memcmp (dst, expected, 128))
+    abort();
+
+ return 0;
+}
+
diff --git a/gcc/testsuite/gcc.target/powerpc/pr85755.c b/gcc/testsuite/gcc.target/powerpc/pr85755.c
new file mode 100644
index 00000000000..2d8741d639e
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr85755.c
@@ -0,0 +1,22 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-options "-O1" } */
+
+void
+preinc (long *q, long n)
+{
+  long i;
+  for (i = 0; i < n; i++)
+    q[i] = i;
+}
+
+void
+predec (long *q, long n)
+{
+  long i;
+  for (i = n; i >= 0; i--)
+    q[i] = i;
+}
+
+/* { dg-final { scan-assembler-times {\mstwu\M} 2 { target ilp32 } } } */
+/* { dg-final { scan-assembler-times {\mstdu\M} 2 { target lp64 } } } */
+/* { dg-final { scan-assembler-not {\mstfdu\M} } } */
diff --git a/gcc/testsuite/gcc.target/powerpc/pr87033.c b/gcc/testsuite/gcc.target/powerpc/pr87033.c
new file mode 100644
index 00000000000..9d62ce73d32
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr87033.c
@@ -0,0 +1,12 @@
+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */
+/* { dg-options "-O2" } */
+
+/* Insure that a LWAX is generated instead of ADD + LWA.  LP64 is needed
+   because the LWA and LWAX instructions are only available in 64-bit mode.  */
+long func (int *p, unsigned long n)
+{
+  return p[n];
+}
+
+/* { dg-final { scan-assembler     {\mlwax\M} } } */
+/* { dg-final { scan-assembler-not {\mlwa\M}  } } */
diff --git a/gcc/testsuite/gcc.target/powerpc/pr87496-1.c b/gcc/testsuite/gcc.target/powerpc/pr87496-1.c
new file mode 100644
index 00000000000..691e440bcf7
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr87496-1.c
@@ -0,0 +1,11 @@
+/* PR target/87496 */
+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */
+/* { dg-skip-if "" { powerpc*-*-darwin* } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power7" } } */
+/* { dg-require-effective-target longdouble128 } */
+/* { dg-options "-O2 -mcpu=power7 -mabi=ieeelongdouble -mno-popcntd -Wno-psabi" } */
+
+int i;
+
+/* { dg-error "'-mabi=ieeelongdouble' requires full ISA 2.06 support" "PR87496" { target *-*-* } 0 } */
+/* { dg-warning "using IEEE extended precision long double" "" { target *-*-* } 0 } */
diff --git a/gcc/testsuite/gcc.target/powerpc/pr87496-2.c b/gcc/testsuite/gcc.target/powerpc/pr87496-2.c
new file mode 100644
index 00000000000..b3e2f01e3b5
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr87496-2.c
@@ -0,0 +1,10 @@
+/* PR target/87496 */
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "" { powerpc*-*-darwin* } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power7" } } */
+/* { dg-options "-O2 -mcpu=power7 -mabi=ieeelongdouble -mlong-double-64 -Wno-psabi" } */
+
+int i;
+
+/* { dg-error "'-mabi=ieeelongdouble' requires '-mlong-double-128'" "PR87496" { target *-*-* } 0 } */
+/* { dg-warning "using IEEE extended precision long double" "" { target *-*-* } 0 } */
diff --git a/gcc/testsuite/gcc.target/powerpc/pr87496-3.c b/gcc/testsuite/gcc.target/powerpc/pr87496-3.c
new file mode 100644
index 00000000000..207680ee17a
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr87496-3.c
@@ -0,0 +1,9 @@
+/* PR target/87496 */
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "" { powerpc*-*-darwin* } } */
+/* { dg-options "-O2 -mabi=ibmlongdouble -mlong-double-64 -Wno-psabi" } */
+
+int i;
+
+/* { dg-error "'-mabi=ibmlongdouble' requires '-mlong-double-128'" "PR87496" { target *-*-* } 0 } */
+/* { dg-warning "using IBM extended precision long double" "" { target *-*-* } 0 } */
diff --git a/gcc/testsuite/gcc.target/powerpc/pr87532-mc.c b/gcc/testsuite/gcc.target/powerpc/pr87532-mc.c
new file mode 100644
index 00000000000..e5f79aa5dc1
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr87532-mc.c
@@ -0,0 +1,258 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx -O2" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <stdlib.h>
+#include <stddef.h>
+#include <altivec.h>
+
+#include <stdio.h>
+
+static vector unsigned __int128
+deoptimize_uint128 (vector unsigned __int128  a)
+{
+  __asm__ (" # %x0" : "+v" (a));
+  return a;
+}
+
+static vector unsigned long long int
+deoptimize_ulong (vector unsigned long long int a)
+{
+  __asm__ (" # %x0" : "+v" (a));
+  return a;
+}
+
+static vector unsigned int
+deoptimize_uint (vector unsigned int a)
+{
+  __asm__ (" # %x0" : "+v" (a));
+  return a;
+}
+
+static vector unsigned char
+deoptimize_uchar (vector unsigned char a)
+{
+  __asm__ (" # %x0" : "+v" (a));
+  return a;
+}
+
+static vector unsigned short
+deoptimize_ushort (vector unsigned short a)
+{
+  __asm__ (" # %x0" : "+v" (a));
+  return a;
+}
+
+__attribute ((noinline)) unsigned __int128
+get_auto_n_uint128 (vector unsigned __int128 a, int n)
+{
+  return __builtin_vec_extract (a, n);
+}
+
+__attribute ((noinline)) unsigned long long int
+get_auto_n_ulong (vector unsigned long long int a, int n)
+{
+  return __builtin_vec_extract (a, n);
+}
+
+__attribute ((noinline))
+unsigned int get_auto_n_uint (vector unsigned int a, int n)
+{
+  return __builtin_vec_extract (a, n);
+}
+
+__attribute ((noinline))
+unsigned char get_auto_n_uchar (vector unsigned char a, int n)
+{
+  return __builtin_vec_extract (a, n);
+}
+
+__attribute ((noinline))
+unsigned short get_auto_n_ushort (vector unsigned short a, int n)
+{
+  return __builtin_vec_extract (a, n);
+}
+
+
+int check_uint128_element (int i, unsigned __int128 entry)
+{
+  printf ("checking uint128 entry at index %d\n", i);
+
+  return (entry == ((((unsigned __int128) 0xffeeddccbbaa9988ULL) << 64)
+		    | 0x0706050403020100ULL));
+}
+
+int check_ulong_element (int i, unsigned long long int entry)
+{
+  printf ("checking ulong entry 0x%llx at index %d\n", entry, i);
+
+  switch (i % 2)
+    {
+      case 0: return (entry == 0x9999901010ULL);
+      case 1: return (entry == 0x7777733333ULL);
+      default:
+	return 0;
+    }
+}
+
+int check_uint_element (int i, unsigned int entry)
+{
+  printf ("checking uint entry 0x%x at index %d\n", entry, i);
+
+  switch (i % 4)
+    {
+    case 0: return (entry == 0x99999);
+    case 1: return (entry == 0x01010);
+    case 2: return (entry == 0x77777);
+    case 3: return (entry == 0x33333);
+    default:
+      return 0;
+    }
+}
+
+int check_uchar_element (int i, unsigned char entry)
+{
+  printf ("checking uchar entry 0x%x at index %d\n", entry, i);
+  switch (i % 16)
+    {
+    case 0: return (entry == 0x90);
+    case 1: return (entry == 0x80);
+    case 2: return (entry == 0x70);
+    case 3: return (entry == 0x60);
+    case 4: return (entry == 0x50);
+    case 5: return (entry == 0x40);
+    case 6: return (entry == 0x30);
+    case 7: return (entry == 0x20);
+    case 8: return (entry == 0x10);
+    case 9: return (entry == 0xf0);
+    case 10: return (entry == 0xe0);
+    case 11: return (entry == 0xd0);
+    case 12: return (entry == 0xc0);
+    case 13: return (entry == 0xb0);
+    case 14: return (entry == 0xa0);
+    case 15: return (entry == 0xff);
+    default:
+      return 0;
+    }
+}
+
+int check_ushort_element (int i, unsigned short entry)
+{
+  printf ("checking ushort entry 0x%x at index %d\n", entry, i);
+  switch (i % 8)
+    {
+    case 0: return (entry == 0x9988);
+    case 1: return (entry == 0x8877);
+    case 2: return (entry == 0x7766);
+    case 3: return (entry == 0x6655);
+    case 4: return (entry == 0x5544);
+    case 5: return (entry == 0x4433);
+    case 6: return (entry == 0x3322);
+    case 7: return (entry == 0x2211);
+    default:
+      return 0;
+    }
+}
+
+void do_auto_uint128 ( vector unsigned __int128 a )
+{
+  int i;
+  unsigned __int128 c;
+  for (i = 0; i < 32; i += 3)
+    {
+      c = get_auto_n_uint128 (a,i);
+      if (!check_uint128_element (i, c)) abort ();
+    }
+ }
+
+void do_auto_ulong ( vector unsigned long long int a )
+{
+  int i;
+  unsigned long long int c;
+  for (i = 0; i < 32; i += 3)
+    {
+      c = get_auto_n_ulong (a,i);
+      if (!check_ulong_element (i, c)) abort ();
+    }
+ }
+
+void do_auto_uint ( vector unsigned int a )
+{
+  int i;
+  unsigned int c;
+  for (i = 0; i < 32; i += 3)
+    {
+      c = get_auto_n_uint (a,i);
+      if (!check_uint_element (i, c)) abort ();
+    }
+ }
+
+void do_auto_ushort ( vector unsigned short a )
+{
+  int i;
+  unsigned short c;
+  for (i = 0; i < 32; i += 3)
+    {
+      c = get_auto_n_ushort (a,i);
+      if (!check_ushort_element (i, c)) abort ();
+    }
+}
+
+void do_auto_uchar ( vector unsigned char a )
+{
+  int i;
+  unsigned char c;
+  for (i = 0; i < 32; i += 3)
+    {
+      c = get_auto_n_uchar (a,i);
+      if (!check_uchar_element (i, c)) abort ();
+    }
+}
+
+int
+main (void)
+{
+  size_t i;
+
+  vector unsigned __int128 u = {
+    ((((unsigned __int128) 0xffeeddccbbaa9988ULL) << 64)
+     | 0x0706050403020100ULL) };
+  vector unsigned __int128 du;
+
+  vector unsigned long long int v = { 0x9999901010ULL, 0x7777733333ULL };
+  vector unsigned long long int dv;
+
+  vector unsigned int x = { 0x99999, 0x01010, 0x77777, 0x33333 };
+  vector unsigned int dx;
+
+  vector unsigned char y = { 0x90, 0x80, 0x70, 0x60, 0x50, 0x40, 0x30, 0x20,
+			     0x10, 0xf0, 0xe0, 0xd0, 0xc0, 0xb0, 0xa0, 0xff };
+  vector unsigned char dy;
+
+  vector unsigned short z = { 0x9988, 0x8877, 0x7766, 0x6655,
+			      0x5544, 0x4433, 0x3322, 0x2211 };
+  vector unsigned short dz;
+
+  do_auto_uint128 (u);
+  do_auto_ulong (v);
+  do_auto_uint (x);
+  do_auto_uchar (y);
+  do_auto_ushort (z);
+
+  du = deoptimize_uint128 (u);
+  dv = deoptimize_ulong (v);
+  dx = deoptimize_uint (x);
+  dy = deoptimize_uchar (y);
+  dz = deoptimize_ushort (z);
+
+  do_auto_uint128 (du);
+  do_auto_ulong (dv);
+  do_auto_uint (dx);
+  do_auto_uchar (dy);
+  do_auto_ushort (dz);
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/pr87532.c b/gcc/testsuite/gcc.target/powerpc/pr87532.c
new file mode 100644
index 00000000000..4b07f07258f
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr87532.c
@@ -0,0 +1,72 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec" } */
+
+/* This test should run the same on any target that supports altivec/dfp
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <stdlib.h>
+#include <stddef.h>
+#include <altivec.h>
+#include <stdio.h>
+
+static void
+check (unsigned char, unsigned char) __attribute__((__noinline__));
+
+static __attribute__((altivec(vector__))) unsigned char
+deoptimize (__attribute__((altivec(vector__))) unsigned char)
+__attribute__((__noinline__));
+
+static __attribute__((altivec(vector__))) unsigned char
+deoptimize (__attribute__((altivec(vector__))) unsigned char a)
+{
+  __asm__ (" # %x0" : "+v" (a));
+  return a;
+}
+
+// Toggle this attribute inline/noinline to see pass/fail.
+// fails with the noinline attribute applied.
+__attribute__ ((__noinline__))
+unsigned char
+get_auto_n (__attribute__((altivec(vector__))) unsigned char a, size_t n)
+{
+  return (unsigned char) __builtin_vec_extract (a, n);
+}
+
+void
+do_auto (__attribute__((altivec(vector__))) unsigned char a)
+{
+  size_t i;
+  for (i = 1; i < 3 ; i++)
+  {
+    do
+      {
+	printf ("get_auto_n (a, %d) produces 0x0%x\n",
+		i, (int) get_auto_n (a, i));
+
+	if ((int) get_auto_n (a,i) > 250) abort();
+      } while (0);
+  }
+}
+
+int
+main (void)
+{
+  size_t i;
+  __attribute__((altivec(vector__))) unsigned char x =
+    { 3, 2, 3, 8, 5, 6, 7, 8, 240, 241, 242, 243, 244, 245, 246, 247 };
+  __attribute__((altivec(vector__))) unsigned char a;
+
+  printf (" first elements of x are: %d %d %d %d %d\n",
+	  x[0], x[1], x[2], x[3], x[4]);
+
+  a = deoptimize (x);
+
+  printf (" after deoptimization, first elements of a are: %d %d %d %d %d\n",
+	  a[0], a[1], a[2], a[3], a[4]);
+
+  do_auto (a);
+
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/pr89424-0.c b/gcc/testsuite/gcc.target/powerpc/pr89424-0.c
new file mode 100644
index 00000000000..301cf90ce5f
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr89424-0.c
@@ -0,0 +1,76 @@
+/* { dg-do run { target { powerpc*-*-* && lp64 } } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+/* Define PR89626 after that pr is addressed.  */
+#ifdef PR89626
+#define SIGNED
+#else
+#define SIGNED signed
+#endif
+
+#define CONST0		(((__int128) 31415926539) << 60)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+__int128 ei (vector SIGNED __int128 v, int i)
+{
+  return __builtin_vec_ext_v1ti (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__int128 mei (vector SIGNED __int128 *vp, int i)
+{
+  return __builtin_vec_ext_v1ti (*vp, i);
+}
+
+int main (int argc, char *argv[]) {
+  vector SIGNED __int128 dv = { CONST0 };
+  __int128 d;
+
+  d = ei (dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 1);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 3);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 1);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 3);
+  if (d != CONST0)
+    abort ();
+
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-1.c b/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-1.c
index 99cfab29e6e..16ccfe471f6 100644
--- a/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-1.c
+++ b/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-1.c
@@ -1,5 +1,6 @@
-/* { dg-do compile { target { lp64 } } } */
+/* { dg-do compile } */
 /* { dg-additional-options "-mno-speculate-indirect-jumps" } */
+/* { dg-warning "'-mno-speculate-indirect-jumps' is deprecated" "" { target *-*-* } 0 } */
 
 /* Test for deliberate misprediction of indirect calls.  */
 
@@ -11,4 +12,10 @@ int bar ()
 }
 
 /* { dg-final { scan-assembler "crset 2" } } */
-/* { dg-final { scan-assembler "beqctrl-" } } */
+
+/* The AIX and ELFv2 ABIs don't allow a sibcall here.  */
+/* { dg-final { scan-assembler "beqctrl-" { target { lp64 || { powerpc*-*-aix* } } } } } */
+
+/* The other ABIs do allow a sibcall.  */
+/* { dg-final { scan-assembler "beqctr-" { target { ilp32 && !powerpc*-*-aix* } } } } */
+/* { dg-final { scan-assembler {b \$} { target { ilp32 && !powerpc*-*-aix* } } } } */
diff --git a/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-2.c b/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-2.c
index 1c23a5d9add..d3d040fbbf0 100644
--- a/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-2.c
+++ b/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-2.c
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
 /* { dg-options "-mno-speculate-indirect-jumps" } */
+/* { dg-warning "'-mno-speculate-indirect-jumps' is deprecated" "" { target *-*-* } 0 } */
 
 /* Test for deliberate misprediction of computed goto.  */
 
diff --git a/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-3.c b/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-3.c
index d0eccc4f262..c338e30d01a 100644
--- a/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-3.c
+++ b/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-3.c
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
 /* { dg-options "-mno-speculate-indirect-jumps" } */
+/* { dg-warning "'-mno-speculate-indirect-jumps' is deprecated" "" { target *-*-* } 0 } */
 
 /* Test for deliberate misprediction of jump tables.  */
 
diff --git a/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-4.c b/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-4.c
index ed0000797c9..b55de13af93 100644
--- a/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-4.c
+++ b/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-4.c
@@ -1,5 +1,6 @@
 /* { dg-do run } */
 /* { dg-additional-options "-mno-speculate-indirect-jumps" } */
+/* { dg-warning "'-mno-speculate-indirect-jumps' is deprecated" "" { target *-*-* } 0 } */
 
 /* Test for deliberate misprediction of indirect calls for ELFv2.  */
 
diff --git a/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-5.c b/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-5.c
index 5a4cd9a838e..fd04ffd56c7 100644
--- a/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-5.c
+++ b/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-5.c
@@ -1,5 +1,6 @@
 /* { dg-do run } */
 /* { dg-additional-options "-mno-speculate-indirect-jumps -Wno-pedantic" } */
+/* { dg-warning "'-mno-speculate-indirect-jumps' is deprecated" "" { target *-*-* } 0 } */
 
 /* Test for deliberate misprediction of computed goto.  */
 
diff --git a/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-6.c b/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-6.c
index a78e468fc70..1468a4ee20d 100644
--- a/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-6.c
+++ b/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-6.c
@@ -1,5 +1,6 @@
 /* { dg-do run } */
 /* { dg-additional-options "-mno-speculate-indirect-jumps" } */
+/* { dg-warning "'-mno-speculate-indirect-jumps' is deprecated" "" { target *-*-* } 0 } */
 
 /* Test for deliberate misprediction of jump tables.  */
 
diff --git a/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-7.c b/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-7.c
index b1bdcca8524..e7d81d40ff0 100644
--- a/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-7.c
+++ b/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-7.c
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
 /* { dg-additional-options "-mno-speculate-indirect-jumps" } */
+/* { dg-warning "'-mno-speculate-indirect-jumps' is deprecated" "" { target *-*-* } 0 } */
 
 /* Test for deliberate misprediction of indirect calls.  */
 
diff --git a/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-8.c b/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-8.c
deleted file mode 100644
index 27642cc4450..00000000000
--- a/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-8.c
+++ /dev/null
@@ -1,15 +0,0 @@
-/* { dg-do compile { target { ilp32 } } } */
-/* { dg-additional-options "-O2 -mno-speculate-indirect-jumps" } */
-
-/* Test for deliberate misprediction of -m32 sibcalls.  */
-
-extern int (*f)();
-
-int bar ()
-{
-  return (*f) ();
-}
-
-/* { dg-final { scan-assembler "crset 2" } } */
-/* { dg-final { scan-assembler "beqctr-" } } */
-/* { dg-final { scan-assembler {b \$} } } */
diff --git a/gcc/testsuite/gcc.target/powerpc/swaps-p8-46.c b/gcc/testsuite/gcc.target/powerpc/swaps-p8-46.c
new file mode 100644
index 00000000000..23494b695a5
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/swaps-p8-46.c
@@ -0,0 +1,34 @@
+/* { dg-do run { target { powerpc64le-*-* } } } */
+/* { dg-require-effective-target powerpc_p8vector_ok } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
+/* { dg-options "-mcpu=power8 -O2 " } */
+
+typedef __attribute__ ((__aligned__ (8))) unsigned long long __m64;
+typedef float __m128 __attribute__ ((__vector_size__ (16), __may_alias__));
+
+/* PR84033.  Extracted from xmmintrin.h but with a pointer param to
+   allow swaps to happen when not inline.  */
+int __attribute__ ((__noinline__))
+_mm_movemask_ps (__m128 *__A)
+{
+  __vector __m64 result;
+  static const __vector unsigned int perm_mask =
+    {
+      0x00204060, 0x80808080, 0x80808080, 0x80808080
+    };
+
+  result = (__vector __m64)
+    __builtin_vec_vbpermq ((__vector unsigned char) (*__A),
+			   (__vector unsigned char) perm_mask);
+  return result[1];
+}
+
+int
+main (void)
+{
+  union { unsigned int i[4]; __m128 m; } x
+    = { 0x80000000, 0x80000000, 0x7fffffff, 0x7fffffff };
+  if (_mm_movemask_ps (&x.m) != 3)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/vec-extract-schar-1.c b/gcc/testsuite/gcc.target/powerpc/vec-extract-schar-1.c
new file mode 100644
index 00000000000..f5dea6f2dd8
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/vec-extract-schar-1.c
@@ -0,0 +1,29 @@
+/* Test to verify that the vec_extract from a vector of
+   signed chars remains signed.  */
+/* { dg-do run } */
+/* { dg-options "-ansi -mcpu=power8 " } */
+/* { dg-require-effective-target p8vector_hw } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
+
+#include <altivec.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+int test1(signed char sc) {
+  int sce;
+
+  vector signed char v = vec_splats(sc);
+  sce = vec_extract(v,0);
+
+  if (sce != sc)
+    abort();
+  return 0;
+}
+
+int main()
+{
+  test1 (0xf6);
+  test1 (0x76);
+  test1 (0x06);
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/vec-extract-sint-1.c b/gcc/testsuite/gcc.target/powerpc/vec-extract-sint-1.c
new file mode 100644
index 00000000000..0cefe200254
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/vec-extract-sint-1.c
@@ -0,0 +1,29 @@
+/* Test to verify that the vec_extract from a vector of
+   signed ints remains signed.  */
+/* { dg-do run } */
+/* { dg-options "-ansi -mcpu=power8 " } */
+/* { dg-require-effective-target p8vector_hw } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
+
+#include <altivec.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+int test1(signed int si) {
+  long long int sie;
+
+  vector signed int v = vec_splats(si);
+  sie = vec_extract(v,0);
+
+  if (sie != si)
+    abort();
+  return 0;
+}
+
+int main()
+{
+  test1 (0xf6000000);
+  test1 (0x76000000);
+  test1 (0x06000000);
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/vec-extract-sint128-1.c b/gcc/testsuite/gcc.target/powerpc/vec-extract-sint128-1.c
new file mode 100644
index 00000000000..5321adcff4b
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/vec-extract-sint128-1.c
@@ -0,0 +1,27 @@
+/* Test to verify that the vec_extract from a vector of
+   signed __int128s remains signed.  */
+/* { dg-do run } */
+/* { dg-options "-ansi -mcpu=power8 " } */
+/* { dg-require-effective-target p8vector_hw } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
+
+#include <altivec.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+int test1(signed __int128 st) {
+
+  vector signed __int128 v = vec_splats(st);
+
+  if (vec_extract (v, 0) > st)
+    abort();
+  return 0;
+}
+
+int main()
+{
+  test1 (((__int128) 0xf600000000000000LL) << 64);
+  test1 (((__int128) 0x7600000000000000LL) << 64);
+  test1 (((__int128) 0x0600000000000000LL) << 64);
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/vec-extract-slong-1.c b/gcc/testsuite/gcc.target/powerpc/vec-extract-slong-1.c
new file mode 100644
index 00000000000..9b4f548240c
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/vec-extract-slong-1.c
@@ -0,0 +1,27 @@
+/* Test to verify that the vec_extract from a vector of
+   signed longs remains signed.  */
+/* { dg-do run } */
+/* { dg-options "-ansi -mcpu=power8 " } */
+/* { dg-require-effective-target p8vector_hw } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
+
+#include <altivec.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+int test1(signed long long int sl) {
+
+  vector signed long long int v = vec_splats(sl);
+
+  if (vec_extract (v, 0) > sl)
+    abort();
+  return 0;
+}
+
+int main()
+{
+  test1 (0xf600000000000000LL);
+  test1 (0x7600000000000000LL);
+  test1 (0x0600000000000000LL);
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/vec-extract-sshort-1.c b/gcc/testsuite/gcc.target/powerpc/vec-extract-sshort-1.c
new file mode 100644
index 00000000000..cd5b4844280
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/vec-extract-sshort-1.c
@@ -0,0 +1,29 @@
+/* Test to verify that the vec_extract from a vector of
+   signed shorts remains signed.  */
+/* { dg-do run } */
+/* { dg-options "-ansi -mcpu=power8 " } */
+/* { dg-require-effective-target p8vector_hw } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
+
+#include <altivec.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+int test1(signed short ss) {
+  int sse;
+
+  vector signed short v = vec_splats(ss);
+  sse = vec_extract(v,0);
+
+  if (sse != ss)
+    abort();
+  return 0;
+}
+
+int main()
+{
+  test1 (0xf600);
+  test1 (0x7600);
+  test1 (0x0600);
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/vec-extract-uchar-1.c b/gcc/testsuite/gcc.target/powerpc/vec-extract-uchar-1.c
new file mode 100644
index 00000000000..b355ef34b6c
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/vec-extract-uchar-1.c
@@ -0,0 +1,29 @@
+/* Test to verify that the vec_extract from a vector of
+   unsigned chars remains unsigned.  */
+/* { dg-do run } */
+/* { dg-options "-ansi -mcpu=power8 " } */
+/* { dg-require-effective-target p8vector_hw } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
+
+#include <altivec.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+int test1(unsigned char uc) {
+  int uce;
+
+  vector unsigned char v = vec_splats(uc);
+  uce = vec_extract(v,0);
+
+  if (uce != uc)
+    abort();
+  return 0;
+}
+
+int main()
+{
+  test1 (0xf6);
+  test1 (0x76);
+  test1 (0x06);
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/vec-extract-uint-1.c b/gcc/testsuite/gcc.target/powerpc/vec-extract-uint-1.c
new file mode 100644
index 00000000000..9dd19837df0
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/vec-extract-uint-1.c
@@ -0,0 +1,29 @@
+/* Test to verify that the vec_extract from a vector of
+   unsigned ints remains unsigned.  */
+/* { dg-do run } */
+/* { dg-options "-ansi -mcpu=power8 " } */
+/* { dg-require-effective-target p8vector_hw } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
+
+#include <altivec.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+int test1(unsigned int ui) {
+  long long int uie;
+
+  vector unsigned int v = vec_splats(ui);
+  uie = vec_extract(v,0);
+
+  if (uie != ui)
+    abort();
+  return 0;
+}
+
+int main()
+{
+  test1 (0xf6000000);
+  test1 (0x76000000);
+  test1 (0x06000000);
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/vec-extract-uint128-1.c b/gcc/testsuite/gcc.target/powerpc/vec-extract-uint128-1.c
new file mode 100644
index 00000000000..1714f2ca432
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/vec-extract-uint128-1.c
@@ -0,0 +1,27 @@
+/* Test to verify that the vec_extract from a vector of
+   unsigned __int128s remains unsigned.  */
+/* { dg-do run } */
+/* { dg-options "-ansi -mcpu=power8 " } */
+/* { dg-require-effective-target p8vector_hw } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
+
+#include <altivec.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+int test1(unsigned __int128 ul) {
+
+  vector unsigned __int128 v = vec_splats(ul);
+
+  if (vec_extract (v, 0) < ul)
+    abort();
+  return 0;
+}
+
+int main()
+{
+  test1 (((__int128) 0xf600000000000000LL) << 64);
+  test1 (((__int128) 0x7600000000000000LL) << 64);
+  test1 (((__int128) 0x0600000000000000LL) << 64);
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/vec-extract-ulong-1.c b/gcc/testsuite/gcc.target/powerpc/vec-extract-ulong-1.c
new file mode 100644
index 00000000000..7bfdc634fa4
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/vec-extract-ulong-1.c
@@ -0,0 +1,27 @@
+/* Test to verify that the vec_extract from a vector of
+   unsigned longs remains unsigned.  */
+/* { dg-do run } */
+/* { dg-options "-ansi -mcpu=power8 " } */
+/* { dg-require-effective-target p8vector_hw } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
+
+#include <altivec.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+int test1(unsigned long long int ul) {
+
+  vector unsigned long long int v = vec_splats(ul);
+
+  if (vec_extract (v, 0) < ul)
+    abort();
+  return 0;
+}
+
+int main()
+{
+  test1 (0xf600000000000000LL);
+  test1 (0x7600000000000000LL);
+  test1 (0x0600000000000000LL);
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/vec-extract-ushort-1.c b/gcc/testsuite/gcc.target/powerpc/vec-extract-ushort-1.c
new file mode 100644
index 00000000000..e76e44cd27c
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/vec-extract-ushort-1.c
@@ -0,0 +1,29 @@
+/* Test to verify that the vec_extract from a vector of
+   signed shorts remains signed.  */
+/* { dg-do run } */
+/* { dg-options "-ansi -mcpu=power8 " } */
+/* { dg-require-effective-target p8vector_hw } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
+
+#include <altivec.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+int test1(unsigned short us) {
+  int use;
+
+  vector unsigned short v = vec_splats(us);
+  use = vec_extract(v,0);
+
+  if (use != us)
+    abort();
+  return 0;
+}
+
+int main()
+{
+  test1 (0xf600);
+  test1 (0x7600);
+  test1 (0x0600);
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/vec-extract-v16qiu-v2.h b/gcc/testsuite/gcc.target/powerpc/vec-extract-v16qiu-v2.h
new file mode 100644
index 00000000000..d1157599ee7
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/vec-extract-v16qiu-v2.h
@@ -0,0 +1,253 @@
+#include <stdlib.h>
+#include <stddef.h>
+#include <altivec.h>
+
+#ifndef RTYPE
+#define RTYPE TYPE
+#endif
+
+#ifdef DO_TRACE
+#include <stdio.h>
+
+#define TRACE(STRING, NUM)						\
+do									\
+  {									\
+    fprintf (stderr, "%s: %2d\n", STRING, (int) NUM);			\
+    fflush (stderr);							\
+  }									\
+while (0)
+
+#ifndef FAIL_FORMAT
+#define FAIL_FORMAT "%ld"
+#define FAIL_CAST(X) ((long)(X))
+#endif
+
+#define FAIL(EXP, GOT)							 \
+do									 \
+  {									 \
+    fprintf (stderr, "Expected: " FAIL_FORMAT ", got " FAIL_FORMAT "\n", \
+	     FAIL_CAST (EXP), FAIL_CAST (GOT));				 \
+    fflush (stderr);							 \
+    abort ();								 \
+  }									 \
+while (0)
+
+#else
+#define TRACE(STRING, NUM)
+#define FAIL(EXP, GOT) abort ()
+#endif
+
+static void
+check (RTYPE, RTYPE) __attribute__((__noinline__));
+
+static vector TYPE
+deoptimize (vector TYPE) __attribute__((__noinline__));
+
+static vector TYPE
+*deoptimize_ptr (vector TYPE *)	__attribute__((__noinline__));
+
+static void
+check (RTYPE expected, RTYPE got)
+{
+  if (expected != got)
+    FAIL (expected, got);
+}
+
+static vector TYPE
+deoptimize (vector TYPE a)
+{
+  __asm__ (" # %x0" : "+v" (a));
+  return a;
+}
+
+static vector TYPE *
+deoptimize_ptr (vector TYPE *p)
+{
+  __asm__ (" # %0" : "+r" (p));
+  return p;
+}
+
+
+RTYPE
+get_auto_0 (vector TYPE a)
+{
+  TRACE ("get_auto_", 0);
+  return (RTYPE) vec_extract (a, 0);
+}
+
+RTYPE
+get_auto_1 (vector TYPE a)
+{
+  TRACE ("get_auto_", 1);
+  return (RTYPE) vec_extract (a, 1);
+}
+
+#if ELEMENTS >= 4
+RTYPE
+get_auto_2 (vector TYPE a)
+{
+  return (RTYPE) vec_extract (a, 2);
+}
+
+RTYPE
+get_auto_3 (vector TYPE a)
+{
+  return (RTYPE) vec_extract (a, 3);
+}
+
+#if ELEMENTS >= 8
+RTYPE
+get_auto_4 (vector TYPE a)
+{
+  return (RTYPE) vec_extract (a, 4);
+}
+
+RTYPE
+get_auto_5 (vector TYPE a)
+{
+  return (RTYPE) vec_extract (a, 5);
+}
+
+RTYPE
+get_auto_6 (vector TYPE a)
+{
+  return (RTYPE) vec_extract (a, 6);
+}
+
+RTYPE
+get_auto_7 (vector TYPE a)
+{
+  return (RTYPE) vec_extract (a, 7);
+}
+
+#if ELEMENTS >= 16
+RTYPE
+get_auto_8 (vector TYPE a)
+{
+  return (RTYPE) vec_extract (a, 8);
+}
+
+RTYPE
+get_auto_9 (vector TYPE a)
+{
+  return (RTYPE) vec_extract (a, 9);
+}
+
+RTYPE
+get_auto_10 (vector TYPE a)
+{
+  return (RTYPE) vec_extract (a, 10);
+}
+
+RTYPE
+get_auto_11 (vector TYPE a)
+{
+  return (RTYPE) vec_extract (a, 11);
+}
+
+RTYPE
+get_auto_12 (vector TYPE a)
+{
+  return (RTYPE) vec_extract (a, 12);
+}
+
+RTYPE
+get_auto_13 (vector TYPE a)
+{
+  return (RTYPE) vec_extract (a, 13);
+}
+
+RTYPE
+get_auto_14 (vector TYPE a)
+{
+  return (RTYPE) vec_extract (a, 14);
+}
+
+RTYPE
+get_auto_15 (vector TYPE a)
+{
+  return (RTYPE) vec_extract (a, 15);
+}
+
+#endif
+#endif
+#endif
+
+
+/* Tests for the normal case of vec_extract where the vector is in a register
+   and returning the result in a register as a return value.  */
+#ifdef DISABLE_INLINE_OF_GET_AUTO_N
+__attribute__ ((__noinline__))
+#else
+/* gcc issues warning: always_inline function might not be inlinable
+
+   __attribute__ ((__always_inline__))
+*/
+#endif
+RTYPE
+get_auto_n (vector TYPE a, ssize_t n)
+{
+  return (RTYPE) vec_extract (a, n);
+}
+
+typedef RTYPE (*auto_func_type) (vector TYPE);
+
+static auto_func_type get_auto_const[] = {
+  get_auto_0,
+  get_auto_1,
+#if ELEMENTS >= 4
+  get_auto_2,
+  get_auto_3,
+#if ELEMENTS >= 8
+  get_auto_4,
+  get_auto_5,
+  get_auto_6,
+  get_auto_7,
+#if ELEMENTS >= 16
+  get_auto_8,
+  get_auto_9,
+  get_auto_10,
+  get_auto_11,
+  get_auto_12,
+  get_auto_13,
+  get_auto_14,
+  get_auto_15,
+#endif
+#endif
+#endif
+};
+
+extern void do_auto (vector TYPE a) __attribute__((__noinline__));
+
+void
+do_auto (vector TYPE a)
+{
+  size_t i;
+
+  for (i = 1; i < 40; i += 3)
+    {
+      TRACE ("do_auto, i: ", i);
+      TRACE ("  get_auto_const[i] returns: ",
+	     (*get_auto_const [i % ELEMENTS]) (a));
+      TRACE ("  get_auto_n returns", get_auto_n (a, i));
+      check (get_auto_n (a, i), (*get_auto_const [i % ELEMENTS]) (a));
+    }
+}
+
+
+
+/* Main program to test all of the possibilities.  */
+int
+main (void)
+{
+  size_t i;
+  vector TYPE x = INITIAL;
+  vector TYPE *p, *p2, a, y;
+  vector TYPE z[2];
+
+  a = deoptimize (x);
+
+  do_auto (a);
+
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/vec-extract-v16qiu-v2a.c b/gcc/testsuite/gcc.target/powerpc/vec-extract-v16qiu-v2a.c
new file mode 100644
index 00000000000..05082b71c20
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/vec-extract-v16qiu-v2a.c
@@ -0,0 +1,14 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-O2 -mvsx" } */
+
+#define TYPE unsigned char
+/* ELEMENTS is number of elements in a vector of TYPE.  */
+#define ELEMENTS 16
+#define INITIAL \
+  {  3, 2, 3, 4, 5, 6, 7, 8, 240, 241, 242, 243, 244, 245, 246, 247 }
+
+#define DO_TRACE
+#define DISABLE_INLINE_OF_GET_AUTO_N
+
+#include "vec-extract-v16qiu-v2.h"
diff --git a/gcc/testsuite/gcc.target/powerpc/vec-extract-v16qiu-v2b.c b/gcc/testsuite/gcc.target/powerpc/vec-extract-v16qiu-v2b.c
new file mode 100644
index 00000000000..87a3aa4a8e5
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/vec-extract-v16qiu-v2b.c
@@ -0,0 +1,14 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-O2 -mvsx" } */
+
+#define TYPE unsigned char
+/* ELEMENTS is number of elements in a vector of TYPE.  */
+#define ELEMENTS 16
+#define INITIAL \
+  {  3, 2, 3, 4, 5, 6, 7, 8, 240, 241, 242, 243, 244, 245, 246, 247 }
+
+#define DO_TRACE
+#undef DISABLE_INLINE_OF_GET_AUTO_N
+
+#include "vec-extract-v16qiu-v2.h"
diff --git a/gcc/testsuite/gcc.target/powerpc/vsx-13.c b/gcc/testsuite/gcc.target/powerpc/vsx-13.c
new file mode 100644
index 00000000000..5b4eb68068f
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/vsx-13.c
@@ -0,0 +1,42 @@
+/* { dg-do compile { target powerpc*-*-* } } */
+/* { dg-require-effective-target powerpc_vsx_ok } */
+/* { dg-options "-mvsx" } */
+
+/* Variations of tests that require VSX support.  This is a variation of
+   the altivec-13.c testcase.  */
+
+#include <altivec.h>
+
+void foo (void)
+{
+
+  vector signed char vsc1, vsc2, vscz;
+  vector unsigned char vuc1, vuc2, vucz;
+  vector bool long long vubll1, vubll2, vubllz;
+  vector signed int long long vsill1, vsill2, vsillz;
+  vector unsigned int long long vuill1, vuill2, vuillz;
+  vector double vd1, vd2, vdz;
+
+  vubllz = vec_sld( vubll1, vubll2, 1 );
+  vsillz = vec_sld( vsill1, vsill2, 1 );
+  vuillz = vec_sld( vuill1, vuill2, 1 );
+
+  vsillz = vec_srl(vsill1, vuc2);
+  vuillz = vec_srl(vuill1, vuc2);
+
+  vsillz = vec_sro(vsill1, vsc2);
+  vsillz = vec_sro(vsill1, vuc2);
+  vuillz = vec_sro(vuill1, vsc2);
+  vuillz = vec_sro(vuill1, vuc2);
+
+  vdz = vec_sld( vd1, vd2, 1 );
+}
+
+/* Expected results:
+   vec_sld          vsldoi
+   vec_srl          vsr
+   vec_sro          vsro  */
+
+/* { dg-final { scan-assembler-times "vsldoi" 4 } } */
+/* { dg-final { scan-assembler-times "vsr " 2 } } */
+/* { dg-final { scan-assembler-times "vsro" 4 } } */
diff --git a/gcc/testsuite/gcc.target/powerpc/vsx-7.h b/gcc/testsuite/gcc.target/powerpc/vsx-7.h
new file mode 100644
index 00000000000..fe5547243f4
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/vsx-7.h
@@ -0,0 +1,18 @@
+
+/* This test code is included into vsx-7-be.c.
+ * this is meant to supplement code in altivec-7.h.  */
+
+#include <altivec.h>
+
+
+vector float *vecfloat;
+vector double *vecdouble;
+
+int main2 ()
+{
+
+  *vecdouble++ = vec_unpackl(vecfloat[0]);
+  *vecdouble++ = vec_unpackh(vecfloat[0]);
+
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/vsx-builtin-10a.c b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-10a.c
new file mode 100644
index 00000000000..e8516de66ff
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-10a.c
@@ -0,0 +1,155 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec" } */
+
+/* This test should run the same on any target that supports altivec/dfp
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+#define CONST4		(4)
+#define CONST5		(5)
+#define CONST6		(6)
+#define CONST7		(7)
+
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+short s3 (vector short v)
+{
+  return __builtin_vec_ext_v8hi (v, 3);
+}
+
+short s7 (vector short v)
+{
+  return __builtin_vec_ext_v8hi (v, 7);
+}
+
+short s21 (vector short v)
+{
+  return __builtin_vec_ext_v8hi (v, 21);
+}
+
+short s30 (vector short v)
+{
+  return __builtin_vec_ext_v8hi (v, 30);
+}
+
+/* Test for vector residing in memory.  */
+short ms3 (vector short *vp)
+{
+  return __builtin_vec_ext_v8hi (*vp, 3);
+}
+
+short ms7 (vector short *vp)
+{
+  return __builtin_vec_ext_v8hi (*vp, 7);
+}
+
+short ms21 (vector short *vp)
+{
+  return __builtin_vec_ext_v8hi (*vp, 21);
+}
+
+short ms30 (vector short *vp)
+{
+  return __builtin_vec_ext_v8hi (*vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+short ci (vector short v, int i)
+{
+  return __builtin_vec_ext_v8hi (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+short mci (vector short *vp, int i)
+{
+  return __builtin_vec_ext_v8hi (*vp, i);
+}
+
+
+int main (int argc, short *argv[]) {
+  vector short sv = {
+    CONST0, CONST1, CONST2, CONST3, CONST4, CONST5, CONST6, CONST7 };
+  short s;
+
+  s = s3 (sv);
+  if (s != CONST3)
+    abort ();
+
+  s = s7 (sv);
+  if (s != CONST7)
+    abort ();
+
+  s = s21 (sv);
+  if (s != CONST5)
+    abort ();
+
+  s = s30 (sv);
+  if (s != CONST6)
+    abort ();
+
+  s = ms3 (&sv);
+  if (s != CONST3)
+    abort ();
+
+  s = ms7 (&sv);
+  if (s != CONST7)
+    abort ();
+
+  s = ms21 (&sv);
+  if (s != CONST5)
+    abort ();
+
+  s = ms30 (&sv);
+  if (s != CONST6)
+    abort ();
+
+  s = ci (sv, 5);
+  if (s != CONST5)
+    abort ();
+
+  s = ci (sv, 2);
+  if (s != CONST2)
+    abort ();
+
+  s = ci (sv, 15);
+  if (s != CONST7)
+    abort ();
+
+  s = ci (sv, 28);
+  if (s != CONST4)
+    abort ();
+
+  s = mci (&sv, 5);
+  if (s != CONST5)
+    abort ();
+
+  s = mci (&sv, 12);
+  if (s != CONST4)
+    abort ();
+
+  s = mci (&sv, 25);
+  if (s != CONST1)
+    abort ();
+
+  s = mci (&sv, 16);
+  if (s != CONST0)
+    abort ();
+
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/vsx-builtin-10b.c b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-10b.c
new file mode 100644
index 00000000000..6300b0e2230
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-10b.c
@@ -0,0 +1,155 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec -O3" } */
+
+/* This test should run the same on any target that supports altivec/dfp
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+#define CONST4		(4)
+#define CONST5		(5)
+#define CONST6		(6)
+#define CONST7		(7)
+
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+short s3 (vector short v)
+{
+  return __builtin_vec_ext_v8hi (v, 3);
+}
+
+short s7 (vector short v)
+{
+  return __builtin_vec_ext_v8hi (v, 7);
+}
+
+short s21 (vector short v)
+{
+  return __builtin_vec_ext_v8hi (v, 21);
+}
+
+short s30 (vector short v)
+{
+  return __builtin_vec_ext_v8hi (v, 30);
+}
+
+/* Test for vector residing in memory.  */
+short ms3 (vector short *vp)
+{
+  return __builtin_vec_ext_v8hi (*vp, 3);
+}
+
+short ms7 (vector short *vp)
+{
+  return __builtin_vec_ext_v8hi (*vp, 7);
+}
+
+short ms21 (vector short *vp)
+{
+  return __builtin_vec_ext_v8hi (*vp, 21);
+}
+
+short ms30 (vector short *vp)
+{
+  return __builtin_vec_ext_v8hi (*vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+short ci (vector short v, int i)
+{
+  return __builtin_vec_ext_v8hi (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+short mci (vector short *vp, int i)
+{
+  return __builtin_vec_ext_v8hi (*vp, i);
+}
+
+
+int main (int argc, short *argv[]) {
+  vector short sv = {
+    CONST0, CONST1, CONST2, CONST3, CONST4, CONST5, CONST6, CONST7 };
+  short s;
+
+  s = s3 (sv);
+  if (s != CONST3)
+    abort ();
+
+  s = s7 (sv);
+  if (s != CONST7)
+    abort ();
+
+  s = s21 (sv);
+  if (s != CONST5)
+    abort ();
+
+  s = s30 (sv);
+  if (s != CONST6)
+    abort ();
+
+  s = ms3 (&sv);
+  if (s != CONST3)
+    abort ();
+
+  s = ms7 (&sv);
+  if (s != CONST7)
+    abort ();
+
+  s = ms21 (&sv);
+  if (s != CONST5)
+    abort ();
+
+  s = ms30 (&sv);
+  if (s != CONST6)
+    abort ();
+
+  s = ci (sv, 5);
+  if (s != CONST5)
+    abort ();
+
+  s = ci (sv, 2);
+  if (s != CONST2)
+    abort ();
+
+  s = ci (sv, 15);
+  if (s != CONST7)
+    abort ();
+
+  s = ci (sv, 28);
+  if (s != CONST4)
+    abort ();
+
+  s = mci (&sv, 5);
+  if (s != CONST5)
+    abort ();
+
+  s = mci (&sv, 12);
+  if (s != CONST4)
+    abort ();
+
+  s = mci (&sv, 25);
+  if (s != CONST1)
+    abort ();
+
+  s = mci (&sv, 16);
+  if (s != CONST0)
+    abort ();
+
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/vsx-builtin-11a.c b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-11a.c
new file mode 100644
index 00000000000..e962e121bd0
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-11a.c
@@ -0,0 +1,149 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec" } */
+
+/* This test should run the same on any target that supports altivec/dfp
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+int s3 (vector int v)
+{
+  return __builtin_vec_ext_v4si (v, 3);
+}
+
+int s1 (vector int v)
+{
+  return __builtin_vec_ext_v4si (v, 1);
+}
+
+int s21 (vector int v)
+{
+  return __builtin_vec_ext_v4si (v, 21);
+}
+
+int s30 (vector int v)
+{
+  return __builtin_vec_ext_v4si (v, 30);
+}
+
+/* Test for vector residing in memory.  */
+int ms3 (vector int *vp)
+{
+  return __builtin_vec_ext_v4si (*vp, 3);
+}
+
+int ms1(vector int *vp)
+{
+  return __builtin_vec_ext_v4si (*vp, 1);
+}
+
+int ms21(vector int *vp)
+{
+  return __builtin_vec_ext_v4si (*vp, 21);
+}
+
+int ms30(vector int *vp)
+{
+  return __builtin_vec_ext_v4si (*vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+int ci (vector int v, int i)
+{
+  return __builtin_vec_ext_v4si (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+int mci(vector int *vp, int i)
+{
+  return __builtin_vec_ext_v4si (*vp, i);
+}
+
+
+int main (int argc, int *argv[]) {
+  vector int sv = { CONST0, CONST1, CONST2, CONST3 };
+  int s;
+
+  s = s3 (sv);
+  if (s != CONST3)
+    abort ();
+
+  s = s1 (sv);
+  if (s != CONST1)
+    abort ();
+
+  s = s21 (sv);
+  if (s != CONST1)
+    abort ();
+
+  s = s30 (sv);
+  if (s != CONST2)
+    abort ();
+
+  s = ms3 (&sv);
+  if (s != CONST3)
+    abort ();
+
+  s = ms1 (&sv);
+  if (s != CONST1)
+    abort ();
+
+  s = ms21 (&sv);
+  if (s != CONST1)
+    abort ();
+
+  s = ms30 (&sv);
+  if (s != CONST2)
+    abort ();
+
+  s = ci (sv, 5);
+  if (s != CONST1)
+    abort ();
+
+  s = ci (sv, 2);
+  if (s != CONST2)
+    abort ();
+
+  s = ci (sv, 15);
+  if (s != CONST3)
+    abort ();
+
+  s = ci (sv, 28);
+  if (s != CONST0)
+    abort ();
+
+  s = mci (&sv, 5);
+  if (s != CONST1)
+    abort ();
+
+  s = mci (&sv, 12);
+  if (s != CONST0)
+    abort ();
+
+  s = mci (&sv, 25);
+  if (s != CONST1)
+    abort ();
+
+  s = mci (&sv, 16);
+  if (s != CONST0)
+    abort ();
+
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/vsx-builtin-11b.c b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-11b.c
new file mode 100644
index 00000000000..fafdd10f842
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-11b.c
@@ -0,0 +1,149 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec -O3" } */
+
+/* This test should run the same on any target that supports altivec/dfp
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+int s3 (vector int v)
+{
+  return __builtin_vec_ext_v4si (v, 3);
+}
+
+int s1 (vector int v)
+{
+  return __builtin_vec_ext_v4si (v, 1);
+}
+
+int s21 (vector int v)
+{
+  return __builtin_vec_ext_v4si (v, 21);
+}
+
+int s30 (vector int v)
+{
+  return __builtin_vec_ext_v4si (v, 30);
+}
+
+/* Test for vector residing in memory.  */
+int ms3 (vector int *vp)
+{
+  return __builtin_vec_ext_v4si (*vp, 3);
+}
+
+int ms1(vector int *vp)
+{
+  return __builtin_vec_ext_v4si (*vp, 1);
+}
+
+int ms21(vector int *vp)
+{
+  return __builtin_vec_ext_v4si (*vp, 21);
+}
+
+int ms30(vector int *vp)
+{
+  return __builtin_vec_ext_v4si (*vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+int ci (vector int v, int i)
+{
+  return __builtin_vec_ext_v4si (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+int mci(vector int *vp, int i)
+{
+  return __builtin_vec_ext_v4si (*vp, i);
+}
+
+
+int main (int argc, int *argv[]) {
+  vector int sv = { CONST0, CONST1, CONST2, CONST3 };
+  int s;
+
+  s = s3 (sv);
+  if (s != CONST3)
+    abort ();
+
+  s = s1 (sv);
+  if (s != CONST1)
+    abort ();
+
+  s = s21 (sv);
+  if (s != CONST1)
+    abort ();
+
+  s = s30 (sv);
+  if (s != CONST2)
+    abort ();
+
+  s = ms3 (&sv);
+  if (s != CONST3)
+    abort ();
+
+  s = ms1 (&sv);
+  if (s != CONST1)
+    abort ();
+
+  s = ms21 (&sv);
+  if (s != CONST1)
+    abort ();
+
+  s = ms30 (&sv);
+  if (s != CONST2)
+    abort ();
+
+  s = ci (sv, 5);
+  if (s != CONST1)
+    abort ();
+
+  s = ci (sv, 2);
+  if (s != CONST2)
+    abort ();
+
+  s = ci (sv, 15);
+  if (s != CONST3)
+    abort ();
+
+  s = ci (sv, 28);
+  if (s != CONST0)
+    abort ();
+
+  s = mci (&sv, 5);
+  if (s != CONST1)
+    abort ();
+
+  s = mci (&sv, 12);
+  if (s != CONST0)
+    abort ();
+
+  s = mci (&sv, 25);
+  if (s != CONST1)
+    abort ();
+
+  s = mci (&sv, 16);
+  if (s != CONST0)
+    abort ();
+
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/vsx-builtin-12a.c b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-12a.c
new file mode 100644
index 00000000000..a79bc7f5384
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-12a.c
@@ -0,0 +1,109 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(31415926539LL)
+#define CONST1		(2 * 31415926539LL)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+long long int e0 (vector long long int v)
+{
+  return __builtin_vec_ext_v2di (v, 0);
+}
+
+long long int e3 (vector long long int v)
+{
+  return __builtin_vec_ext_v2di (v, 3);
+}
+
+/* Test for vector residing in memory.  */
+long long int me0 (vector long long int *vp)
+{
+  return __builtin_vec_ext_v2di (*vp, 0);
+}
+
+long long int me3 (vector long long int *vp)
+{
+  return __builtin_vec_ext_v2di (*vp, 3);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+long long int ei (vector long long int v, int i)
+{
+  return __builtin_vec_ext_v2di (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+long long int mei (vector long long int *vp, int i)
+{
+  return __builtin_vec_ext_v2di (*vp, i);
+}
+
+int main (int argc, char *argv[]) {
+  vector long long int dv = { CONST0, CONST1 };
+  long long int d;
+
+  d = e0 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = e3 (dv);
+  if (d != CONST1)
+    abort ();
+
+  d = me0 (&dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me3 (&dv);
+  if (d != CONST1)
+    abort ();
+
+  d = ei (dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 1);
+  if (d != CONST1)
+    abort ();
+
+  d = ei (dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 3);
+  if (d != CONST1)
+    abort ();
+
+  d = mei (&dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 1);
+  if (d != CONST1)
+    abort ();
+
+  d = mei (&dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 3);
+  if (d != CONST1)
+    abort ();
+
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/vsx-builtin-12b.c b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-12b.c
new file mode 100644
index 00000000000..2b63624f8b1
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-12b.c
@@ -0,0 +1,109 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx -O3" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(31415926539LL)
+#define CONST1		(2 * 31415926539LL)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+long long int e0 (vector long long int v)
+{
+  return __builtin_vec_ext_v2di (v, 0);
+}
+
+long long int e3 (vector long long int v)
+{
+  return __builtin_vec_ext_v2di (v, 3);
+}
+
+/* Test for vector residing in memory.  */
+long long int me0 (vector long long int *vp)
+{
+  return __builtin_vec_ext_v2di (*vp, 0);
+}
+
+long long int me3 (vector long long int *vp)
+{
+  return __builtin_vec_ext_v2di (*vp, 3);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+long long int ei (vector long long int v, int i)
+{
+  return __builtin_vec_ext_v2di (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+long long int mei (vector long long int *vp, int i)
+{
+  return __builtin_vec_ext_v2di (*vp, i);
+}
+
+int main (int argc, char *argv[]) {
+  vector long long int dv = { CONST0, CONST1 };
+  long long int d;
+
+  d = e0 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = e3 (dv);
+  if (d != CONST1)
+    abort ();
+
+  d = me0 (&dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me3 (&dv);
+  if (d != CONST1)
+    abort ();
+
+  d = ei (dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 1);
+  if (d != CONST1)
+    abort ();
+
+  d = ei (dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 3);
+  if (d != CONST1)
+    abort ();
+
+  d = mei (&dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 1);
+  if (d != CONST1)
+    abort ();
+
+  d = mei (&dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 3);
+  if (d != CONST1)
+    abort ();
+
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/vsx-builtin-13a.c b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-13a.c
new file mode 100644
index 00000000000..7dc6bd994e4
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-13a.c
@@ -0,0 +1,124 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+/* Define this after PR89424 is addressed.  */
+#define PR89424
+
+/* Define this after PR89626 is addressed.  */
+#undef PR89626
+
+#ifdef PR89626
+#define SIGNED
+#else
+#define SIGNED signed
+#endif
+
+extern void abort (void);
+
+#define CONST0		(((SIGNED __int128) 31415926539) << 60)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+SIGNED __int128 e0 (vector SIGNED __int128 v)
+{
+  return __builtin_vec_ext_v1ti (v, 0);
+}
+
+SIGNED __int128 e3 (vector SIGNED __int128 v)
+{
+  return __builtin_vec_ext_v1ti (v, 3);
+}
+
+/* Test for vector residing in memory.  */
+SIGNED __int128 me0 (vector SIGNED __int128 *vp)
+{
+  return __builtin_vec_ext_v1ti (*vp, 0);
+}
+
+SIGNED __int128 me3 (vector SIGNED __int128 *vp)
+{
+  return __builtin_vec_ext_v1ti (*vp, 3);
+}
+
+/* Test the same with variable indices.  */
+
+#ifdef PR89424
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+SIGNED __int128 ei (vector SIGNED __int128 v, int i)
+{
+  return __builtin_vec_ext_v1ti (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+SIGNED __int128 mei (vector SIGNED __int128 *vp, int i)
+{
+  return __builtin_vec_ext_v1ti (*vp, i);
+}
+#endif
+
+int main (int argc, char *argv[]) {
+  vector SIGNED __int128 dv = { CONST0 };
+  SIGNED __int128 d;
+
+  d = e0 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = e3 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me0 (&dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me3 (&dv);
+  if (d != CONST0)
+    abort ();
+
+#ifdef PR89424
+  d = ei (dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 1);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 3);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 1);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 3);
+  if (d != CONST0)
+    abort ();
+#endif
+
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/vsx-builtin-13b.c b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-13b.c
new file mode 100644
index 00000000000..168227214fc
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-13b.c
@@ -0,0 +1,124 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx -O3" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+/* Define this after PR89424 is addressed.  */
+#define PR89424
+
+/* Define this after PR89626 is addressed.  */
+#undef PR89626
+
+#ifdef PR89626
+#define SIGNED
+#else
+#define SIGNED signed
+#endif
+
+extern void abort (void);
+
+#define CONST0		(((SIGNED __int128) 31415926539) << 60)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+SIGNED __int128 e0 (vector SIGNED __int128 v)
+{
+  return __builtin_vec_ext_v1ti (v, 0);
+}
+
+SIGNED __int128 e3 (vector SIGNED __int128 v)
+{
+  return __builtin_vec_ext_v1ti (v, 3);
+}
+
+/* Test for vector residing in memory.  */
+SIGNED __int128 me0 (vector SIGNED __int128 *vp)
+{
+  return __builtin_vec_ext_v1ti (*vp, 0);
+}
+
+SIGNED __int128 me3 (vector SIGNED __int128 *vp)
+{
+  return __builtin_vec_ext_v1ti (*vp, 3);
+}
+
+/* Test the same with variable indices.  */
+
+#ifdef PR89424
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+SIGNED __int128 ei (vector SIGNED __int128 v, int i)
+{
+  return __builtin_vec_ext_v1ti (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+SIGNED __int128 mei (vector SIGNED __int128 *vp, int i)
+{
+  return __builtin_vec_ext_v1ti (*vp, i);
+}
+#endif
+
+int main (int argc, char *argv[]) {
+  vector SIGNED __int128 dv = { CONST0 };
+  SIGNED __int128 d;
+
+  d = e0 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = e3 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me0 (&dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me3 (&dv);
+  if (d != CONST0)
+    abort ();
+
+#ifdef PR89424
+  d = ei (dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 1);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 3);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 1);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 3);
+  if (d != CONST0)
+    abort ();
+#endif
+
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/vsx-builtin-14a.c b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-14a.c
new file mode 100644
index 00000000000..8eb8eb63fbe
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-14a.c
@@ -0,0 +1,126 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec" } */
+
+/* This test should run the same on any target that supports altivec/dfp
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		((float) (3.1415926539))
+#define CONST1		((float) (3.1415926539 * 2))
+#define CONST2		((float) (3.1415926539 * 3))
+#define CONST3		((float) (3.1415926539 * 4))
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+float e0(vector float v){ return __builtin_vec_ext_v4sf (v, 0); }
+float e1(vector float v){ return __builtin_vec_ext_v4sf (v, 1); }
+float e7(vector float v){ return __builtin_vec_ext_v4sf (v, 7); }
+float e8(vector float v){ return __builtin_vec_ext_v4sf (v, 8); }
+
+/* Test for vector residing in memory.  */
+float me0(vector float *vp){ return __builtin_vec_ext_v4sf (*vp, 0); }
+float me1(vector float *vp){ return __builtin_vec_ext_v4sf (*vp, 1); }
+
+float me13(vector float *vp)
+{
+  return __builtin_vec_ext_v4sf (*vp, 13);
+}
+
+float me15(vector float *vp)
+{
+  return __builtin_vec_ext_v4sf (*vp, 15);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+float ei(vector float v, int i)
+{
+  return __builtin_vec_ext_v4sf (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+float mei(vector float *vp, int i)
+{
+  return __builtin_vec_ext_v4sf (*vp, i);
+}
+
+
+int main (int argc, char *argv[]) {
+  vector float dv = { CONST0, CONST1, CONST2, CONST3 };
+  float d;
+
+  d = e0 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = e1 (dv);
+  if (d != CONST1)
+    abort ();
+
+  d = e7 (dv);
+  if (d != CONST3)
+    abort ();
+
+  d = e8 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me0 (&dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me1 (&dv);
+  if (d != CONST1)
+    abort ();
+
+  d = me13 (&dv);
+  if (d != CONST1)
+    abort ();
+
+  d = me15 (&dv);
+  if (d != CONST3)
+    abort ();
+
+  d = ei (dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 2);
+  if (d != CONST2)
+    abort ();
+
+  d = ei (dv, 11);
+  if (d != CONST3)
+    abort ();
+
+  d = ei (dv, 17);
+  if (d != CONST1)
+    abort ();
+
+  d = mei (&dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 1);
+  if (d != CONST1)
+    abort ();
+
+  d = mei (&dv, 15);
+  if (d != CONST3)
+    abort ();
+
+  d = mei (&dv, 6);
+  if (d != CONST2)
+    abort ();
+
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/vsx-builtin-14b.c b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-14b.c
new file mode 100644
index 00000000000..84bc8a2ae71
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-14b.c
@@ -0,0 +1,126 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec -O3" } */
+
+/* This test should run the same on any target that supports altivec/dfp
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		((float) (3.1415926539))
+#define CONST1		((float) (3.1415926539 * 2))
+#define CONST2		((float) (3.1415926539 * 3))
+#define CONST3		((float) (3.1415926539 * 4))
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+float e0(vector float v){ return __builtin_vec_ext_v4sf (v, 0); }
+float e1(vector float v){ return __builtin_vec_ext_v4sf (v, 1); }
+float e7(vector float v){ return __builtin_vec_ext_v4sf (v, 7); }
+float e8(vector float v){ return __builtin_vec_ext_v4sf (v, 8); }
+
+/* Test for vector residing in memory.  */
+float me0(vector float *vp){ return __builtin_vec_ext_v4sf (*vp, 0); }
+float me1(vector float *vp){ return __builtin_vec_ext_v4sf (*vp, 1); }
+
+float me13(vector float *vp)
+{
+  return __builtin_vec_ext_v4sf (*vp, 13);
+}
+
+float me15(vector float *vp)
+{
+  return __builtin_vec_ext_v4sf (*vp, 15);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+float ei(vector float v, int i)
+{
+  return __builtin_vec_ext_v4sf (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+float mei(vector float *vp, int i)
+{
+  return __builtin_vec_ext_v4sf (*vp, i);
+}
+
+
+int main (int argc, char *argv[]) {
+  vector float dv = { CONST0, CONST1, CONST2, CONST3 };
+  float d;
+
+  d = e0 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = e1 (dv);
+  if (d != CONST1)
+    abort ();
+
+  d = e7 (dv);
+  if (d != CONST3)
+    abort ();
+
+  d = e8 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me0 (&dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me1 (&dv);
+  if (d != CONST1)
+    abort ();
+
+  d = me13 (&dv);
+  if (d != CONST1)
+    abort ();
+
+  d = me15 (&dv);
+  if (d != CONST3)
+    abort ();
+
+  d = ei (dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 2);
+  if (d != CONST2)
+    abort ();
+
+  d = ei (dv, 11);
+  if (d != CONST3)
+    abort ();
+
+  d = ei (dv, 17);
+  if (d != CONST1)
+    abort ();
+
+  d = mei (&dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 1);
+  if (d != CONST1)
+    abort ();
+
+  d = mei (&dv, 15);
+  if (d != CONST3)
+    abort ();
+
+  d = mei (&dv, 6);
+  if (d != CONST2)
+    abort ();
+
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/vsx-builtin-15a.c b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-15a.c
new file mode 100644
index 00000000000..b8bff5c3f56
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-15a.c
@@ -0,0 +1,113 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(3.1415926539)
+#define CONST1		(3.1415926539 * 2)
+
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+double e0(vector double v){ return __builtin_vec_ext_v2df (v, 0); }
+double e1(vector double v){ return __builtin_vec_ext_v2df (v, 1); }
+double e2(vector double v){ return __builtin_vec_ext_v2df (v, 2); }
+double e3(vector double v){ return __builtin_vec_ext_v2df (v, 3); }
+
+/* Test for vector residing in memory.  */
+double me0(vector double *vp){ return __builtin_vec_ext_v2df (*vp, 0); }
+double me1(vector double *vp){ return __builtin_vec_ext_v2df (*vp, 1); }
+double me2(vector double *vp){ return __builtin_vec_ext_v2df (*vp, 2); }
+double me3(vector double *vp){ return __builtin_vec_ext_v2df (*vp, 3); }
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+double ei(vector double v, int i){ return __builtin_vec_ext_v2df (v, i); }
+
+/* Test for variable selector and vector residing in memory.  */
+double mei(vector double *vp, int i){ return __builtin_vec_ext_v2df (*vp, i); }
+
+
+int main (int argc, char *argv[]) {
+  vector double dv;
+  double d;
+  dv[0] = CONST0;
+  dv[1] = CONST1;
+
+  d = e0 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = e1 (dv);
+  if (d != CONST1)
+    abort ();
+
+  d = e2 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = e3 (dv);
+  if (d != CONST1)
+    abort ();
+
+  d = me0 (&dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me1 (&dv);
+  if (d != CONST1)
+    abort ();
+
+  d = me2 (&dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me3 (&dv);
+  if (d != CONST1)
+    abort ();
+
+  d = ei (dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 1);
+  if (d != CONST1)
+    abort ();
+
+  d = ei (dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 3);
+  if (d != CONST1)
+    abort ();
+
+  d = mei (&dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 1);
+  if (d != CONST1)
+    abort ();
+
+  d = mei (&dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 3);
+  if (d != CONST1)
+    abort ();
+
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/vsx-builtin-15b.c b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-15b.c
new file mode 100644
index 00000000000..402cde7b1c3
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-15b.c
@@ -0,0 +1,113 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx -O3" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(3.1415926539)
+#define CONST1		(3.1415926539 * 2)
+
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+double e0(vector double v){ return __builtin_vec_ext_v2df (v, 0); }
+double e1(vector double v){ return __builtin_vec_ext_v2df (v, 1); }
+double e2(vector double v){ return __builtin_vec_ext_v2df (v, 2); }
+double e3(vector double v){ return __builtin_vec_ext_v2df (v, 3); }
+
+/* Test for vector residing in memory.  */
+double me0(vector double *vp){ return __builtin_vec_ext_v2df (*vp, 0); }
+double me1(vector double *vp){ return __builtin_vec_ext_v2df (*vp, 1); }
+double me2(vector double *vp){ return __builtin_vec_ext_v2df (*vp, 2); }
+double me3(vector double *vp){ return __builtin_vec_ext_v2df (*vp, 3); }
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+double ei(vector double v, int i){ return __builtin_vec_ext_v2df (v, i); }
+
+/* Test for variable selector and vector residing in memory.  */
+double mei(vector double *vp, int i){ return __builtin_vec_ext_v2df (*vp, i); }
+
+
+int main (int argc, char *argv[]) {
+  vector double dv;
+  double d;
+  dv[0] = CONST0;
+  dv[1] = CONST1;
+
+  d = e0 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = e1 (dv);
+  if (d != CONST1)
+    abort ();
+
+  d = e2 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = e3 (dv);
+  if (d != CONST1)
+    abort ();
+
+  d = me0 (&dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me1 (&dv);
+  if (d != CONST1)
+    abort ();
+
+  d = me2 (&dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me3 (&dv);
+  if (d != CONST1)
+    abort ();
+
+  d = ei (dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 1);
+  if (d != CONST1)
+    abort ();
+
+  d = ei (dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 3);
+  if (d != CONST1)
+    abort ();
+
+  d = mei (&dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 1);
+  if (d != CONST1)
+    abort ();
+
+  d = mei (&dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 3);
+  if (d != CONST1)
+    abort ();
+
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/vsx-builtin-16a.c b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-16a.c
new file mode 100644
index 00000000000..465296a820a
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-16a.c
@@ -0,0 +1,165 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec" } */
+
+/* This test should run the same on any target that supports altivec/dfp
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+#define CONST4		(4)
+#define CONST5		(5)
+#define CONST6		(6)
+#define CONST7		(7)
+#define CONST8		(8)
+#define CONST9		(9)
+#define CONSTA		(10)
+#define CONSTB		(11)
+#define CONSTC		(12)
+#define CONSTD		(13)
+#define CONSTE		(14)
+#define CONSTF		(15)
+
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+unsigned char c0 (vector unsigned char v)
+{
+  return __builtin_vec_extract (v, 0);
+}
+
+unsigned char c9 (vector unsigned char v)
+{
+  return __builtin_vec_extract (v, 9);
+}
+
+unsigned char c21 (vector unsigned char v)
+{
+  return __builtin_vec_extract (v, 21);
+}
+
+unsigned char c30 (vector unsigned char v)
+{
+  return __builtin_vec_extract (v, 30);
+}
+
+/* Test for vector residing in memory.  */
+unsigned char mc0 (vector unsigned char *vp)
+{
+  return __builtin_vec_extract (*vp, 0);
+}
+
+unsigned char mc9 (vector unsigned char *vp)
+{
+  return __builtin_vec_extract (*vp, 9);
+}
+
+unsigned char mc21 (vector unsigned char *vp)
+{
+  return __builtin_vec_extract (*vp, 21);
+}
+
+unsigned char mc30 (vector unsigned char *vp)
+{
+  return __builtin_vec_extract (*vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+unsigned char ci (vector unsigned char v, int i)
+{
+  return __builtin_vec_extract (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+unsigned char mci (vector unsigned char *vp, int i)
+{
+  return __builtin_vec_extract (*vp, i);
+}
+
+
+int main (int argc, char *argv[]) {
+  vector unsigned char cv = { CONST0, CONST1, CONST2, CONST3,
+			    CONST4, CONST5, CONST6, CONST7,
+			    CONST8, CONST9, CONSTA, CONSTB,
+			    CONSTC, CONSTD, CONSTE, CONSTF };
+  unsigned char c;
+
+  c = c0 (cv);
+  if (c != CONST0)
+    abort ();
+
+  c = c9 (cv);
+  if (c != CONST9)
+    abort ();
+
+  c = c21 (cv);
+  if (c != CONST5)
+    abort ();
+
+  c = c30 (cv);
+  if (c != CONSTE)
+    abort ();
+
+  c = mc0 (&cv);
+  if (c != CONST0)
+    abort ();
+
+  c = mc9 (&cv);
+  if (c != CONST9)
+    abort ();
+
+  c = mc21 (&cv);
+  if (c != CONST5)
+    abort ();
+
+  c = mc30 (&cv);
+  if (c != CONSTE)
+    abort ();
+
+  c = ci (cv, 8);
+  if (c != CONST8)
+    abort ();
+
+  c = ci (cv, 13);
+  if (c != CONSTD)
+    abort ();
+
+  c = ci (cv, 23);
+  if (c != CONST7)
+    abort ();
+
+  c = ci (cv, 31);
+  if (c != CONSTF)
+    abort ();
+
+  c = mci (&cv, 5);
+  if (c != CONST5)
+    abort ();
+
+  c = mci (&cv, 12);
+  if (c != CONSTC)
+    abort ();
+
+  c = mci (&cv, 25);
+  if (c != CONST9)
+    abort ();
+
+  c = mci (&cv, 16);
+  if (c != CONST0)
+    abort ();
+
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/vsx-builtin-16b.c b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-16b.c
new file mode 100644
index 00000000000..b646fb12dab
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-16b.c
@@ -0,0 +1,165 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec -O3" } */
+
+/* This test should run the same on any target that supports altivec/dfp
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+#define CONST4		(4)
+#define CONST5		(5)
+#define CONST6		(6)
+#define CONST7		(7)
+#define CONST8		(8)
+#define CONST9		(9)
+#define CONSTA		(10)
+#define CONSTB		(11)
+#define CONSTC		(12)
+#define CONSTD		(13)
+#define CONSTE		(14)
+#define CONSTF		(15)
+
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+unsigned char c0 (vector unsigned char v)
+{
+  return __builtin_vec_extract (v, 0);
+}
+
+unsigned char c9 (vector unsigned char v)
+{
+  return __builtin_vec_extract (v, 9);
+}
+
+unsigned char c21 (vector unsigned char v)
+{
+  return __builtin_vec_extract (v, 21);
+}
+
+unsigned char c30 (vector unsigned char v)
+{
+  return __builtin_vec_extract (v, 30);
+}
+
+/* Test for vector residing in memory.  */
+unsigned char mc0 (vector unsigned char *vp)
+{
+  return __builtin_vec_extract (*vp, 0);
+}
+
+unsigned char mc9 (vector unsigned char *vp)
+{
+  return __builtin_vec_extract (*vp, 9);
+}
+
+unsigned char mc21 (vector unsigned char *vp)
+{
+  return __builtin_vec_extract (*vp, 21);
+}
+
+unsigned char mc30 (vector unsigned char *vp)
+{
+  return __builtin_vec_extract (*vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+unsigned char ci (vector unsigned char v, int i)
+{
+  return __builtin_vec_extract (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+unsigned char mci (vector unsigned char *vp, int i)
+{
+  return __builtin_vec_extract (*vp, i);
+}
+
+
+int main (int argc, char *argv[]) {
+  vector unsigned char cv = { CONST0, CONST1, CONST2, CONST3,
+			    CONST4, CONST5, CONST6, CONST7,
+			    CONST8, CONST9, CONSTA, CONSTB,
+			    CONSTC, CONSTD, CONSTE, CONSTF };
+  unsigned char c;
+
+  c = c0 (cv);
+  if (c != CONST0)
+    abort ();
+
+  c = c9 (cv);
+  if (c != CONST9)
+    abort ();
+
+  c = c21 (cv);
+  if (c != CONST5)
+    abort ();
+
+  c = c30 (cv);
+  if (c != CONSTE)
+    abort ();
+
+  c = mc0 (&cv);
+  if (c != CONST0)
+    abort ();
+
+  c = mc9 (&cv);
+  if (c != CONST9)
+    abort ();
+
+  c = mc21 (&cv);
+  if (c != CONST5)
+    abort ();
+
+  c = mc30 (&cv);
+  if (c != CONSTE)
+    abort ();
+
+  c = ci (cv, 8);
+  if (c != CONST8)
+    abort ();
+
+  c = ci (cv, 13);
+  if (c != CONSTD)
+    abort ();
+
+  c = ci (cv, 23);
+  if (c != CONST7)
+    abort ();
+
+  c = ci (cv, 31);
+  if (c != CONSTF)
+    abort ();
+
+  c = mci (&cv, 5);
+  if (c != CONST5)
+    abort ();
+
+  c = mci (&cv, 12);
+  if (c != CONSTC)
+    abort ();
+
+  c = mci (&cv, 25);
+  if (c != CONST9)
+    abort ();
+
+  c = mci (&cv, 16);
+  if (c != CONST0)
+    abort ();
+
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/vsx-builtin-17a.c b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-17a.c
new file mode 100644
index 00000000000..afb69342a31
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-17a.c
@@ -0,0 +1,155 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec" } */
+
+/* This test should run the same on any target that supports altivec/dfp
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+#define CONST4		(4)
+#define CONST5		(5)
+#define CONST6		(6)
+#define CONST7		(7)
+
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+unsigned short s3 (vector unsigned short v)
+{
+  return __builtin_vec_extract (v, 3);
+}
+
+unsigned short s7 (vector unsigned short v)
+{
+  return __builtin_vec_extract (v, 7);
+}
+
+unsigned short s21 (vector unsigned short v)
+{
+  return __builtin_vec_extract (v, 21);
+}
+
+unsigned short s30 (vector unsigned short v)
+{
+  return __builtin_vec_extract (v, 30);
+}
+
+/* Test for vector residing in memory.  */
+unsigned short ms3 (vector unsigned short *vp)
+{
+  return __builtin_vec_extract (*vp, 3);
+}
+
+unsigned short ms7 (vector unsigned short *vp)
+{
+  return __builtin_vec_extract (*vp, 7);
+}
+
+unsigned short ms21 (vector unsigned short *vp)
+{
+  return __builtin_vec_extract (*vp, 21);
+}
+
+unsigned short ms30 (vector unsigned short *vp)
+{
+  return __builtin_vec_extract (*vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+unsigned short ci (vector unsigned short v, int i)
+{
+  return __builtin_vec_extract (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+unsigned short mci (vector unsigned short *vp, int i)
+{
+  return __builtin_vec_extract (*vp, i);
+}
+
+
+int main (int argc, unsigned short *argv[]) {
+  vector unsigned short sv = {
+    CONST0, CONST1, CONST2, CONST3, CONST4, CONST5, CONST6, CONST7 };
+  unsigned short s;
+
+  s = s3 (sv);
+  if (s != CONST3)
+    abort ();
+
+  s = s7 (sv);
+  if (s != CONST7)
+    abort ();
+
+  s = s21 (sv);
+  if (s != CONST5)
+    abort ();
+
+  s = s30 (sv);
+  if (s != CONST6)
+    abort ();
+
+  s = ms3 (&sv);
+  if (s != CONST3)
+    abort ();
+
+  s = ms7 (&sv);
+  if (s != CONST7)
+    abort ();
+
+  s = ms21 (&sv);
+  if (s != CONST5)
+    abort ();
+
+  s = ms30 (&sv);
+  if (s != CONST6)
+    abort ();
+
+  s = ci (sv, 5);
+  if (s != CONST5)
+    abort ();
+
+  s = ci (sv, 2);
+  if (s != CONST2)
+    abort ();
+
+  s = ci (sv, 15);
+  if (s != CONST7)
+    abort ();
+
+  s = ci (sv, 28);
+  if (s != CONST4)
+    abort ();
+
+  s = mci (&sv, 5);
+  if (s != CONST5)
+    abort ();
+
+  s = mci (&sv, 12);
+  if (s != CONST4)
+    abort ();
+
+  s = mci (&sv, 25);
+  if (s != CONST1)
+    abort ();
+
+  s = mci (&sv, 16);
+  if (s != CONST0)
+    abort ();
+
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/vsx-builtin-17b.c b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-17b.c
new file mode 100644
index 00000000000..63814ee4bb4
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-17b.c
@@ -0,0 +1,155 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec -O3" } */
+
+/* This test should run the same on any target that supports altivec/dfp
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+#define CONST4		(4)
+#define CONST5		(5)
+#define CONST6		(6)
+#define CONST7		(7)
+
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+unsigned short s3 (vector unsigned short v)
+{
+  return __builtin_vec_extract (v, 3);
+}
+
+unsigned short s7 (vector unsigned short v)
+{
+  return __builtin_vec_extract (v, 7);
+}
+
+unsigned short s21 (vector unsigned short v)
+{
+  return __builtin_vec_extract (v, 21);
+}
+
+unsigned short s30 (vector unsigned short v)
+{
+  return __builtin_vec_extract (v, 30);
+}
+
+/* Test for vector residing in memory.  */
+unsigned short ms3 (vector unsigned short *vp)
+{
+  return __builtin_vec_extract (*vp, 3);
+}
+
+unsigned short ms7 (vector unsigned short *vp)
+{
+  return __builtin_vec_extract (*vp, 7);
+}
+
+unsigned short ms21 (vector unsigned short *vp)
+{
+  return __builtin_vec_extract (*vp, 21);
+}
+
+unsigned short ms30 (vector unsigned short *vp)
+{
+  return __builtin_vec_extract (*vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+unsigned short ci (vector unsigned short v, int i)
+{
+  return __builtin_vec_extract (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+unsigned short mci (vector unsigned short *vp, int i)
+{
+  return __builtin_vec_extract (*vp, i);
+}
+
+
+int main (int argc, unsigned short *argv[]) {
+  vector unsigned short sv = {
+    CONST0, CONST1, CONST2, CONST3, CONST4, CONST5, CONST6, CONST7 };
+  unsigned short s;
+
+  s = s3 (sv);
+  if (s != CONST3)
+    abort ();
+
+  s = s7 (sv);
+  if (s != CONST7)
+    abort ();
+
+  s = s21 (sv);
+  if (s != CONST5)
+    abort ();
+
+  s = s30 (sv);
+  if (s != CONST6)
+    abort ();
+
+  s = ms3 (&sv);
+  if (s != CONST3)
+    abort ();
+
+  s = ms7 (&sv);
+  if (s != CONST7)
+    abort ();
+
+  s = ms21 (&sv);
+  if (s != CONST5)
+    abort ();
+
+  s = ms30 (&sv);
+  if (s != CONST6)
+    abort ();
+
+  s = ci (sv, 5);
+  if (s != CONST5)
+    abort ();
+
+  s = ci (sv, 2);
+  if (s != CONST2)
+    abort ();
+
+  s = ci (sv, 15);
+  if (s != CONST7)
+    abort ();
+
+  s = ci (sv, 28);
+  if (s != CONST4)
+    abort ();
+
+  s = mci (&sv, 5);
+  if (s != CONST5)
+    abort ();
+
+  s = mci (&sv, 12);
+  if (s != CONST4)
+    abort ();
+
+  s = mci (&sv, 25);
+  if (s != CONST1)
+    abort ();
+
+  s = mci (&sv, 16);
+  if (s != CONST0)
+    abort ();
+
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/vsx-builtin-18a.c b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-18a.c
new file mode 100644
index 00000000000..3681ad9d019
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-18a.c
@@ -0,0 +1,149 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec" } */
+
+/* This test should run the same on any target that supports altivec/dfp
+   instructions.  Unsigned Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+unsigned int s3 (vector unsigned int v)
+{
+  return __builtin_vec_extract (v, 3);
+}
+
+unsigned int s1 (vector unsigned int v)
+{
+  return __builtin_vec_extract (v, 1);
+}
+
+unsigned int s21 (vector unsigned int v)
+{
+  return __builtin_vec_extract (v, 21);
+}
+
+unsigned int s30 (vector unsigned int v)
+{
+  return __builtin_vec_extract (v, 30);
+}
+
+/* Test for vector residing in memory.  */
+unsigned int ms3 (vector unsigned int *vp)
+{
+  return __builtin_vec_extract (*vp, 3);
+}
+
+unsigned int ms1(vector unsigned int *vp)
+{
+  return __builtin_vec_extract (*vp, 1);
+}
+
+unsigned int ms21(vector unsigned int *vp)
+{
+  return __builtin_vec_extract (*vp, 21);
+}
+
+unsigned int ms30(vector unsigned int *vp)
+{
+  return __builtin_vec_extract (*vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+unsigned int ci (vector unsigned int v, int i)
+{
+  return __builtin_vec_extract (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+unsigned int mci(vector unsigned int *vp, int i)
+{
+  return __builtin_vec_extract (*vp, i);
+}
+
+
+unsigned int main (int argc, unsigned char *argv[]) {
+  vector unsigned int sv = { CONST0, CONST1, CONST2, CONST3 };
+  unsigned int s;
+
+  s = s3 (sv);
+  if (s != CONST3)
+    abort ();
+
+  s = s1 (sv);
+  if (s != CONST1)
+    abort ();
+
+  s = s21 (sv);
+  if (s != CONST1)
+    abort ();
+
+  s = s30 (sv);
+  if (s != CONST2)
+    abort ();
+
+  s = ms3 (&sv);
+  if (s != CONST3)
+    abort ();
+
+  s = ms1 (&sv);
+  if (s != CONST1)
+    abort ();
+
+  s = ms21 (&sv);
+  if (s != CONST1)
+    abort ();
+
+  s = ms30 (&sv);
+  if (s != CONST2)
+    abort ();
+
+  s = ci (sv, 5);
+  if (s != CONST1)
+    abort ();
+
+  s = ci (sv, 2);
+  if (s != CONST2)
+    abort ();
+
+  s = ci (sv, 15);
+  if (s != CONST3)
+    abort ();
+
+  s = ci (sv, 28);
+  if (s != CONST0)
+    abort ();
+
+  s = mci (&sv, 5);
+  if (s != CONST1)
+    abort ();
+
+  s = mci (&sv, 12);
+  if (s != CONST0)
+    abort ();
+
+  s = mci (&sv, 25);
+  if (s != CONST1)
+    abort ();
+
+  s = mci (&sv, 16);
+  if (s != CONST0)
+    abort ();
+
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/vsx-builtin-18b.c b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-18b.c
new file mode 100644
index 00000000000..57b5c43282c
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-18b.c
@@ -0,0 +1,149 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec -O3" } */
+
+/* This test should run the same on any target that supports altivec/dfp
+   instructions.  Unsigned Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+unsigned int s3 (vector unsigned int v)
+{
+  return __builtin_vec_extract (v, 3);
+}
+
+unsigned int s1 (vector unsigned int v)
+{
+  return __builtin_vec_extract (v, 1);
+}
+
+unsigned int s21 (vector unsigned int v)
+{
+  return __builtin_vec_extract (v, 21);
+}
+
+unsigned int s30 (vector unsigned int v)
+{
+  return __builtin_vec_extract (v, 30);
+}
+
+/* Test for vector residing in memory.  */
+unsigned int ms3 (vector unsigned int *vp)
+{
+  return __builtin_vec_extract (*vp, 3);
+}
+
+unsigned int ms1(vector unsigned int *vp)
+{
+  return __builtin_vec_extract (*vp, 1);
+}
+
+unsigned int ms21(vector unsigned int *vp)
+{
+  return __builtin_vec_extract (*vp, 21);
+}
+
+unsigned int ms30(vector unsigned int *vp)
+{
+  return __builtin_vec_extract (*vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+unsigned int ci (vector unsigned int v, int i)
+{
+  return __builtin_vec_extract (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+unsigned int mci(vector unsigned int *vp, int i)
+{
+  return __builtin_vec_extract (*vp, i);
+}
+
+
+unsigned int main (int argc, unsigned char *argv[]) {
+  vector unsigned int sv = { CONST0, CONST1, CONST2, CONST3 };
+  unsigned int s;
+
+  s = s3 (sv);
+  if (s != CONST3)
+    abort ();
+
+  s = s1 (sv);
+  if (s != CONST1)
+    abort ();
+
+  s = s21 (sv);
+  if (s != CONST1)
+    abort ();
+
+  s = s30 (sv);
+  if (s != CONST2)
+    abort ();
+
+  s = ms3 (&sv);
+  if (s != CONST3)
+    abort ();
+
+  s = ms1 (&sv);
+  if (s != CONST1)
+    abort ();
+
+  s = ms21 (&sv);
+  if (s != CONST1)
+    abort ();
+
+  s = ms30 (&sv);
+  if (s != CONST2)
+    abort ();
+
+  s = ci (sv, 5);
+  if (s != CONST1)
+    abort ();
+
+  s = ci (sv, 2);
+  if (s != CONST2)
+    abort ();
+
+  s = ci (sv, 15);
+  if (s != CONST3)
+    abort ();
+
+  s = ci (sv, 28);
+  if (s != CONST0)
+    abort ();
+
+  s = mci (&sv, 5);
+  if (s != CONST1)
+    abort ();
+
+  s = mci (&sv, 12);
+  if (s != CONST0)
+    abort ();
+
+  s = mci (&sv, 25);
+  if (s != CONST1)
+    abort ();
+
+  s = mci (&sv, 16);
+  if (s != CONST0)
+    abort ();
+
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/vsx-builtin-19a.c b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-19a.c
new file mode 100644
index 00000000000..dee8319fb10
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-19a.c
@@ -0,0 +1,109 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(31415926539LL)
+#define CONST1		(2 * 31415926539LL)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+unsigned long long int e0 (vector unsigned long long int v)
+{
+  return __builtin_vec_extract (v, 0);
+}
+
+unsigned long long int e3 (vector unsigned long long int v)
+{
+  return __builtin_vec_extract (v, 3);
+}
+
+/* Test for vector residing in memory.  */
+unsigned long long int me0 (vector unsigned long long int *vp)
+{
+  return __builtin_vec_extract (*vp, 0);
+}
+
+unsigned long long int me3 (vector unsigned long long int *vp)
+{
+  return __builtin_vec_extract (*vp, 3);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+unsigned long long int ei (vector unsigned long long int v, int i)
+{
+  return __builtin_vec_extract (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+unsigned long long int mei (vector unsigned long long int *vp, int i)
+{
+  return __builtin_vec_extract (*vp, i);
+}
+
+int main (int argc, char *argv[]) {
+  vector unsigned long long int dv = { CONST0, CONST1 };
+  unsigned long long int d;
+
+  d = e0 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = e3 (dv);
+  if (d != CONST1)
+    abort ();
+
+  d = me0 (&dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me3 (&dv);
+  if (d != CONST1)
+    abort ();
+
+  d = ei (dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 1);
+  if (d != CONST1)
+    abort ();
+
+  d = ei (dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 3);
+  if (d != CONST1)
+    abort ();
+
+  d = mei (&dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 1);
+  if (d != CONST1)
+    abort ();
+
+  d = mei (&dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 3);
+  if (d != CONST1)
+    abort ();
+
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/vsx-builtin-19b.c b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-19b.c
new file mode 100644
index 00000000000..c39923e319b
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-19b.c
@@ -0,0 +1,109 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx -O3" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(31415926539LL)
+#define CONST1		(2 * 31415926539LL)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+unsigned long long int e0 (vector unsigned long long int v)
+{
+  return __builtin_vec_extract (v, 0);
+}
+
+unsigned long long int e3 (vector unsigned long long int v)
+{
+  return __builtin_vec_extract (v, 3);
+}
+
+/* Test for vector residing in memory.  */
+unsigned long long int me0 (vector unsigned long long int *vp)
+{
+  return __builtin_vec_extract (*vp, 0);
+}
+
+unsigned long long int me3 (vector unsigned long long int *vp)
+{
+  return __builtin_vec_extract (*vp, 3);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+unsigned long long int ei (vector unsigned long long int v, int i)
+{
+  return __builtin_vec_extract (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+unsigned long long int mei (vector unsigned long long int *vp, int i)
+{
+  return __builtin_vec_extract (*vp, i);
+}
+
+int main (int argc, char *argv[]) {
+  vector unsigned long long int dv = { CONST0, CONST1 };
+  unsigned long long int d;
+
+  d = e0 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = e3 (dv);
+  if (d != CONST1)
+    abort ();
+
+  d = me0 (&dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me3 (&dv);
+  if (d != CONST1)
+    abort ();
+
+  d = ei (dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 1);
+  if (d != CONST1)
+    abort ();
+
+  d = ei (dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 3);
+  if (d != CONST1)
+    abort ();
+
+  d = mei (&dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 1);
+  if (d != CONST1)
+    abort ();
+
+  d = mei (&dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 3);
+  if (d != CONST1)
+    abort ();
+
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/vsx-builtin-20a.c b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-20a.c
new file mode 100644
index 00000000000..12350c3ed7a
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-20a.c
@@ -0,0 +1,115 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+/* Define this after PR89424 is addressed.  */
+#define PR89424
+
+extern void abort (void);
+
+#define CONST0		(((unsigned __int128) 31415926539) << 60)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+unsigned __int128 e0 (vector unsigned __int128 v)
+{
+  return __builtin_vec_extract (v, 0);
+}
+
+unsigned __int128 e3 (vector unsigned __int128 v)
+{
+  return __builtin_vec_extract (v, 3);
+}
+
+/* Test for vector residing in memory.  */
+unsigned __int128 me0 (vector unsigned __int128 *vp)
+{
+  return __builtin_vec_extract (*vp, 0);
+}
+
+unsigned __int128 me3 (vector unsigned __int128 *vp)
+{
+  return __builtin_vec_extract (*vp, 3);
+}
+
+/* Test the same with variable indices.  */
+
+#ifdef PR89424
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+unsigned __int128 ei (vector unsigned __int128 v, int i)
+{
+  return __builtin_vec_extract (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+unsigned __int128 mei (vector unsigned __int128 *vp, int i)
+{
+  return __builtin_vec_extract (*vp, i);
+}
+#endif
+
+int main (int argc, char *argv[]) {
+  vector unsigned __int128 dv = { CONST0 };
+  unsigned __int128 d;
+
+  d = e0 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = e3 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me0 (&dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me3 (&dv);
+  if (d != CONST0)
+    abort ();
+
+#ifdef PR89424
+  d = ei (dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 1);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 3);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 1);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 3);
+  if (d != CONST0)
+    abort ();
+#endif
+
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/vsx-builtin-20b.c b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-20b.c
new file mode 100644
index 00000000000..37fb7133ba0
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-20b.c
@@ -0,0 +1,115 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx -O3" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+/* Define this after PR89424 is addressed.  */
+#define PR89424
+
+extern void abort (void);
+
+#define CONST0		(((unsigned __int128) 31415926539) << 60)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+unsigned __int128 e0 (vector unsigned __int128 v)
+{
+  return __builtin_vec_extract (v, 0);
+}
+
+unsigned __int128 e3 (vector unsigned __int128 v)
+{
+  return __builtin_vec_extract (v, 3);
+}
+
+/* Test for vector residing in memory.  */
+unsigned __int128 me0 (vector unsigned __int128 *vp)
+{
+  return __builtin_vec_extract (*vp, 0);
+}
+
+unsigned __int128 me3 (vector unsigned __int128 *vp)
+{
+  return __builtin_vec_extract (*vp, 3);
+}
+
+/* Test the same with variable indices.  */
+
+#ifdef PR89424
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+unsigned __int128 ei (vector unsigned __int128 v, int i)
+{
+  return __builtin_vec_extract (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+unsigned __int128 mei (vector unsigned __int128 *vp, int i)
+{
+  return __builtin_vec_extract (*vp, i);
+}
+#endif
+
+int main (int argc, char *argv[]) {
+  vector unsigned __int128 dv = { CONST0 };
+  unsigned __int128 d;
+
+  d = e0 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = e3 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me0 (&dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me3 (&dv);
+  if (d != CONST0)
+    abort ();
+
+#ifdef PR89424
+  d = ei (dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 1);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 3);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 1);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 3);
+  if (d != CONST0)
+    abort ();
+#endif
+
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/vsx-builtin-9a.c b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-9a.c
new file mode 100644
index 00000000000..7b3543443b7
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-9a.c
@@ -0,0 +1,164 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec" } */
+
+/* This test should run the same on any target that supports altivec/dfp
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+#define CONST4		(4)
+#define CONST5		(5)
+#define CONST6		(6)
+#define CONST7		(7)
+#define CONST8		(8)
+#define CONST9		(9)
+#define CONSTA		(10)
+#define CONSTB		(11)
+#define CONSTC		(12)
+#define CONSTD		(13)
+#define CONSTE		(14)
+#define CONSTF		(15)
+
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+signed char c0 (vector signed char v)
+{
+  return __builtin_vec_ext_v16qi (v, 0);
+}
+
+signed char c9 (vector signed char v)
+{
+  return __builtin_vec_ext_v16qi (v, 9);
+}
+
+signed char c21 (vector signed char v)
+{
+  return __builtin_vec_ext_v16qi (v, 21);
+}
+
+signed char c30 (vector signed char v)
+{
+  return __builtin_vec_ext_v16qi (v, 30);
+}
+
+/* Test for vector residing in memory.  */
+signed char mc0 (vector signed char *vp)
+{
+  return __builtin_vec_ext_v16qi (*vp, 0);
+}
+
+signed char mc9 (vector signed char *vp)
+{
+  return __builtin_vec_ext_v16qi (*vp, 9);
+}
+
+signed char mc21 (vector signed char *vp)
+{
+  return __builtin_vec_ext_v16qi (*vp, 21);
+}
+
+signed char mc30 (vector signed char *vp)
+{
+  return __builtin_vec_ext_v16qi (*vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+signed char ci (vector signed char v, int i)
+{
+  return __builtin_vec_ext_v16qi (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+signed char mci(vector signed char *vp, int i) {
+  return __builtin_vec_ext_v16qi (*vp, i);
+}
+
+
+int main (int argc, char *argv[]) {
+  vector signed char cv = { CONST0, CONST1, CONST2, CONST3,
+			    CONST4, CONST5, CONST6, CONST7,
+			    CONST8, CONST9, CONSTA, CONSTB,
+			    CONSTC, CONSTD, CONSTE, CONSTF };
+  signed char c;
+
+  c = c0 (cv);
+  if (c != CONST0)
+    abort ();
+
+  c = c9 (cv);
+  if (c != CONST9)
+    abort ();
+
+  c = c21 (cv);
+  if (c != CONST5)
+    abort ();
+
+  c = c30 (cv);
+  if (c != CONSTE)
+    abort ();
+
+  c = mc0 (&cv);
+  if (c != CONST0)
+    abort ();
+
+  c = mc9 (&cv);
+  if (c != CONST9)
+    abort ();
+
+  c = mc21 (&cv);
+  if (c != CONST5)
+    abort ();
+
+  c = mc30 (&cv);
+  if (c != CONSTE)
+    abort ();
+
+  c = ci (cv, 8);
+  if (c != CONST8)
+    abort ();
+
+  c = ci (cv, 13);
+  if (c != CONSTD)
+    abort ();
+
+  c = ci (cv, 23);
+  if (c != CONST7)
+    abort ();
+
+  c = ci (cv, 31);
+  if (c != CONSTF)
+    abort ();
+
+  c = mci (&cv, 5);
+  if (c != CONST5)
+    abort ();
+
+  c = mci (&cv, 12);
+  if (c != CONSTC)
+    abort ();
+
+  c = mci (&cv, 25);
+  if (c != CONST9)
+    abort ();
+
+  c = mci (&cv, 16);
+  if (c != CONST0)
+    abort ();
+
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/vsx-builtin-9b.c b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-9b.c
new file mode 100644
index 00000000000..ff081b354b2
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-9b.c
@@ -0,0 +1,164 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec -O3" } */
+
+/* This test should run the same on any target that supports altivec/dfp
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+#define CONST4		(4)
+#define CONST5		(5)
+#define CONST6		(6)
+#define CONST7		(7)
+#define CONST8		(8)
+#define CONST9		(9)
+#define CONSTA		(10)
+#define CONSTB		(11)
+#define CONSTC		(12)
+#define CONSTD		(13)
+#define CONSTE		(14)
+#define CONSTF		(15)
+
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+signed char c0 (vector signed char v)
+{
+  return __builtin_vec_ext_v16qi (v, 0);
+}
+
+signed char c9 (vector signed char v)
+{
+  return __builtin_vec_ext_v16qi (v, 9);
+}
+
+signed char c21 (vector signed char v)
+{
+  return __builtin_vec_ext_v16qi (v, 21);
+}
+
+signed char c30 (vector signed char v)
+{
+  return __builtin_vec_ext_v16qi (v, 30);
+}
+
+/* Test for vector residing in memory.  */
+signed char mc0 (vector signed char *vp)
+{
+  return __builtin_vec_ext_v16qi (*vp, 0);
+}
+
+signed char mc9 (vector signed char *vp)
+{
+  return __builtin_vec_ext_v16qi (*vp, 9);
+}
+
+signed char mc21 (vector signed char *vp)
+{
+  return __builtin_vec_ext_v16qi (*vp, 21);
+}
+
+signed char mc30 (vector signed char *vp)
+{
+  return __builtin_vec_ext_v16qi (*vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+signed char ci (vector signed char v, int i)
+{
+  return __builtin_vec_ext_v16qi (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+signed char mci(vector signed char *vp, int i) {
+  return __builtin_vec_ext_v16qi (*vp, i);
+}
+
+
+int main (int argc, char *argv[]) {
+  vector signed char cv = { CONST0, CONST1, CONST2, CONST3,
+			    CONST4, CONST5, CONST6, CONST7,
+			    CONST8, CONST9, CONSTA, CONSTB,
+			    CONSTC, CONSTD, CONSTE, CONSTF };
+  signed char c;
+
+  c = c0 (cv);
+  if (c != CONST0)
+    abort ();
+
+  c = c9 (cv);
+  if (c != CONST9)
+    abort ();
+
+  c = c21 (cv);
+  if (c != CONST5)
+    abort ();
+
+  c = c30 (cv);
+  if (c != CONSTE)
+    abort ();
+
+  c = mc0 (&cv);
+  if (c != CONST0)
+    abort ();
+
+  c = mc9 (&cv);
+  if (c != CONST9)
+    abort ();
+
+  c = mc21 (&cv);
+  if (c != CONST5)
+    abort ();
+
+  c = mc30 (&cv);
+  if (c != CONSTE)
+    abort ();
+
+  c = ci (cv, 8);
+  if (c != CONST8)
+    abort ();
+
+  c = ci (cv, 13);
+  if (c != CONSTD)
+    abort ();
+
+  c = ci (cv, 23);
+  if (c != CONST7)
+    abort ();
+
+  c = ci (cv, 31);
+  if (c != CONSTF)
+    abort ();
+
+  c = mci (&cv, 5);
+  if (c != CONST5)
+    abort ();
+
+  c = mci (&cv, 12);
+  if (c != CONSTC)
+    abort ();
+
+  c = mci (&cv, 25);
+  if (c != CONST9)
+    abort ();
+
+  c = mci (&cv, 16);
+  if (c != CONST0)
+    abort ();
+
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/vsx-vector-6.c b/gcc/testsuite/gcc.target/powerpc/vsx-vector-6.c
deleted file mode 100644
index f8e644bb532..00000000000
--- a/gcc/testsuite/gcc.target/powerpc/vsx-vector-6.c
+++ /dev/null
@@ -1,81 +0,0 @@
-/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */
-/* { dg-skip-if "" { powerpc*-*-darwin* } { "*" } { "" } } */
-/* { dg-require-effective-target powerpc_vsx_ok } */
-/* { dg-options "-mvsx -O2" } */
-
-#include <altivec.h>
-
-void foo (vector double *out, vector double *in, vector long *p_l, vector bool long *p_b, vector unsigned char *p_uc, int *i)
-{
-  vector double in0 = in[0];
-  vector double in1 = in[1];
-  vector double in2 = in[2];
-  vector long inl = *p_l;
-  vector bool long inb = *p_b;
-  vector unsigned char uc = *p_uc;
-
-  *out++ = vec_abs (in0);
-  *out++ = vec_add (in0, in1);
-  *out++ = vec_and (in0, in1);
-  *out++ = vec_and (in0, inb);
-  *out++ = vec_and (inb, in0);
-  *out++ = vec_andc (in0, in1);
-  *out++ = vec_andc (in0, inb);
-  *out++ = vec_andc (inb, in0);
-  *out++ = vec_ceil (in0);
-  *p_b++ = vec_cmpeq (in0, in1);
-  *p_b++ = vec_cmpgt (in0, in1);
-  *p_b++ = vec_cmpge (in0, in1);
-  *p_b++ = vec_cmplt (in0, in1);
-  *p_b++ = vec_cmple (in0, in1);
-  *out++ = vec_div (in0, in1);
-  *out++ = vec_floor (in0);
-  *out++ = vec_madd (in0, in1, in2);
-  *out++ = vec_msub (in0, in1, in2);
-  *out++ = vec_max (in0, in1);
-  *out++ = vec_min (in0, in1);
-  *out++ = vec_msub (in0, in1, in2);
-  *out++ = vec_mul (in0, in1);
-  *out++ = vec_nearbyint (in0);
-  *out++ = vec_nmadd (in0, in1, in2);
-  *out++ = vec_nmsub (in0, in1, in2);
-  *out++ = vec_nor (in0, in1);
-  *out++ = vec_or (in0, in1);
-  *out++ = vec_or (in0, inb);
-  *out++ = vec_or (inb, in0);
-  *out++ = vec_perm (in0, in1, uc);
-  *out++ = vec_rint (in0);
-  *out++ = vec_sel (in0, in1, inl);
-  *out++ = vec_sel (in0, in1, inb);
-  *out++ = vec_sub (in0, in1);
-  *out++ = vec_sqrt (in0);
-  *out++ = vec_trunc (in0);
-  *out++ = vec_xor (in0, in1);
-  *out++ = vec_xor (in0, inb);
-  *out++ = vec_xor (inb, in0);
-
-  *i++ = vec_all_eq (in0, in1);
-  *i++ = vec_all_ge (in0, in1);
-  *i++ = vec_all_gt (in0, in1);
-  *i++ = vec_all_le (in0, in1);
-  *i++ = vec_all_lt (in0, in1);
-  *i++ = vec_all_nan (in0);
-  *i++ = vec_all_ne (in0, in1);
-  *i++ = vec_all_nge (in0, in1);
-  *i++ = vec_all_ngt (in0, in1);
-  *i++ = vec_all_nle (in0, in1);
-  *i++ = vec_all_nlt (in0, in1);
-  *i++ = vec_all_numeric (in0);
-  *i++ = vec_any_eq (in0, in1);
-  *i++ = vec_any_ge (in0, in1);
-  *i++ = vec_any_gt (in0, in1);
-  *i++ = vec_any_le (in0, in1);
-  *i++ = vec_any_lt (in0, in1);
-  *i++ = vec_any_nan (in0);
-  *i++ = vec_any_ne (in0, in1);
-  *i++ = vec_any_nge (in0, in1);
-  *i++ = vec_any_ngt (in0, in1);
-  *i++ = vec_any_nle (in0, in1);
-  *i++ = vec_any_nlt (in0, in1);
-  *i++ = vec_any_numeric (in0);
-}
diff --git a/gcc/testsuite/gcc.target/powerpc/vsx-vector-6.h b/gcc/testsuite/gcc.target/powerpc/vsx-vector-6.h
new file mode 100644
index 00000000000..a891b64e6fa
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/vsx-vector-6.h
@@ -0,0 +1,167 @@
+/* This test code is included into vsx-vector-6-be.c and vsx-vector-6-le.c.  
+   The two files have the tests for the number of instructions generated for
+   LE versus BE.  */
+
+#include <altivec.h>
+
+void foo (vector double *out, vector double *in, vector long *p_l, vector bool long *p_b,
+	  vector unsigned char *p_uc, int *i, vector float *p_f,
+	  vector bool char *outbc, vector bool int *outbi,
+	  vector bool short *outbsi, vector int *outsi,
+	  vector unsigned int *outui, vector signed char *outsc,
+	  vector unsigned char *outuc)
+{
+  vector double in0 = in[0];
+  vector double in1 = in[1];
+  vector double in2 = in[2];
+  vector long inl = *p_l;
+  vector bool long inb = *p_b;
+  vector bool long long inbl0;
+  vector bool long long inbl1;
+  vector unsigned char uc = *p_uc;
+  vector float inf0;
+  vector float inf1;
+  vector float inf2;
+  vector char inc0;
+  vector char inc1;
+  vector bool char inbc0;
+  vector bool char inbc1;
+  vector bool short inbs0;
+  vector bool short inbs1;
+  vector bool int inbi0;
+  vector bool int inbi1;
+  vector signed short int inssi0, inssi1;
+  vector unsigned short int inusi0, inusi1;
+  vector signed int insi0, insi1;
+  vector unsigned int inui0, inui1;
+  vector unsigned char inuc0, inuc1;
+  
+  *out++ = vec_abs (in0);
+  *out++ = vec_add (in0, in1);
+  *out++ = vec_and (in0, in1);
+  *out++ = vec_and (in0, inb);
+  *out++ = vec_and (inb, in0);
+  *out++ = vec_andc (in0, in1);
+  *out++ = vec_andc (in0, inb);
+  *out++ = vec_andc (inb, in0);
+  *out++ = vec_andc (inbl0, in0);
+  *out++ = vec_andc (in0, inbl0);
+
+  *out++ = vec_ceil (in0);
+  *p_b++ = vec_cmpeq (in0, in1);
+  *p_b++ = vec_cmpgt (in0, in1);
+  *p_b++ = vec_cmpge (in0, in1);
+  *p_b++ = vec_cmplt (in0, in1);
+  *p_b++ = vec_cmple (in0, in1);
+  *out++ = vec_div (in0, in1);
+  *out++ = vec_floor (in0);
+  *out++ = vec_madd (in0, in1, in2);
+  *out++ = vec_msub (in0, in1, in2);
+  *out++ = vec_max (in0, in1);
+  *out++ = vec_min (in0, in1);
+  *out++ = vec_msub (in0, in1, in2);
+  *out++ = vec_mul (in0, in1);
+  *out++ = vec_nearbyint (in0);
+  *out++ = vec_nmadd (in0, in1, in2);
+  *out++ = vec_nmsub (in0, in1, in2);
+  *out++ = vec_nor (in0, in1);
+  *out++ = vec_or (in0, in1);
+  *out++ = vec_or (in0, inb);
+  *out++ = vec_or (inb, in0);
+  *out++ = vec_perm (in0, in1, uc);
+  *out++ = vec_rint (in0);
+  *out++ = vec_sel (in0, in1, inl);
+  *out++ = vec_sel (in0, in1, inb);
+  *out++ = vec_sub (in0, in1);
+  *out++ = vec_sqrt (in0);
+  *out++ = vec_trunc (in0);
+  *out++ = vec_xor (in0, in1);
+  *out++ = vec_xor (in0, inb);
+  *out++ = vec_xor (inb, in0);
+
+  *i++ = vec_all_eq (in0, in1);
+  *i++ = vec_all_ge (in0, in1);
+  *i++ = vec_all_gt (in0, in1);
+  *i++ = vec_all_le (in0, in1);
+  *i++ = vec_all_lt (in0, in1);
+  *i++ = vec_all_nan (in0);
+  *i++ = vec_all_ne (in0, in1);
+  *i++ = vec_all_nge (in0, in1);
+  *i++ = vec_all_ngt (in0, in1);
+  *i++ = vec_all_nle (in0, in1);
+  *i++ = vec_all_nlt (in0, in1);
+  *i++ = vec_all_numeric (in0);
+  *i++ = vec_any_eq (in0, in1);
+  *i++ = vec_any_ge (in0, in1);
+  *i++ = vec_any_gt (in0, in1);
+  *i++ = vec_any_le (in0, in1);
+  *i++ = vec_any_lt (in0, in1);
+  *i++ = vec_any_nan (in0);
+  *i++ = vec_any_ne (in0, in1);
+  *i++ = vec_any_nge (in0, in1);
+  *i++ = vec_any_ngt (in0, in1);
+  *i++ = vec_any_nle (in0, in1);
+  *i++ = vec_any_nlt (in0, in1);
+  *i++ = vec_any_numeric (in0);
+
+  *p_f++ = vec_msub (inf0, inf1, inf2);
+  *p_f++ = vec_nmsub (inf0, inf1, inf2);
+  *p_f++ = vec_nmadd (inf0, inf1, inf2);
+  *p_f++ = vec_or (inf0, inf1);
+  *p_f++ = vec_trunc (inf0);
+  
+  *out++ = vec_or (inbl0, in0);
+  *out++ = vec_or (in0, inbl0);
+
+  *out++ = vec_nor (in0, in1);
+
+  *outbc++ = vec_nor (inbc0, inbc1);
+  *outbc++ = vec_andc (inbc0, inbc1);
+  *outbc++ = vec_or (inbc0, inbc1);
+
+  *outuc++ = vec_max (inuc0, inuc1);
+
+  *outbi++ = vec_andc (inbi0, inbi1);
+  *outbsi++ = vec_andc (inbs0, inbs1);
+
+  *outbsi++ = vec_andc (inbs0, inbs1);
+
+  *outbi++ = vec_nor (inbi0, inbi1);
+  *outbi++ = vec_or (inbi0, inbi1);
+
+  *outbsi++ = vec_nor (inbs0, inbs1);
+  *outbsi++ = vec_or (inbs0, inbs1);
+
+  *outsi++ = vec_msums(inssi0, inssi1, insi0);
+  *outui++ = vec_msums(inusi0, inusi1, inui0);
+
+  *p_f++ = vec_nor (inf0, inf1);
+
+  *p_f++ = vec_andc (inf0, inf1);
+  *p_f++ = vec_andc (inbi0, inf0);
+  *p_f++ = vec_andc (inf0, inbi0);
+
+  *in++ = vec_andc (inbl0, in1);
+  *in++ = vec_andc (in0, inbl1);
+}
+
+int main()
+{
+  vector double *out;
+  vector double *in;
+  vector long *p_l;
+  vector bool long *p_b;
+  vector unsigned char *p_uc;
+  int *i;
+  vector float *p_f;
+  vector bool char *outbc;
+  vector bool int *outbi;
+  vector bool short *outbsi;
+  vector int *outsi;
+  vector unsigned int *outui;
+  vector signed char *outsc;
+  vector unsigned char *outuc;
+
+  foo (out, in, p_l, p_b, p_uc, i, p_f, outbc,
+       outbi, outbsi, outsi, outui, outsc, outuc);
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/vsx-vector-6.p7.c b/gcc/testsuite/gcc.target/powerpc/vsx-vector-6.p7.c
new file mode 100644
index 00000000000..68f40db7bef
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/vsx-vector-6.p7.c
@@ -0,0 +1,42 @@
+/* { dg-do compile { target { lp64 && be } } } */
+/* { dg-skip-if "" { powerpc*-*-darwin* } } */
+/* { dg-require-effective-target powerpc_vsx_ok } */
+/* { dg-options "-mvsx -O2 -mcpu=power7 -dp" } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power7" } } */
+
+/* Expected instruction counts for Power 7 */
+
+/* { dg-final { scan-assembler-times "xvabsdp" 1 } } */
+/* { dg-final { scan-assembler-times "xvadddp" 1 } } */
+/* { dg-final { scan-assembler-times "xxlnor" 5 } } */
+/* { dg-final { scan-assembler-times {\mxvcmpeqdp\s} 1 } } */
+/* { dg-final { scan-assembler-times {\mxvcmpeqdp\.\s} 5 } } */
+/* { dg-final { scan-assembler-times {\mxvcmpgtdp\s} 2 } } */
+/* { dg-final { scan-assembler-times {\mxvcmpgtdp\.\s} 5 } } */
+/* { dg-final { scan-assembler-times {\mxvcmpgedp\s} 1 } } */
+/* { dg-final { scan-assembler-times {\mxvcmpgedp\.\s} 6 } } */
+/* { dg-final { scan-assembler-times "xvrdpim" 1 } } */
+/* { dg-final { scan-assembler-times "xvmaddadp" 1 } } */
+/* { dg-final { scan-assembler-times "xvmsubadp" 1 } } */
+/* { dg-final { scan-assembler-times "xvsubdp" 1 } } */
+/* { dg-final { scan-assembler-times "xvmaxdp" 1 } } */
+/* { dg-final { scan-assembler-times "xvmindp" 1 } } */
+/* { dg-final { scan-assembler-times "xvmuldp" 1 } } */
+/* { dg-final { scan-assembler-times "vperm" 2 } } */
+/* { dg-final { scan-assembler-times "xvrdpic" 2 } } */
+/* { dg-final { scan-assembler-times "xvsqrtdp" 1 } } */
+/* { dg-final { scan-assembler-times "xvrdpiz" 1 } } */
+/* { dg-final { scan-assembler-times "xvmsubasp" 1 } } */
+/* { dg-final { scan-assembler-times "xvnmaddasp" 1 } } */
+/* { dg-final { scan-assembler-times "xvnmaddadp" 1 } } */
+/* { dg-final { scan-assembler-times "xvnmsubadp" 1 } } */
+/* { dg-final { scan-assembler-times "vmsumshs" 2 } } */
+/* { dg-final { scan-assembler-times "xxland" 13 } } */
+/* { dg-final { scan-assembler-times "xxlxor" 2 } } */
+/* { dg-final { scan-assembler-times "xxsel" 4 } } */
+/* { dg-final { scan-assembler-times "xvrdpip" 1 } } */
+/* { dg-final { scan-assembler-times "xvdivdp" 1 } } */
+/* { dg-final { scan-assembler-times "xvrdpi" 7 } } */
+
+/* Source code for the test in vsx-vector-6.h */
+#include "vsx-vector-6.h"
diff --git a/gcc/testsuite/gcc.target/powerpc/vsx-vector-6.p8.c b/gcc/testsuite/gcc.target/powerpc/vsx-vector-6.p8.c
new file mode 100644
index 00000000000..5a7ebe0e1c5
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/vsx-vector-6.p8.c
@@ -0,0 +1,54 @@
+/* { dg-do compile { target lp64 } } */
+/* { dg-skip-if "" { powerpc*-*-darwin* } } */
+/* { dg-require-effective-target powerpc_vsx_ok } */
+/* { dg-options "-mvsx -O2 -mcpu=power8" } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
+
+/* Expected instruction counts for Power 8.  */
+
+/* { dg-final { scan-assembler-times "xvabsdp" 1 } } */
+/* { dg-final { scan-assembler-times "xvadddp" 1 } } */
+/* { dg-final { scan-assembler-times "xxlnor" 6 { target le } } } */
+/* { dg-final { scan-assembler-times "xxlnor" 5 { target be } } } */
+
+/* We generate xxlor instructions for many reasons other than or'ing vector
+   operands or calling __builtin_vec_or(), which  means we cannot rely on
+   their usage counts being stable.  Therefore, we just ensure at least one
+   xxlor instruction was generated.  */
+/* { dg-final { scan-assembler "xxlor" } } */
+
+/* { dg-final { scan-assembler-times {\mxvcmpeqdp\s} 0 { target le } } } */
+/* { dg-final { scan-assembler-times {\mxvcmpeqdp\s} 1 { target be } } } */
+/* { dg-final { scan-assembler-times {\mxvcmpeqdp\.\s} 6 { target le } } } */
+/* { dg-final { scan-assembler-times {\mxvcmpeqdp\.\s} 5 { target be } } } */
+/* { dg-final { scan-assembler-times {\mxvcmpgtdp\s} 2 } } */
+/* { dg-final { scan-assembler-times {\mxvcmpgtdp\.\s} 5 { target le } } } */
+/* { dg-final { scan-assembler-times {\mxvcmpgtdp\.\s} 6 { target be } } } */
+/* { dg-final { scan-assembler-times {\mxvcmpgedp\s} 2 } } */
+/* { dg-final { scan-assembler-times {\mxvcmpgedp\.\s} 4 } } */
+/* { dg-final { scan-assembler-times "xvrdpim" 1 } } */
+/* { dg-final { scan-assembler-times "xvmaddadp" 1 } } */
+/* { dg-final { scan-assembler-times "xvmsubadp" 1 } } */
+/* { dg-final { scan-assembler-times "xvsubdp" 1 } } */
+/* { dg-final { scan-assembler-times "xvmaxdp" 1 } } */
+/* { dg-final { scan-assembler-times "xvmindp" 1 } } */
+/* { dg-final { scan-assembler-times "xvmuldp" 1 } } */
+/* { dg-final { scan-assembler-times "vperm" 1 } } */
+/* { dg-final { scan-assembler-times "xvrdpic" 1 } } */
+/* { dg-final { scan-assembler-times "xvsqrtdp" 1 } } */
+/* { dg-final { scan-assembler-times "xvrdpiz" 1 } } */
+/* { dg-final { scan-assembler-times "xvmsubasp" 1 } } */
+/* { dg-final { scan-assembler-times "xvnmaddasp" 1 } } */
+/* { dg-final { scan-assembler-times "xvnmaddadp" 1 } } */
+/* { dg-final { scan-assembler-times "xvnmsubadp" 1 } } */
+/* { dg-final { scan-assembler-times "vmsumshs" 1 } } */
+/* { dg-final { scan-assembler-times "xxland" 9 { target le } } } */
+/* { dg-final { scan-assembler-times "xxland" 13 { target be } } } */
+/* { dg-final { scan-assembler-times "xxlxor" 2 } } */
+/* { dg-final { scan-assembler-times "xxsel" 2 } } */
+/* { dg-final { scan-assembler-times "xvrdpip" 1 } } */
+/* { dg-final { scan-assembler-times "xvdivdp" 1 } } */
+/* { dg-final { scan-assembler-times "xvrdpi" 5 } } */
+
+/* Source code for the test in vsx-vector-6.h */
+#include "vsx-vector-6.h"
diff --git a/gcc/testsuite/gcc.target/powerpc/vsx-vector-6.p9.c b/gcc/testsuite/gcc.target/powerpc/vsx-vector-6.p9.c
new file mode 100644
index 00000000000..48ac4a37143
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/vsx-vector-6.p9.c
@@ -0,0 +1,39 @@
+/* { dg-do compile { target lp64 } } */
+/* { dg-skip-if "" { powerpc*-*-darwin* } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-options "-mvsx -O2 -mcpu=power9" } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+
+/* Expected instruction counts for Power9. */
+
+/* { dg-final { scan-assembler-times "xvabsdp" 1 } } */
+/* { dg-final { scan-assembler-times "xvadddp" 1 } } */
+/* { dg-final { scan-assembler-times "xxlnor" 5 } } */
+
+/* We generate xxlor instructions for many reasons other than or'ing vector
+   operands or calling __builtin_vec_or(), which  means we cannot rely on
+   their usage counts being stable.  Therefore, we just ensure at least one
+   xxlor instruction was generated.  */
+/* { dg-final { scan-assembler "xxlor" } } */
+
+/* { dg-final { scan-assembler-times "xvcmpeqdp" 7 } } */
+/* { dg-final { scan-assembler-times "xvcmpgtdp" 8 } } */
+/* { dg-final { scan-assembler-times "xvcmpgedp" 7 } } */
+/* { dg-final { scan-assembler-times "xvrdpim" 1 } } */
+/* { dg-final { scan-assembler-times "xvmaddadp" 1 } } */
+/* { dg-final { scan-assembler-times "xvmsubadp" 1 } } */
+/* { dg-final { scan-assembler-times "xvsubdp" 1 } } */
+/* { dg-final { scan-assembler-times "xvmaxdp" 1 } } */
+/* { dg-final { scan-assembler-times "xvmindp" 1 } } */
+/* { dg-final { scan-assembler-times "xvmuldp" 1 } } */
+/* { dg-final { scan-assembler-times "vperm" 1 } } */
+/* { dg-final { scan-assembler-times "xvrdpic" 1 } } */
+/* { dg-final { scan-assembler-times "xvsqrtdp" 1 } } */
+/* { dg-final { scan-assembler-times "xvrdpiz" 1 } } */
+/* { dg-final { scan-assembler-times "xvmsubasp" 1 } } */
+/* { dg-final { scan-assembler-times "xvnmaddasp" 1 } } */
+/* { dg-final { scan-assembler-times "vmsumshs" 1 } } */
+/* { dg-final { scan-assembler-times "xxland" 13 } } */
+
+/* Source code for the test in vsx-vector-6.h */
+#include "vsx-vector-6.h"
diff --git a/gcc/testsuite/gcc.target/powerpc/vsxcopy.c b/gcc/testsuite/gcc.target/powerpc/vsxcopy.c
index fbe3c67e7e5..2060046eaf2 100644
--- a/gcc/testsuite/gcc.target/powerpc/vsxcopy.c
+++ b/gcc/testsuite/gcc.target/powerpc/vsxcopy.c
@@ -1,8 +1,8 @@
 /* { dg-do compile { target { powerpc64*-*-* } } } */
 /* { dg-require-effective-target powerpc_vsx_ok } */
 /* { dg-options "-O1 -mvsx" } */
-/* { dg-final { scan-assembler "lxvd2x" } } */
-/* { dg-final { scan-assembler "stxvd2x" } } */
+/* { dg-final { scan-assembler {\mlxvd2x\M|\mlxv\M} } } */
+/* { dg-final { scan-assembler {\mstxvd2x\M|\mstxv\M} } } */
 /* { dg-final { scan-assembler-not "xxpermdi" } } */
 
 typedef float vecf __attribute__ ((vector_size (16)));
diff --git a/gcc/testsuite/gcc.target/s390/dfp_to_bfp_rounding.c b/gcc/testsuite/gcc.target/s390/dfp_to_bfp_rounding.c
new file mode 100644
index 00000000000..9a32abfdea6
--- /dev/null
+++ b/gcc/testsuite/gcc.target/s390/dfp_to_bfp_rounding.c
@@ -0,0 +1,29 @@
+/* { dg-do run } */
+/* { dg-options "-O3 -mzarch -march=z10" } */
+
+/* According to IEEE 754 2008 4.3 Conversion operations between
+   different radixes must use the rounding mode of the target radix.
+   On S/390 this means passing the right value in GPR0 to PFPO
+   instruction.  */
+
+#include <fenv.h>
+
+double __attribute__((noclone,noinline))
+convert (_Decimal64 in)
+{
+  return (double)in;
+}
+
+int
+main ()
+{
+  fesetround (FE_UPWARD);
+
+  if (convert (1e-325DD) != __DBL_DENORM_MIN__)
+    __builtin_abort ();
+
+  fesetround (FE_DOWNWARD);
+
+  if (convert (-1e-325DD) != -__DBL_DENORM_MIN__)
+    __builtin_abort ();
+}
diff --git a/gcc/testsuite/gcc.target/s390/flogr-1.c b/gcc/testsuite/gcc.target/s390/flogr-1.c
new file mode 100644
index 00000000000..a3869000d62
--- /dev/null
+++ b/gcc/testsuite/gcc.target/s390/flogr-1.c
@@ -0,0 +1,47 @@
+/* { dg-do run } */
+/* { dg-options "-O2 -funroll-loops -march=z9-109" } */
+/* { dg-require-effective-target stdint_types } */
+
+/* Folding of the FLOGR caused a wrong value to be returned by
+   __builtin_clz becuase of a problem in the RTX we emit for FLOGR.
+   The problematic folding can only be triggered with constants inputs
+   introduced on RTL level.  In this case it happens with loop
+   unrolling.  */
+
+#include <stdint.h>
+#include <assert.h>
+
+static inline uint32_t pow2_ceil_u32(uint32_t x) {
+  if (x <= 1) {
+    return x;
+  }
+  int msb_on_index;
+  msb_on_index = (31 ^ __builtin_clz(x - 1));
+  assert(msb_on_index < 31);
+  return 1U << (msb_on_index + 1);
+}
+
+void __attribute__((noinline,noclone))
+die (int a)
+{
+  if (a)
+    __builtin_abort ();
+}
+
+void test_pow2_ceil_u32(void) {
+  unsigned i;
+
+  for (i = 0; i < 18; i++) {
+      uint32_t a_ = (pow2_ceil_u32(((uint32_t)1) << i));
+      if (!(a_ == (((uint32_t)1) << i))) {
+	die(1);
+      }
+  }
+}
+
+int
+main(void) {
+  test_pow2_ceil_u32();
+
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/s390/htm-builtins-compile-4.c b/gcc/testsuite/gcc.target/s390/htm-builtins-compile-4.c
new file mode 100644
index 00000000000..c3866bde4a4
--- /dev/null
+++ b/gcc/testsuite/gcc.target/s390/htm-builtins-compile-4.c
@@ -0,0 +1,10 @@
+/* { dg-do compile } */
+/* { dg-options "-O3 -march=zEC12 -mzarch" } */
+
+/* A bug in the builtin definition made__builtin_tbeginc to have an
+   integer return argument.  */
+void
+must_not_compile1 (void)
+{
+  int rc = __builtin_tbeginc (); /* { dg-error "void value not ignored as it ought to be" } */
+}
diff --git a/gcc/testsuite/gcc.target/s390/nobp-function-pointer-attr.c b/gcc/testsuite/gcc.target/s390/nobp-function-pointer-attr.c
new file mode 100644
index 00000000000..db9336d51dd
--- /dev/null
+++ b/gcc/testsuite/gcc.target/s390/nobp-function-pointer-attr.c
@@ -0,0 +1,56 @@
+/* { dg-do run } */
+/* { dg-options "-O3  -march=z10 --save-temps -mindirect-branch-table" } */
+
+int gl;
+
+void __attribute__((noinline,noclone))
+foo (int a)
+{
+  gl = a + 40;
+}
+
+int __attribute__((noinline,noclone))
+foo_value (int a)
+{
+  return a + 40;
+}
+
+void* __attribute__((noinline,noclone))
+get_fptr (int a)
+{
+  switch (a)
+    {
+    case 0: return &foo; break;
+    case 1: return &foo_value; break;
+    default: __builtin_abort ();
+    }
+}
+
+void (*f) (int);
+int (*g) (int);
+
+int __attribute__((indirect_branch_call("thunk")))
+main ()
+{
+  int res;
+
+  f = get_fptr(0);
+  f (2);
+  if (gl != 42)
+    __builtin_abort ();
+
+  g = get_fptr(1);
+  if (g (2) != 42)
+    __builtin_abort ();
+
+  return 0;
+}
+
+/* 2 x main
+/* { dg-final { scan-assembler-times "brasl\t%r\[0-9\]*,__s390_indirect_jump" 2 } } */
+/* { dg-final { scan-assembler "exrl" } } */
+
+/* { dg-final { scan-assembler-not "section\t.s390_indirect_jump" } } */
+/* { dg-final { scan-assembler     "section\t.s390_indirect_call" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_return_reg" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_return_mem" } } */
diff --git a/gcc/testsuite/gcc.target/s390/nobp-function-pointer-nothunk.c b/gcc/testsuite/gcc.target/s390/nobp-function-pointer-nothunk.c
new file mode 100644
index 00000000000..c02b45a2cc7
--- /dev/null
+++ b/gcc/testsuite/gcc.target/s390/nobp-function-pointer-nothunk.c
@@ -0,0 +1,59 @@
+/* { dg-do compile } */
+/* { dg-options "-O3  -march=z10 --save-temps -mindirect-branch-call=thunk-extern -mindirect-branch-table" } */
+
+int gl;
+
+void __attribute__((noinline,noclone))
+foo (int a)
+{
+  gl = a + 40;
+}
+
+int __attribute__((noinline,noclone))
+foo_value (int a)
+{
+  return a + 40;
+}
+
+void*  __attribute__((noinline,noclone))
+get_fptr (int a)
+{
+  switch (a)
+    {
+    case 0: return &foo; break;
+    case 1: return &foo_value; break;
+    default: __builtin_abort ();
+    }
+}
+
+void (*f) (int);
+int (*g) (int);
+
+int
+main ()
+{
+  int res;
+
+  f = get_fptr(0);
+  f (2);
+  if (gl != 42)
+    __builtin_abort ();
+
+  g = get_fptr(1);
+  if (g (2) != 42)
+    __builtin_abort ();
+
+  return 0;
+}
+
+/* 2 x main
+/* { dg-final { scan-assembler-times "brasl\t%r\[0-9\]*,__s390_indirect_jump" 2 } } */
+
+/* No thunks due to thunk-extern.  */
+/* { dg-final { scan-assembler-not "exrl" } } */
+/* { dg-final { scan-assembler-not ".globl __s390_indirect_jump" } } */
+
+/* { dg-final { scan-assembler-not "section\t.s390_indirect_jump" } } */
+/* { dg-final { scan-assembler     "section\t.s390_indirect_call" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_return_reg" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_return_mem" } } */
diff --git a/gcc/testsuite/gcc.target/s390/nobp-function-pointer-z10.c b/gcc/testsuite/gcc.target/s390/nobp-function-pointer-z10.c
new file mode 100644
index 00000000000..b5f13eb0793
--- /dev/null
+++ b/gcc/testsuite/gcc.target/s390/nobp-function-pointer-z10.c
@@ -0,0 +1,56 @@
+/* { dg-do run } */
+/* { dg-options "-O3  -march=z10 --save-temps -mindirect-branch-call=thunk -mindirect-branch-table" } */
+
+int gl;
+
+void __attribute__((noinline,noclone))
+foo (int a)
+{
+  gl = a + 40;
+}
+
+int __attribute__((noinline,noclone))
+foo_value (int a)
+{
+  return a + 40;
+}
+
+void*  __attribute__((noinline,noclone))
+get_fptr (int a)
+{
+  switch (a)
+    {
+    case 0: return &foo; break;
+    case 1: return &foo_value; break;
+    default: __builtin_abort ();
+    }
+}
+
+void (*f) (int);
+int (*g) (int);
+
+int
+main ()
+{
+  int res;
+
+  f = get_fptr(0);
+  f (2);
+  if (gl != 42)
+    __builtin_abort ();
+
+  g = get_fptr(1);
+  if (g (2) != 42)
+    __builtin_abort ();
+
+  return 0;
+}
+
+/* 2 x main
+/* { dg-final { scan-assembler-times "brasl\t%r\[0-9\]*,__s390_indirect_jump" 2 } } */
+/* { dg-final { scan-assembler "exrl" } } */
+
+/* { dg-final { scan-assembler-not "section\t.s390_indirect_jump" } } */
+/* { dg-final { scan-assembler     "section\t.s390_indirect_call" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_return_reg" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_return_mem" } } */
diff --git a/gcc/testsuite/gcc.target/s390/nobp-function-pointer-z900.c b/gcc/testsuite/gcc.target/s390/nobp-function-pointer-z900.c
new file mode 100644
index 00000000000..486495b97ac
--- /dev/null
+++ b/gcc/testsuite/gcc.target/s390/nobp-function-pointer-z900.c
@@ -0,0 +1,56 @@
+/* { dg-do run } */
+/* { dg-options "-O3  -march=z900 --save-temps -mindirect-branch-call=thunk -mindirect-branch-table" } */
+
+int gl;
+
+void __attribute__((noinline,noclone))
+foo (int a)
+{
+  gl = a + 40;
+}
+
+int __attribute__((noinline,noclone))
+foo_value (int a)
+{
+  return a + 40;
+}
+
+void*  __attribute__((noinline,noclone))
+get_fptr (int a)
+{
+  switch (a)
+    {
+    case 0: return &foo; break;
+    case 1: return &foo_value; break;
+    default: __builtin_abort ();
+    }
+}
+
+void (*f) (int);
+int (*g) (int);
+
+int
+main ()
+{
+  int res;
+
+  f = get_fptr(0);
+  f (2);
+  if (gl != 42)
+    __builtin_abort ();
+
+  g = get_fptr(1);
+  if (g (2) != 42)
+    __builtin_abort ();
+
+  return 0;
+}
+
+/* 2 x main
+/* { dg-final { scan-assembler-times "brasl\t%r\[0-9\]*,__s390_indirect_jump" 2 } } */
+/* { dg-final { scan-assembler "ex\t" } } */
+
+/* { dg-final { scan-assembler-not "section\t.s390_indirect_jump" } } */
+/* { dg-final { scan-assembler     "section\t.s390_indirect_call" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_return_reg" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_return_mem" } } */
diff --git a/gcc/testsuite/gcc.target/s390/nobp-indirect-jump-attr.c b/gcc/testsuite/gcc.target/s390/nobp-indirect-jump-attr.c
new file mode 100644
index 00000000000..c62ddf56b8a
--- /dev/null
+++ b/gcc/testsuite/gcc.target/s390/nobp-indirect-jump-attr.c
@@ -0,0 +1,42 @@
+/* { dg-do run } */
+/* { dg-options "-O3 -march=z10 --save-temps -mindirect-branch-table" } */
+/* { dg-require-effective-target label_values } */
+
+/* This is a copy of the gcc.c-torture/execute/20040302-1.c
+   testcase.  */
+
+int code[]={0,0,0,0,1};
+
+void
+foo(int x) {
+  volatile int b;
+  b = 0xffffffff;
+}
+
+void __attribute__((indirect_branch_jump("thunk")))
+bar(int *pc) {
+  static const void *l[] = {&&lab0, &&end};
+
+  foo(0);
+  goto *l[*pc];
+ lab0:
+  foo(0);
+  pc++;
+  goto *l[*pc];
+ end:
+  return;
+}
+
+int main() {
+  bar(code);
+  return 0;
+}
+
+/* 2x bar */
+/* { dg-final { scan-assembler-times "jg\t__s390_indirect_jump" 2 } } */
+/* { dg-final { scan-assembler "exrl" } } */
+
+/* { dg-final { scan-assembler     "section\t.s390_indirect_jump" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_indirect_call" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_return_reg" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_return_mem" } } */
diff --git a/gcc/testsuite/gcc.target/s390/nobp-indirect-jump-inline-attr.c b/gcc/testsuite/gcc.target/s390/nobp-indirect-jump-inline-attr.c
new file mode 100644
index 00000000000..63d64c15941
--- /dev/null
+++ b/gcc/testsuite/gcc.target/s390/nobp-indirect-jump-inline-attr.c
@@ -0,0 +1,42 @@
+/* { dg-do run } */
+/* { dg-options "-O3 -march=z10 --save-temps -mindirect-branch-table" } */
+/* { dg-require-effective-target label_values } */
+
+/* This is a copy of the gcc.c-torture/execute/20040302-1.c
+   testcase.  */
+
+int code[]={0,0,0,0,1};
+
+void foo(int x) {
+  volatile int b;
+  b = 0xffffffff;
+}
+
+void __attribute__((indirect_branch_jump("thunk-inline")))
+bar(int *pc) {
+  static const void *l[] = {&&lab0, &&end};
+
+  foo(0);
+  goto *l[*pc];
+ lab0:
+  foo(0);
+  pc++;
+  goto *l[*pc];
+ end:
+  return;
+}
+
+int
+main() {
+  bar(code);
+  return 0;
+}
+
+/* The two gotos in bar get merged.  */
+/* { dg-final { scan-assembler-times "exrl" 1 } } */
+
+/* { dg-final { scan-assembler-not "jg\t__s390_indirect_jump" } } */
+/* { dg-final { scan-assembler     "section\t.s390_indirect_jump" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_indirect_call" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_return_reg" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_return_mem" } } */
diff --git a/gcc/testsuite/gcc.target/s390/nobp-indirect-jump-inline-z10.c b/gcc/testsuite/gcc.target/s390/nobp-indirect-jump-inline-z10.c
new file mode 100644
index 00000000000..28d7837e2a4
--- /dev/null
+++ b/gcc/testsuite/gcc.target/s390/nobp-indirect-jump-inline-z10.c
@@ -0,0 +1,43 @@
+/* { dg-do run } */
+/* { dg-options "-O3 -march=z10 --save-temps -mindirect-branch-jump=thunk-inline -mindirect-branch-table" } */
+/* { dg-require-effective-target label_values } */
+
+/* This is a copy of the gcc.c-torture/execute/20040302-1.c
+   testcase.  */
+
+int code[]={0,0,0,0,1};
+
+void
+foo(int x) {
+  volatile int b;
+  b = 0xffffffff;
+}
+
+void
+bar(int *pc) {
+  static const void *l[] = {&&lab0, &&end};
+
+  foo(0);
+  goto *l[*pc];
+ lab0:
+  foo(0);
+  pc++;
+  goto *l[*pc];
+ end:
+  return;
+}
+
+int
+main() {
+  bar(code);
+  return 0;
+}
+
+/* The two gotos in bar get merged.  */
+/* { dg-final { scan-assembler-times "exrl" 1 } } */
+
+/* { dg-final { scan-assembler-not "jg\t__s390_indirect_jump" } } */
+/* { dg-final { scan-assembler     "section\t.s390_indirect_jump" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_indirect_call" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_return_reg" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_return_mem" } } */
diff --git a/gcc/testsuite/gcc.target/s390/nobp-indirect-jump-inline-z900.c b/gcc/testsuite/gcc.target/s390/nobp-indirect-jump-inline-z900.c
new file mode 100644
index 00000000000..3c0c0072539
--- /dev/null
+++ b/gcc/testsuite/gcc.target/s390/nobp-indirect-jump-inline-z900.c
@@ -0,0 +1,43 @@
+/* { dg-do run } */
+/* { dg-options "-O3 -march=z900 --save-temps -mindirect-branch-jump=thunk-inline -mindirect-branch-table" } */
+/* { dg-require-effective-target label_values } */
+
+/* This is a copy of the gcc.c-torture/execute/20040302-1.c
+   testcase.  */
+
+int code[]={0,0,0,0,1};
+
+void
+foo(int x) {
+  volatile int b;
+  b = 0xffffffff;
+}
+
+void
+bar(int *pc) {
+  static const void *l[] = {&&lab0, &&end};
+
+  foo(0);
+  goto *l[*pc];
+ lab0:
+  foo(0);
+  pc++;
+  goto *l[*pc];
+ end:
+  return;
+}
+
+int
+main() {
+  bar(code);
+  return 0;
+}
+
+/* The two gotos in bar get merged.  */
+/* { dg-final { scan-assembler-times "\tex\t" 1 } } */
+
+/* { dg-final { scan-assembler-not "jg\t__s390_indirect_jump" } } */
+/* { dg-final { scan-assembler     "section\t.s390_indirect_jump" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_indirect_call" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_return_reg" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_return_mem" } } */
diff --git a/gcc/testsuite/gcc.target/s390/nobp-indirect-jump-nothunk.c b/gcc/testsuite/gcc.target/s390/nobp-indirect-jump-nothunk.c
new file mode 100644
index 00000000000..05c8bb8c12d
--- /dev/null
+++ b/gcc/testsuite/gcc.target/s390/nobp-indirect-jump-nothunk.c
@@ -0,0 +1,46 @@
+/* { dg-do compile } */
+/* { dg-options "-O3 -march=z10 --save-temps -mindirect-branch-jump=thunk-extern -mindirect-branch-table" } */
+/* { dg-require-effective-target label_values } */
+
+/* This is a copy of the gcc.c-torture/execute/20040302-1.c
+   testcase.  */
+
+int code[]={0,0,0,0,1};
+
+void
+foo(int x) {
+  volatile int b;
+  b = 0xffffffff;
+}
+
+void
+bar(int *pc) {
+  static const void *l[] = {&&lab0, &&end};
+
+  foo(0);
+  goto *l[*pc];
+ lab0:
+  foo(0);
+  pc++;
+  goto *l[*pc];
+ end:
+  return;
+}
+
+int
+main() {
+  bar(code);
+  return 0;
+}
+
+/* 2 x bar
+/* { dg-final { scan-assembler-times "jg\t__s390_indirect_jump" 2 } } */
+
+/* No thunks due to thunk-extern.  */
+/* { dg-final { scan-assembler-not "exrl" } } */
+/* { dg-final { scan-assembler-not ".globl __s390_indirect_jump" } } */
+
+/* { dg-final { scan-assembler     "section\t.s390_indirect_jump" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_indirect_call" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_return_reg" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_return_mem" } } */
diff --git a/gcc/testsuite/gcc.target/s390/nobp-indirect-jump-z10.c b/gcc/testsuite/gcc.target/s390/nobp-indirect-jump-z10.c
new file mode 100644
index 00000000000..71c86fdfebc
--- /dev/null
+++ b/gcc/testsuite/gcc.target/s390/nobp-indirect-jump-z10.c
@@ -0,0 +1,43 @@
+/* { dg-do run } */
+/* { dg-options "-O3 -march=z10 --save-temps -mindirect-branch-jump=thunk -mindirect-branch-table" } */
+/* { dg-require-effective-target label_values } */
+
+/* This is a copy of the gcc.c-torture/execute/20040302-1.c
+   testcase.  */
+
+int code[]={0,0,0,0,1};
+
+void
+foo(int x) {
+  volatile int b;
+  b = 0xffffffff;
+}
+
+void
+bar(int *pc) {
+  static const void *l[] = {&&lab0, &&end};
+
+  foo(0);
+  goto *l[*pc];
+ lab0:
+  foo(0);
+  pc++;
+  goto *l[*pc];
+ end:
+  return;
+}
+
+int
+main() {
+  bar(code);
+  return 0;
+}
+
+/* 2x bar */
+/* { dg-final { scan-assembler-times "jg\t__s390_indirect_jump" 2 } } */
+/* { dg-final { scan-assembler "exrl" } } */
+
+/* { dg-final { scan-assembler     "section\t.s390_indirect_jump" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_indirect_call" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_return_reg" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_return_mem" } } */
diff --git a/gcc/testsuite/gcc.target/s390/nobp-indirect-jump-z900.c b/gcc/testsuite/gcc.target/s390/nobp-indirect-jump-z900.c
new file mode 100644
index 00000000000..89ad799c7a6
--- /dev/null
+++ b/gcc/testsuite/gcc.target/s390/nobp-indirect-jump-z900.c
@@ -0,0 +1,43 @@
+/* { dg-do run } */
+/* { dg-options "-O3 -march=z900 --save-temps -mindirect-branch-jump=thunk -mindirect-branch-table" } */
+/* { dg-require-effective-target label_values } */
+
+/* This is a copy of the gcc.c-torture/execute/20040302-1.c
+   testcase.  */
+
+int code[]={0,0,0,0,1};
+
+void
+foo(int x) {
+  volatile int b;
+  b = 0xffffffff;
+}
+
+void
+bar(int *pc) {
+  static const void *l[] = {&&lab0, &&end};
+
+  foo(0);
+  goto *l[*pc];
+ lab0:
+  foo(0);
+  pc++;
+  goto *l[*pc];
+ end:
+  return;
+}
+
+int
+main() {
+  bar(code);
+  return 0;
+}
+
+/* 2 x bar
+/* { dg-final { scan-assembler-times "jg\t__s390_indirect_jump" 2 } } */
+/* { dg-final { scan-assembler "ex\t" } } */
+
+/* { dg-final { scan-assembler     "section\t.s390_indirect_jump" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_indirect_call" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_return_reg" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_return_mem" } } */
diff --git a/gcc/testsuite/gcc.target/s390/nobp-no-dwarf2-cfi.c b/gcc/testsuite/gcc.target/s390/nobp-no-dwarf2-cfi.c
new file mode 100644
index 00000000000..75e32a1c7c0
--- /dev/null
+++ b/gcc/testsuite/gcc.target/s390/nobp-no-dwarf2-cfi.c
@@ -0,0 +1,19 @@
+/* { dg-do run } */
+/* { dg-options "-O3 -march=z900 --save-temps -mfunction-return-reg=thunk -mindirect-branch-table -fno-dwarf2-cfi-asm" } */
+
+/* Make sure that we do not emit .cfi directives when -fno-dwarf2-cfi-asm is being used.  */
+
+int
+main ()
+{
+  return 0;
+}
+
+/* 1 x main
+/* { dg-final { scan-assembler-times "jg\t__s390_indirect_jump" 1 } } */
+/* { dg-final { scan-assembler "ex\t" } } */
+
+/* { dg-final { scan-assembler-not "section\t.s390_indirect_jump" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_indirect_call" } } */
+/* { dg-final { scan-assembler     "section\t.s390_return_reg" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_return_mem" } } */
diff --git a/gcc/testsuite/gcc.target/s390/nobp-return-attr-all.c b/gcc/testsuite/gcc.target/s390/nobp-return-attr-all.c
new file mode 100644
index 00000000000..4bf88cf78c2
--- /dev/null
+++ b/gcc/testsuite/gcc.target/s390/nobp-return-attr-all.c
@@ -0,0 +1,46 @@
+/* { dg-do run } */
+/* { dg-options "-O3 -march=z10 -mzarch --save-temps -mindirect-branch-table" } */
+
+int gl = 0;
+
+int __attribute__((noinline,noclone))
+bar (int a)
+{
+  return a + 2;
+}
+
+void __attribute__((function_return("thunk"),noinline,noclone))
+foo (int a)
+{
+  int i;
+
+  if (a == 42)
+    return;
+
+  for (i = 0; i < a; i++)
+    gl += bar (i);
+}
+
+int
+main ()
+{
+  foo (3);
+  if (gl != 9)
+    __builtin_abort ();
+
+  return 0;
+}
+
+/* With -march=z10 -mzarch the shrink wrapped returns use compare and
+   swap relative to jump to the exit block instead of making use of
+   the conditional return pattern.
+   FIXME: Use compare and branch register for that!!!! */
+
+/* 2 x foo
+/* { dg-final { scan-assembler-times "jg\t__s390_indirect_jump" 2 } } */
+/* { dg-final { scan-assembler "exrl" } } */
+
+/* { dg-final { scan-assembler-not "section\t.s390_indirect_jump" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_indirect_call" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_return_reg" } } */
+/* { dg-final { scan-assembler     "section\t.s390_return_mem" } } */
diff --git a/gcc/testsuite/gcc.target/s390/nobp-return-attr-neg.c b/gcc/testsuite/gcc.target/s390/nobp-return-attr-neg.c
new file mode 100644
index 00000000000..8b32bfe5172
--- /dev/null
+++ b/gcc/testsuite/gcc.target/s390/nobp-return-attr-neg.c
@@ -0,0 +1,40 @@
+/* { dg-do run } */
+/* { dg-options "-O3 -march=z10 -mzarch --save-temps -mfunction-return-mem=thunk -mindirect-branch-table" } */
+
+int gl = 0;
+
+int __attribute__((noinline,noclone))
+bar (int a)
+{
+  return a + 2;
+}
+
+void __attribute__((function_return("keep"),noinline,noclone))
+foo (int a)
+{
+  int i;
+
+  if (a == 42)
+    return;
+
+  for (i = 0; i < a; i++)
+    gl += bar (i);
+}
+
+int __attribute__((function_return("keep")))
+main ()
+{
+  foo (3);
+  if (gl != 9)
+    __builtin_abort ();
+
+  return 0;
+}
+
+/* { dg-final { scan-assembler-not "jg\t__s390_indirect_jump" } } */
+/* { dg-final { scan-assembler-not "exrl" } } */
+
+/* { dg-final { scan-assembler-not "section\t.s390_indirect_jump" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_indirect_call" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_return_reg" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_return_mem" } } */
diff --git a/gcc/testsuite/gcc.target/s390/nobp-return-mem-attr.c b/gcc/testsuite/gcc.target/s390/nobp-return-mem-attr.c
new file mode 100644
index 00000000000..39cab8bd89e
--- /dev/null
+++ b/gcc/testsuite/gcc.target/s390/nobp-return-mem-attr.c
@@ -0,0 +1,46 @@
+/* { dg-do run } */
+/* { dg-options "-O3 -march=z10 -mzarch --save-temps -mindirect-branch-table" } */
+
+int gl = 0;
+
+int __attribute__((noinline,noclone))
+bar (int a)
+{
+  return a + 2;
+}
+
+void __attribute__((function_return_mem("thunk"),noinline,noclone))
+foo (int a)
+{
+  int i;
+
+  if (a == 42)
+    return;
+
+  for (i = 0; i < a; i++)
+    gl += bar (i);
+}
+
+int
+main ()
+{
+  foo (3);
+  if (gl != 9)
+    __builtin_abort ();
+
+  return 0;
+}
+
+/* With -march=z10 -mzarch the shrink wrapped returns use compare and
+   swap relative to jump to the exit block instead of making use of
+   the conditional return pattern.
+   FIXME: Use compare and branch register for that!!!! */
+
+/* 2 x foo
+/* { dg-final { scan-assembler-times "jg\t__s390_indirect_jump" 2 } } */
+/* { dg-final { scan-assembler "exrl" } } */
+
+/* { dg-final { scan-assembler-not "section\t.s390_indirect_jump" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_indirect_call" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_return_reg" } } */
+/* { dg-final { scan-assembler     "section\t.s390_return_mem" } } */
diff --git a/gcc/testsuite/gcc.target/s390/nobp-return-mem-nothunk.c b/gcc/testsuite/gcc.target/s390/nobp-return-mem-nothunk.c
new file mode 100644
index 00000000000..f99f152305c
--- /dev/null
+++ b/gcc/testsuite/gcc.target/s390/nobp-return-mem-nothunk.c
@@ -0,0 +1,49 @@
+/* { dg-do compile } */
+/* { dg-options "-O3 -march=z10 -mzarch --save-temps -mfunction-return-mem=thunk-extern -mindirect-branch-table" } */
+
+int gl = 0;
+
+int __attribute__((noinline,noclone))
+bar (int a)
+{
+  return a + 2;
+}
+
+void __attribute__((noinline,noclone))
+foo (int a)
+{
+  int i;
+
+  if (a == 42)
+    return;
+
+  for (i = 0; i < a; i++)
+    gl += bar (i);
+}
+
+int
+main ()
+{
+  foo (3);
+  if (gl != 9)
+    __builtin_abort ();
+
+  return 0;
+}
+
+/* With -march=z10 -mzarch the shrink wrapped returns use compare and
+   swap relative to jump to the exit block instead of making use of
+   the conditional return pattern.
+   FIXME: Use compare and branch register for that!!!! */
+
+/* 2 x foo, 1 x main
+/* { dg-final { scan-assembler-times "jg\t__s390_indirect_jump" 3 } } */
+
+/* No thunks due to thunk-extern.  */
+/* { dg-final { scan-assembler-not "exrl" } } */
+/* { dg-final { scan-assembler-not ".globl __s390_indirect_jump" } } */
+
+/* { dg-final { scan-assembler-not "section\t.s390_indirect_jump" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_indirect_call" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_return_reg" } } */
+/* { dg-final { scan-assembler     "section\t.s390_return_mem" } } */
diff --git a/gcc/testsuite/gcc.target/s390/nobp-return-mem-z10.c b/gcc/testsuite/gcc.target/s390/nobp-return-mem-z10.c
new file mode 100644
index 00000000000..177fc32c24b
--- /dev/null
+++ b/gcc/testsuite/gcc.target/s390/nobp-return-mem-z10.c
@@ -0,0 +1,46 @@
+/* { dg-do run } */
+/* { dg-options "-O3 -march=z10 -mzarch --save-temps -mfunction-return-mem=thunk -mindirect-branch-table" } */
+
+int gl = 0;
+
+int __attribute__((noinline,noclone))
+bar (int a)
+{
+  return a + 2;
+}
+
+void __attribute__((noinline,noclone))
+foo (int a)
+{
+  int i;
+
+  if (a == 42)
+    return;
+
+  for (i = 0; i < a; i++)
+    gl += bar (i);
+}
+
+int
+main ()
+{
+  foo (3);
+  if (gl != 9)
+    __builtin_abort ();
+
+  return 0;
+}
+
+/* With -march=z10 -mzarch the shrink wrapped returns use compare and
+   swap relative to jump to the exit block instead of making use of
+   the conditional return pattern.
+   FIXME: Use compare and branch register for that!!!! */
+
+/* 2 x foo, 1 x main
+/* { dg-final { scan-assembler-times "jg\t__s390_indirect_jump" 3 } } */
+/* { dg-final { scan-assembler "exrl" } } */
+
+/* { dg-final { scan-assembler-not "section\t.s390_indirect_jump" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_indirect_call" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_return_reg" } } */
+/* { dg-final { scan-assembler     "section\t.s390_return_mem" } } */
diff --git a/gcc/testsuite/gcc.target/s390/nobp-return-mem-z900.c b/gcc/testsuite/gcc.target/s390/nobp-return-mem-z900.c
new file mode 100644
index 00000000000..0b318115a8f
--- /dev/null
+++ b/gcc/testsuite/gcc.target/s390/nobp-return-mem-z900.c
@@ -0,0 +1,48 @@
+/* { dg-do run } */
+/* { dg-options "-O3 -march=z900 --save-temps -mfunction-return-mem=thunk -mindirect-branch-table" } */
+
+int gl = 0;
+
+int __attribute__((noinline,noclone))
+bar (int a)
+{
+  return a + 2;
+}
+
+void __attribute__((noinline,noclone))
+foo (int a)
+{
+  int i;
+
+  if (a == 42)
+    return;
+
+  for (i = 0; i < a; i++)
+    gl += bar (i);
+}
+
+int
+main ()
+{
+  foo (3);
+  if (gl != 9)
+    __builtin_abort ();
+
+  return 0;
+}
+
+/* 1 x foo, 1 x main
+/* { dg-final { scan-assembler-times "jg\t__s390_indirect_jump" 2 } } */
+
+/* 1 x foo, conditional return, shrink wrapped
+/* { dg-final { scan-assembler "jge\t__s390_indirect_jump" } } */
+
+/* 1 x foo, conditional return, shrink wrapped
+/* { dg-final { scan-assembler "jgle\t__s390_indirect_jump" } } */
+
+/* { dg-final { scan-assembler "ex\t" } } */
+
+/* { dg-final { scan-assembler-not "section\t.s390_indirect_jump" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_indirect_call" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_return_reg" } } */
+/* { dg-final { scan-assembler     "section\t.s390_return_mem" } } */
diff --git a/gcc/testsuite/gcc.target/s390/nobp-return-reg-attr.c b/gcc/testsuite/gcc.target/s390/nobp-return-reg-attr.c
new file mode 100644
index 00000000000..ebfc9ff0ebb
--- /dev/null
+++ b/gcc/testsuite/gcc.target/s390/nobp-return-reg-attr.c
@@ -0,0 +1,41 @@
+/* { dg-do run } */
+/* { dg-options "-O3 -march=z10 --save-temps -mindirect-branch-table" } */
+
+int gl = 0;
+
+int __attribute__((function_return_reg("thunk"),noinline,noclone))
+bar (int a)
+{
+  return a + 2;
+}
+
+void __attribute__((noinline,noclone))
+foo (int a)
+{
+  int i;
+
+  if (a == 42)
+    return;
+
+  for (i = 0; i < a; i++)
+    gl += bar (i);
+}
+
+int
+main ()
+{
+  foo (3);
+  if (gl != 9)
+    __builtin_abort ();
+
+  return 0;
+}
+
+/* 1 x bar
+/* { dg-final { scan-assembler-times "jg\t__s390_indirect_jump" 1 } } */
+/* { dg-final { scan-assembler "exrl" } } */
+
+/* { dg-final { scan-assembler-not "section\t.s390_indirect_jump" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_indirect_call" } } */
+/* { dg-final { scan-assembler     "section\t.s390_return_reg" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_return_mem" } } */
diff --git a/gcc/testsuite/gcc.target/s390/nobp-return-reg-mixed.c b/gcc/testsuite/gcc.target/s390/nobp-return-reg-mixed.c
new file mode 100644
index 00000000000..82833f7e0d7
--- /dev/null
+++ b/gcc/testsuite/gcc.target/s390/nobp-return-reg-mixed.c
@@ -0,0 +1,44 @@
+/* { dg-do run } */
+/* { dg-options "-O3 -march=z900 --save-temps -mfunction-return-reg=thunk -mindirect-branch-table" } */
+
+/* We have to generate different thunks for indirect branches
+   depending on whether the code is compiled for pre z10 machines or
+   later.  This testcase makes sure this works within the same compile
+   unit.  */
+
+int __attribute__((noinline,noclone,target("arch=z10")))
+bar (int a)
+{
+  return a + 2;
+}
+
+int __attribute__((noinline,noclone,target("arch=z9-ec")))
+foo (int a)
+{
+  return a + 3;
+}
+
+int
+main ()
+{
+  if (bar (42) != 44)
+    __builtin_abort ();
+
+  if (foo (42) != 45)
+    __builtin_abort ();
+
+  return 0;
+}
+
+/* 1 x bar, 1 x foo */
+/* { dg-final { scan-assembler-times "jg\t__s390_indirect_jump" 2 } } */
+/* 1 x foo */
+/* { dg-final { scan-assembler-times "jg\t__s390_indirect_jump_r1use" 1 } } */
+
+/* { dg-final { scan-assembler-times "ex\t" 1 } } */
+/* { dg-final { scan-assembler-times "exrl\t" 1 } } */
+
+/* { dg-final { scan-assembler-not "section\t.s390_indirect_jump" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_indirect_call" } } */
+/* { dg-final { scan-assembler     "section\t.s390_return_reg" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_return_mem" } } */
diff --git a/gcc/testsuite/gcc.target/s390/nobp-return-reg-nothunk.c b/gcc/testsuite/gcc.target/s390/nobp-return-reg-nothunk.c
new file mode 100644
index 00000000000..4ea14e379f5
--- /dev/null
+++ b/gcc/testsuite/gcc.target/s390/nobp-return-reg-nothunk.c
@@ -0,0 +1,44 @@
+/* { dg-do compile } */
+/* { dg-options "-O3 -march=z10 --save-temps -mfunction-return-reg=thunk-extern -mindirect-branch-table" } */
+
+int gl = 0;
+
+int __attribute__((noinline,noclone))
+bar (int a)
+{
+  return a + 2;
+}
+
+void __attribute__((noinline,noclone))
+foo (int a)
+{
+  int i;
+
+  if (a == 42)
+    return;
+
+  for (i = 0; i < a; i++)
+    gl += bar (i);
+}
+
+int
+main ()
+{
+  foo (3);
+  if (gl != 9)
+    __builtin_abort ();
+
+  return 0;
+}
+
+/* 1 x bar
+/* { dg-final { scan-assembler-times "jg\t__s390_indirect_jump" 1 } } */
+
+/* No thunks due to thunk-extern.  */
+/* { dg-final { scan-assembler-not "exrl" } } */
+/* { dg-final { scan-assembler-not ".globl __s390_indirect_jump" } } */
+
+/* { dg-final { scan-assembler-not "section\t.s390_indirect_jump" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_indirect_call" } } */
+/* { dg-final { scan-assembler     "section\t.s390_return_reg" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_return_mem" } } */
diff --git a/gcc/testsuite/gcc.target/s390/nobp-return-reg-z10.c b/gcc/testsuite/gcc.target/s390/nobp-return-reg-z10.c
new file mode 100644
index 00000000000..42c3e7435fa
--- /dev/null
+++ b/gcc/testsuite/gcc.target/s390/nobp-return-reg-z10.c
@@ -0,0 +1,41 @@
+/* { dg-do run } */
+/* { dg-options "-O3 -march=z10 --save-temps -mfunction-return-reg=thunk -mindirect-branch-table" } */
+
+int gl = 0;
+
+int __attribute__((noinline,noclone))
+bar (int a)
+{
+  return a + 2;
+}
+
+void __attribute__((noinline,noclone))
+foo (int a)
+{
+  int i;
+
+  if (a == 42)
+    return;
+
+  for (i = 0; i < a; i++)
+    gl += bar (i);
+}
+
+int
+main ()
+{
+  foo (3);
+  if (gl != 9)
+    __builtin_abort ();
+
+  return 0;
+}
+
+/* 1 x bar
+/* { dg-final { scan-assembler-times "jg\t__s390_indirect_jump" 1 } } */
+/* { dg-final { scan-assembler "exrl" } } */
+
+/* { dg-final { scan-assembler-not "section\t.s390_indirect_jump" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_indirect_call" } } */
+/* { dg-final { scan-assembler     "section\t.s390_return_reg" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_return_mem" } } */
diff --git a/gcc/testsuite/gcc.target/s390/nobp-return-reg-z900.c b/gcc/testsuite/gcc.target/s390/nobp-return-reg-z900.c
new file mode 100644
index 00000000000..3f4efa57e71
--- /dev/null
+++ b/gcc/testsuite/gcc.target/s390/nobp-return-reg-z900.c
@@ -0,0 +1,41 @@
+/* { dg-do run } */
+/* { dg-options "-O3 -march=z900 --save-temps -mfunction-return-reg=thunk -mindirect-branch-table" } */
+
+int gl = 0;
+
+int __attribute__((noinline,noclone))
+bar (int a)
+{
+  return a + 2;
+}
+
+void __attribute__((noinline,noclone))
+foo (int a)
+{
+  int i;
+
+  if (a == 42)
+    return;
+
+  for (i = 0; i < a; i++)
+    gl += bar (i);
+}
+
+int
+main ()
+{
+  foo (3);
+  if (gl != 9)
+    __builtin_abort ();
+
+  return 0;
+}
+
+/* 1 x bar
+/* { dg-final { scan-assembler-times "jg\t__s390_indirect_jump" 1 } } */
+/* { dg-final { scan-assembler "ex\t" } } */
+
+/* { dg-final { scan-assembler-not "section\t.s390_indirect_jump" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_indirect_call" } } */
+/* { dg-final { scan-assembler     "section\t.s390_return_reg" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_return_mem" } } */
diff --git a/gcc/testsuite/gcc.target/s390/nobp-table-jump-inline-z10.c b/gcc/testsuite/gcc.target/s390/nobp-table-jump-inline-z10.c
new file mode 100644
index 00000000000..8dfd7e4c786
--- /dev/null
+++ b/gcc/testsuite/gcc.target/s390/nobp-table-jump-inline-z10.c
@@ -0,0 +1,78 @@
+/* { dg-do run } */
+/* { dg-options "-O3 -march=z10 -mzarch --save-temps -mindirect-branch-jump=thunk-inline -mindirect-branch-table" } */
+
+/* case-values-threshold will be set to 20 by the back-end when jump
+   thunk are requested.  */
+
+int __attribute__((noinline,noclone)) foo1 (void) { return 1; }
+int __attribute__((noinline,noclone)) foo2 (void) { return 2; }
+int __attribute__((noinline,noclone)) foo3 (void) { return 3; }
+int __attribute__((noinline,noclone)) foo4 (void) { return 4; }
+int __attribute__((noinline,noclone)) foo5 (void) { return 5; }
+int __attribute__((noinline,noclone)) foo6 (void) { return 6; }
+int __attribute__((noinline,noclone)) foo7 (void) { return 7; }
+int __attribute__((noinline,noclone)) foo8 (void) { return 8; }
+int __attribute__((noinline,noclone)) foo9 (void) { return 9; }
+int __attribute__((noinline,noclone)) foo10 (void) { return 10; }
+int __attribute__((noinline,noclone)) foo11 (void) { return 11; }
+int __attribute__((noinline,noclone)) foo12 (void) { return 12; }
+int __attribute__((noinline,noclone)) foo13 (void) { return 13; }
+int __attribute__((noinline,noclone)) foo14 (void) { return 14; }
+int __attribute__((noinline,noclone)) foo15 (void) { return 15; }
+int __attribute__((noinline,noclone)) foo16 (void) { return 16; }
+int __attribute__((noinline,noclone)) foo17 (void) { return 17; }
+int __attribute__((noinline,noclone)) foo18 (void) { return 18; }
+int __attribute__((noinline,noclone)) foo19 (void) { return 19; }
+int __attribute__((noinline,noclone)) foo20 (void) { return 20; }
+
+
+int __attribute__((noinline,noclone))
+bar (int a)
+{
+  int ret = 0;
+
+  switch (a)
+    {
+    case 1: ret = foo1 (); break;
+    case 2: ret = foo2 (); break;
+    case 3: ret = foo3 (); break;
+    case 4: ret = foo4 (); break;
+    case 5: ret = foo5 (); break;
+    case 6: ret = foo6 (); break;
+    case 7: ret = foo7 (); break;
+    case 8: ret = foo8 (); break;
+    case 9: ret = foo9 (); break;
+    case 10: ret = foo10 (); break;
+    case 11: ret = foo11 (); break;
+    case 12: ret = foo12 (); break;
+    case 13: ret = foo13 (); break;
+    case 14: ret = foo14 (); break;
+    case 15: ret = foo15 (); break;
+    case 16: ret = foo16 (); break;
+    case 17: ret = foo17 (); break;
+    case 18: ret = foo18 (); break;
+    case 19: ret = foo19 (); break;
+    case 20: ret = foo20 (); break;
+    default:
+      __builtin_abort ();
+    }
+
+  return ret;
+}
+
+int
+main ()
+{
+  if (bar (3) != 3)
+    __builtin_abort ();
+
+  return 0;
+}
+
+/* 1 x bar
+/* { dg-final { scan-assembler-times "exrl" 1 } } */
+
+/* { dg-final { scan-assembler     "section\t.s390_indirect_jump" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_indirect_call" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_return_fromreg" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_return_frommem" } } */
diff --git a/gcc/testsuite/gcc.target/s390/nobp-table-jump-inline-z900.c b/gcc/testsuite/gcc.target/s390/nobp-table-jump-inline-z900.c
new file mode 100644
index 00000000000..46d2c54bcff
--- /dev/null
+++ b/gcc/testsuite/gcc.target/s390/nobp-table-jump-inline-z900.c
@@ -0,0 +1,78 @@
+/* { dg-do run } */
+/* { dg-options "-O3 -march=z900 -mzarch --save-temps -mindirect-branch-jump=thunk-inline -mindirect-branch-table" } */
+
+/* case-values-threshold will be set to 20 by the back-end when jump
+   thunk are requested.  */
+
+int __attribute__((noinline,noclone)) foo1 (void) { return 1; }
+int __attribute__((noinline,noclone)) foo2 (void) { return 2; }
+int __attribute__((noinline,noclone)) foo3 (void) { return 3; }
+int __attribute__((noinline,noclone)) foo4 (void) { return 4; }
+int __attribute__((noinline,noclone)) foo5 (void) { return 5; }
+int __attribute__((noinline,noclone)) foo6 (void) { return 6; }
+int __attribute__((noinline,noclone)) foo7 (void) { return 7; }
+int __attribute__((noinline,noclone)) foo8 (void) { return 8; }
+int __attribute__((noinline,noclone)) foo9 (void) { return 9; }
+int __attribute__((noinline,noclone)) foo10 (void) { return 10; }
+int __attribute__((noinline,noclone)) foo11 (void) { return 11; }
+int __attribute__((noinline,noclone)) foo12 (void) { return 12; }
+int __attribute__((noinline,noclone)) foo13 (void) { return 13; }
+int __attribute__((noinline,noclone)) foo14 (void) { return 14; }
+int __attribute__((noinline,noclone)) foo15 (void) { return 15; }
+int __attribute__((noinline,noclone)) foo16 (void) { return 16; }
+int __attribute__((noinline,noclone)) foo17 (void) { return 17; }
+int __attribute__((noinline,noclone)) foo18 (void) { return 18; }
+int __attribute__((noinline,noclone)) foo19 (void) { return 19; }
+int __attribute__((noinline,noclone)) foo20 (void) { return 20; }
+
+
+int __attribute__((noinline,noclone))
+bar (int a)
+{
+  int ret = 0;
+
+  switch (a)
+    {
+    case 1: ret = foo1 (); break;
+    case 2: ret = foo2 (); break;
+    case 3: ret = foo3 (); break;
+    case 4: ret = foo4 (); break;
+    case 5: ret = foo5 (); break;
+    case 6: ret = foo6 (); break;
+    case 7: ret = foo7 (); break;
+    case 8: ret = foo8 (); break;
+    case 9: ret = foo9 (); break;
+    case 10: ret = foo10 (); break;
+    case 11: ret = foo11 (); break;
+    case 12: ret = foo12 (); break;
+    case 13: ret = foo13 (); break;
+    case 14: ret = foo14 (); break;
+    case 15: ret = foo15 (); break;
+    case 16: ret = foo16 (); break;
+    case 17: ret = foo17 (); break;
+    case 18: ret = foo18 (); break;
+    case 19: ret = foo19 (); break;
+    case 20: ret = foo20 (); break;
+    default:
+      __builtin_abort ();
+    }
+
+  return ret;
+}
+
+int
+main ()
+{
+  if (bar (3) != 3)
+    __builtin_abort ();
+
+  return 0;
+}
+
+/* 1 x bar
+/* { dg-final { scan-assembler-times "\tex\t" 1 } } */
+
+/* { dg-final { scan-assembler     "section\t.s390_indirect_jump" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_indirect_call" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_return_fromreg" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_return_frommem" } } */
diff --git a/gcc/testsuite/gcc.target/s390/nobp-table-jump-z10.c b/gcc/testsuite/gcc.target/s390/nobp-table-jump-z10.c
new file mode 100644
index 00000000000..9dfe391f337
--- /dev/null
+++ b/gcc/testsuite/gcc.target/s390/nobp-table-jump-z10.c
@@ -0,0 +1,77 @@
+/* { dg-do run } */
+/* { dg-options "-O3 -march=z10 -mzarch --save-temps -mindirect-branch-jump=thunk -mindirect-branch-table" } */
+/* case-values-threshold will be set to 20 by the back-end when jump
+   thunk are requested.  */
+
+int __attribute__((noinline,noclone)) foo1 (void) { return 1; }
+int __attribute__((noinline,noclone)) foo2 (void) { return 2; }
+int __attribute__((noinline,noclone)) foo3 (void) { return 3; }
+int __attribute__((noinline,noclone)) foo4 (void) { return 4; }
+int __attribute__((noinline,noclone)) foo5 (void) { return 5; }
+int __attribute__((noinline,noclone)) foo6 (void) { return 6; }
+int __attribute__((noinline,noclone)) foo7 (void) { return 7; }
+int __attribute__((noinline,noclone)) foo8 (void) { return 8; }
+int __attribute__((noinline,noclone)) foo9 (void) { return 9; }
+int __attribute__((noinline,noclone)) foo10 (void) { return 10; }
+int __attribute__((noinline,noclone)) foo11 (void) { return 11; }
+int __attribute__((noinline,noclone)) foo12 (void) { return 12; }
+int __attribute__((noinline,noclone)) foo13 (void) { return 13; }
+int __attribute__((noinline,noclone)) foo14 (void) { return 14; }
+int __attribute__((noinline,noclone)) foo15 (void) { return 15; }
+int __attribute__((noinline,noclone)) foo16 (void) { return 16; }
+int __attribute__((noinline,noclone)) foo17 (void) { return 17; }
+int __attribute__((noinline,noclone)) foo18 (void) { return 18; }
+int __attribute__((noinline,noclone)) foo19 (void) { return 19; }
+int __attribute__((noinline,noclone)) foo20 (void) { return 20; }
+
+
+int __attribute__((noinline,noclone))
+bar (int a)
+{
+  int ret = 0;
+
+  switch (a)
+    {
+    case 1: ret = foo1 (); break;
+    case 2: ret = foo2 (); break;
+    case 3: ret = foo3 (); break;
+    case 4: ret = foo4 (); break;
+    case 5: ret = foo5 (); break;
+    case 6: ret = foo6 (); break;
+    case 7: ret = foo7 (); break;
+    case 8: ret = foo8 (); break;
+    case 9: ret = foo9 (); break;
+    case 10: ret = foo10 (); break;
+    case 11: ret = foo11 (); break;
+    case 12: ret = foo12 (); break;
+    case 13: ret = foo13 (); break;
+    case 14: ret = foo14 (); break;
+    case 15: ret = foo15 (); break;
+    case 16: ret = foo16 (); break;
+    case 17: ret = foo17 (); break;
+    case 18: ret = foo18 (); break;
+    case 19: ret = foo19 (); break;
+    case 20: ret = foo20 (); break;
+    default:
+      __builtin_abort ();
+    }
+
+  return ret;
+}
+
+int
+main ()
+{
+  if (bar (3) != 3)
+    __builtin_abort ();
+
+  return 0;
+}
+
+/* 1 x bar
+/* { dg-final { scan-assembler-times "exrl" 1 } } */
+
+/* { dg-final { scan-assembler     "section\t.s390_indirect_jump" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_indirect_call" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_return_fromreg" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_return_frommem" } } */
diff --git a/gcc/testsuite/gcc.target/s390/nobp-table-jump-z900.c b/gcc/testsuite/gcc.target/s390/nobp-table-jump-z900.c
new file mode 100644
index 00000000000..f1439a8b120
--- /dev/null
+++ b/gcc/testsuite/gcc.target/s390/nobp-table-jump-z900.c
@@ -0,0 +1,78 @@
+/* { dg-do run } */
+/* { dg-options "-O3 -march=z900 -mzarch --save-temps -mindirect-branch-jump=thunk -mindirect-branch-table" } */
+
+/* case-values-threshold will be set to 20 by the back-end when jump
+   thunk are requested.  */
+
+int __attribute__((noinline,noclone)) foo1 (void) { return 1; }
+int __attribute__((noinline,noclone)) foo2 (void) { return 2; }
+int __attribute__((noinline,noclone)) foo3 (void) { return 3; }
+int __attribute__((noinline,noclone)) foo4 (void) { return 4; }
+int __attribute__((noinline,noclone)) foo5 (void) { return 5; }
+int __attribute__((noinline,noclone)) foo6 (void) { return 6; }
+int __attribute__((noinline,noclone)) foo7 (void) { return 7; }
+int __attribute__((noinline,noclone)) foo8 (void) { return 8; }
+int __attribute__((noinline,noclone)) foo9 (void) { return 9; }
+int __attribute__((noinline,noclone)) foo10 (void) { return 10; }
+int __attribute__((noinline,noclone)) foo11 (void) { return 11; }
+int __attribute__((noinline,noclone)) foo12 (void) { return 12; }
+int __attribute__((noinline,noclone)) foo13 (void) { return 13; }
+int __attribute__((noinline,noclone)) foo14 (void) { return 14; }
+int __attribute__((noinline,noclone)) foo15 (void) { return 15; }
+int __attribute__((noinline,noclone)) foo16 (void) { return 16; }
+int __attribute__((noinline,noclone)) foo17 (void) { return 17; }
+int __attribute__((noinline,noclone)) foo18 (void) { return 18; }
+int __attribute__((noinline,noclone)) foo19 (void) { return 19; }
+int __attribute__((noinline,noclone)) foo20 (void) { return 20; }
+
+
+int __attribute__((noinline,noclone))
+bar (int a)
+{
+  int ret = 0;
+
+  switch (a)
+    {
+    case 1: ret = foo1 (); break;
+    case 2: ret = foo2 (); break;
+    case 3: ret = foo3 (); break;
+    case 4: ret = foo4 (); break;
+    case 5: ret = foo5 (); break;
+    case 6: ret = foo6 (); break;
+    case 7: ret = foo7 (); break;
+    case 8: ret = foo8 (); break;
+    case 9: ret = foo9 (); break;
+    case 10: ret = foo10 (); break;
+    case 11: ret = foo11 (); break;
+    case 12: ret = foo12 (); break;
+    case 13: ret = foo13 (); break;
+    case 14: ret = foo14 (); break;
+    case 15: ret = foo15 (); break;
+    case 16: ret = foo16 (); break;
+    case 17: ret = foo17 (); break;
+    case 18: ret = foo18 (); break;
+    case 19: ret = foo19 (); break;
+    case 20: ret = foo20 (); break;
+    default:
+      __builtin_abort ();
+    }
+
+  return ret;
+}
+
+int
+main ()
+{
+  if (bar (3) != 3)
+    __builtin_abort ();
+
+  return 0;
+}
+
+/* 1 x bar
+/* { dg-final { scan-assembler-times "ex\t" 1 } } */
+
+/* { dg-final { scan-assembler     "section\t.s390_indirect_jump" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_indirect_call" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_return_fromreg" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_return_frommem" } } */
diff --git a/gcc/testsuite/gcc.target/s390/pr84295.c b/gcc/testsuite/gcc.target/s390/pr84295.c
new file mode 100644
index 00000000000..4da43c3cded
--- /dev/null
+++ b/gcc/testsuite/gcc.target/s390/pr84295.c
@@ -0,0 +1,14 @@
+/* { dg-do compile } */
+/* { dg-options "-O3 -march=z900 -fgnu89-inline --save-temps -mfunction-return-reg=thunk -mindirect-branch-table" } */
+
+extern void foo (void);
+extern __inline  void foo (void) {}
+void foo (void) {}
+
+/* { dg-final { scan-assembler-times "jg\t__s390_indirect_jump" 1 } } */
+/* { dg-final { scan-assembler "ex\t" } } */
+
+/* { dg-final { scan-assembler-not "section\t.s390_indirect_jump" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_indirect_call" } } */
+/* { dg-final { scan-assembler     "section\t.s390_return_reg" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_return_mem" } } */
diff --git a/gcc/testsuite/gcc.target/s390/zvector/vec-double-1.c b/gcc/testsuite/gcc.target/s390/zvector/vec-double-1.c
new file mode 100644
index 00000000000..39b6d84f828
--- /dev/null
+++ b/gcc/testsuite/gcc.target/s390/zvector/vec-double-1.c
@@ -0,0 +1,12 @@
+/* { dg-do compile } */
+/* { dg-options "-O3 -mzarch -march=z13 -mzvector" } */
+
+#include <vecintrin.h>
+
+vector double
+test (vector unsigned long long x)
+{
+  return vec_double (x);
+}
+
+/* { dg-final { scan-assembler-times "vcdlgb\t" 1 } } */
diff --git a/gcc/testsuite/gcc.target/s390/zvector/vec-double-2.c b/gcc/testsuite/gcc.target/s390/zvector/vec-double-2.c
new file mode 100644
index 00000000000..c592ea2e975
--- /dev/null
+++ b/gcc/testsuite/gcc.target/s390/zvector/vec-double-2.c
@@ -0,0 +1,12 @@
+/* { dg-do compile } */
+/* { dg-options "-O3 -mzarch -march=z13 -mzvector" } */
+
+#include <vecintrin.h>
+
+vector double
+test (vector long long x)
+{
+  return vec_double (x);
+}
+
+/* { dg-final { scan-assembler-times "vcdgb\t" 1 } } */
diff --git a/gcc/testsuite/gcc.target/sparc/struct-ret-check-1.c b/gcc/testsuite/gcc.target/sparc/struct-ret-check-1.c
index 00307fe2978..0428bc99df9 100644
--- a/gcc/testsuite/gcc.target/sparc/struct-ret-check-1.c
+++ b/gcc/testsuite/gcc.target/sparc/struct-ret-check-1.c
@@ -7,7 +7,7 @@
 
 /* Origin: Carlos O'Donell <carlos@codesourcery.com> */
 /* { dg-do run { target sparc*-*-solaris* sparc*-*-linux* sparc*-*-*bsd* } } */
-/* { dg-options "-mstd-struct-return" } */
+/* { dg-options "-mstd-struct-return -fno-pie" } */
 /* { dg-require-effective-target ilp32 } */
 #include <stdio.h>
 #include <stdlib.h>
diff --git a/gcc/testsuite/gcc.target/sparc/tls-ld-int16.c b/gcc/testsuite/gcc.target/sparc/tls-ld-int16.c
new file mode 100644
index 00000000000..d3d28086156
--- /dev/null
+++ b/gcc/testsuite/gcc.target/sparc/tls-ld-int16.c
@@ -0,0 +1,34 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" }
+/* { dg-add-options tls } */
+
+#include <stdint.h>
+
+__thread int16_t var1 __attribute__((tls_model("local-dynamic")));
+__thread int16_t var2 __attribute__((tls_model("local-dynamic")));
+
+int16_t sum (void)
+{
+  return var1 + var2;
+}
+
+int32_t ext32_sum (void)
+{
+  return (int32_t)var1 + (int32_t)var2;
+}
+
+long ext_sum (void)
+{
+  return (long)var1 + (long)var2;
+}
+
+void set (int16_t i)
+{
+  var1 = i;
+  var2 = i;
+}
+
+/* { dg-final { scan-assembler-times "__tls_get_addr" 4 } } */
+/* { dg-final { scan-assembler-times "lduh\t\[^\n\]*tldo_add" 2 } } */
+/* { dg-final { scan-assembler-times "ldsh\t\[^\n\]*tldo_add" 4 } } */
+/* { dg-final { scan-assembler-times "sth\t\[^\n\]*tldo_add" 2 } } */
diff --git a/gcc/testsuite/gcc.target/sparc/tls-ld-int32.c b/gcc/testsuite/gcc.target/sparc/tls-ld-int32.c
new file mode 100644
index 00000000000..cf18147ef72
--- /dev/null
+++ b/gcc/testsuite/gcc.target/sparc/tls-ld-int32.c
@@ -0,0 +1,36 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" }
+/* { dg-add-options tls } */
+
+#include <stdint.h>
+
+__thread int32_t var1 __attribute__((tls_model("local-dynamic")));
+__thread int32_t var2 __attribute__((tls_model("local-dynamic")));
+
+int32_t sum (void)
+{
+  return var1 + var2;
+}
+
+#if defined(__sparcv9) || defined(__arch64__)
+long ext_sum (void)
+{
+  return (long)var1 + (long)var2;
+}
+#else
+void *addr (void)
+{
+  return &var1;
+}
+#endif
+
+void set (int32_t i)
+{
+  var1 = i;
+  var2 = i;
+}
+
+/* { dg-final { scan-assembler-times "__tls_get_addr" 3 } } */
+/* { dg-final { scan-assembler-times "ld\t\[^\n\]*tldo_add" 2 } } */
+/* { dg-final { scan-assembler-times "ldsw\t\[^\n\]*tldo_add" 2 { target lp64 } } } */
+/* { dg-final { scan-assembler-times "st\t\[^\n\]*tldo_add" 2 } } */
diff --git a/gcc/testsuite/gcc.target/sparc/tls-ld-int64.c b/gcc/testsuite/gcc.target/sparc/tls-ld-int64.c
new file mode 100644
index 00000000000..c1925df084f
--- /dev/null
+++ b/gcc/testsuite/gcc.target/sparc/tls-ld-int64.c
@@ -0,0 +1,24 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" }
+/* { dg-add-options tls } */
+/* { dg-require-effective-target lp64 } */
+
+#include <stdint.h>
+
+__thread int64_t var1 __attribute__((tls_model("local-dynamic")));
+__thread int64_t var2 __attribute__((tls_model("local-dynamic")));
+
+int64_t sum (void)
+{
+  return var1 + var2;
+}
+
+void set (int64_t i)
+{
+  var1 = i;
+  var2 = i;
+}
+
+/* { dg-final { scan-assembler-times "__tls_get_addr" 2 } } */
+/* { dg-final { scan-assembler-times "ldx\t\[^\n\]*tldo_add" 2 } } */
+/* { dg-final { scan-assembler-times "stx\t\[^\n\]*tldo_add" 2 } } */
diff --git a/gcc/testsuite/gcc.target/sparc/tls-ld-int8.c b/gcc/testsuite/gcc.target/sparc/tls-ld-int8.c
new file mode 100644
index 00000000000..a07cffc37f8
--- /dev/null
+++ b/gcc/testsuite/gcc.target/sparc/tls-ld-int8.c
@@ -0,0 +1,39 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" }
+/* { dg-add-options tls } */
+
+#include <stdint.h>
+
+__thread int8_t var1 __attribute__((tls_model("local-dynamic")));
+__thread int8_t var2 __attribute__((tls_model("local-dynamic")));
+
+int8_t sum (void)
+{
+  return var1 + var2;
+}
+
+int16_t ext16_sum (void)
+{
+  return (int16_t)var1 + (int16_t)var2;
+}
+
+int32_t ext32_sum (void)
+{
+  return (int32_t)var1 + (int32_t)var2;
+}
+
+long ext_sum (void)
+{
+  return (long)var1 + (long)var2;
+}
+
+void set (int8_t i)
+{
+  var1 = i;
+  var2 = i;
+}
+
+/* { dg-final { scan-assembler-times "__tls_get_addr" 5 } } */
+/* { dg-final { scan-assembler-times "ldub\t\[^\n\]*tldo_add" 2 } } */
+/* { dg-final { scan-assembler-times "ldsb\t\[^\n\]*tldo_add" 6 } } */
+/* { dg-final { scan-assembler-times "stb\t\[^\n\]*tldo_add" 2 } } */
diff --git a/gcc/testsuite/gcc.target/sparc/tls-ld-uint16.c b/gcc/testsuite/gcc.target/sparc/tls-ld-uint16.c
new file mode 100644
index 00000000000..41ee687b28c
--- /dev/null
+++ b/gcc/testsuite/gcc.target/sparc/tls-ld-uint16.c
@@ -0,0 +1,33 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" }
+/* { dg-add-options tls } */
+
+#include <stdint.h>
+
+__thread uint16_t var1 __attribute__((tls_model("local-dynamic")));
+__thread uint16_t var2 __attribute__((tls_model("local-dynamic")));
+
+uint16_t sum (void)
+{
+  return var1 + var2;
+}
+
+uint32_t ext32_sum (void)
+{
+  return (uint32_t)var1 + (uint32_t)var2;
+}
+
+unsigned long ext_sum (void)
+{
+  return (unsigned long)var1 + (unsigned long)var2;
+}
+
+void set (uint16_t i)
+{
+  var1 = i;
+  var2 = i;
+}
+
+/* { dg-final { scan-assembler-times "__tls_get_addr" 4 } } */
+/* { dg-final { scan-assembler-times "lduh\t\[^\n\]*tldo_add" 6 } } */
+/* { dg-final { scan-assembler-times "sth\t\[^\n\]*tldo_add" 2 } } */
diff --git a/gcc/testsuite/gcc.target/sparc/tls-ld-uint32.c b/gcc/testsuite/gcc.target/sparc/tls-ld-uint32.c
new file mode 100644
index 00000000000..9c7915372b9
--- /dev/null
+++ b/gcc/testsuite/gcc.target/sparc/tls-ld-uint32.c
@@ -0,0 +1,36 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" }
+/* { dg-add-options tls } */
+
+#include <stdint.h>
+
+__thread uint32_t var1 __attribute__((tls_model("local-dynamic")));
+__thread uint32_t var2 __attribute__((tls_model("local-dynamic")));
+
+uint32_t sum (void)
+{
+  return var1 + var2;
+}
+
+#if defined(__sparcv9) || defined(__arch64__)
+unsigned long ext_sum (void)
+{
+  return (unsigned long)var1 + (unsigned long)var2;
+}
+#else
+void *addr (void)
+{
+  return &var1;
+}
+#endif
+
+void set (int32_t i)
+{
+  var1 = i;
+  var2 = i;
+}
+
+/* { dg-final { scan-assembler-times "__tls_get_addr" 3 } } */
+/* { dg-final { scan-assembler-times "ld\t\[^\n\]*tldo_add" 2 } } */
+/* { dg-final { scan-assembler-times "lduw\t\[^\n\]*tldo_add" 2 { target lp64 } } } */
+/* { dg-final { scan-assembler-times "st\t\[^\n\]*tldo_add" 2 } } */
diff --git a/gcc/testsuite/gcc.target/sparc/tls-ld-uint8.c b/gcc/testsuite/gcc.target/sparc/tls-ld-uint8.c
new file mode 100644
index 00000000000..0dcff66eb15
--- /dev/null
+++ b/gcc/testsuite/gcc.target/sparc/tls-ld-uint8.c
@@ -0,0 +1,38 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" }
+/* { dg-add-options tls } */
+
+#include <stdint.h>
+
+__thread uint8_t var1 __attribute__((tls_model("local-dynamic")));
+__thread uint8_t var2 __attribute__((tls_model("local-dynamic")));
+
+uint8_t sum (void)
+{
+  return var1 + var2;
+}
+
+uint16_t ext16_sum (void)
+{
+  return (uint16_t)var1 + (uint16_t)var2;
+}
+
+uint32_t ext32_sum (void)
+{
+  return (uint32_t)var1 + (uint32_t)var2;
+}
+
+unsigned long ext_sum (void)
+{
+  return (unsigned long)var1 + (unsigned long)var2;
+}
+
+void set (uint8_t i)
+{
+  var1 = i;
+  var2 = i;
+}
+
+/* { dg-final { scan-assembler-times "__tls_get_addr" 5 } } */
+/* { dg-final { scan-assembler-times "ldub\t\[^\n\]*tldo_add" 8 } } */
+/* { dg-final { scan-assembler-times "stb\t\[^\n\]*tldo_add" 2 } } */
diff --git a/gcc/testsuite/gcc.target/x86_64/abi/avx/asm-support-darwin.s b/gcc/testsuite/gcc.target/x86_64/abi/avx/asm-support-darwin.s
new file mode 100644
index 00000000000..c070d65034a
--- /dev/null
+++ b/gcc/testsuite/gcc.target/x86_64/abi/avx/asm-support-darwin.s
@@ -0,0 +1,77 @@
+	.file	"asm-support-darwin.s"
+	.text
+	.p2align 4,,15
+	.globl _snapshot
+_snapshot:
+LFB3:
+	movq	%rax, _rax(%rip)
+	movq	%rbx, _rbx(%rip)
+	movq	%rcx, _rcx(%rip)
+	movq	%rdx, _rdx(%rip)
+	movq	%rdi, _rdi(%rip)
+	movq	%rsi, _rsi(%rip)
+	movq	%rbp, _rbp(%rip)
+	movq	%rsp, _rsp(%rip)
+	movq	%r8, _r8(%rip)
+	movq	%r9, _r9(%rip)
+	movq	%r10, _r10(%rip)
+	movq	%r11, _r11(%rip)
+	movq	%r12, _r12(%rip)
+	movq	%r13, _r13(%rip)
+	movq	%r14, _r14(%rip)
+	movq	%r15, _r15(%rip)
+	vmovdqu	%ymm0, _ymm_regs+0(%rip)
+	vmovdqu	%ymm1, _ymm_regs+32(%rip)
+	vmovdqu	%ymm2, _ymm_regs+64(%rip)
+	vmovdqu	%ymm3, _ymm_regs+96(%rip)
+	vmovdqu	%ymm4, _ymm_regs+128(%rip)
+	vmovdqu	%ymm5, _ymm_regs+160(%rip)
+	vmovdqu	%ymm6, _ymm_regs+192(%rip)
+	vmovdqu	%ymm7, _ymm_regs+224(%rip)
+	vmovdqu	%ymm8, _ymm_regs+256(%rip)
+	vmovdqu	%ymm9, _ymm_regs+288(%rip)
+	vmovdqu	%ymm10, _ymm_regs+320(%rip)
+	vmovdqu	%ymm11, _ymm_regs+352(%rip)
+	vmovdqu	%ymm12, _ymm_regs+384(%rip)
+	vmovdqu	%ymm13, _ymm_regs+416(%rip)
+	vmovdqu	%ymm14, _ymm_regs+448(%rip)
+	vmovdqu	%ymm15, _ymm_regs+480(%rip)
+	jmp	*_callthis(%rip)
+LFE3:
+	.p2align 4,,15
+	.globl _snapshot_ret
+_snapshot_ret:
+	movq	%rdi, _rdi(%rip)
+	subq	$8, %rsp
+	call	*_callthis(%rip)
+	addq	$8, %rsp
+	movq	%rax, _rax(%rip)
+	movq	%rdx, _rdx(%rip)
+	vmovdqu	%ymm0, _ymm_regs+0(%rip)
+	vmovdqu	%ymm1, _ymm_regs+32(%rip)
+	fstpt	_x87_regs(%rip)
+	fstpt	_x87_regs+16(%rip)
+	fldt	_x87_regs+16(%rip)
+	fldt	_x87_regs(%rip)
+	ret
+
+	.comm	_callthis,8,3
+	.comm	_rax,8,3
+	.comm	_rbx,8,3
+	.comm	_rcx,8,3
+	.comm	_rdx,8,3
+	.comm	_rsi,8,3
+	.comm	_rdi,8,3
+	.comm	_rsp,8,3
+	.comm	_rbp,8,3
+	.comm	_r8,8,3
+	.comm	_r9,8,3
+	.comm	_r10,8,3
+	.comm	_r11,8,3
+	.comm	_r12,8,3
+	.comm	_r13,8,3
+	.comm	_r14,8,3
+	.comm	_r15,8,3
+	.comm	_ymm_regs,512,5
+	.comm	_x87_regs,128,5
+	.comm   _volatile_var,8,3
diff --git a/gcc/testsuite/gfortran.dg/20181025-1.f b/gcc/testsuite/gfortran.dg/20181025-1.f
new file mode 100644
index 00000000000..1acbd72616c
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/20181025-1.f
@@ -0,0 +1,28 @@
+! { dg-do compile }
+! { dg-options "-Ofast" }
+! { dg-additional-options "-mavx2" { target { x86_64-*-* i?86-*-* } } }
+      SUBROUTINE FOO(EF3,CA,ZA,NATA,IC4,NFRGPT)
+      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
+      PARAMETER (MXATM=500)
+      COMMON DE(3,MXATM)
+      DIMENSION CA(3,NATA)
+      DIMENSION ZA(NATA)
+      DIMENSION EF3(3,NFRGPT)
+      DO II = 1,NATA
+         XII = XJ - CA(1,II)
+         YII = YJ - CA(2,II)
+         ZII = ZJ - CA(3,II)
+         RJII = SQRT(XII*XII + YII*YII + ZII*ZII)
+         R3 = RJII*RJII*RJII
+         IF (IC4.EQ.0) THEN
+            DE(1,II) = DE(1,II) - S2*ZA(II)*XII/R3
+            DE(2,II) = DE(2,II) - S2*ZA(II)*YII/R3
+            DE(3,II) = DE(3,II) - S2*ZA(II)*ZII/R3
+         ELSE 
+            EF3(1,IC4+II) = EF3(1,IC4+II) - S2*ZA(II)*XII/R3
+            EF3(2,IC4+II) = EF3(2,IC4+II) - S2*ZA(II)*YII/R3
+            EF3(3,IC4+II) = EF3(3,IC4+II) - S2*ZA(II)*ZII/R3
+         END IF
+      END DO
+      RETURN
+      END           
diff --git a/gcc/testsuite/gfortran.dg/alloc_comp_assign_16.f03 b/gcc/testsuite/gfortran.dg/alloc_comp_assign_16.f03
new file mode 100644
index 00000000000..892ea172e20
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/alloc_comp_assign_16.f03
@@ -0,0 +1,37 @@
+! { dg-do run }
+!
+! Test the fix for PR88393 in which a segfault occurred as indicated.
+!
+! Contributed by Janus Weil  <janus@gcc.gnu.org>
+!
+module m
+   implicit none
+   type :: t
+      character(len=:), allocatable :: cs
+   contains
+      procedure :: ass
+      generic :: assignment(=) => ass
+   end type
+contains
+   subroutine ass(a, b)
+      class(t), intent(inout) :: a
+      class(t), intent(in)    :: b
+      a%cs = b%cs
+      print *, "ass"
+   end subroutine
+end module
+
+program p
+   use m
+   implicit none
+   type :: t2
+      type(t) :: c
+   end type
+   type(t2), dimension(1:2) :: arr
+   arr(1)%c%cs = "abcd"
+   arr(2)%c = arr(1)%c  ! Segfault here.
+   print *, "done", arr(2)%c%cs, arr(2)%c%cs
+! Make sure with valgrind that there are no memory leaks.
+   deallocate (arr(1)%c%cs)
+   deallocate (arr(2)%c%cs)
+end
diff --git a/gcc/testsuite/gfortran.dg/allocate_alloc_opt_1.f90 b/gcc/testsuite/gfortran.dg/allocate_alloc_opt_1.f90
index 95571fdfe12..12005a6cc16 100644
--- a/gcc/testsuite/gfortran.dg/allocate_alloc_opt_1.f90
+++ b/gcc/testsuite/gfortran.dg/allocate_alloc_opt_1.f90
@@ -22,7 +22,7 @@ program a
   allocate(i(2))) ! { dg-error "Syntax error in ALLOCATE" }
   allocate(i(2), errmsg=err, errmsg=err) ! { dg-error "Redundant ERRMSG" }
   allocate(i(2), errmsg=err) ! { dg-warning "useless without a STAT" }
-  allocate(i(2), stat=j, errmsg=x) ! { dg-error "must be a scalar CHARACTER" }
+  allocate(i(2), stat=j, errmsg=x) ! { dg-error "shall be a scalar default CHARACTER" }
 
   allocate(err) ! { dg-error "neither a data pointer nor an allocatable" }
 
diff --git a/gcc/testsuite/gfortran.dg/allocate_alloc_opt_14.f90 b/gcc/testsuite/gfortran.dg/allocate_alloc_opt_14.f90
new file mode 100644
index 00000000000..6de43a7597f
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/allocate_alloc_opt_14.f90
@@ -0,0 +1,8 @@
+! { dg-do compile }
+program p
+   integer, allocatable :: arr(:)
+   integer :: stat
+   character(len=128, kind=4) :: errmsg = ' '
+   allocate (arr(3), stat=stat, errmsg=errmsg)  ! { dg-error "shall be a scalar default CHARACTER" }
+   print *, allocated(arr), stat, trim(errmsg)
+end
diff --git a/gcc/testsuite/gfortran.dg/allocate_assumed_charlen_4.f90 b/gcc/testsuite/gfortran.dg/allocate_assumed_charlen_4.f90
new file mode 100644
index 00000000000..1a5539a642b
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/allocate_assumed_charlen_4.f90
@@ -0,0 +1,39 @@
+! { dg-do run }
+!
+! Test the fix for PR82923, in which an ICE occurred because the
+! character length from 'getchars' scope was being used in the
+! automatic allocation of 'mine'.
+!
+! Contributed by "Werner Blokbuster"  <werner.blokbuster@gmail.com>
+!
+module m
+    implicit none
+contains
+    function getchars(my_len,my_size)
+        integer, intent(in) :: my_len, my_size
+        character(my_len) :: getchars(my_size)
+            getchars = 'A-'
+    end function getchars
+
+    function getchars2(my_len)
+        integer, intent(in) :: my_len
+        character(my_len) :: getchars2
+            getchars2 = 'B--'
+    end function getchars2
+end module m
+
+program testca
+    use m, only: getchars, getchars2
+    implicit none
+    character(:), allocatable :: mine(:)
+    character(:), allocatable :: mine2
+    integer :: i
+
+    ! ICE occured at this line:
+    mine = getchars(2,4)
+    if (any (mine .ne. [('A-', i = 1, 4)])) stop 1
+
+    ! The scalar version was fine and this will keep it so:
+    mine2 = getchars2(3)
+    if (mine2 .ne. 'B--') stop 2
+end program testca
diff --git a/gcc/testsuite/gfortran.dg/allocate_stat_2.f90 b/gcc/testsuite/gfortran.dg/allocate_stat_2.f90
index 7cf6d659ea2..a28a2536046 100644
--- a/gcc/testsuite/gfortran.dg/allocate_stat_2.f90
+++ b/gcc/testsuite/gfortran.dg/allocate_stat_2.f90
@@ -5,6 +5,6 @@ program main
   character(len=30), dimension(2) :: er
   integer, dimension (:), allocatable :: a
   allocate (a (16), stat = ier) ! { dg-error "must be a scalar INTEGER" }
-  allocate (a (14), stat=ier(1),errmsg=er) ! { dg-error "must be a scalar CHARACTER" }
+  allocate (a (14), stat=ier(1),errmsg=er) ! { dg-error "shall be a scalar default CHARACTER" }
 end
 
diff --git a/gcc/testsuite/gfortran.dg/allocate_with_mold_2.f90 b/gcc/testsuite/gfortran.dg/allocate_with_mold_2.f90
new file mode 100644
index 00000000000..fcf7a8a4425
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/allocate_with_mold_2.f90
@@ -0,0 +1,62 @@
+! { dg-do compile }
+! { dg-options "-fdump-tree-original" }
+!
+! Test the fix for PR87284 in which the indexing in allocate with mold
+! was incorrect for class array initialization and resulted in the valgrind
+! error:
+! "Conditional jump or move depends on uninitialised value(s)" at line 42.
+!
+! Contributed by Andrew Baldwin on clf.
+!
+      MODULE INTS_TYPE_MODULE
+        TYPE, ABSTRACT :: BASE_TYPE
+        END TYPE BASE_TYPE
+
+        TYPE, EXTENDS (BASE_TYPE) :: INTS_TYPE
+          INTEGER, ALLOCATABLE :: INTS(:)
+        END TYPE INTS_TYPE
+      CONTAINS
+        SUBROUTINE MOLD_ALLOCATE (IT_OBJS, MOLD_OBJ)
+          CLASS (BASE_TYPE), ALLOCATABLE, INTENT (OUT) :: IT_OBJS(:)
+          CLASS (BASE_TYPE), INTENT (IN) :: MOLD_OBJ
+
+          ALLOCATE (IT_OBJS(2), mold = MOLD_OBJ)
+
+          RETURN
+        END SUBROUTINE MOLD_ALLOCATE
+      END MODULE INTS_TYPE_MODULE
+
+      PROGRAM MFE
+        USE INTS_TYPE_MODULE
+        IMPLICIT NONE
+
+        CLASS (BASE_TYPE), ALLOCATABLE :: IT_OBJS(:)
+        INTEGER :: I
+        TYPE (INTS_TYPE) :: MOLD_OBJ
+
+        ALLOCATE (INTS_TYPE :: IT_OBJS(2))
+
+        SELECT TYPE (IT_OBJS)
+        TYPE IS (INTS_TYPE)
+          ALLOCATE (IT_OBJS(1)%INTS(10))
+
+          ALLOCATE (IT_OBJS(2)%INTS(10))
+        END SELECT
+
+
+        DEALLOCATE (IT_OBJS)
+
+        CALL MOLD_ALLOCATE (IT_OBJS, MOLD_OBJ)
+
+        IF (ALLOCATED(IT_OBJS)) THEN
+          IF (SIZE(IT_OBJS) .GE. 2) THEN
+            SELECT TYPE (IT_OBJS)
+            TYPE IS (INTS_TYPE)
+              ALLOCATE (IT_OBJS(1)%INTS(10))
+
+              ALLOCATE (IT_OBJS(2)%INTS(10))
+            END SELECT
+          END IF
+        END IF
+      END PROGRAM MFE
+! { dg-final { scan-tree-dump-times "it_objs->_vptr->_size" 1 "original" } }
diff --git a/gcc/testsuite/gfortran.dg/altreturn_9_0.f90 b/gcc/testsuite/gfortran.dg/altreturn_9_0.f90
new file mode 100644
index 00000000000..58715c7db40
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/altreturn_9_0.f90
@@ -0,0 +1,10 @@
+! { dg-do  run }
+! { dg-options -std=gnu }
+! { dg-additional-sources altreturn_9_1.f90 }
+! PR 89496 - wrong type for alternate return was generated
+
+program main
+  call sub(10, *10, 20)
+  stop 1
+10 continue
+end program main
diff --git a/gcc/testsuite/gfortran.dg/altreturn_9_1.f90 b/gcc/testsuite/gfortran.dg/altreturn_9_1.f90
new file mode 100644
index 00000000000..9549869a6be
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/altreturn_9_1.f90
@@ -0,0 +1,7 @@
+! { dg-do compile }
+! { dg-options "-std=gnu" }
+! See altreturn_9_0.f90
+subroutine sub(i, *, j)
+  if (i == 10 .and. j == 20) return 1
+  return
+end subroutine sub
diff --git a/gcc/testsuite/gfortran.dg/array_constructor_52.f90 b/gcc/testsuite/gfortran.dg/array_constructor_52.f90
new file mode 100644
index 00000000000..63581acf989
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/array_constructor_52.f90
@@ -0,0 +1,11 @@
+! { dg-do  run }
+! PR 84931 - long array constructors with type conversion were not
+! handled correctly.
+program test
+   implicit none
+   integer, parameter :: n = 2**16
+   real, dimension(n) :: y
+   integer :: i
+   y = (/ (1, i=1, n) /)
+   if (y(2) /= 1) stop 1
+end program test
diff --git a/gcc/testsuite/gfortran.dg/array_function_5.f90 b/gcc/testsuite/gfortran.dg/array_function_5.f90
index 9c95f800517..a2c66950e07 100644
--- a/gcc/testsuite/gfortran.dg/array_function_5.f90
+++ b/gcc/testsuite/gfortran.dg/array_function_5.f90
@@ -1,4 +1,4 @@
-! {  dg-do run }
+! { dg-do run }
 ! PR41278 internal compiler error related to matmul and transpose
 ! Test case prepared by Jerry DeLisle  <jvdelisle@gcc.gnu.org>
 ! Original test case by Chris <cmklaij@hetnet.nl>
diff --git a/gcc/testsuite/gfortran.dg/associate_30.f90 b/gcc/testsuite/gfortran.dg/associate_30.f90
index ad15d8bf576..ecc9ad06a56 100644
--- a/gcc/testsuite/gfortran.dg/associate_30.f90
+++ b/gcc/testsuite/gfortran.dg/associate_30.f90
@@ -8,8 +8,3 @@
       associate (x => null())   ! { dg-error "cannot be NULL()" }
       end associate
    end subroutine
-
-   subroutine s2
-      associate (x => [null()]) ! { dg-error "has no type" }
-      end associate
-   end subroutine
diff --git a/gcc/testsuite/gfortran.dg/associate_33.f03 b/gcc/testsuite/gfortran.dg/associate_33.f03
new file mode 100644
index 00000000000..1f87b22e8e4
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/associate_33.f03
@@ -0,0 +1,11 @@
+! { dg-do run }
+!
+! Test the fix for PR83898.f90
+!
+! Contributed by G Steinmetz  <gscfq@t-online.de>
+!
+program p
+   associate (x => ['1','2'])
+      if (any (x .ne. ['1','2'])) call abort
+   end associate
+end
diff --git a/gcc/testsuite/gfortran.dg/associate_44.f90 b/gcc/testsuite/gfortran.dg/associate_44.f90
new file mode 100644
index 00000000000..de42d8aedd8
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/associate_44.f90
@@ -0,0 +1,23 @@
+! { dg-do compile }
+!
+! Test the fix for PR56386
+!
+! Contributed by Vladimir Fuka  <vladimir.fuka@gmail.com>
+!
+subroutine  CustomSolidBodies
+   implicit none
+
+    type inner
+      real :: elev
+    end type
+
+    type :: outer
+      type(inner),dimension(0) :: PrPoints
+    end type
+
+    type(outer) :: SB
+
+    associate (Prter=>SB%PrPoints)
+       PrTer%elev=0                  ! ICE here
+    end associate
+end subroutine  CustomSolidBodies
diff --git a/gcc/testsuite/gfortran.dg/associate_46.f90 b/gcc/testsuite/gfortran.dg/associate_46.f90
new file mode 100644
index 00000000000..69cc189bfa4
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/associate_46.f90
@@ -0,0 +1,37 @@
+! { dg-do run }
+!
+! Check the fix for PR88143, in which the associate name caused
+! a segfault in resolve.c. Make sure that the associate construct
+! does its job correctly, as well as compiles.
+!
+! Contributed by Andrew Wood  <andrew@fluidgravity.co.uk>
+!
+MODULE m
+   IMPLICIT NONE
+   TYPE t
+      INTEGER, DIMENSION(:), ALLOCATABLE :: i
+   END TYPE
+   CONTAINS
+      SUBROUTINE s(x, idx1, idx2, k)
+         CLASS(*), DIMENSION(:), INTENT(IN), OPTIONAL :: x
+         INTEGER :: idx1, idx2, k
+         SELECT TYPE ( x )
+         CLASS IS ( t )
+            ASSOCIATE ( j => x(idx1)%i )
+               k = j(idx2)
+            END ASSOCIATE
+         END SELECT
+      END
+END
+
+  use m
+  class (t), allocatable :: c(:)
+  integer :: k
+  allocate (c(2))
+  allocate (c(1)%i, source = [3,2,1])
+  allocate (c(2)%i, source = [6,5,4])
+  call s(c, 1, 3, k)
+  if (k .ne. 1) stop 1
+  call s(c, 2, 1, k)
+  if (k .ne. 6) stop 2
+end
diff --git a/gcc/testsuite/gfortran.dg/assumed_charlen_parameter.f90 b/gcc/testsuite/gfortran.dg/assumed_charlen_parameter.f90
new file mode 100644
index 00000000000..2653f1b127a
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/assumed_charlen_parameter.f90
@@ -0,0 +1,9 @@
+! { dg-do compile }
+! PR fortran/82049
+! Original code contributed by John Harper <john dot harper at vuw dot ac dot nz>
+program ice ! f2003
+  implicit none
+  character(*), parameter:: a = 'ice', b = '*'
+  character(*), parameter:: c(2) = [character(len(a)) :: a, b]
+  print "(2A4)",adjustr(c)
+end program ice
diff --git a/gcc/testsuite/gfortran.dg/assumed_rank_14.f90 b/gcc/testsuite/gfortran.dg/assumed_rank_14.f90
new file mode 100644
index 00000000000..18271f91bad
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/assumed_rank_14.f90
@@ -0,0 +1,11 @@
+! { dg-do compile }
+! { dg-options "-std=legacy" }
+!
+! PR fortran/83184
+!
+
+integer n1(..) /1/
+! { dg-error "Assumed-rank array.*must be a dummy argument" "" { target *-*-* } 7 }
+! { dg-error "Assumed-rank variable.*actual argument" "" { target *-*-* } 7 }
+
+end
diff --git a/gcc/testsuite/gfortran.dg/assumed_rank_15.f90 b/gcc/testsuite/gfortran.dg/assumed_rank_15.f90
new file mode 100644
index 00000000000..efeb4a5f47b
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/assumed_rank_15.f90
@@ -0,0 +1,11 @@
+! { dg-do compile }
+! { dg-options "-fdec-structure" }
+!
+! PR fortran/83184
+!
+
+structure /s/
+  integer n(..) /1/ ! { dg-error "must have an explicit shape" }
+end structure
+
+end
diff --git a/gcc/testsuite/gfortran.dg/assumed_type_2.f90 b/gcc/testsuite/gfortran.dg/assumed_type_2.f90
index f1a20747884..d2bc4cfc496 100644
--- a/gcc/testsuite/gfortran.dg/assumed_type_2.f90
+++ b/gcc/testsuite/gfortran.dg/assumed_type_2.f90
@@ -157,7 +157,7 @@ end
 ! { dg-final { scan-tree-dump-times "sub_scalar .\\(struct t1 .\\) array_class_t1_alloc._data.data" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "sub_scalar .\\(struct t1 .\\) \\(array_class_t1_ptr._data.dat" 1 "original" } }
 
-! { dg-final { scan-tree-dump-times "sub_array_assumed \\(D" 3 "original" } }
+! { dg-final { scan-tree-dump-times "sub_array_assumed \\(D" 4 "original" } }
 ! { dg-final { scan-tree-dump-times " = _gfortran_internal_pack \\(&parm" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "sub_array_assumed \\(&array_int\\)" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "sub_array_assumed \\(\\(real\\(kind=4\\).0:. . restrict\\) array_real_alloc.data" 1 "original" } }
@@ -166,7 +166,7 @@ end
 ! { dg-final { scan-tree-dump-times "sub_array_assumed \\(\\(struct t1.0:. .\\) parm" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "sub_array_assumed \\(\\(struct t2.0:. . restrict\\) array_t2_alloc.data\\);" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "sub_array_assumed \\(\\(struct t1.0:. . restrict\\) array_class_t1_alloc._data.data\\);" 1 "original" } }
-! { dg-final { scan-tree-dump-times "sub_array_assumed \\(\\(struct t1.0:. .\\) array_class_t1_ptr._data.data\\);" 1 "original" } }
+! { dg-final { scan-tree-dump-times "sub_array_assumed \\(\\(struct t1.0:. .\\) array_class_t1_ptr._data.data\\);" 0 "original" } }
 
 ! { dg-final { scan-tree-dump-times "sub_array_shape \\(&array_real_alloc," 1 "original" } }
 ! { dg-final { scan-tree-dump-times "sub_array_shape \\(&array_char_ptr," 1 "original" } }
diff --git a/gcc/testsuite/gfortran.dg/automatic_module_variable.f90 b/gcc/testsuite/gfortran.dg/automatic_module_variable.f90
index 201dcf4e1d3..ab041fcf4f5 100644
--- a/gcc/testsuite/gfortran.dg/automatic_module_variable.f90
+++ b/gcc/testsuite/gfortran.dg/automatic_module_variable.f90
@@ -1,10 +1,12 @@
 ! { dg-do compile }
 ! Tests fix for PR15976
 !
+! Error message update with patch for PR fortran/83633
+!
 module sd
   integer, parameter :: n = 20
   integer :: i(n)
-  integer :: j(m) ! { dg-error "must have constant shape" }
+  integer :: j(m) ! { dg-error "array with nonconstant bounds" }
   integer, pointer :: p(:)
   integer, allocatable :: q(:)
 contains
diff --git a/gcc/testsuite/gfortran.dg/bad_automatic_objects_1.f90 b/gcc/testsuite/gfortran.dg/bad_automatic_objects_1.f90
index 27344186194..61db2174e5b 100644
--- a/gcc/testsuite/gfortran.dg/bad_automatic_objects_1.f90
+++ b/gcc/testsuite/gfortran.dg/bad_automatic_objects_1.f90
@@ -5,16 +5,18 @@
 !
 ! Contributed by Joost VandeVondele  <jv244@cam.ac.uk>
 !
+! Error message update with patch for PR fortran/83633
+!
 module foo
   integer    ::  i
 end module foo
 module bar
   use foo
-  integer, dimension (i) :: j ! { dg-error "must have constant shape" }
+  integer, dimension (i) :: j ! { dg-error "array with nonconstant bounds" }
   character (len = i) :: c1   ! { dg-error "must have constant character length" }
 end module bar
 program foobar
   use foo
-  integer, dimension (i) :: k ! { dg-error "must have constant shape" }
+  integer, dimension (i) :: k ! { dg-error "array with nonconstant bounds" }
   character (len = i) :: c2   ! { dg-error "must have constant character length" }
 end program foobar
diff --git a/gcc/testsuite/gfortran.dg/binding_label_tests_30.f90 b/gcc/testsuite/gfortran.dg/binding_label_tests_30.f90
new file mode 100644
index 00000000000..168d4b52f2d
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/binding_label_tests_30.f90
@@ -0,0 +1,7 @@
+! { dg-do compile }
+! Make sure this error is flagged.
+subroutine foo() ! { dg-error "is already being used as a SUBROUTINE" }
+end subroutine foo
+
+subroutine bar() bind(C,name="foo") ! { dg-error "is already being used as a SUBROUTINE" }
+end subroutine bar
diff --git a/gcc/testsuite/gfortran.dg/binding_label_tests_31.f90 b/gcc/testsuite/gfortran.dg/binding_label_tests_31.f90
new file mode 100644
index 00000000000..e914c66a7b8
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/binding_label_tests_31.f90
@@ -0,0 +1,19 @@
+! { dg-do compile }
+! PR fortran/66695 - this used to ICE.
+! Original test case by Vladimir Fuka.
+module mod
+  implicit none
+contains
+    integer function F()
+    end function
+end module
+    
+module mod_C
+  use mod
+  implicit none
+contains
+  subroutine s()  bind(C, name="f")
+    integer :: x
+      x = F()
+  end subroutine
+end module
diff --git a/gcc/testsuite/gfortran.dg/binding_label_tests_32.f90 b/gcc/testsuite/gfortran.dg/binding_label_tests_32.f90
new file mode 100644
index 00000000000..f18df66a2cc
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/binding_label_tests_32.f90
@@ -0,0 +1,35 @@
+! { dg-do run }
+! PR 77746 - this used to crash during execution.
+! Original test case by Vladimir Fuka.
+module first
+  private
+  public execute
+  
+  interface execute
+    module procedure random_name
+  end interface
+  
+contains
+
+  subroutine random_name()
+  end subroutine
+end module
+
+module test
+  use first
+
+  implicit none
+
+contains
+
+  subroutine p_execute(i)  bind(C, name="random_name")
+    integer :: i
+
+    call execute()
+  end subroutine
+  
+end module
+
+  use test
+  call p_execute(1)
+end
diff --git a/gcc/testsuite/gfortran.dg/binding_label_tests_33.f90 b/gcc/testsuite/gfortran.dg/binding_label_tests_33.f90
new file mode 100644
index 00000000000..fdb9a887f60
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/binding_label_tests_33.f90
@@ -0,0 +1,39 @@
+! { dg-do run }
+! PR 79485 - used to crash because the wrong routine was called.
+module fmod1
+
+  contains
+
+  subroutine foo(i)
+    implicit none
+
+    integer, intent(inout) :: i
+
+    i=i+1
+
+  end subroutine foo
+
+end module fmod1
+
+module fmod2
+  use iso_c_binding
+  use fmod1, only : foo_first => foo
+
+  contains
+
+  subroutine foo(i) bind(c)
+    implicit none
+
+    integer, intent(inout) :: i
+
+    i=i+2
+    call foo_first(i)
+
+  end subroutine foo
+
+end module fmod2
+
+  use fmod2
+  
+  call foo(i)
+end
diff --git a/gcc/testsuite/gfortran.dg/blockdata_11.f90 b/gcc/testsuite/gfortran.dg/blockdata_11.f90
new file mode 100644
index 00000000000..4aee18b7c7a
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/blockdata_11.f90
@@ -0,0 +1,33 @@
+! { dg-do run }
+! PR 84394 - this used to complain about private procedures in
+! BLOCK data.
+module mod1
+   implicit none
+   type :: type1
+      integer :: i1
+   end type type1
+end module
+
+module mod2
+   implicit none
+   contains
+      subroutine sub1
+         integer vals
+         common /block1/ vals(5)
+         if (any(vals /= [1, 2, 3, 4, 5])) stop 1
+      end subroutine
+end module
+
+block data blkdat
+  use mod1
+  integer vals
+  common /block1/ vals(5)
+  data vals/1, 2, 3, 4, 5/
+end block data blkdat
+
+program main
+  use mod2, only: sub1
+  implicit none
+  call sub1
+end program
+
diff --git a/gcc/testsuite/gfortran.dg/c_funptr_1.f90 b/gcc/testsuite/gfortran.dg/c_funptr_1.f90
new file mode 100644
index 00000000000..541f0765960
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/c_funptr_1.f90
@@ -0,0 +1,38 @@
+! { dg-do preprocess }
+! { dg-additional-options "-cpp" }
+! PR 57048 - this used not to compile. Original test case by Angelo
+! Graziosi.  Only works if compiled c_funptr_1_mod.f90, hence the
+! do-nothing directive above.
+module procs
+  
+  implicit none
+  private
+
+  public WndProc
+
+contains
+  function WndProc()
+    integer :: WndProc
+    
+    WndProc = 0
+  end function WndProc
+end module procs
+
+function WinMain()
+  use, intrinsic :: iso_c_binding, only: C_INT,c_sizeof,c_funloc
+  use win32_types
+  use procs
+  implicit none
+
+  integer :: WinMain
+
+  type(WNDCLASSEX_T) :: WndClass
+
+  WndClass%cbSize = int(c_sizeof(Wndclass),C_INT)
+  WndClass%lpfnWndProc = c_funloc(WndProc)
+
+  WinMain = 0
+end function WinMain
+
+program main
+end 
diff --git a/gcc/testsuite/gfortran.dg/c_funptr_1_mod.f90 b/gcc/testsuite/gfortran.dg/c_funptr_1_mod.f90
new file mode 100644
index 00000000000..6db515bdf16
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/c_funptr_1_mod.f90
@@ -0,0 +1,16 @@
+! { dg-do  run }
+! { dg-additional-sources c_funptr_1.f90 }
+! Additional module to go with c_funptr_1.f90
+module win32_types
+  use, intrinsic :: iso_c_binding, only: C_INT,C_FUNPTR
+  implicit none
+  private
+
+  public WNDCLASSEX_T
+  type, bind(C) :: WNDCLASSEX_T
+     integer(C_INT) :: cbSize
+     type(C_FUNPTR) :: lpfnWndProc
+
+  end type WNDCLASSEX_T
+
+end module win32_types
diff --git a/gcc/testsuite/gfortran.dg/c_ptr_tests_19.f90 b/gcc/testsuite/gfortran.dg/c_ptr_tests_19.f90
new file mode 100644
index 00000000000..2cb0b183c88
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/c_ptr_tests_19.f90
@@ -0,0 +1,36 @@
+! { dg-do run }
+
+! PR 71544 - this failed with some optimization options due to a
+! pointer not being marked as escaping.
+
+module store_cptr
+    use, intrinsic :: iso_c_binding
+    implicit none
+    public
+    type(c_ptr), save :: cptr
+end module store_cptr
+
+subroutine init()
+    use, intrinsic :: iso_c_binding
+    implicit none
+    integer(c_int), pointer :: a
+    allocate(a)
+    call save_cptr(c_loc(a))
+    a = 100
+end subroutine init
+
+subroutine save_cptr(cptr_in)
+    use store_cptr
+    implicit none
+    type(c_ptr), intent(in) :: cptr_in
+    cptr = cptr_in
+end subroutine save_cptr
+
+program init_fails
+    use store_cptr
+    implicit none
+    integer(c_int), pointer :: val
+    call init()
+    call c_f_pointer(cptr,val)
+    if (val /= 100) stop 1
+end program init_fails
diff --git a/gcc/testsuite/gfortran.dg/char_result_18.f90 b/gcc/testsuite/gfortran.dg/char_result_18.f90
new file mode 100644
index 00000000000..f47c88ad4b3
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/char_result_18.f90
@@ -0,0 +1,10 @@
+! { dg-do compile }
+!
+! Tests the fix for PR80657.
+!
+! Contributed by Vittorio Zecca  <zeccav@gmail.com>
+!
+function f(x)
+implicit character(len(f)) (x) ! { dg-error "Self reference in character length" }
+character(len(x)) f
+end
diff --git a/gcc/testsuite/gfortran.dg/charlen_17.f90 b/gcc/testsuite/gfortran.dg/charlen_17.f90
new file mode 100644
index 00000000000..6b766d8f433
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/charlen_17.f90
@@ -0,0 +1,14 @@
+! { dg-do compile }
+! PR 87673 - used to cause errors about non-pure functions.
+
+module x
+  implicit none
+contains
+  pure function foo() result(res)
+    character(len=:), allocatable :: res
+    allocate (character(bar()) :: res)
+  end function foo
+  pure integer function bar()
+    bar = 1
+  end function bar
+end module x
diff --git a/gcc/testsuite/gfortran.dg/class_66.f90 b/gcc/testsuite/gfortran.dg/class_66.f90
index 1843ea7eb69..5a7b87aea5b 100644
--- a/gcc/testsuite/gfortran.dg/class_66.f90
+++ b/gcc/testsuite/gfortran.dg/class_66.f90
@@ -1,4 +1,4 @@
-! { dg- do run }
+! { dg-do run }
 !
 ! Test the fix for PR78641 in which an ICE occured on assignment
 ! of a class array constructor to a derived type array.
diff --git a/gcc/testsuite/gfortran.dg/class_67.f90 b/gcc/testsuite/gfortran.dg/class_67.f90
new file mode 100644
index 00000000000..20029939d64
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/class_67.f90
@@ -0,0 +1,55 @@
+! { dg-do run }
+!
+! Test the fix for PR78990 in which the scalarization of the assignment
+! in the main program failed for two reasons: (i) The conversion of 'v1'
+! into a class actual was being done after the call to 'return_t1', giving
+! rise to the ICE reported in comment #1; and (ii) The 'info' descriptor,
+! required for scalarization was not set, which gave rise to the ICE noted
+! by the contributor.
+!
+! Contributed by Chris Macmackin  <cmacmackin@gmail.com>
+!
+module test_type
+  implicit none
+
+  type t1
+     integer :: i
+   contains
+     procedure :: assign
+     generic :: assignment(=) => assign
+  end type t1
+
+contains
+
+  elemental subroutine assign(this,rhs)
+    class(t1), intent(inout) :: this
+    class(t1), intent(in) :: rhs
+    this%i = rhs%i
+  end subroutine assign
+
+  function return_t1(arg)
+    class(t1), dimension(:), intent(in) :: arg
+    class(t1), dimension(:), allocatable :: return_t1
+    allocate(return_t1(size(arg)), source=arg)
+  end function return_t1
+
+  function return_t1_p(arg)
+    class(t1), dimension(:), intent(in), target :: arg
+    class(t1), dimension(:), pointer :: return_t1_p
+    return_t1_p => arg
+  end function return_t1_p
+end module test_type
+
+program test
+  use test_type
+  implicit none
+
+  type(t1), dimension(3) :: v1, v2
+  v1%i = [1,2,3]
+  v2 = return_t1(v1)
+  if (any (v2%i .ne. v1%i)) call abort
+
+  v1%i = [4,5,6]
+  v2 = return_t1_p(v1)
+  if (any (v2%i .ne. v1%i)) call abort
+end program test
diff --git a/gcc/testsuite/gfortran.dg/coarray/caf.exp b/gcc/testsuite/gfortran.dg/coarray/caf.exp
index edac7dc981f..1f21454cb4b 100644
--- a/gcc/testsuite/gfortran.dg/coarray/caf.exp
+++ b/gcc/testsuite/gfortran.dg/coarray/caf.exp
@@ -51,11 +51,21 @@ proc dg-compile-aux-modules { args } {
     global gfortran_test_path
     global gfortran_aux_module_flags
     if { [llength $args] != 2 } {
-	error "dg-set-target-env-var: needs one argument"
+	error "dg-compile-aux-modules: needs one argument"
 	return
     }
+
+    set level [info level]
+    if { [info procs dg-save-unknown] != [list] } {
+	rename dg-save-unknown dg-save-unknown-level-$level
+    }
+
     dg-test $gfortran_test_path/[lindex $args 1] "" $gfortran_aux_module_flags
-    # cleanup-modules isn't intentionally invoked here.
+    # cleanup-modules is intentionally not invoked here.
+
+    if { [info procs dg-save-unknown-level-$level] != [list] } {
+	rename dg-save-unknown-level-$level dg-save-unknown
+    }
 }
 
 # Add -latomic only where supported.  Assume built-in support elsewhere.
diff --git a/gcc/testsuite/gfortran.dg/coarray/event_3.f08 b/gcc/testsuite/gfortran.dg/coarray/event_3.f08
index f6e28b78c8d..60d3193f776 100644
--- a/gcc/testsuite/gfortran.dg/coarray/event_3.f08
+++ b/gcc/testsuite/gfortran.dg/coarray/event_3.f08
@@ -3,9 +3,9 @@
 ! Check PR fortran/70696 is fixed.
 
 program global_event
-  use iso_fortran_env , only : event_type
+  use iso_fortran_env, only : event_type
   implicit none
-  type(event_type) :: x[*]
+  type(event_type), save :: x[*]
   
   call exchange
   contains
diff --git a/gcc/testsuite/gfortran.dg/coarray/get_to_indexed_array_1.f90 b/gcc/testsuite/gfortran.dg/coarray/get_to_indexed_array_1.f90
new file mode 100644
index 00000000000..04714711707
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/coarray/get_to_indexed_array_1.f90
@@ -0,0 +1,32 @@
+! { dg-do run }
+
+! Test that index vector on lhs of caf-expression works correctly.
+
+program pr81773
+
+  integer, parameter :: ndim = 5
+  integer :: i
+  integer :: vec(ndim) = -1
+  integer :: res(ndim)[*] = [ (i, i=1, ndim) ]
+  type T
+    integer :: padding
+    integer :: dest(ndim)
+    integer :: src(ndim)
+  end type
+
+  type(T) :: dest
+  type(T), allocatable :: caf[:]
+
+  vec([ndim, 3, 1]) = res(1:3)[1]
+  if (any (vec /= [ 3, -1, 2, -1, 1])) stop 1
+
+  dest = T(42, [ ( -1, i = 1, ndim ) ], [ ( i - 2, i = ndim, 1, -1) ] )
+  dest%dest([ 4,3,2 ]) = res(3:5)[1]
+  if (any (dest%dest /= [-1, 5, 4, 3, -1])) stop 2
+
+  vec(:) = -1
+  allocate(caf[*], source = T(42, [ ( -1, i = 1, ndim ) ], [ ( i - 2, i = ndim, 1, -1) ] ))
+  vec([ 5,3,2 ]) = caf[1]%src(2:4)
+  if (any (vec /= [ -1, 0, 1, -1, 2])) stop 3
+end
+
diff --git a/gcc/testsuite/gfortran.dg/coarray/get_to_indirect_array.f90 b/gcc/testsuite/gfortran.dg/coarray/get_to_indirect_array.f90
new file mode 100644
index 00000000000..efb78353637
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/coarray/get_to_indirect_array.f90
@@ -0,0 +1,28 @@
+! { dg-do run }
+!
+! Test that pr81773/fortran is fixed.
+
+program get_to_indexed_array
+
+  integer, parameter :: ndim = 5
+  integer :: i
+  integer :: vec(1:ndim) = 0
+  integer :: indx(1:2) = [3, 2]
+  integer :: mat(1:ndim, 1:ndim) = 0
+  integer :: res(1:ndim)[*]=[ (i, i=1, ndim) ]
+
+  ! No sync needed, because this test always is running on single image
+  vec([ndim , 1]) = res(1:2)[1]
+  if (vec(1) /= res(2) .or. vec(ndim) /= res(1)) then
+    print *,"vec: ", vec, " on image: ", this_image()
+    stop 1
+  end if
+
+  mat(2:3,[indx(:)]) = reshape(res(1:4)[1], [2, 2])
+  if (any(mat(2:3, 3:2:-1) /= reshape(res(1:4), [2,2]))) then
+    print *, "mat: ", mat, " on image: ", this_image()
+    stop 2
+  end if
+end
+
+! vim:ts=2:sts=2:sw=2:
diff --git a/gcc/testsuite/gfortran.dg/coarray_3.f90 b/gcc/testsuite/gfortran.dg/coarray_3.f90
index aba4eb1bc84..d152ce1b2bd 100644
--- a/gcc/testsuite/gfortran.dg/coarray_3.f90
+++ b/gcc/testsuite/gfortran.dg/coarray_3.f90
@@ -13,7 +13,7 @@ end critical fkl ! { dg-error "Expecting END PROGRAM" }
 
 sync all (stat=1) ! { dg-error "Syntax error in SYNC ALL" }
 sync all ( stat = n,stat=k) ! { dg-error "Redundant STAT" }
-sync memory (errmsg=str)
+sync memory (errmsg=str) ! { dg-error "must be a scalar CHARACTER variable" }
 sync memory (errmsg=n) ! { dg-error "must be a scalar CHARACTER variable" }
 sync images (*, stat=1.0) ! { dg-error "Syntax error in SYNC IMAGES" }
 sync images (-1) ! { dg-error "must between 1 and num_images" }
diff --git a/gcc/testsuite/gfortran.dg/coarray_45.f90 b/gcc/testsuite/gfortran.dg/coarray_45.f90
new file mode 100644
index 00000000000..87763563efe
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/coarray_45.f90
@@ -0,0 +1,24 @@
+! { dg-do compile }
+! { dg-options "-fcoarray=lib -lcaf_single " }
+!
+! Test the fix for PR83076
+!
+module m
+   type t
+      integer, pointer :: z
+   end type
+   type(t) :: ptr
+contains
+   function g(x)
+      type(t) :: x[*]
+      if (associated (x%z, ptr%z)) deallocate (x%z) ! This used to ICE with -fcoarray=lib
+   end
+end module
+
+  use m
+contains
+   function f(x)
+      type(t) :: x[*]
+      if (associated (x%z, ptr%z)) deallocate (x%z)
+   end
+end
diff --git a/gcc/testsuite/gfortran.dg/coarray_46.f90 b/gcc/testsuite/gfortran.dg/coarray_46.f90
new file mode 100644
index 00000000000..273c6e86840
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/coarray_46.f90
@@ -0,0 +1,17 @@
+! { dg-do compile }
+! { dg-options "-fcoarray=lib -lcaf_single" }
+!
+! Test the fix for PR83319
+!
+module foo_module
+  implicit none
+  type foo
+    integer, allocatable :: i(:)
+  end type
+end module
+
+  use foo_module
+  implicit none
+  type(foo), save :: bar[*]
+  allocate(bar%i(1))     ! Used to ICE here.
+end
diff --git a/gcc/testsuite/gfortran.dg/coarray_8.f90 b/gcc/testsuite/gfortran.dg/coarray_8.f90
index db6eb6c2e2d..060f94118ac 100644
--- a/gcc/testsuite/gfortran.dg/coarray_8.f90
+++ b/gcc/testsuite/gfortran.dg/coarray_8.f90
@@ -145,7 +145,7 @@ end module mmm4
 
 subroutine tfgh()
   integer :: i(2)
-  DATA i/(i, i=1,2)/ ! { dg-error "Expected PARAMETER symbol" }
+  DATA i/(i, i=1,2)/ ! { dg-error "Syntax error in DATA" }
   do i = 1, 5 ! { dg-error "cannot be an array" }
   end do ! { dg-error "Expecting END SUBROUTINE" }
 end subroutine tfgh
@@ -153,7 +153,7 @@ end subroutine tfgh
 subroutine tfgh2()
   integer, save :: x[*]
   integer :: i(2)
-  DATA i/(x, x=1,2)/ ! { dg-error "Expected PARAMETER symbol" }
+  DATA i/(x, x=1,2)/ ! { dg-error "Syntax error in DATA" }
   do x = 1, 5 ! { dg-error "cannot be a coarray" }
   end do ! { dg-error "Expecting END SUBROUTINE" }
 end subroutine tfgh2
diff --git a/gcc/testsuite/gfortran.dg/coarray_allocate_11.f90 b/gcc/testsuite/gfortran.dg/coarray_allocate_11.f90
new file mode 100644
index 00000000000..0e806f0955b
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/coarray_allocate_11.f90
@@ -0,0 +1,15 @@
+! { dg-do compile }
+! { dg-additional-options -fcoarray=single }
+program p
+   integer, allocatable :: z[:,:]
+   integer :: i
+   allocate (z[1:,*]) ! { dg-error "Bad array specification in ALLOCATE statement" }
+   allocate (z[:2,*]) ! { dg-error "Bad array specification in ALLOCATE statement" }
+   allocate (z[2:1,*]) ! { dg-error "Upper cobound is less than lower cobound" }
+   allocate (z[:0,*]) ! { dg-error "Bad array specification in ALLOCATE statement" }
+   allocate (z[0,*]) ! { dg-error "Upper cobound is less than lower cobound" }
+   allocate (z[1,*]) ! This is OK
+   allocate (z[1:1,*]) ! This is OK
+   allocate (z[i:i,*]) ! This is OK
+   allocate (z[i:i-1,*]) ! { dg-error "Upper cobound is less than lower cobound" }
+end
diff --git a/gcc/testsuite/gfortran.dg/coarray_data_1.f90 b/gcc/testsuite/gfortran.dg/coarray_data_1.f90
new file mode 100644
index 00000000000..94ab4c26cec
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/coarray_data_1.f90
@@ -0,0 +1,11 @@
+! { dg-do  run }
+! { dg-options "-fcoarray=lib -lcaf_single " }
+! PR 71066 - this used to ICE
+program p
+   real :: a(2,2)[*]
+   integer :: b(2,2)[*]
+   data a /4*0.0/
+   data b /1234, 2345, 3456, 4567/
+   if (any (a /= 0.0)) stop 1
+   if (any (b /= reshape([1234, 2345, 3456, 4567],[2,2]))) stop 2
+end
diff --git a/gcc/testsuite/gfortran.dg/coarray_dependency_1.f90 b/gcc/testsuite/gfortran.dg/coarray_dependency_1.f90
new file mode 100644
index 00000000000..dc4cbacba1e
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/coarray_dependency_1.f90
@@ -0,0 +1,11 @@
+! { dg-do compile }
+! { dg-options "-fcoarray=lib -lcaf_single" }
+!
+! Check that reffing x on both sides of a coarray send does not ICE. 
+! PR 85507
+
+program check_dependency
+  integer :: x[*]
+  x[42] = x
+end program check_dependency
+
diff --git a/gcc/testsuite/gfortran.dg/coarray_lib_comm_1.f90 b/gcc/testsuite/gfortran.dg/coarray_lib_comm_1.f90
index 8ad6b081a13..df3b9d439b1 100644
--- a/gcc/testsuite/gfortran.dg/coarray_lib_comm_1.f90
+++ b/gcc/testsuite/gfortran.dg/coarray_lib_comm_1.f90
@@ -38,9 +38,8 @@ B(1:5) = B(3:7)
 if (any (A-B /= 0)) call abort
 end
 
-! { dg-final { scan-tree-dump-times "_gfortran_caf_get \\\(caf_token.0, \\\(integer\\\(kind=\[48\]\\\)\\\) parm.\[0-9\]+.data - \\\(integer\\\(kind=\[48\]\\\)\\\) a, 1, &parm.\[0-9\]+, 0B, &parm.\[0-9\]+, 4, 4, 0, 0B\\\);" 1 "original" } }
-! { dg-final { scan-tree-dump-times "_gfortran_caf_get \\\(caf_token.0, \\\(integer\\\(kind=\[48\]\\\)\\\) parm.\[0-9\]+.data - \\\(integer\\\(kind=\[48\]\\\)\\\) a, 1, &parm.\[0-9\]+, 0B, &parm.\[0-9\]+, 4, 4, 1, 0B\\\);" 1 "original" } }
+! { dg-final { scan-tree-dump-times "_gfortran_caf_get \\\(caf_token.0, \\\(integer\\\(kind=\[48\]\\\)\\\) parm.\[0-9\]+.data - \\\(integer\\\(kind=\[48\]\\\)\\\) a, 1, &parm.\[0-9\]+, 0B, &parm.\[0-9\]+, 4, 4, 1, 0B\\\);" 2 "original" } }
 ! { dg-final { scan-tree-dump-times "_gfortran_caf_get \\\(caf_token.0, \\\(integer\\\(kind=\[48\]\\\)\\\) parm.\[0-9\]+.data - \\\(integer\\\(kind=\[48\]\\\)\\\) a, 1, &parm.\[0-9\]+, 0B, &p, 4, 4, 1, 0B\\\);" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "_gfortran_caf_get \\\(caf_token.1, \\\(integer\\\(kind=\[48\]\\\)\\\) parm.\[0-9\]+.data - \\\(integer\\\(kind=\[48\]\\\)\\\) b, 1, &parm.\[0-9\]+, 0B, &p, 4, 4, 0, 0B\\\);" 1 "original" } }
-! { dg-final { scan-tree-dump-times "_gfortran_caf_sendget \\\(caf_token.0, \\\(integer\\\(kind=\[48\]\\\)\\\) parm.\[0-9\]+.data - \\\(integer\\\(kind=\[48\]\\\)\\\) a, 1, &parm.\[0-9\]+, 0B, caf_token.0, \\\(integer\\\(kind=\[48\]\\\)\\\) parm.\[0-9\]+.data - \\\(integer\\\(kind=\[48\]\\\)\\\) a, 1, &parm.\[0-9\]+, 0B, 4, 4, 0, 0B\\\);" 1 "original" } }
+! { dg-final { scan-tree-dump-times "_gfortran_caf_sendget \\\(caf_token.0, \\\(integer\\\(kind=\[48\]\\\)\\\) parm.\[0-9\]+.data - \\\(integer\\\(kind=\[48\]\\\)\\\) a, 1, &parm.\[0-9\]+, 0B, caf_token.0, \\\(integer\\\(kind=\[48\]\\\)\\\) parm.\[0-9\]+.data - \\\(integer\\\(kind=\[48\]\\\)\\\) a, 1, &parm.\[0-9\]+, 0B, 4, 4, 1, 0B\\\);" 1 "original" } }
 
diff --git a/gcc/testsuite/gfortran.dg/coarray_lock_7.f90 b/gcc/testsuite/gfortran.dg/coarray_lock_7.f90
index 10c390f1860..04905ca589d 100644
--- a/gcc/testsuite/gfortran.dg/coarray_lock_7.f90
+++ b/gcc/testsuite/gfortran.dg/coarray_lock_7.f90
@@ -35,8 +35,8 @@ end
 ! { dg-final { scan-tree-dump-times "_gfortran_caf_lock \\(caf_token.., 0, 0, 0B, 0B, 0B, 0\\);" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "_gfortran_caf_unlock \\(caf_token.., 0, 0, 0B, 0B, 0\\);" 1 "original" } }
 
-! { dg-final { scan-tree-dump-times "_gfortran_caf_lock \\(caf_token.., \\(3 - \\(integer\\(kind=4\\)\\) parm...dim\\\[0\\\].lbound\\) \\+ \\(integer\\(kind=4\\)\\) MAX_EXPR <\\(parm...dim\\\[0\\\].ubound - parm...dim\\\[0\\\].lbound\\) \\+ 1, 0> \\* \\(3 - \\(integer\\(kind=4\\)\\) parm...dim\\\[1\\\].lbound\\), 0, 0B, &ii, 0B, 0\\);|_gfortran_caf_lock \\(caf_token.1, \\(3 - parm...dim\\\[0\\\].lbound\\) \\+ MAX_EXPR <\\(parm...dim\\\[0\\\].ubound - parm...dim\\\[0\\\].lbound\\) \\+ 1, 0> \\* \\(3 - parm...dim\\\[1\\\].lbound\\), 0, 0B, &ii, 0B, 0\\);" 1 "original" } }
-! { dg-final { scan-tree-dump-times "_gfortran_caf_unlock \\(caf_token.., \\(2 - \\(integer\\(kind=4\\)\\) parm...dim\\\[0\\\].lbound\\) \\+ \\(integer\\(kind=4\\)\\) MAX_EXPR <\\(parm...dim\\\[0\\\].ubound - parm...dim\\\[0\\\].lbound\\) \\+ 1, 0> \\* \\(3 - \\(integer\\(kind=4\\)\\) parm...dim\\\[1\\\].lbound\\), 0, &ii, 0B, 0\\);|_gfortran_caf_unlock \\(caf_token.., \\(2 - parm...dim\\\[0\\\].lbound\\) \\+ MAX_EXPR <\\(parm...dim\\\[0\\\].ubound - parm...dim\\\[0\\\].lbound\\) \\+ 1, 0> \\* \\(3 - parm...dim\\\[1\\\].lbound\\), 0, &ii, 0B, 0\\);" 1 "original" } }
+! { dg-final { scan-tree-dump-times "_gfortran_caf_lock \\(caf_token.., \\(3 - \\(integer\\(kind=4\\)\\) parm....dim\\\[0\\\].lbound\\) \\+ \\(integer\\(kind=4\\)\\) MAX_EXPR <\\(parm....dim\\\[0\\\].ubound - parm....dim\\\[0\\\].lbound\\) \\+ 1, 0> \\* \\(3 - \\(integer\\(kind=4\\)\\) parm....dim\\\[1\\\].lbound\\), 0, 0B, &ii, 0B, 0\\);|_gfortran_caf_lock \\(caf_token.1, \\(3 - parm....dim\\\[0\\\].lbound\\) \\+ MAX_EXPR <\\(parm....dim\\\[0\\\].ubound - parm....dim\\\[0\\\].lbound\\) \\+ 1, 0> \\* \\(3 - parm....dim\\\[1\\\].lbound\\), 0, 0B, &ii, 0B, 0\\);" 1 "original" } }
+! { dg-final { scan-tree-dump-times "_gfortran_caf_unlock \\(caf_token.., \\(2 - \\(integer\\(kind=4\\)\\) parm....dim\\\[0\\\].lbound\\) \\+ \\(integer\\(kind=4\\)\\) MAX_EXPR <\\(parm....dim\\\[0\\\].ubound - parm....dim\\\[0\\\].lbound\\) \\+ 1, 0> \\* \\(3 - \\(integer\\(kind=4\\)\\) parm....dim\\\[1\\\].lbound\\), 0, &ii, 0B, 0\\);|_gfortran_caf_unlock \\(caf_token.., \\(2 - parm....dim\\\[0\\\].lbound\\) \\+ MAX_EXPR <\\(parm....dim\\\[0\\\].ubound - parm....dim\\\[0\\\].lbound\\) \\+ 1, 0> \\* \\(3 - parm....dim\\\[1\\\].lbound\\), 0, &ii, 0B, 0\\);" 1 "original" } }
 
 ! { dg-final { scan-tree-dump-times "_gfortran_caf_lock \\(three.token, 0, 5 - \\(integer\\(kind=4\\)\\) three.dim\\\[0\\\].lbound, &acquired.\[0-9\]+, 0B, 0B, 0\\);|_gfortran_caf_lock \\(three.token, 0, 5 - three.dim\\\[0\\\].lbound, &acquired.\[0-9\]+, 0B, 0B, 0\\);" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "_gfortran_caf_unlock \\(three.token, 0, 8 - \\(integer\\(kind=4\\)\\) three.dim\\\[0\\\].lbound, &ii, 0B, 0\\);|_gfortran_caf_unlock \\(three.token, 0, 8 - three.dim\\\[0\\\].lbound, &ii, 0B, 0\\);" 1 "original" } }
diff --git a/gcc/testsuite/gfortran.dg/constant_shape.f90 b/gcc/testsuite/gfortran.dg/constant_shape.f90
index c2eaf82f5ec..5ee927b20e2 100644
--- a/gcc/testsuite/gfortran.dg/constant_shape.f90
+++ b/gcc/testsuite/gfortran.dg/constant_shape.f90
@@ -3,7 +3,8 @@
 ! PR 78392: ICE in gfc_trans_auto_array_allocation, at fortran/trans-array.c:5979
 !
 ! Contributed by Janus Weil <janus@gcc.gnu.org>
-
+! Error message update with patch for PR fortran/83633
+!
 module mytypes
    implicit none
  contains
@@ -15,6 +16,6 @@ end module
 program test
   use mytypes
   implicit none
-  integer, dimension(get_i()) :: x  ! { dg-error "must have constant shape" }
-  print *, size (x)
+  integer, dimension(get_i()) :: x  ! { dg-error "array with nonconstant bounds" }
+  print *, size (x)                 ! { dg-error "has no IMPLICIT type" }
 end
diff --git a/gcc/testsuite/gfortran.dg/data_bounds_1.f90 b/gcc/testsuite/gfortran.dg/data_bounds_1.f90
index b20aa415b8a..24cdc7c9815 100644
--- a/gcc/testsuite/gfortran.dg/data_bounds_1.f90
+++ b/gcc/testsuite/gfortran.dg/data_bounds_1.f90
@@ -1,4 +1,5 @@
 ! { dg-do compile }
+! { dg-options "-std=gnu" }
 ! Checks the fix for PR32315, in which the bounds checks below were not being done.
 !
 ! Contributed by Tobias Burnus <burnus@gcc.gnu.org>
diff --git a/gcc/testsuite/gfortran.dg/data_char_1.f90 b/gcc/testsuite/gfortran.dg/data_char_1.f90
index 96db4fd30eb..24785b636fa 100644
--- a/gcc/testsuite/gfortran.dg/data_char_1.f90
+++ b/gcc/testsuite/gfortran.dg/data_char_1.f90
@@ -1,4 +1,5 @@
 ! { dg-do run }
+! { dg-options "-std=gnu" }
 ! Test character variables in data statements
 ! Also substrings of character variables.
 ! PR14976 PR16228 
diff --git a/gcc/testsuite/gfortran.dg/data_substring.f90 b/gcc/testsuite/gfortran.dg/data_substring.f90
new file mode 100644
index 00000000000..6d6b2c01579
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/data_substring.f90
@@ -0,0 +1,6 @@
+! { dg-do compile }
+! PR fortran/30792
+character string*1025
+integer i
+data (string(i:i),i=1,1025)/1025*'?'/  ! { dg-error "Invalid substring" }
+end
diff --git a/gcc/testsuite/gfortran.dg/deallocate_alloc_opt_1.f90 b/gcc/testsuite/gfortran.dg/deallocate_alloc_opt_1.f90
index 969ce257efe..58790ebfb58 100644
--- a/gcc/testsuite/gfortran.dg/deallocate_alloc_opt_1.f90
+++ b/gcc/testsuite/gfortran.dg/deallocate_alloc_opt_1.f90
@@ -22,7 +22,7 @@ program a
   deallocate(i)) ! { dg-error "Syntax error in DEALLOCATE" }
   deallocate(i, errmsg=err, errmsg=err) ! { dg-error "Redundant ERRMSG" }
   deallocate(i, errmsg=err) ! { dg-warning "useless without a STAT" }
-  deallocate(i, stat=j, errmsg=x) ! { dg-error "must be a scalar CHARACTER" }
+  deallocate(i, stat=j, errmsg=x) ! { dg-error "shall be a scalar default CHARACTER" }
 
   deallocate(err) ! { dg-error "nonprocedure pointer nor an allocatable" }
 
diff --git a/gcc/testsuite/gfortran.dg/deallocate_error_3.f90 b/gcc/testsuite/gfortran.dg/deallocate_error_3.f90
new file mode 100644
index 00000000000..149b7c8c15a
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/deallocate_error_3.f90
@@ -0,0 +1,9 @@
+! { dg-do compile }
+! PR fortran/82994
+! Code contributed by Gerhard Steinmetz
+program p
+   type t
+   end type
+   class(t) :: x  ! { dg-error "must be dummy, allocatable or pointer" }
+   deallocate (x) ! { dg-error "not a nonprocedure pointer nor an allocatable" }
+end
diff --git a/gcc/testsuite/gfortran.dg/deallocate_error_4.f90 b/gcc/testsuite/gfortran.dg/deallocate_error_4.f90
new file mode 100644
index 00000000000..c12e776dd27
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/deallocate_error_4.f90
@@ -0,0 +1,10 @@
+! { dg-do compile }
+! PR fortran/82994
+! Code contributed by Gerhard Steinmetz
+program p
+   type t
+   end type
+   class(t) :: x  ! { dg-error "must be dummy, allocatable or pointer" }
+   allocate (x)   ! { dg-error "neither a data pointer nor an allocatable" }
+   deallocate (x) ! { dg-error "not a nonprocedure pointer nor an allocatable" }
+end
diff --git a/gcc/testsuite/gfortran.dg/debug/pr35154-stabs.f b/gcc/testsuite/gfortran.dg/debug/pr35154-stabs.f
index fd731994f36..da3759c5b32 100644
--- a/gcc/testsuite/gfortran.dg/debug/pr35154-stabs.f
+++ b/gcc/testsuite/gfortran.dg/debug/pr35154-stabs.f
@@ -1,7 +1,7 @@
 C     Test program for common block debugging.  G. Helffrich 11 July 2004.
 C { dg-do compile }
 C { dg-skip-if "No stabs" { aarch64*-*-* mmix-*-* alpha*-*-* hppa*64*-*-* ia64-*-* *-*-vxworks* } { "*" } { "" } }
-C { dg-skip-if "No stabs" {*-*-* } { "*" } { "-gstabs" } }
+C { dg-skip-if "No stabs" { *-*-* } { "*" } { "-gstabs" } }
       common i,j
       common /label/l,m
       i = 1
diff --git a/gcc/testsuite/gfortran.dg/dec_parameter_1.f b/gcc/testsuite/gfortran.dg/dec_parameter_1.f
index 69ffa53c806..62e635f4ce8 100644
--- a/gcc/testsuite/gfortran.dg/dec_parameter_1.f
+++ b/gcc/testsuite/gfortran.dg/dec_parameter_1.f
@@ -22,7 +22,6 @@
           two = 2.0d0
           x = two * pi_1 * f_1 * t
           y = two * pi_2 * f_2 * t
-          z = two * pi_3 * f_3 * t
           return
         end subroutine
 
diff --git a/gcc/testsuite/gfortran.dg/dec_parameter_2.f90 b/gcc/testsuite/gfortran.dg/dec_parameter_2.f90
index 280f0007f93..d0c9f8b7eb0 100644
--- a/gcc/testsuite/gfortran.dg/dec_parameter_2.f90
+++ b/gcc/testsuite/gfortran.dg/dec_parameter_2.f90
@@ -21,7 +21,6 @@ subroutine sub1(t, x, y)
   two = 2.0d0
   x = two * pi_1 * f_1 * t
   y = two * pi_2 * f_2 * t
-  z = two * pi_3 * f_3 * t
   return
 end subroutine
 
diff --git a/gcc/testsuite/gfortran.dg/dec_structure_12.f90 b/gcc/testsuite/gfortran.dg/dec_structure_12.f90
index b6cc5aa12ed..720d6ddc5d0 100644
--- a/gcc/testsuite/gfortran.dg/dec_structure_12.f90
+++ b/gcc/testsuite/gfortran.dg/dec_structure_12.f90
@@ -1,4 +1,4 @@
-! { dg-do "compile" }
+! { dg-do compile }
 ! { dg-options "-fdec-structure" }
 !
 ! Test a regression where multiple anonymous structures failed to
diff --git a/gcc/testsuite/gfortran.dg/dec_structure_14.f90 b/gcc/testsuite/gfortran.dg/dec_structure_14.f90
index 4e271b7390f..0079e6c1c29 100644
--- a/gcc/testsuite/gfortran.dg/dec_structure_14.f90
+++ b/gcc/testsuite/gfortran.dg/dec_structure_14.f90
@@ -1,4 +1,4 @@
-  ! { dg-do "compile" }
+  ! { dg-do compile }
   ! { dg-options "-fdec-structure" }
   !
   ! Test that structures inside a common block do not require the
diff --git a/gcc/testsuite/gfortran.dg/dec_structure_15.f90 b/gcc/testsuite/gfortran.dg/dec_structure_15.f90
index fd06ff9f10d..46e073190e4 100644
--- a/gcc/testsuite/gfortran.dg/dec_structure_15.f90
+++ b/gcc/testsuite/gfortran.dg/dec_structure_15.f90
@@ -1,4 +1,4 @@
-! { dg-do "compile" }
+! { dg-do compile }
 ! { dg-options "" }
 !
 ! PR fortran/77584
diff --git a/gcc/testsuite/gfortran.dg/dec_structure_23.f90 b/gcc/testsuite/gfortran.dg/dec_structure_23.f90
new file mode 100644
index 00000000000..78db344e0fc
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec_structure_23.f90
@@ -0,0 +1,20 @@
+! { dg-do compile }
+! { dg-options "-fdec-structure" }
+!
+! PR fortran/78240
+!
+! Test a regression where an ICE occurred attempting to create array variables
+! with non-constant array-specs in legacy clist initializers.
+!
+! Error message update with patch for PR fortran/83633
+!
+program p
+  implicit none
+  integer :: nn
+  real :: rr
+  structure /s/
+    integer x(n)    /1/   ! { dg-error "array with nonconstant bounds" }
+    integer xx(nn)  /1/   ! { dg-error "array with nonconstant bounds" }
+    integer xxx(rr) /1.0/ ! { dg-error "array with nonconstant bounds" }
+  end structure
+end
diff --git a/gcc/testsuite/gfortran.dg/dec_structure_8.f90 b/gcc/testsuite/gfortran.dg/dec_structure_8.f90
index 160b92a8b96..f84bf156864 100644
--- a/gcc/testsuite/gfortran.dg/dec_structure_8.f90
+++ b/gcc/testsuite/gfortran.dg/dec_structure_8.f90
@@ -6,7 +6,7 @@
 
 ! Old-style (clist) initialization
 integer,parameter :: as = 3
-structure /t1/
+structure /t1/              ! { dg-error "Type definition.*T1" }
   integer*1 a /300_2/       ! { dg-error "Arithmetic overflow" }
   integer   b //            ! { dg-error "Empty old style initializer list" }
   integer   c /2*3/         ! { dg-error "Repeat spec invalid in scalar" }
@@ -44,14 +44,14 @@ record /t1/            ! { dg-error "Invalid character in name" }
 
 structure /t2/
   ENTRY here           ! { dg-error "ENTRY statement.*cannot appear" }
-  integer a
+  integer a            ! { dg-error "Component.*already declared" }
   integer a            ! { dg-error "Component.*already declared" }
   structure $z         ! { dg-error "Invalid character in name" }
   structure //         ! { dg-error "Invalid character in name" }
   structure // x       ! { dg-error "Invalid character in name" }
   structure /t3/       ! { dg-error "Invalid character in name" }
   structure /t3/ x,$y  ! { dg-error "Invalid character in name" }
-  structure /t4/ y
+  structure /t4/ y     ! { dg-error "Type definition.*T4" }
     integer i, j, k
   end structure
   structure /t4/ z     ! { dg-error "Type definition.*T4" }
diff --git a/gcc/testsuite/gfortran.dg/deferred_character_32.f90 b/gcc/testsuite/gfortran.dg/deferred_character_32.f90
new file mode 100644
index 00000000000..3969d97ffc9
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/deferred_character_32.f90
@@ -0,0 +1,13 @@
+! { dg-do run }
+!
+! Test the fix for PR88117.
+!
+! Contributed by Gerhard Steinmetz  <gscfq@t-online.de>
+!
+program p
+   character(:), pointer :: z(:)
+   allocate (z, source  = ['abcd', 'bcde'])
+   z = (z) ! gimplifier choked here.
+   if (any (z .ne. ['abcd', 'bcde'])) stop 1
+   deallocate (z)
+end
diff --git a/gcc/testsuite/gfortran.dg/dependency_53.f90 b/gcc/testsuite/gfortran.dg/dependency_53.f90
new file mode 100644
index 00000000000..a45302fb0a3
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dependency_53.f90
@@ -0,0 +1,25 @@
+! { dg-do run }
+! PR fortran/66089 - used to ICE and, after that ICE was fixed,
+! gave wrong results.
+  type :: t
+    integer :: c
+  end type t
+
+  class(t), dimension(:), allocatable :: b,c
+
+  allocate (b(5), source=t(7))
+  allocate(c(5), source=t(13))
+  c = plus(c(1), b)
+  if (any(c%c /= 20)) stop 1
+  c = t(13)
+  c = plus(b, c(1))
+  if (any(c%c /= 20)) stop 2
+contains
+
+  elemental function plus(lhs, rhs)
+    class(t), intent(in) :: lhs, rhs
+    type(t)             :: plus
+    plus%c = lhs%c + rhs%c
+  end function plus
+
+end
diff --git a/gcc/testsuite/gfortran.dg/dg.exp b/gcc/testsuite/gfortran.dg/dg.exp
index 82cbb210b92..320e2e09c81 100644
--- a/gcc/testsuite/gfortran.dg/dg.exp
+++ b/gcc/testsuite/gfortran.dg/dg.exp
@@ -36,7 +36,7 @@ proc dg-compile-aux-modules { args } {
     global gfortran_test_path
     global gfortran_aux_module_flags
     if { [llength $args] != 2 } {
-	error "dg-set-target-env-var: needs one argument"
+	error "dg-compile-aux-modules: needs one argument"
 	return
     }
 
diff --git a/gcc/testsuite/gfortran.dg/explicit_shape_1.f90 b/gcc/testsuite/gfortran.dg/explicit_shape_1.f90
new file mode 100644
index 00000000000..ca3cd00d855
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/explicit_shape_1.f90
@@ -0,0 +1,7 @@
+! { dg-do compile }
+! PR fortran/83633
+! Original testcase by Nathan T. Weeks  <weeks at iastate dot edu>
+!
+integer :: A(command_argument_count()) = 1 ! { dg-error "nonconstant bounds" }
+write (*,*) A
+end
diff --git a/gcc/testsuite/gfortran.dg/extends_11.f03 b/gcc/testsuite/gfortran.dg/extends_11.f03
index 7b32cdf547f..2f19225d703 100644
--- a/gcc/testsuite/gfortran.dg/extends_11.f03
+++ b/gcc/testsuite/gfortran.dg/extends_11.f03
@@ -37,4 +37,4 @@
   recruit%service%education%person%ss = 9
 end
 
-! { dg-final { scan-tree-dump-times " +recruit\\.service\\.education\\.person\\.ss =" 8 "original"} }
+! { dg-final { scan-tree-dump-times " +recruit\\.service\\.education\\.person\\.ss =" 8 "original" } }
diff --git a/gcc/testsuite/gfortran.dg/finalize_28.f90 b/gcc/testsuite/gfortran.dg/finalize_28.f90
index f0c9665252f..597413b2dd3 100644
--- a/gcc/testsuite/gfortran.dg/finalize_28.f90
+++ b/gcc/testsuite/gfortran.dg/finalize_28.f90
@@ -21,4 +21,4 @@ contains
     integer, intent(out) :: edges(:,:)
   end subroutine coo_dump_edges
 end module coo_graphs
-! { dg-final { scan-tree-dump-times "__builtin_free" 6 "original" } }
+! { dg-final { scan-tree-dump-times "__builtin_free" 5 "original" } }
diff --git a/gcc/testsuite/gfortran.dg/finalize_34.f90 b/gcc/testsuite/gfortran.dg/finalize_34.f90
new file mode 100644
index 00000000000..e2f02a5c51c
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/finalize_34.f90
@@ -0,0 +1,25 @@
+! { dg-do compile }
+! { dg-additional-options "-fdump-tree-original" }
+! PR 87352 - this used to cause an excessive number of deallocations.
+module testmodule
+  implicit none
+  public
+
+  type :: evtlist_type
+     real,  allocatable, dimension(:) :: p1
+     real,  allocatable, dimension(:) :: p2
+     real,  allocatable, dimension(:) :: p3
+     real,  allocatable, dimension(:) :: p4
+  end type evtlist_type
+
+  type :: evtlistlist_type
+     type(evtlist_type)  :: evtlist(1:1)
+  end type evtlistlist_type
+
+end module testmodule 
+
+program main
+  use testmodule
+  type(evtlist_type), dimension(10) :: a
+end program main
+! { dg-final  { scan-tree-dump-times "__builtin_free" 8 "original" } }
diff --git a/gcc/testsuite/gfortran.dg/generic_34.f90 b/gcc/testsuite/gfortran.dg/generic_34.f90
new file mode 100644
index 00000000000..1bcbfa089fa
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/generic_34.f90
@@ -0,0 +1,27 @@
+! { dg-do compile }
+!
+! PR 86116: [6/7/8/9 Regression] Ambiguous generic interface not recognised
+!
+! Contributed by martin <mscfd@gmx.net>
+
+module mod
+
+   type :: t
+   end type t
+
+   interface sub
+      module procedure s1
+      module procedure s2
+   end interface
+
+contains
+
+   subroutine s1(x)  ! { dg-error "Ambiguous interfaces in generic interface" }
+      type(t) :: x
+   end subroutine
+
+   subroutine s2(x)  ! { dg-error "Ambiguous interfaces in generic interface" }
+      class(*), allocatable :: x
+   end subroutine
+
+end
diff --git a/gcc/testsuite/gfortran.dg/goacc/pr84963.f90 b/gcc/testsuite/gfortran.dg/goacc/pr84963.f90
new file mode 100644
index 00000000000..4548082bee3
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/goacc/pr84963.f90
@@ -0,0 +1,7 @@
+! PR ipa/84963
+! { dg-options "-O2" }
+
+program p
+   print *, sin([1.0, 2.0])
+   print *, cos([1.0, 2.0])
+end
diff --git a/gcc/testsuite/gfortran.dg/gomp/pr83977.f90 b/gcc/testsuite/gfortran.dg/gomp/pr83977.f90
new file mode 100644
index 00000000000..b8ad1a7e39c
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/gomp/pr83977.f90
@@ -0,0 +1,15 @@
+! PR middle-end/83977
+! { dg-do compile }
+
+integer function foo (a, b)
+   integer :: a, b
+!$omp declare simd uniform(b) linear(ref(a):b)
+   a = a + 1
+! This function can't be called from simd loops,
+! because it violates declare simd restrictions.
+! We shouldn't ICE on it though, nor attempt to generate
+! simd clones for the *omp_fn* functions.
+!$omp parallel
+   call sub
+!$omp end parallel
+end
diff --git a/gcc/testsuite/gfortran.dg/gomp/pr84116.f90 b/gcc/testsuite/gfortran.dg/gomp/pr84116.f90
new file mode 100644
index 00000000000..3a95ac5f36f
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/gomp/pr84116.f90
@@ -0,0 +1,12 @@
+! PR fortran/84116
+! { dg-do compile }
+
+program pr84116
+   integer :: i, j
+   !$omp simd linear ((i))	! { dg-error "Syntax error" }
+   do i = 1, 2
+   end do
+   !$omp simd linear ()		! { dg-error "Syntax error" }
+   do j = 1, 2
+   end do
+end
diff --git a/gcc/testsuite/gfortran.dg/gomp/pr85313.f90 b/gcc/testsuite/gfortran.dg/gomp/pr85313.f90
new file mode 100644
index 00000000000..04599849ed7
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/gomp/pr85313.f90
@@ -0,0 +1,25 @@
+! PR fortran/85313
+! { dg-do compile }
+
+!$omp do collapse(3)
+  do i = 1, 10
+    do j = i, 20	! { dg-error "form rectangular iteration space" }
+      do k = 1, 2
+      end do
+    end do
+  end do
+!$omp do collapse(3)
+  do i = 1, 10
+    do j = 1, 5
+      do k = i, 20	! { dg-error "form rectangular iteration space" }
+      end do
+    end do
+  end do
+!$omp do collapse(3)
+  do i = 1, 10
+    do j = 1, 5
+      do k = j, 20	! { dg-error "form rectangular iteration space" }
+      end do
+    end do
+  end do
+end
diff --git a/gcc/testsuite/gfortran.dg/ieee/ieee.exp b/gcc/testsuite/gfortran.dg/ieee/ieee.exp
index 14741b768c5..1d6eab18e14 100644
--- a/gcc/testsuite/gfortran.dg/ieee/ieee.exp
+++ b/gcc/testsuite/gfortran.dg/ieee/ieee.exp
@@ -22,15 +22,15 @@
 load_lib gfortran-dg.exp
 load_lib target-supports.exp
 
-# Initialize `dg'.
-dg-init
-
-# Flags specified in each test
+# If a testcase doesn't have special options, use these.
 global DEFAULT_FFLAGS
 if ![info exists DEFAULT_FFLAGS] then {
-    set DEFAULT_FFLAGS ""
+    set DEFAULT_FFLAGS " -pedantic-errors"
 }
 
+# Initialize `dg'.
+dg-init
+
 # Flags for finding the IEEE modules
 if [info exists TOOL_OPTIONS] {
    set specpath [get_multilibs ${TOOL_OPTIONS}]
diff --git a/gcc/testsuite/gfortran.dg/implied_do_2.f90 b/gcc/testsuite/gfortran.dg/implied_do_2.f90
new file mode 100644
index 00000000000..5078ac804d3
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/implied_do_2.f90
@@ -0,0 +1,7 @@
+! { dg-do compile }
+! PR fortran/56667
+program error_message
+   implicit none
+   integer :: ir
+   write(*,*) ( ir, ir = 1,10    ! { dg-error "Expected a right parenthesis" }
+end program error_message 
diff --git a/gcc/testsuite/gfortran.dg/init_flag_17.f90 b/gcc/testsuite/gfortran.dg/init_flag_17.f90
new file mode 100644
index 00000000000..401830fccbc
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/init_flag_17.f90
@@ -0,0 +1,28 @@
+! { dg-do compile }
+! { dg-options "-finit-derived -finit-local-zero -fdump-tree-original" }
+!
+! PR fortran/82972
+!
+! Make sure we do not ICE when generating initializers for c_ptr and c_funptr
+! components of derived types (and make sure they are properly initialized to
+! zero).
+!
+
+program init_flag_17
+  use iso_c_binding
+  implicit none
+
+  type :: ty
+    type(c_ptr)    :: ptr  ! = c_null_ptr
+    type(c_funptr) :: fptr ! = c_null_funptr
+  end type
+
+  type(ty) :: t
+
+  print *, t%ptr
+  print *, t%fptr
+
+end program
+
+! { dg-final { scan-tree-dump "\.ptr=0" "original" } }
+! { dg-final { scan-tree-dump "\.fptr=0" "original" } }
diff --git a/gcc/testsuite/gfortran.dg/init_flag_18.f90 b/gcc/testsuite/gfortran.dg/init_flag_18.f90
new file mode 100644
index 00000000000..9ab00a9afce
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/init_flag_18.f90
@@ -0,0 +1,19 @@
+! { dg-do compile }
+! { dg-options "-finit-derived" }
+!
+! PR fortran/83183
+!
+! Test a regression where -finit-derived recursed infinitely generating
+! initializers for allocatable components of the same derived type.
+!
+
+program pr83183
+  type :: linked_list
+     type(linked_list), allocatable :: link
+     integer :: value
+  end type
+  type(linked_list) :: test
+  allocate(test % link)
+  print *, test%value
+  print *, test%link%value
+end program
diff --git a/gcc/testsuite/gfortran.dg/init_flag_19.f03 b/gcc/testsuite/gfortran.dg/init_flag_19.f03
new file mode 100644
index 00000000000..bbcee8aa8b4
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/init_flag_19.f03
@@ -0,0 +1,36 @@
+! { dg-do compile }
+! { dg-options "-finit-derived -finit-local-zero -fdump-tree-original" }
+!
+! Test initializers for BT_CLASS components/variables with -finit-derived.
+!
+
+implicit none
+
+type :: ty1
+  integer :: ival
+  real    :: rval
+end type
+
+type :: ty2
+  type(ty1)               :: bt
+  type(ty1), allocatable  :: bt_alloc
+  type(ty1), pointer      :: bt_ptr
+  class(ty1), allocatable :: class_alloc
+  class(ty1), pointer     :: class_ptr
+end type
+
+type(ty2) basic
+class(ty1), allocatable :: calloc
+
+print *, basic%bt%ival
+print *, calloc%ival
+
+end
+
+! { dg-final { scan-tree-dump-times "\.ival *= *0" 1 "original" } }
+! { dg-final { scan-tree-dump-times "\.rval *= *0" 1 "original" } }
+! { dg-final { scan-tree-dump-times "\.bt_ptr *= *0" 1 "original" } }
+! { dg-final { scan-tree-dump-times "\.bt_alloc *= *0" 1 "original" } }
+! { dg-final { scan-tree-dump-times "\.class_alloc(?: *= *\{)?\._data *= *0" 1 "original" } }
+! { dg-final { scan-tree-dump-times "\.class_ptr(?: *= *\{)?\._data *= *0" 1 "original" } }
+! { dg-final { scan-tree-dump-times "calloc(?: *= *\{)?\._data *= *0" 1 "original" } }
diff --git a/gcc/testsuite/gfortran.dg/inline_matmul_22.f90 b/gcc/testsuite/gfortran.dg/inline_matmul_22.f90
new file mode 100644
index 00000000000..702e32e7467
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/inline_matmul_22.f90
@@ -0,0 +1,44 @@
+! { dg-do compile }
+! { dg-additional-options "-ffrontend-optimize" }
+! PR 84270 - this used to be rejected.
+! Test case by Michael Weinert
+
+module fp_precision
+
+   integer, parameter   :: fp = selected_real_kind(13)
+
+end module fp_precision
+
+      subroutine lhcal(nrot,orth,ngpts,vgauss,vr_0)
+
+      use fp_precision  ! floating point precision
+
+      implicit none
+
+!--->    rotation matrices and rotations (input)
+      integer,          intent(in)  :: nrot
+!     real(kind=fp),    intent(in)  :: orth(3,3,nrot)  ! fine at all -O
+      real(kind=fp),    intent(in)  :: orth(3,3,*)
+
+!--->    gaussian integration points
+      integer,          intent(in)  :: ngpts
+      real(kind=fp),    intent(in)  :: vgauss(3,*)
+
+!--->    output results
+      real(kind=fp),    intent(out) :: vr_0(3)
+
+      real(kind=fp)     :: v(3),vr(3)
+      integer           :: n,nn
+
+      vr_0 = 0
+      do nn=1,ngpts
+         v(:) = vgauss(:,nn)
+!--->    apply rotations
+         do n=2,nrot
+            vr = matmul( orth(:,:,n), v )
+            vr_0 = vr_0 + vr
+         enddo
+      enddo
+
+      return
+      end subroutine lhcal
diff --git a/gcc/testsuite/gfortran.dg/inline_matmul_24.f90 b/gcc/testsuite/gfortran.dg/inline_matmul_24.f90
new file mode 100644
index 00000000000..3168d5f1006
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/inline_matmul_24.f90
@@ -0,0 +1,42 @@
+! { dg-do run }
+! { dg-options "-ffrontend-optimize -fdump-tree-original" }
+!
+! PR fortran/87597
+!
+! Contributed by gallmeister
+!
+! Before, for the inlined matmul,
+! gamma5 was converted to an EXPR_ARRAY with lbound = 1
+! instead of the lbound = 0 as declared; leading to
+! an off-by-one problem.
+!
+program testMATMUL
+  implicit none
+    complex, dimension(0:3,0:3), parameter :: gamma5 = reshape((/ 0., 0., 1., 0., &
+                                                                  0., 0., 0., 1., &
+                                                                  1., 0., 0., 0., &
+                                                                  0., 1., 0., 0. /),(/4,4/))
+    complex, dimension(0:3,0:3) :: A, B, D
+    integer :: i
+
+    A = 0.0
+    do i=0,3
+       A(i,i) = i*1.0
+    end do
+
+    B = cmplx(7,-9)
+    B = matmul(A,gamma5)
+
+    D = reshape([0, 0, 2, 0, &
+                 0, 0, 0, 3, &
+                 0, 0, 0, 0, &
+                 0, 1, 0, 0], [4, 4])
+    write(*,*) B(0,:)
+    write(*,*) B(1,:)
+    write(*,*) B(2,:)
+    write(*,*) B(3,:)
+    if (any(B /= D)) then
+      call abort()
+    end if
+end program testMATMUL
+! { dg-final { scan-tree-dump-times "gamma5\\\[__var_1_do \\* 4 \\+ __var_2_do\\\]|gamma5\\\[NON_LVALUE_EXPR <__var_1_do> \\* 4 \\+ NON_LVALUE_EXPR <__var_2_do>\\\]" 1 "original" } }
diff --git a/gcc/testsuite/gfortran.dg/inquire_18.f90 b/gcc/testsuite/gfortran.dg/inquire_18.f90
new file mode 100644
index 00000000000..9829688225b
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/inquire_18.f90
@@ -0,0 +1,11 @@
+! { dg-do run }
+! PR84412 Wrong "Inquire statement identifies an internal file" error 
+program bug
+  implicit none
+  integer          :: i
+  character(len=1) :: s
+  write (s,'(i1)') 0
+  open(newUnit=i,file='inquire_18.txt',status='unknown')
+  inquire(unit=i)
+  close(i, status="delete")
+end program bug
diff --git a/gcc/testsuite/gfortran.dg/inquire_19.f90 b/gcc/testsuite/gfortran.dg/inquire_19.f90
new file mode 100644
index 00000000000..7d01b6b56ce
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/inquire_19.f90
@@ -0,0 +1,13 @@
+! { dg-do run }
+! PR84506  INQUIRE(pos=) always sets pos=0 with -fdefault-integer-8
+program TestInquire
+   implicit none
+   integer(8) :: iUnit
+   integer(8) :: iPos
+   open(newunit=iunit, file='output.txt', access='stream', status='replace')
+   write(iUnit) 'TEXT'
+   inquire(iUnit, pos=iPos)
+   close(iUnit, status='delete')
+   !print *, iPos
+   if (iPos.ne.5) stop 1
+end program TestInquire
diff --git a/gcc/testsuite/gfortran.dg/interface_41.f90 b/gcc/testsuite/gfortran.dg/interface_41.f90
new file mode 100644
index 00000000000..b5ea8af189d
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/interface_41.f90
@@ -0,0 +1,19 @@
+! { dg-do compile }
+! PR fortran/85001 
+! Contributed by Gerhard Steinmetz.
+program p
+   type t
+   end type
+   call s
+contains
+   real function f(x)
+      class(t) :: x
+      dimension :: x(:)
+      f = 1.0
+   end
+   subroutine s
+      type(t) :: x(2)
+      real :: z
+      z = f(x)     ! { dg-error "Rank mismatch in argument" }
+   end
+end
diff --git a/gcc/testsuite/gfortran.dg/interface_abstract_5.f90 b/gcc/testsuite/gfortran.dg/interface_abstract_5.f90
new file mode 100644
index 00000000000..fddf6b89d27
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/interface_abstract_5.f90
@@ -0,0 +1,32 @@
+! { dg-do compile }
+!
+! PR 71861: [7/8/9 Regression] [F03] ICE in write_symbol(): bad module symbol
+!
+! Contributed by Gerhard Steinmetz <gerhard.steinmetz.fortran@t-online.de>
+
+module m1
+   intrinsic abs
+   abstract interface
+      function abs(x)    ! { dg-error "ABSTRACT attribute conflicts with INTRINSIC attribute" }
+         real :: abs, x
+      end
+   end interface
+end
+
+module m2
+   abstract interface
+      function abs(x)
+         real :: abs, x
+      end
+   end interface
+   intrinsic abs    ! { dg-error "ABSTRACT attribute conflicts with INTRINSIC attribute" }
+end
+
+module m3
+   abstract interface
+      function f(x)
+         real :: f, x
+      end
+   end interface
+   intrinsic f    ! { dg-error "ABSTRACT attribute conflicts with INTRINSIC attribute" }
+end
diff --git a/gcc/testsuite/gfortran.dg/internal_references_1.f90 b/gcc/testsuite/gfortran.dg/internal_references_1.f90
index 12041df9d70..2434e28d5e3 100644
--- a/gcc/testsuite/gfortran.dg/internal_references_1.f90
+++ b/gcc/testsuite/gfortran.dg/internal_references_1.f90
@@ -11,7 +11,7 @@ module m
   implicit none
 contains
 
-  subroutine p (i)   ! { dg-error "is already defined" }
+  subroutine p (i)   ! { dg-error "(1)" }
     integer :: i
   end subroutine
 
@@ -22,14 +22,15 @@ end module
 !
 ! PR25124 - would happily ignore the declaration of foo in the main program.
 program test
-real :: foo, x      ! { dg-error "explicit interface and must not have attributes declared" }
+real :: foo, x
 x = bar ()          ! This is OK because it is a regular reference.
 x = foo ()
 contains
-    function foo () ! { dg-error "explicit interface and must not have attributes declared" }
+    function foo () ! { dg-error "explicit interface from a previous" }
       foo = 1.0
     end function foo
     function bar ()
       bar = 1.0
     end function bar
 end program test
+
diff --git a/gcc/testsuite/gfortran.dg/lto/20091028-1_0.f90 b/gcc/testsuite/gfortran.dg/lto/20091028-1_0.f90
index 57c1b1f6028..f33f6c8b946 100644
--- a/gcc/testsuite/gfortran.dg/lto/20091028-1_0.f90
+++ b/gcc/testsuite/gfortran.dg/lto/20091028-1_0.f90
@@ -1,5 +1,5 @@
 ! { dg-lto-do link }
-! { dg-extra-ld-options "-r -nostdlib -finline-functions" }
+! { dg-extra-ld-options "-r -nostdlib -finline-functions -Wno-lto-type-mismatch" }
 
 SUBROUTINE int_gen_ti_header_char( hdrbuf, hdrbufsize, itypesize, &
                               DataHandle, Element, VarName, Data, code )
diff --git a/gcc/testsuite/gfortran.dg/lto/20091028-2_0.f90 b/gcc/testsuite/gfortran.dg/lto/20091028-2_0.f90
index 57c1b1f6028..f33f6c8b946 100644
--- a/gcc/testsuite/gfortran.dg/lto/20091028-2_0.f90
+++ b/gcc/testsuite/gfortran.dg/lto/20091028-2_0.f90
@@ -1,5 +1,5 @@
 ! { dg-lto-do link }
-! { dg-extra-ld-options "-r -nostdlib -finline-functions" }
+! { dg-extra-ld-options "-r -nostdlib -finline-functions -Wno-lto-type-mismatch" }
 
 SUBROUTINE int_gen_ti_header_char( hdrbuf, hdrbufsize, itypesize, &
                               DataHandle, Element, VarName, Data, code )
diff --git a/gcc/testsuite/gfortran.dg/lto/pr87689_0.f b/gcc/testsuite/gfortran.dg/lto/pr87689_0.f
new file mode 100644
index 00000000000..5beee9391c6
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/lto/pr87689_0.f
@@ -0,0 +1,13 @@
+! { dg-lto-run }
+! PR 87689 - this used to fail for POWER, plus it used to
+! give warnings about mismatches with LTO.
+! Original test case by Judicaël Grasset.
+      program main
+        implicit none
+        character :: c
+        character(len=20) :: res, doesntwork_p8
+        external doesntwork_p8
+        c = 'o'
+        res = doesntwork_p8(c,1,2,3,4,5,6)
+        if (res /= 'foo') stop 3
+      end program main
diff --git a/gcc/testsuite/gfortran.dg/lto/pr87689_1.f b/gcc/testsuite/gfortran.dg/lto/pr87689_1.f
new file mode 100644
index 00000000000..f293a0054bd
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/lto/pr87689_1.f
@@ -0,0 +1,11 @@
+      function doesntwork_p8(c,a1,a2,a3,a4,a5,a6)
+        implicit none
+        character(len=20) :: doesntwork_p8
+        character :: c
+        integer :: a1,a2,a3,a4,a5,a6
+        if (a1 /= 1 .or. a2 /= 2 .or. a3 /= 3 .or. a4 /= 4 .or. a5 /= 5
+     &       .or. a6 /= 6) stop 1
+       if (c /= 'o ') stop 2
+       doesntwork_p8 = 'foo'
+       return
+       end
diff --git a/gcc/testsuite/gfortran.dg/matmul_rank_1.f90 b/gcc/testsuite/gfortran.dg/matmul_rank_1.f90
new file mode 100644
index 00000000000..f111b26018f
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/matmul_rank_1.f90
@@ -0,0 +1,9 @@
+! { dg-do compile }
+! { dg-additional-options "-ffrontend-optimize" }
+! PR 85044 - used to die on allocating a negative amount of memory.
+! Test case by Gerhard Steinmetz.
+program p
+   real :: a(3,3) = 1.0
+   real :: b(33)
+   b = matmul(a, a) ! { dg-error "Incompatible ranks" }
+end
diff --git a/gcc/testsuite/gfortran.dg/no_arg_check_2.f90 b/gcc/testsuite/gfortran.dg/no_arg_check_2.f90
index b3fb4685efe..7d509589788 100644
--- a/gcc/testsuite/gfortran.dg/no_arg_check_2.f90
+++ b/gcc/testsuite/gfortran.dg/no_arg_check_2.f90
@@ -139,7 +139,7 @@ end
 ! { dg-final { scan-tree-dump-times "sub_scalar .\\(struct t1 .\\) array_class_t1_alloc._data.data" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "sub_scalar .\\(struct t1 .\\) \\(array_class_t1_ptr._data.dat" 1 "original" } }
 
-! { dg-final { scan-tree-dump-times "sub_array_assumed \\(D" 3 "original" } }
+! { dg-final { scan-tree-dump-times "sub_array_assumed \\(D" 4 "original" } }
 ! { dg-final { scan-tree-dump-times " = _gfortran_internal_pack \\(&parm" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "sub_array_assumed \\(&array_int\\)" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "sub_array_assumed \\(\\(real\\(kind=4\\).0:. . restrict\\) array_real_alloc.data" 1 "original" } }
@@ -148,5 +148,5 @@ end
 ! { dg-final { scan-tree-dump-times "sub_array_assumed \\(\\(struct t1.0:. .\\) parm" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "sub_array_assumed \\(\\(struct t2.0:. . restrict\\) array_t2_alloc.data\\);" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "sub_array_assumed \\(\\(struct t1.0:. . restrict\\) array_class_t1_alloc._data.data\\);" 1 "original" } }
-! { dg-final { scan-tree-dump-times "sub_array_assumed \\(\\(struct t1.0:. .\\) array_class_t1_ptr._data.data\\);" 1 "original" } }
+! { dg-final { scan-tree-dump-times "sub_array_assumed \\(\\(struct t1.0:. .\\) array_class_t1_ptr._data.data\\);" 0 "original" } }
 
diff --git a/gcc/testsuite/gfortran.dg/null_10.f90 b/gcc/testsuite/gfortran.dg/null_10.f90
new file mode 100644
index 00000000000..ec1ac0ddd4d
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/null_10.f90
@@ -0,0 +1,7 @@
+! { dg-do compile }
+! PR 71860 - this used to ICE
+! Original test case by Gerhard Steinmetz
+program p
+   class(*), pointer :: z
+   z => null(z)
+end
diff --git a/gcc/testsuite/gfortran.dg/pointer_init_2.f90 b/gcc/testsuite/gfortran.dg/pointer_init_2.f90
index a280a3e4f98..bc1ef74ec55 100644
--- a/gcc/testsuite/gfortran.dg/pointer_init_2.f90
+++ b/gcc/testsuite/gfortran.dg/pointer_init_2.f90
@@ -18,7 +18,7 @@ subroutine sub
   integer, pointer :: dp0 => 13  ! { dg-error "Error in pointer initialization" }
   integer, pointer :: dp1 => r   ! { dg-error "Different types in pointer assignment" }
   integer, pointer :: dp2 => v   ! { dg-error "Different ranks in pointer assignment" }
-  integer, pointer :: dp3 => i   ! { dg-error "is neither TARGET nor POINTER" }
+  integer, pointer :: dp3 => i   ! { dg-error "Pointer assignment target in initialization expression does not have the TARGET attribute" }
   integer, pointer :: dp4 => j   ! { dg-error "must have the SAVE attribute" }
   integer, pointer :: dp5 => a   ! { dg-error "must not be ALLOCATABLE" }
 
@@ -35,7 +35,7 @@ subroutine sub
   end type t3
 
   type t4
-    integer, pointer :: dpc3 => i   ! { dg-error "Pointer assignment target is neither TARGET nor POINTER" }
+    integer, pointer :: dpc3 => i   ! { dg-error "Pointer assignment target in initialization expression does not have the TARGET attribute" }
   end type t4
 
   type t5
diff --git a/gcc/testsuite/gfortran.dg/pointer_init_6.f90 b/gcc/testsuite/gfortran.dg/pointer_init_6.f90
index f5e7555c4a7..3abad4ae179 100644
--- a/gcc/testsuite/gfortran.dg/pointer_init_6.f90
+++ b/gcc/testsuite/gfortran.dg/pointer_init_6.f90
@@ -13,7 +13,7 @@ module m1
  integer, target :: i
  type(t), target :: x
  integer, pointer :: p1 => i
- integer, pointer :: p2 => p1   ! { dg-error "must have the TARGET attribute" }
+ integer, pointer :: p2 => p1   ! { dg-error "Pointer assignment target in initialization expression does not have the TARGET attribute at" }
  integer, pointer :: p3 => x%p  ! { dg-error "must have the TARGET attribute" }
  integer, pointer :: p4 => x%i
  integer, pointer :: p5 => u    ! { dg-error "has no IMPLICIT type" }
diff --git a/gcc/testsuite/gfortran.dg/pointer_init_9.f90 b/gcc/testsuite/gfortran.dg/pointer_init_9.f90
new file mode 100644
index 00000000000..da00330e536
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pointer_init_9.f90
@@ -0,0 +1,13 @@
+! { dg-do compile }
+! PR 71237 - this used to ICE.
+module data_mod
+  implicit none
+
+  type data_t
+    integer :: i
+  end type
+
+  type(data_t), pointer :: data
+  integer, pointer :: idata => data%i ! { dg-error "Pointer assignment target in initialization expression does not have the TARGET attribute" }
+
+end module
diff --git a/gcc/testsuite/gfortran.dg/power_7.f90 b/gcc/testsuite/gfortran.dg/power_7.f90
new file mode 100644
index 00000000000..5b6b291b561
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/power_7.f90
@@ -0,0 +1,27 @@
+! { dg-do run }
+! { dg-additional-options "-fdump-tree-original" }
+! PR 85544 - this used to ICE.
+program p
+   integer, parameter :: na = -3, ne = 10
+   integer :: i, a(na:ne), b(na:ne)
+   integer :: v
+   a = [(i, i=na, ne)]
+   b = [2**a]
+   if (any (b /= [0,0,0,1,2,4,8,16,32,64,128,256,512,1024])) stop 1
+   b = [1**a]
+   if (any (b /= 1)) stop 2
+   b = [(-1)**a]
+   if (any (b /= [-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1]) )stop 3
+   b = [8**a]
+   if (any (b /= [0,0,0,1,8,64,512,4096,32768,262144,2097152,16777216,&
+        134217728,1073741824])) stop 4
+   b = [4**a]
+   if (any (b /= [0,0,0,1,4,16,64,256,1024,4096,16384,65536,262144,1048576])) stop 5
+   
+   v = 1
+   do i=1,6
+      v = v * 16
+      if (v /= 16**i) stop 6 
+   end do
+ end program p
+! { dg-final { scan-tree-dump-not "_gfortran_pow" "original" } }
diff --git a/gcc/testsuite/gfortran.dg/pr35031.f90 b/gcc/testsuite/gfortran.dg/pr35031.f90
new file mode 100644
index 00000000000..a4d78406006
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr35031.f90
@@ -0,0 +1,10 @@
+! { dg-do compile }
+elemental subroutine sub2(x)
+   integer, intent(in) :: x
+   entry sub2_c(x) bind(c)    ! { dg-error "prohibited in an elemental" }
+end subroutine sub2
+
+elemental function func2(x)
+   integer, intent(in) :: x
+   entry func2_c(x) bind(c)   ! { dg-error "prohibited in an elemental" }
+end function func2
diff --git a/gcc/testsuite/gfortran.dg/pr38351.f90 b/gcc/testsuite/gfortran.dg/pr38351.f90
new file mode 100644
index 00000000000..08e1724dc0a
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr38351.f90
@@ -0,0 +1,21 @@
+! { dg-do compile }
+module m1
+   type t1
+      integer :: i
+   end type t1
+   interface operator(+)
+      module procedure add
+   end interface
+   contains
+      type(t1) function add(a,b)
+         type(t1), intent(in) :: a,b
+      end function
+end module m1
+
+program foo
+   use m1
+   type(t1), dimension(2,2) :: a = t1(1), b = t1(2)
+   type(t1) :: c=t1(1), d=t1(2)
+   c = c + d
+   a = a + b   ! { dg-error "Unexpected derived-type entities" }
+end program foo
diff --git a/gcc/testsuite/gfortran.dg/pr44491.f90 b/gcc/testsuite/gfortran.dg/pr44491.f90
new file mode 100644
index 00000000000..406bb262f71
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr44491.f90
@@ -0,0 +1,5 @@
+! { dg-do compile }
+! { dg-options "-std=gnu" }
+! PR fortran/44491
+      character*2 escape /z'1B'/  ! { dg-error "Incompatible types in DATA" }
+      end
diff --git a/gcc/testsuite/gfortran.dg/pr51434.f90 b/gcc/testsuite/gfortran.dg/pr51434.f90
new file mode 100644
index 00000000000..49bca660931
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr51434.f90
@@ -0,0 +1,19 @@
+! { dg-do run }
+! PR fortran/51434
+module foo
+   implicit none
+   integer, parameter :: n = 5
+   character(len=1), parameter :: s(n) = 'a'
+   type :: a
+      integer :: m = n
+      character(len=1):: t(n) = transfer('abcde', s)
+   end type a
+end module foo
+
+program bar
+   use foo
+   implicit none
+   type(a) c
+   if (c%m /= n) stop 1
+   if (any(c%t /= ['a', 'b', 'c', 'd', 'e'])) stop 2
+end program bar
diff --git a/gcc/testsuite/gfortran.dg/pr58968.f b/gcc/testsuite/gfortran.dg/pr58968.f
index db06d50fa27..b6ea17f4ae2 100644
--- a/gcc/testsuite/gfortran.dg/pr58968.f
+++ b/gcc/testsuite/gfortran.dg/pr58968.f
@@ -1,5 +1,5 @@
 C PR rtl-optimization/58968.f
-C { dg-do compile { target powerpc*-*-*} }
+C { dg-do compile { target powerpc*-*-* } }
 C { dg-options "-mcpu=power7 -O3 -w -ffast-math  -funroll-loops" }
       SUBROUTINE MAKTABS(IW,SOME,LBOX1,LBOX2,LBOX3,NSPACE,NA,NB,
      *            LBST,X,
diff --git a/gcc/testsuite/gfortran.dg/pr63514.f90 b/gcc/testsuite/gfortran.dg/pr63514.f90
new file mode 100644
index 00000000000..389fb92608e
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr63514.f90
@@ -0,0 +1,41 @@
+! { dg-do compile }
+! PR fortran/63514.f90
+program foo
+
+   implicit none
+
+   integer, volatile :: n
+
+   n = 0
+
+   call bar
+   call bah
+
+   contains
+
+   subroutine bar
+      integer k
+      integer, volatile :: m
+      block
+         integer, save :: i
+         integer, volatile :: j
+         i = 42
+         j = 2 * i
+         k = i + j + n
+      end block
+   end subroutine bar
+
+   pure subroutine bah
+      integer k
+      integer, volatile :: m     ! { dg-error "cannot be specified in a PURE" }
+      block
+         integer, save :: i      ! { dg-error "cannot be specified in a PURE" }
+         integer, volatile :: j  ! { dg-error "cannot be specified in a PURE" }
+         i = 42                  ! { dg-error "has no IMPLICIT type" }
+         j = 2 * i               ! { dg-error "has no IMPLICIT type" }
+         k = i + j + n
+      end block
+      m = k * m                  ! { dg-error "has no IMPLICIT type" }
+   end subroutine bah
+
+end program foo
diff --git a/gcc/testsuite/gfortran.dg/pr64124.f90 b/gcc/testsuite/gfortran.dg/pr64124.f90
new file mode 100644
index 00000000000..349c20de204
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr64124.f90
@@ -0,0 +1,5 @@
+! { dg-do compile }
+! PR fortran/64124.f90
+  character(len=kind(1)) x
+  integer(len(x)) y
+  end
diff --git a/gcc/testsuite/gfortran.dg/pr65453.f90 b/gcc/testsuite/gfortran.dg/pr65453.f90
new file mode 100644
index 00000000000..8d30116b79d
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr65453.f90
@@ -0,0 +1,8 @@
+! { dg-do compile }
+! PR fortran/65453
+! Contributed by Tobias Burnus  <burnus at gcc.gnu.org>
+procedure() :: foo   ! { dg-error "(1)" }
+  contains
+    subroutine foo() ! { dg-error "clashes with procedure" }
+    end
+end
diff --git a/gcc/testsuite/gfortran.dg/pr67803.f90 b/gcc/testsuite/gfortran.dg/pr67803.f90
index 9a8ff309feb..55a1bbf5794 100644
--- a/gcc/testsuite/gfortran.dg/pr67803.f90
+++ b/gcc/testsuite/gfortran.dg/pr67803.f90
@@ -10,5 +10,4 @@ program p
   x = '0' // [character :: 1d1]     ! { dg-error "Incompatible typespec for" }
   x = '0' // [character :: (0.,1.)] ! { dg-error "Incompatible typespec for" }
   x = '0' // [character :: .true.]  ! { dg-error "Incompatible typespec for" }
-  x = '0' // [character :: null()]  ! { dg-error "Incompatible typespec for" }
 end
diff --git a/gcc/testsuite/gfortran.dg/pr67805.f90 b/gcc/testsuite/gfortran.dg/pr67805.f90
index 7371991717d..2aedde8977b 100644
--- a/gcc/testsuite/gfortran.dg/pr67805.f90
+++ b/gcc/testsuite/gfortran.dg/pr67805.f90
@@ -22,7 +22,6 @@ subroutine p
    s = [character([1.]) :: 'x', 'y']      ! { dg-error "INTEGER expression expected" }
    s = [character([1d1]) :: 'x', 'y']     ! { dg-error "INTEGER expression expected" }
    s = [character([(0.,1.)]) :: 'x', 'y'] ! { dg-error "INTEGER expression expected" }
-   s = [character([null()]) :: 'x', 'y']  ! { dg-error "INTEGER expression expected" }
    s =  [character(null()) :: 'x', 'y']   ! { dg-error "INTEGER expression expected" }
    call foo(s)
 end subroutine p
diff --git a/gcc/testsuite/gfortran.dg/pr68318_1.f90 b/gcc/testsuite/gfortran.dg/pr68318_1.f90
index 1a3d59402f6..667e08eed11 100644
--- a/gcc/testsuite/gfortran.dg/pr68318_1.f90
+++ b/gcc/testsuite/gfortran.dg/pr68318_1.f90
@@ -1,5 +1,5 @@
 ! { dg-do compile }
-! { dg-options "-O0"
+! { dg-options "-O0" }
 ! PR fortran/68318
 ! Original code submitted by Gerhard Steinmetz
 ! <gerhard dot steinmetz dot fortran at t-online dot de>
diff --git a/gcc/testsuite/gfortran.dg/pr70409.f90 b/gcc/testsuite/gfortran.dg/pr70409.f90
new file mode 100644
index 00000000000..0372f6e9632
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr70409.f90
@@ -0,0 +1,23 @@
+! { dg-do run }
+! PR fortran/70409
+! Contriubted by Harald Anlauf  <anlauf at gmx dot de>
+program foo
+  integer, parameter :: huge_1 = huge(0_1)
+  character(    huge_1      ), parameter :: x = 'abc'
+  character(    huge(0_1)   ), parameter :: y = 'abc'
+  character(    huge(0_1)+0 ), parameter :: z = 'abcdef'
+  character(    huge(0_1)   )            :: a = 'abc'
+  integer, parameter :: huge_2 = huge(0_2)
+  character(    huge_2      ), parameter :: u = 'abc'
+  character(    huge(0_2)   ), parameter :: v = 'abc'
+  character(int(huge(0_2),4)), parameter :: w = 'abcdef'
+  character(    huge(0_2)   )            :: b = 'abc'
+  if (len(x) /= huge_1) stop 1
+  if (len(y) /= huge_1) stop 2
+  if (len(z) /= huge_1) stop 3
+  if (len(a) /= huge_1) stop 4
+  if (len(u) /= huge_2) stop 5
+  if (len(v) /= huge_2) stop 6
+  if (len(w) /= huge_2) stop 7
+  if (len(b) /= huge_2) stop 8
+end program foo
diff --git a/gcc/testsuite/gfortran.dg/pr70870_1.f90 b/gcc/testsuite/gfortran.dg/pr70870_1.f90
new file mode 100644
index 00000000000..eeec92143f4
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr70870_1.f90
@@ -0,0 +1,10 @@
+! { dg-do compile }
+! { dg-options "-std=gnu" }
+! PR fortran/70870
+! Contributed by Vittorio Zecca <zeccav at gmail dot com >
+      type t
+       integer :: g=0   ! default initialization
+      end type
+      type(t) :: v2
+      data v2/t(2)/     ! { dg-error "default initialization shall not" }
+      end
diff --git a/gcc/testsuite/gfortran.dg/pr71085.f90 b/gcc/testsuite/gfortran.dg/pr71085.f90
new file mode 100644
index 00000000000..11d9850fb90
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr71085.f90
@@ -0,0 +1,12 @@
+! { dg-do compile }
+! PR 71085
+!
+! Testcase from PR by Vladimir Fuka <vladimir.fuka@gmail.com>
+!
+program pr71085
+  print *, f()
+contains
+  function f()
+    integer :: f(iargc()*10)
+  end
+end
diff --git a/gcc/testsuite/gfortran.dg/pr77414.f90 b/gcc/testsuite/gfortran.dg/pr77414.f90
new file mode 100644
index 00000000000..222c1a31542
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr77414.f90
@@ -0,0 +1,9 @@
+! { dg-do compile }
+! PR fortran/77414
+subroutine a(x)               ! { dg-error "(1)" }
+   character(*) :: x
+   contains
+      subroutine a(x)         ! { dg-error " is already defined at" }
+         character(*) :: x
+      end subroutine a
+end subroutine a
diff --git a/gcc/testsuite/gfortran.dg/pr77583.f90 b/gcc/testsuite/gfortran.dg/pr77583.f90
new file mode 100644
index 00000000000..c2ee0744297
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr77583.f90
@@ -0,0 +1,10 @@
+! { dg-do compile }
+!
+! PR fortran/77583 - ICE in pp_quoted_string, at pretty-print.c:966
+! Contributed by Gerhard Steinmetz <gerhard.steinmetz.fortran@t-online.de>
+
+pure subroutine sub(s)
+contains
+   pure subroutine s  ! { dg-error "conflicts with DUMMY argument" }
+   end
+end
diff --git a/gcc/testsuite/gfortran.dg/pr78259.f90 b/gcc/testsuite/gfortran.dg/pr78259.f90
index 82f48ea5f3e..4c40aacbcb7 100644
--- a/gcc/testsuite/gfortran.dg/pr78259.f90
+++ b/gcc/testsuite/gfortran.dg/pr78259.f90
@@ -1,4 +1,4 @@
-! { dg-do "compile" }
+! { dg-do compile }
 ! { dg-options "-fdec-structure" }
 !
 ! PR fortran/78259
diff --git a/gcc/testsuite/gfortran.dg/pr78278.f90 b/gcc/testsuite/gfortran.dg/pr78278.f90
new file mode 100644
index 00000000000..fd50e3e1c18
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr78278.f90
@@ -0,0 +1,14 @@
+! { dg-do compile }
+! { dg-options "-std=f95" }
+! PR fortran/78278
+program p
+   character, pointer :: x => null()
+   data x /null()/         ! { dg-error "GNU Extension: re-initialization" }
+   print *, associated(x)
+end
+
+subroutine foo
+   real :: x = 42
+   data x /0/              ! { dg-error "GNU Extension: re-initialization" }
+   print *, x
+end subroutine foo
diff --git a/gcc/testsuite/gfortran.dg/pr78741.f90 b/gcc/testsuite/gfortran.dg/pr78741.f90
new file mode 100644
index 00000000000..6eb85789f94
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr78741.f90
@@ -0,0 +1,16 @@
+! { dg-do compile }
+! PR fortran/78741
+! Contributed by Gerhard Steinmetz <gerhard.steinmetz.fortran at t-online.de>
+subroutine s(n, x)
+   integer :: n
+   character(n) :: x
+   character, pointer :: z(:)
+   x = 'a'
+   return
+entry g(n, x)           ! { dg-error "is already defined" }
+   x = 'b'
+contains
+   subroutine g         ! { dg-error "(1)" }
+      z(1) = x(1:1)
+   end
+end
diff --git a/gcc/testsuite/gfortran.dg/pr81849.f90 b/gcc/testsuite/gfortran.dg/pr81849.f90
new file mode 100644
index 00000000000..e2f2d6ffbed
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr81849.f90
@@ -0,0 +1,16 @@
+! { dg-do run }
+! PR fortran/81849
+program p
+   implicit none
+   integer  :: n=3
+   if (any(g() /= f())) stop 1
+   contains
+      function g()
+         real g(n)
+         g = 7
+      end function g
+      function f() result(r)
+         real r(n)
+         r = 7
+      end function f
+end program
diff --git a/gcc/testsuite/gfortran.dg/pr83149.f90 b/gcc/testsuite/gfortran.dg/pr83149.f90
new file mode 100644
index 00000000000..fc0607e1369
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr83149.f90
@@ -0,0 +1,14 @@
+! Compiled with pr83149_1.f90
+!
+module mod1
+  integer :: ncells
+end module
+
+module mod2
+contains
+  function get() result(array)
+    use mod1
+    real array(ncells)
+    array = 1.0
+  end function
+end module
diff --git a/gcc/testsuite/gfortran.dg/pr83149_1.f90 b/gcc/testsuite/gfortran.dg/pr83149_1.f90
new file mode 100644
index 00000000000..3a8f5d55d9b
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr83149_1.f90
@@ -0,0 +1,24 @@
+! Compiled with pr83149.f90
+! { dg-do run }
+! { dg-options "-fno-whole-file" }
+! { dg-compile-aux-modules "pr83149.f90" }
+! { dg-additional-sources pr83149.f90 }
+!
+! Contributed by Neil Carlson  <neil.n.carlson@gmail.com>
+!
+subroutine sub(s)
+  use mod2
+  real :: s
+  s = sum(get())
+end
+
+  use mod1
+  real :: s
+  ncells = 2
+  call sub (s)
+  if (int (s) .ne. ncells) stop 1
+  ncells = 10
+  call sub (s)
+  if (int (s) .ne. ncells) stop 2
+end
+
diff --git a/gcc/testsuite/gfortran.dg/pr83149_a.f90 b/gcc/testsuite/gfortran.dg/pr83149_a.f90
new file mode 100644
index 00000000000..3f15198bfe9
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr83149_a.f90
@@ -0,0 +1,11 @@
+! Compiled with pr83149_b.f90
+!
+module mod
+  character(8) string
+contains
+  function get_string() result(s)
+    character(len_trim(string)) s
+    s = string
+  end function
+end module
+
diff --git a/gcc/testsuite/gfortran.dg/pr83149_b.f90 b/gcc/testsuite/gfortran.dg/pr83149_b.f90
new file mode 100644
index 00000000000..f67ffd95159
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr83149_b.f90
@@ -0,0 +1,16 @@
+! Compiled with pr83149_a.f90
+! { dg-do run }
+! { dg-options "-fno-whole-file" }
+! { dg-compile-aux-modules "pr83149_a.f90" }
+! { dg-additional-sources pr83149_a.f90 }
+!
+! Contributed by Neil Carlson  <neil.n.carlson@gmail.com>
+!
+  use mod
+  string = 'fubar'
+  select case (get_string())
+    case ('fubar')
+    case default
+      stop 1
+  end select
+end
diff --git a/gcc/testsuite/gfortran.dg/pr83939.f90 b/gcc/testsuite/gfortran.dg/pr83939.f90
new file mode 100644
index 00000000000..dfeaac71630
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr83939.f90
@@ -0,0 +1,12 @@
+! { dg-do compile }
+elemental function f() result(s) ! { dg-error "shall not have an ALLOCATABLE or POINTER" }
+  allocatable s
+  allocate(s)
+  s = 3.5
+end function
+
+elemental function g() result(s) ! { dg-error "shall not have an ALLOCATABLE or POINTER" }
+  pointer s
+  allocate(s)
+  s = 3.5
+end function
diff --git a/gcc/testsuite/gfortran.dg/pr84117.f90 b/gcc/testsuite/gfortran.dg/pr84117.f90
new file mode 100644
index 00000000000..1853d8c5f39
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr84117.f90
@@ -0,0 +1,7 @@
+! PR tree-optimization/84117
+! { dg-do compile }
+! { dg-options "-O3 -ftrapv" }
+  FUNCTION pw_integral_aa ( cc ) RESULT ( integral_value )
+    COMPLEX(KIND=8), DIMENSION(:), POINTER :: cc
+    integral_value = accurate_sum ( CONJG ( cc (:) ) * cc (:) )
+  END FUNCTION pw_integral_aa
diff --git a/gcc/testsuite/gfortran.dg/pr84734.f90 b/gcc/testsuite/gfortran.dg/pr84734.f90
new file mode 100644
index 00000000000..4b117ae43e7
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr84734.f90
@@ -0,0 +1,4 @@
+! { dg-do compile }
+! PR fortran/84734
+   integer :: b(huge(1_8)+1_8) = 0 ! { dg-error "Arithmetic overflow" }
+   end
diff --git a/gcc/testsuite/gfortran.dg/pr85138_1.f90 b/gcc/testsuite/gfortran.dg/pr85138_1.f90
new file mode 100644
index 00000000000..a64d9ce9329
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr85138_1.f90
@@ -0,0 +1,29 @@
+! { dg-do compile }
+module fox_m_fsys_format
+
+  interface len
+     module procedure str_real_sp_len, str_real_sp_fmt_len
+  end interface
+
+contains
+
+  pure function str_real_sp_fmt_len(x, fmt) result(n)
+    real, intent(in) :: x
+    character(len=*), intent(in) :: fmt
+    if (.not.checkFmt(fmt)) then
+    endif
+  end function str_real_sp_fmt_len
+  pure function str_real_sp_len(x) result(n)
+    real, intent(in) :: x
+    n = len(x, "")
+  end function str_real_sp_len
+  pure function str_real_dp_matrix(xa) result(s)
+    real, intent(in) :: xa
+    character(len=len(xa)) :: s
+  end function str_real_dp_matrix
+
+  pure function checkfmt(s) result(a)
+   logical a
+   character(len=*), intent(in) :: s
+  end function checkfmt
+end module fox_m_fsys_format
diff --git a/gcc/testsuite/gfortran.dg/pr85138_2.f90 b/gcc/testsuite/gfortran.dg/pr85138_2.f90
new file mode 100644
index 00000000000..942cc6684d8
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr85138_2.f90
@@ -0,0 +1,32 @@
+! { dg-do compile }
+module fox_m_fsys_format
+  interface len
+    module procedure str_real_dp_len, str_real_dp_fmt_len
+  end interface
+contains
+  pure function str_real_dp_fmt_len(x, fmt) result(n)
+    real, intent(in) :: x
+    character(len=*), intent(in) :: fmt
+    if (.not.checkFmt(fmt)) then
+    endif
+  end function str_real_dp_fmt_len
+  pure function str_real_dp_len(x) result(n)
+    real, intent(in) :: x
+  end function str_real_dp_len
+  pure function str_real_dp_array_len(xa) result(n)
+    real, dimension(:), intent(in) :: xa
+  end function str_real_dp_array_len
+  pure function str_real_dp_array_fmt_len(xa, fmt) result(n)
+    real, dimension(:), intent(in) :: xa
+    character(len=*), intent(in) :: fmt
+  end function str_real_dp_array_fmt_len
+  pure function str_real_dp_fmt(x, fmt) result(s)
+    real, intent(in) :: x
+    character(len=*), intent(in) :: fmt
+    character(len=len(x, fmt)) :: s
+  end function str_real_dp_fmt
+  pure function checkFmt(fmt) result(good)
+    character(len=*), intent(in) :: fmt
+    logical :: good
+  end function checkFmt
+end module fox_m_fsys_format
diff --git a/gcc/testsuite/gfortran.dg/pr85520.f90 b/gcc/testsuite/gfortran.dg/pr85520.f90
new file mode 100644
index 00000000000..3e66a9020f8
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr85520.f90
@@ -0,0 +1,7 @@
+! { dg-do run }
+! PR fortran/85520
+! Original code from Gerhard Steinmetz <gscfq at t-online dot de>
+program p
+   character(-huge(1)) :: c = ' '
+    if (len(c) /= 0) stop 1
+end
diff --git a/gcc/testsuite/gfortran.dg/pr85521_1.f90 b/gcc/testsuite/gfortran.dg/pr85521_1.f90
new file mode 100644
index 00000000000..57e4620fe0d
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr85521_1.f90
@@ -0,0 +1,8 @@
+! { dg-do compile }
+! PR fortran/85521
+program p
+   character(3) :: c = 'abc'
+   character(3) :: z(1)
+   z = [ c(:-1) ]
+   print *, z
+end
diff --git a/gcc/testsuite/gfortran.dg/pr85521_2.f90 b/gcc/testsuite/gfortran.dg/pr85521_2.f90
new file mode 100644
index 00000000000..737b61a11b9
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr85521_2.f90
@@ -0,0 +1,8 @@
+! { dg-do compile }
+! PR fortran/85521
+program p
+   character(3) :: c = 'abc'
+   character(3) :: z(1)
+   z = [ c(:-2) ]
+   print *, z
+end
diff --git a/gcc/testsuite/gfortran.dg/pr85542.f90 b/gcc/testsuite/gfortran.dg/pr85542.f90
new file mode 100644
index 00000000000..f61d2c9beb0
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr85542.f90
@@ -0,0 +1,7 @@
+! { dg-do compile }
+! PR fortran/85542
+function f(x)
+   character(*), intent(in) :: x
+   character((len((x)))) :: f
+   f = x
+end
diff --git a/gcc/testsuite/gfortran.dg/pr85543.f90 b/gcc/testsuite/gfortran.dg/pr85543.f90
new file mode 100644
index 00000000000..d3f83276a7f
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr85543.f90
@@ -0,0 +1,8 @@
+! { dg-do compile }
+! PR fortran/85543
+program p
+   procedure(), pointer :: z
+contains
+   real(z()) function f()  ! { dg-error "in initialization expression at" }
+   end
+end
diff --git a/gcc/testsuite/gfortran.dg/pr85687.f90 b/gcc/testsuite/gfortran.dg/pr85687.f90
new file mode 100644
index 00000000000..03bc2119364
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr85687.f90
@@ -0,0 +1,8 @@
+! { dg-do compile }
+! PR fortran/85687
+! Code original contributed by Gerhard Steinmetz gscfq at t-oline dot de
+program p
+   type t
+   end type
+   print *, rank(t)  ! { dg-error "must be a data object" }
+end
diff --git a/gcc/testsuite/gfortran.dg/pr85779_1.f90 b/gcc/testsuite/gfortran.dg/pr85779_1.f90
new file mode 100644
index 00000000000..186568ff124
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr85779_1.f90
@@ -0,0 +1,6 @@
+! { dg-do compile }
+! PR fortran/85779
+type(t) function f() ! { dg-error "is not accessible" }
+   type f            ! { dg-error "already has a basic type" }
+   end type          ! { dg-error "END FUNCTION statement" }
+end
diff --git a/gcc/testsuite/gfortran.dg/pr85779_2.f90 b/gcc/testsuite/gfortran.dg/pr85779_2.f90
new file mode 100644
index 00000000000..4cc3c62979c
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr85779_2.f90
@@ -0,0 +1,7 @@
+! { dg-do compile }
+! PR fortran/85779
+type(t) function f() result(z)   ! { dg-error "is not accessible" }
+   type z                        ! { dg-error "already has a basic type" }
+   end type                      ! { dg-error "END FUNCTION statement" }
+end
+
diff --git a/gcc/testsuite/gfortran.dg/pr85779_3.f90 b/gcc/testsuite/gfortran.dg/pr85779_3.f90
new file mode 100644
index 00000000000..fba1133b3ea
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr85779_3.f90
@@ -0,0 +1,7 @@
+! { dg-do compile }
+! PR fortran/85779
+class(t) function f()   ! { dg-error "must be dummy, allocatable or pointer" }
+   type f               ! { dg-error "already has a basic type" }
+   end type             ! { dg-error "END FUNCTION statement" }
+end
+
diff --git a/gcc/testsuite/gfortran.dg/pr85780.f90 b/gcc/testsuite/gfortran.dg/pr85780.f90
new file mode 100644
index 00000000000..ad6b27fc4db
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr85780.f90
@@ -0,0 +1,5 @@
+! { dg-do compile }
+! { dg-options "-std=legacy" }
+! PR fortran/85780
+subroutine s(*) bind(c)
+end
diff --git a/gcc/testsuite/gfortran.dg/pr85797.f90 b/gcc/testsuite/gfortran.dg/pr85797.f90
new file mode 100644
index 00000000000..01d8e640621
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr85797.f90
@@ -0,0 +1,31 @@
+! { dg-do compile }
+! PR fortran/83515 - ICE: Invalid expression in gfc_element_size 
+! PR fortran/85797 - ICE in gfc_element_size, at fortran/target-memory.c:126
+! PR fortran/89904 - ICE in gfortran starting with r270045
+
+recursive subroutine a
+  c = transfer (a, b)           ! { dg-error "'SOURCE' argument of 'TRANSFER'" }
+end
+
+recursive subroutine d
+  c = transfer (b, d)           ! { dg-error "'MOLD' argument of 'TRANSFER'" }
+end
+
+subroutine f
+  use, intrinsic :: iso_c_binding
+  integer(c_intptr_t) :: b, c
+  procedure(), pointer :: a
+  c = transfer (a, b)
+  c = transfer (transfer (b, a), b)
+end
+
+module m
+contains
+  function f () result (z)
+    class(*), pointer :: z
+  end function f
+  recursive subroutine s (q)
+    procedure(f) :: q
+    call s (q)
+  end subroutine s
+end
diff --git a/gcc/testsuite/gfortran.dg/pr85798.f90 b/gcc/testsuite/gfortran.dg/pr85798.f90
new file mode 100644
index 00000000000..1cc224d1fef
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr85798.f90
@@ -0,0 +1,14 @@
+! { dg-do compile }
+program p
+   type t
+      integer, allocatable :: a(:)
+   end type
+   type u
+      real x
+      type(t) y
+   end type
+   type(t) :: z
+   type(u) :: q
+   data z%a(1) / 789 /     ! { dg-error "Allocatable component" }
+   data q%y%a(1) / 789 /   ! { dg-error "Allocatable component" }
+end
diff --git a/gcc/testsuite/gfortran.dg/pr85895.f90 b/gcc/testsuite/gfortran.dg/pr85895.f90
new file mode 100644
index 00000000000..184266e5ec8
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr85895.f90
@@ -0,0 +1,17 @@
+! { dg-do compile }
+! { dg-options "-fcoarray=lib" }
+! PR fortran/85895
+subroutine p
+   character(80) :: c(2)
+   sync memory (errmsg=c)        ! { dg-error "scalar CHARACTER variable" }
+end subroutine p
+
+subroutine q
+   character(80) :: c(2)
+   sync memory (errmsg=c(1:2))   ! { dg-error "scalar CHARACTER variable" }
+end subroutine q
+
+subroutine r
+   character(80) :: c(2)
+   sync memory (errmsg=c(1))
+end subroutine r
diff --git a/gcc/testsuite/gfortran.dg/pr85996.f90 b/gcc/testsuite/gfortran.dg/pr85996.f90
new file mode 100644
index 00000000000..e594d6771c8
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr85996.f90
@@ -0,0 +1,69 @@
+! { dg-do compile }
+module strings
+
+   type string
+      integer :: len = 0, size = 0
+      character, pointer :: chars(:) => null()
+   end type string
+
+   interface length
+      module procedure len_s
+   end interface
+
+   interface char
+      module procedure s_to_c, s_to_slc  
+   end interface
+
+   interface uppercase
+      module procedure uppercase_c
+   end interface
+
+   interface replace
+      module procedure replace_ccs
+   end interface
+
+   contains
+
+      elemental function len_s(s)
+         type(string), intent(in) :: s
+         integer :: len_s
+      end function len_s
+
+      pure function s_to_c(s)
+         type(string),intent(in) :: s
+         character(length(s)) :: s_to_c
+      end function s_to_c
+
+      pure function s_to_slc(s,long)
+         type(string),intent(in) :: s
+         integer, intent(in) :: long
+         character(long) :: s_to_slc
+      end function s_to_slc
+
+      pure function lr_sc_s(s,start,ss) result(l)
+         type(string), intent(in) :: s
+         character(*), intent(in) :: ss
+         integer, intent(in)  :: start
+         integer :: l
+      end function lr_sc_s
+
+      pure function lr_ccc(s,tgt,ss,action) result(l)
+         character(*), intent(in) :: s,tgt,ss,action
+         integer :: l
+         select case(uppercase(action))
+         case default
+         end select
+      end function lr_ccc
+
+      function replace_ccs(s,tgt,ss) result(r)
+         character(*), intent(in)             :: s,tgt
+         type(string), intent(in)             :: ss
+         character(lr_ccc(s,tgt,char(ss),'first'))  :: r
+      end function replace_ccs
+
+      pure function uppercase_c(c)
+         character(*), intent(in) :: c
+         character(len(c)) :: uppercase_c
+      end function uppercase_c
+
+end module strings
diff --git a/gcc/testsuite/gfortran.dg/pr86045.f90 b/gcc/testsuite/gfortran.dg/pr86045.f90
new file mode 100644
index 00000000000..685672f1dbd
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr86045.f90
@@ -0,0 +1,7 @@
+! { dg-do compile }
+program p
+   logical :: a(2) = (mod([2,3],0) == 0)     ! { dg-error "shall not be zero" }
+   integer :: b = count(mod([2,3],0) == 0)   ! { dg-error "shall not be zero" }
+   integer :: c = all(mod([2,3],0) == 0)     ! { dg-error "shall not be zero" }
+   integer :: d = any(mod([2,3],0) == 0)     ! { dg-error "shall not be zero" }
+end
diff --git a/gcc/testsuite/gfortran.dg/pr86059.f90 b/gcc/testsuite/gfortran.dg/pr86059.f90
new file mode 100644
index 00000000000..e0caed102d7
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr86059.f90
@@ -0,0 +1,8 @@
+! { dg-do compile }
+! PR fortran/86059
+program foo
+   integer :: i(2) = [ null(), 1 ]           ! { dg-error "cannot appear in an array constructor" }
+   integer :: j(2) = [ (null(), n = 1, 2) ]  ! { dg-error "cannot appear in an array constructor" }
+   integer k(2)
+   k = 42 + [1, null()]                      ! { dg-error "cannot appear in an array constructor" }
+end program foo
diff --git a/gcc/testsuite/gfortran.dg/pr86110.f90 b/gcc/testsuite/gfortran.dg/pr86110.f90
new file mode 100644
index 00000000000..890670f5854
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr86110.f90
@@ -0,0 +1,7 @@
+! { dg-do compile }
+! PR fortran/86110
+program p
+   character(:), allocatable :: x, y
+   x = 'abc'
+   y = [x(:)]  ! { dg-error "Incompatible ranks 0 and 1" }
+end
diff --git a/gcc/testsuite/gfortran.dg/pr88138.f90 b/gcc/testsuite/gfortran.dg/pr88138.f90
new file mode 100644
index 00000000000..04b826c8cbe
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr88138.f90
@@ -0,0 +1,9 @@
+! { dg-do compile }
+program p
+   type t
+      character :: c = 'c'
+   end type
+   type(t), parameter :: x  = 1.e1  ! { dg-error "Incompatible initialization between a" }s
+   print *, 'a' // x%c
+end
+! { dg-prune-output "has no IMPLICIT type" }
diff --git a/gcc/testsuite/gfortran.dg/pr88155.f90 b/gcc/testsuite/gfortran.dg/pr88155.f90
new file mode 100644
index 00000000000..e10eaca2ba6
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr88155.f90
@@ -0,0 +1,9 @@
+! { dg-do compile }
+program p
+   type t
+      integer :: a
+   end type
+   type(t) :: x
+   data x /t()1/     ! { dg-error "No initializer for component" }
+   print *, x
+end
diff --git a/gcc/testsuite/gfortran.dg/pr88169_1.f90 b/gcc/testsuite/gfortran.dg/pr88169_1.f90
new file mode 100644
index 00000000000..6ea4aba5e10
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr88169_1.f90
@@ -0,0 +1,21 @@
+! { dg-do run }
+module foo_nml
+   implicit none
+   real :: x = -1
+   namelist /foo/ x
+end module
+
+program main
+   use foo_nml, only: bar => foo, x
+   implicit none
+   integer fd
+   x = 42
+   open(newunit=fd, file='tmp.dat', status='replace')
+   write(fd,nml=bar)
+   close(fd)
+   open(newunit=fd, file='tmp.dat', status='old')
+   read(fd,nml=bar)
+   if (x /= 42) stop 1
+   close(fd)
+end program
+! { dg-final { cleanup-modules "foo_nml" } }
diff --git a/gcc/testsuite/gfortran.dg/pr88169_2.f90 b/gcc/testsuite/gfortran.dg/pr88169_2.f90
new file mode 100644
index 00000000000..a7805b4557a
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr88169_2.f90
@@ -0,0 +1,31 @@
+! { dg-do run }
+module foo_nml
+   implicit none
+   real :: x = -1
+   namelist /foo/ x
+end module
+!
+! Yes, implicit typing of local variable 'x'.
+!
+program main
+   use foo_nml, only: bar => foo
+   integer fd
+   x = 42
+   open(newunit=fd, file='tmp.dat', status='replace')
+   write(fd,nml=bar)
+   close(fd)
+   open(newunit=fd, file='tmp.dat', status='old')
+   read(fd,nml=bar)
+   close(fd)
+   call bah
+   if (x /= 42) stop 1
+end program
+
+subroutine bah
+   use foo_nml
+   integer fd
+   open(newunit=fd, file='tmp.dat', status='old')
+   read(fd,nml=foo)
+   if (x /= -1) stop 2
+   close(fd, status='delete')
+end subroutine bah
diff --git a/gcc/testsuite/gfortran.dg/pr88169_3.f90 b/gcc/testsuite/gfortran.dg/pr88169_3.f90
new file mode 100644
index 00000000000..6bc24ed6b71
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr88169_3.f90
@@ -0,0 +1,15 @@
+! { dg-do compile }
+! { dg-options "-std=f95" }
+module foo_nml
+   implicit none
+   real :: x = -1
+   namelist /foo/ x
+end module
+
+program main
+   use foo_nml, only: bar => foo, x
+   implicit none
+   real a
+   namelist /bar/a  ! { dg-error "already is USE associated" }
+end program
+! { dg-final { cleanup-modules "foo_nml" } }
diff --git a/gcc/testsuite/gfortran.dg/pr88205.f90 b/gcc/testsuite/gfortran.dg/pr88205.f90
new file mode 100644
index 00000000000..d9e08069109
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr88205.f90
@@ -0,0 +1,14 @@
+! { dg-do compile }
+! PR fortran/88205
+subroutine s1
+   real, parameter :: status = 0
+   open (newunit=n, status=status)        ! { dg-error "STATUS requires" }
+end
+subroutine s2
+   complex, parameter :: status = 0
+   open (newunit=n, status=status)        ! { dg-error "STATUS requires" }
+end
+program p
+  logical, parameter :: status = .false.
+  open (newunit=a, status=status)         ! { dg-error "STATUS requires" }
+end
diff --git a/gcc/testsuite/gfortran.dg/pr88206.f90 b/gcc/testsuite/gfortran.dg/pr88206.f90
new file mode 100644
index 00000000000..71c61f06098
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr88206.f90
@@ -0,0 +1,8 @@
+! { dg-do compile }
+! PR fortran/88206
+program p
+   integer, parameter :: z(4) = [1,2,3,4]
+   integer :: k = 2
+   print *, [real(z(k))]
+end
+
diff --git a/gcc/testsuite/gfortran.dg/pr88228.f90 b/gcc/testsuite/gfortran.dg/pr88228.f90
new file mode 100644
index 00000000000..cf5bbbe0ae8
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr88228.f90
@@ -0,0 +1,8 @@
+! { dg-do compile }
+! { dg-options "-fdec" }
+! PR fortran/88228
+program p
+   integer :: n = .not. 1
+   integer :: j = .true. .or. 1
+end
+
diff --git a/gcc/testsuite/gfortran.dg/pr88249.f90 b/gcc/testsuite/gfortran.dg/pr88249.f90
new file mode 100644
index 00000000000..401fb3514e7
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr88249.f90
@@ -0,0 +1,7 @@
+! { dg-do compile }
+program p
+   backspace (err=1) ! { dg-error "UNIT number missing" }
+   endfile (err=1)   ! { dg-error "UNIT number missing" }
+   flush (err=1)     ! { dg-error "UNIT number missing" }
+   rewind (err=1)    ! { dg-error "UNIT number missing" }
+end
diff --git a/gcc/testsuite/gfortran.dg/pr88269.f90 b/gcc/testsuite/gfortran.dg/pr88269.f90
new file mode 100644
index 00000000000..6cda5f7a339
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr88269.f90
@@ -0,0 +1,6 @@
+! { dg-do compile }
+! PR fortran/88269
+program p
+   write (end=1e1) ! { dg-error "tag not allowed" }
+end
+
diff --git a/gcc/testsuite/gfortran.dg/pr89077.f90 b/gcc/testsuite/gfortran.dg/pr89077.f90
new file mode 100644
index 00000000000..26a0d2821bb
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr89077.f90
@@ -0,0 +1,11 @@
+! { dg-do run }
+!
+! PR fortran/89077 - ICE using * as len specifier for character parameter
+
+program test
+  implicit none
+  integer :: i
+  character(*), parameter :: s = 'abcdef'
+  character(*), parameter :: t = transfer ([(s(i:i), i=1,len(s))], s)
+  if (len (t) /= len (s) .or. t /= s) stop 1
+end
diff --git a/gcc/testsuite/gfortran.dg/pr89253.f b/gcc/testsuite/gfortran.dg/pr89253.f
new file mode 100644
index 00000000000..6dc9df138fd
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr89253.f
@@ -0,0 +1,19 @@
+! { dg-do compile }
+! { dg-additional-options "-fsplit-loops -fno-tree-dominator-opts -std=legacy -w" }
+      program jr
+      integer :: w5, pg, zh
+      w5 = 0
+      write (w5)
+      assign 0002 to w5
+      do pg = 1, 3
+         if (pg .eq. 1) then
+            do zh = 1, pg
+            end do
+         else
+            goto w5
+ 0001       zh = 0
+ 0002       zh = 0
+            assign 0001 to w5
+         endif
+      end do
+      end
diff --git a/gcc/testsuite/gfortran.dg/pr90344.f90 b/gcc/testsuite/gfortran.dg/pr90344.f90
new file mode 100644
index 00000000000..9d74a402774
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr90344.f90
@@ -0,0 +1,25 @@
+! { dg-do compile }
+! { dg-additional-options "-ffrontend-optimize" }
+! PR 90344 - this used to ICE.
+! Test case by Urban Jost.
+module M_xterm
+contains
+   elemental function func1(ch) result(res)
+      character,intent(in) :: ch
+      logical              :: res
+      res=.true.
+   end function func1
+   elemental function func2(ch) result(res)
+      character,intent(in) :: ch
+      logical              :: res
+      res=.false.
+   end function func2
+   pure function s2a(string)  RESULT (array)
+      character(len=*),intent(in) :: string
+      character(len=1)            :: array(len(string))
+      forall(i=1:len(string)) array(i) = string(i:i)
+   end function s2a
+   subroutine sub1()
+      write(*,*)all(func1(s2a('ABCDEFG')).or.func2(s2a('ABCDEFG')))
+   end subroutine sub1
+end module M_xterm
diff --git a/gcc/testsuite/gfortran.dg/proc_ptr_50.f90 b/gcc/testsuite/gfortran.dg/proc_ptr_50.f90
new file mode 100644
index 00000000000..14f0c0a7935
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/proc_ptr_50.f90
@@ -0,0 +1,68 @@
+! { dg-do compile }
+!
+! Test the fix for PR86242, in which the procedure pointer in 'tester'
+! was being copied as if it were an allocatable class component.
+!
+! Contributed by <cfd@mnet-mail.de>
+!
+module test
+
+   implicit none
+
+   private
+   public :: tester
+
+   type :: wrapper
+      integer(4) :: n
+   end type wrapper
+
+   type :: output
+      real(8) :: dummy
+   end type output
+
+   type :: tester
+      class(wrapper),  allocatable :: wrap
+      procedure(proc1), pointer :: ptr => null()
+   end type tester
+
+   abstract interface
+      function proc1(self) result(uc)
+         import :: tester, output
+         class(tester), intent(in) :: self
+         class(output), allocatable :: uc
+      end function proc1
+   end interface
+
+end module test
+
+! Comment #2 from Janus Weil  <janus@gcc.gnu.org>
+module test1
+
+   implicit none
+
+   type :: output
+   end type
+
+   type :: tester
+      integer,  allocatable :: wrap
+      procedure(proc1), pointer, nopass :: ptr
+   end type
+
+   interface                              ! Originally abstract
+      function proc1() result(uc)
+         import :: output
+         class(output), allocatable :: uc ! Works if a pointer
+      end function
+   end interface
+
+! PR82969 from Gerhard Steinmetz  <gscfq@t-online.de>
+   type t
+      real, allocatable :: x(:)
+      procedure(f), nopass, pointer :: g
+   end type
+contains
+   function f() result(z)
+      class(t), allocatable :: z
+   end
+
+end module test1
diff --git a/gcc/testsuite/gfortran.dg/ptr_func_assign_5.f08 b/gcc/testsuite/gfortran.dg/ptr_func_assign_5.f08
new file mode 100644
index 00000000000..9aa19e69b64
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/ptr_func_assign_5.f08
@@ -0,0 +1,45 @@
+! { dg-do run }
+!
+! Test the fix for PR77703, in which calls of the pointer function
+! caused an ICE in 'gfc_trans_auto_character_variable'.
+!
+! Contributed by Gerhard Steinmetz  <gerhard.steinmetz.fortran@t-online.de>
+!
+module m
+   implicit none
+   private
+   integer, parameter, public :: n = 2
+   integer, parameter :: ell = 6
+
+   character(len=n*ell), target, public :: s
+
+   public :: t
+contains
+   function t( idx ) result( substr )
+      integer, intent(in) :: idx
+      character(len=ell), pointer  :: substr
+
+      if ( (idx < 0).or.(idx > n) ) then
+         error stop
+      end if
+      substr => s((idx-1)*ell+1:idx*ell)
+   end function t
+end module m
+
+program p
+   use m, only : s, t, n
+   integer :: i
+
+   ! Define 's'
+   s = "123456789012"
+
+   ! Then perform operations involving 't'
+   if (t(1) .ne. "123456") stop 1
+   if (t(2) .ne. "789012") stop 2
+
+   ! Do the pointer function assignments
+   t(1) = "Hello "
+   if (s .ne. "Hello 789012") Stop 3
+   t(2) = "World!"
+   if (s .ne. "Hello World!") Stop 4
+end program p
diff --git a/gcc/testsuite/gfortran.dg/public_private_module_10.f90 b/gcc/testsuite/gfortran.dg/public_private_module_10.f90
new file mode 100644
index 00000000000..1877cc23279
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/public_private_module_10.f90
@@ -0,0 +1,18 @@
+! { dg-do compile }
+! PR 87734 - this used to issue spurious errors.
+
+module m_vstring
+  implicit none
+
+  public :: vstring_length
+
+contains
+
+  subroutine vstring_cast()
+    character ( len = vstring_length() ) :: char_string
+  end subroutine
+
+  pure integer function vstring_length ()
+  end function
+
+end module
diff --git a/gcc/testsuite/gfortran.dg/realloc_on_assign_29.f90 b/gcc/testsuite/gfortran.dg/realloc_on_assign_29.f90
new file mode 100644
index 00000000000..a9160660280
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/realloc_on_assign_29.f90
@@ -0,0 +1,13 @@
+! { dg-do run }
+! PR fortran/81116
+! The assignment was broken due to a missing temporary.
+! Original test case by Clive Page.
+
+program test10
+  implicit none
+  character(:), allocatable :: string
+  !
+  string = '1234567890'
+  string = string(1:5) // string(7:)
+  if (string /= '123457890') STOP 1
+end program test10
diff --git a/gcc/testsuite/gfortran.dg/realloc_on_assign_30.f90 b/gcc/testsuite/gfortran.dg/realloc_on_assign_30.f90
new file mode 100644
index 00000000000..4e7eb4ba220
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/realloc_on_assign_30.f90
@@ -0,0 +1,13 @@
+! { dg-do compile }
+! PR 85641 - this used to ICE due do infinite recursion.
+! Test case by Antony Lewis.
+program tester
+character(LEN=:), allocatable :: fields
+integer j
+character(LEN=4), parameter :: CMB_CL_Fields = 'TEBP'
+
+fields = ''
+j=1
+fields = fields // CMB_CL_Fields(j:j)
+
+end program tester
diff --git a/gcc/testsuite/gfortran.dg/select_type_40.f90 b/gcc/testsuite/gfortran.dg/select_type_40.f90
new file mode 100644
index 00000000000..4bfa1c7e848
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/select_type_40.f90
@@ -0,0 +1,9 @@
+! { dg-do compile }
+! { dg-additional-options "-fdefault-integer-8" }
+! PR 78238 - this used to cause an ICE.
+! Original test cae by Gerhard Steinmetz
+class(*), allocatable :: q
+select type (x => q)
+type is (real)
+end select
+end
diff --git a/gcc/testsuite/gfortran.dg/select_type_41.f90 b/gcc/testsuite/gfortran.dg/select_type_41.f90
new file mode 100644
index 00000000000..eebb87922bd
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/select_type_41.f90
@@ -0,0 +1,30 @@
+! { dg-do compile }
+! { dg-options "-O2" }
+!
+! Tests the fix for PR80965 in which the use of the name 'loc'
+! for the dummy argument of 'xyz' caused an ICE. If the module
+! was used, the error "DUMMY attribute conflicts with INTRINSIC
+! attribute in ‘loc’ at (1)" was emitted. Note that although 'loc'
+! is a GNU extension and so can be over-ridden, this is not very
+! good practice.
+!
+! Contributed by David Sagan  <david.sagan@gmail.com>
+!
+module mode3_mod
+contains
+  subroutine xyz (loc)
+    implicit none
+    class(*) :: loc
+    real x(6)
+    integer ix_use
+    select type (loc)
+      type is (integer)
+        x = 0
+        print *, "integer"
+      type is (real)
+        ix_use = 0
+        print *, "real"
+    end select
+  end subroutine xyz
+end module mode3_mod
+
diff --git a/gcc/testsuite/gfortran.dg/select_type_42.f90 b/gcc/testsuite/gfortran.dg/select_type_42.f90
new file mode 100644
index 00000000000..ff73e6c7858
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/select_type_42.f90
@@ -0,0 +1,26 @@
+! { dg-do run }
+!
+! Tests the fix for PR82275.
+! Associating a name with a reduced-dimension section of a
+! multidimensional array precluded subsequent use of the name
+! with the appropriately reduced dimensionality and instead
+! required use of the (invalid) full set of original dimensions.
+!
+! Contributed by Damian Rouson  <damian@sourceryinstitute.org>
+!
+  type component
+   integer :: i
+  end type
+  type container
+    class(component), allocatable :: component_array(:,:)
+  end type
+  type(container) bag
+  type(component) section_copy
+  allocate(bag%component_array, source = reshape ([component(10), component (100)], [1,2]))
+  select type(associate_name=>bag%component_array(1,:))
+    type is (component)
+      section_copy = associate_name(2)  ! gfortran rejected valid
+!      section_copy = associate_name(1,1)! gfortran accepted invalid
+  end select
+  if (section_copy%i .ne. 100) stop 1
+end
diff --git a/gcc/testsuite/gfortran.dg/select_type_45.f90 b/gcc/testsuite/gfortran.dg/select_type_45.f90
new file mode 100644
index 00000000000..a5e04fabcad
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/select_type_45.f90
@@ -0,0 +1,22 @@
+! { dg-do compile }
+!
+! Tests the fix for PR80260
+!
+! Contributed by Damian Rouson  <damian@sourceryinstitute.org>
+!
+    type foo
+    end type foo
+    type, extends(foo) :: bar
+    end type
+contains
+    subroutine f(x)
+      class(foo) x(:,:)
+      select type(x)
+        class is (bar)
+          call g(x(1,:))   ! ICEd here.
+      end select
+    end subroutine
+    subroutine g(y)
+      class(bar) y(:)
+    end subroutine
+end
diff --git a/gcc/testsuite/gfortran.dg/select_type_46.f90 b/gcc/testsuite/gfortran.dg/select_type_46.f90
new file mode 100644
index 00000000000..7582ab78f91
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/select_type_46.f90
@@ -0,0 +1,21 @@
+! { dg-do compile }
+!
+! Tests the fix for PR82077
+!
+! Contributed by Damian Rouson  <damian@sourceryinstitute.org>
+!
+    type parent
+    end type parent
+    type, extends(parent) :: child
+    end type
+    class(parent), allocatable :: foo(:,:)
+    allocate(child::foo(1,1))
+    select type(foo)
+      class is (child)
+        call gfortran7_ICE(foo(1,:))  ! ICEd here.
+    end select
+contains
+    subroutine gfortran7_ICE(bar)
+      class(child) bar(:)
+    end subroutine
+end
diff --git a/gcc/testsuite/gfortran.dg/shape_9.f90 b/gcc/testsuite/gfortran.dg/shape_9.f90
new file mode 100644
index 00000000000..6d33f976cb8
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/shape_9.f90
@@ -0,0 +1,16 @@
+! { dg-do  run }
+! { dg-require-effective-target lto }
+! { dg-options "-flto" }
+! Check that there are no warnings with LTO for a KIND argument.
+!
+program test
+   implicit none
+   real, allocatable :: x(:,:)
+
+   allocate(x(2,5))
+   if (any(shape(x) /= [ 2, 5 ])) call abort
+   if (any(shape(x,kind=1) /= [ 2, 5 ])) call abort
+   if (any(shape(x,kind=2) /= [ 2, 5 ])) call abort
+   if (any(shape(x,kind=4) /= [ 2, 5 ])) call abort
+   if (any(shape(x,kind=8) /= [ 2, 5 ])) call abort
+ end program test
diff --git a/gcc/testsuite/gfortran.dg/statement_function_1.f90 b/gcc/testsuite/gfortran.dg/statement_function_1.f90
new file mode 100644
index 00000000000..e717725e67e
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/statement_function_1.f90
@@ -0,0 +1,24 @@
+! { dg-do compile }
+! PR fortran/84276
+      subroutine stepns(hh, h, s, w)
+      real, intent(inout) :: h, hh, s
+      real, intent(out) :: w
+      real :: qofs
+      integer i
+      qofs(s) = s
+      w = qofs(hh + h)
+      i = 42
+      w = qofs(i)       ! { dg-error "Type mismatch in argument" }
+      end subroutine stepns
+
+      subroutine step(hh, h, s, w)
+      real, intent(inout) :: h, hh, s
+      real, intent(out) :: w
+      real :: qofs
+      integer i
+      qofs(s, i) = i * s
+      i = 42
+      w = qofs(hh, i)
+      w = qofs(i = i, s = hh) ! { dg-error "invalid in a statement function" }
+      end subroutine step
+! { dg-prune-output " Obsolescent feature" }
diff --git a/gcc/testsuite/gfortran.dg/statement_function_2.f90 b/gcc/testsuite/gfortran.dg/statement_function_2.f90
new file mode 100644
index 00000000000..703ca1716ca
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/statement_function_2.f90
@@ -0,0 +1,26 @@
+! { dg-do compile }
+! PR fortran/54223
+subroutine r(d)
+    implicit none
+    integer, optional :: d
+    integer :: h, q
+    q(d) = d + 1     ! statement function statement
+    h = q(d)
+end subroutine r
+
+subroutine s(x)
+    implicit none
+    integer, optional :: x
+    integer :: g, z
+    g(x) = x + 1     ! statement function statement
+    z = g()          ! { dg-error "Missing actual argument" }
+end subroutine s
+
+subroutine t(a)
+    implicit none
+    integer :: a
+    integer :: f, y
+    f(a) = a + 1     ! statement function statement
+    y = f()          ! { dg-error "Missing actual argument" }
+end subroutine t
+! { dg-prune-output " Obsolescent feature" }
diff --git a/gcc/testsuite/gfortran.dg/statement_function_3.f b/gcc/testsuite/gfortran.dg/statement_function_3.f
new file mode 100644
index 00000000000..dcfb3e2b9dc
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/statement_function_3.f
@@ -0,0 +1,15 @@
+! { dg-do compile }
+! PR fortran/35299
+      subroutine phtod(e,n,i,h)
+      dimension e(n)
+      hstar(e,b)=b**.4*((1.25*fun(-e/40)+.18)) ! { dg-error "must be scalar" }
+      a = 1.
+      h = hstar(e(i-1), a)
+      end
+
+      function fun(a)
+         real a(*)
+         fun = 42
+      end
+! { dg-prune-output " Obsolescent feature" }
+
diff --git a/gcc/testsuite/gfortran.dg/submodule_30.f08 b/gcc/testsuite/gfortran.dg/submodule_30.f08
new file mode 100644
index 00000000000..7d59bab5271
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/submodule_30.f08
@@ -0,0 +1,42 @@
+! { dg-do run }
+!
+! Test the fix for PR82550 in which the reference to 'p' in 'foo'
+! was not being correctly handled.
+!
+! Contributed by Reinhold Bader  <Bader@lrz.de>
+!
+module m_subm_18_pos
+  implicit none
+  integer :: i = 0
+  interface
+    module subroutine foo(fun_ptr)
+      procedure(p), pointer, intent(out) :: fun_ptr
+    end subroutine
+  end interface
+contains
+  subroutine p()
+    i = 1
+  end subroutine p
+end module m_subm_18_pos
+submodule (m_subm_18_pos) subm_18_pos
+    implicit none
+contains
+    module subroutine foo(fun_ptr)
+      procedure(p), pointer, intent(out) :: fun_ptr
+      fun_ptr => p
+    end subroutine
+end submodule
+program p_18_pos
+  use m_subm_18_pos
+  implicit none
+  procedure(), pointer :: x
+  call foo(x)
+  call x()
+  if (i == 1) then
+     write(*,*) 'OK'
+  else
+     write(*,*) 'FAIL'
+     STOP 1
+  end if
+end program p_18_pos
+
diff --git a/gcc/testsuite/gfortran.dg/submodule_31.f08 b/gcc/testsuite/gfortran.dg/submodule_31.f08
new file mode 100644
index 00000000000..72594d05df3
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/submodule_31.f08
@@ -0,0 +1,54 @@
+! { dg-do run }
+!
+! Test the fix for PR82814 in which an ICE occurred for the submodule allocation.
+!
+! Contributed by "Werner Blokbuster"  <werner.blokbuster@gmail.com>
+!
+module u
+
+    implicit none
+
+    interface unique
+        module function uniq_char(input) result(uniq)
+            character(*), intent(in) :: input(:)
+            character(size(input)), allocatable :: uniq(:)
+        end function uniq_char
+    end interface unique
+
+contains
+
+    module function uniq2(input) result(uniq)
+        character(*), intent(in) :: input(:)
+        character(size(input)), allocatable :: uniq(:)
+            allocate(uniq(1))
+            uniq = 'A'
+    end function uniq2
+
+end module u
+
+
+submodule (u) z
+
+    implicit none
+
+contains
+
+    module function uniq_char(input) result(uniq)
+        character(*), intent(in) :: input(:)
+        character(size(input)), allocatable :: uniq(:)
+            allocate(uniq(1)) ! This used to ICE
+            uniq = 'A'
+    end function uniq_char
+
+end submodule z
+
+
+program test_uniq
+    use u
+    implicit none
+    character(1), dimension(4) :: chr = ['1','2','1','2']
+
+    write(*,*) unique(chr)
+    write(*,*) uniq2(chr)
+
+end program test_uniq
diff --git a/gcc/testsuite/gfortran.dg/temporary_2.f90 b/gcc/testsuite/gfortran.dg/temporary_2.f90
new file mode 100644
index 00000000000..0598ea54f28
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/temporary_2.f90
@@ -0,0 +1,39 @@
+! { dg-do compile }
+!
+! Tests the fix for PR70864 in which compiler generated temporaries received
+! the attributes of a dummy argument. This is the original testcase.
+! The simplified version by Gerhard Steinmetz is gratefully acknowledged.
+!
+! Contributed by Weiqun Zhang  <weiqun.zhang@gmail.com>
+!
+module boxarray_module
+  implicit none
+  type :: BoxArray
+     integer     :: i = 0
+   contains
+     procedure ::                  boxarray_assign
+     generic   :: assignment(=) => boxarray_assign
+  end type BoxArray
+contains
+  subroutine boxarray_assign (dst, src)
+    class(BoxArray), intent(inout) :: dst
+    type (BoxArray), intent(in   ) :: src
+    dst%i =src%i
+  end subroutine boxarray_assign
+end module boxarray_module
+
+module multifab_module
+  use boxarray_module
+  implicit none
+  type, public   :: MultiFab
+     type(BoxArray) :: ba
+  end type MultiFab
+contains
+  subroutine multifab_swap(mf1, mf2)
+    type(MultiFab), intent(inout) :: mf1, mf2
+    type(MultiFab) :: tmp
+    tmp = mf1
+    mf1 = mf2 ! Generated an ICE in trans-decl.c.
+    mf2 = tmp
+  end subroutine multifab_swap
+end module multifab_module
diff --git a/gcc/testsuite/gfortran.dg/temporary_3.f90 b/gcc/testsuite/gfortran.dg/temporary_3.f90
new file mode 100644
index 00000000000..84b300a38d9
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/temporary_3.f90
@@ -0,0 +1,121 @@
+! { dg-do run }
+!
+! Tests the fix for PR68846 in which compiler generated temporaries were
+! receiving the attributes of dummy arguments. This test is the original.
+! The simplified versions by Gerhard Steinmetz are gratefully acknowledged.
+!
+! Contributed by Mirco Valentini  <mirco.valentini@polimi.it>
+!
+MODULE grid
+  IMPLICIT NONE
+  PRIVATE
+  REAL(KIND=8), DIMENSION(100,100), TARGET :: WORKSPACE
+  TYPE, PUBLIC :: grid_t
+    REAL(KIND=8), DIMENSION(:,:), POINTER :: P => NULL ()
+  END TYPE
+  PUBLIC :: INIT
+CONTAINS
+  SUBROUTINE INIT (DAT)
+    IMPLICIT NONE
+    TYPE(grid_t), INTENT(INOUT) :: DAT
+    INTEGER :: I, J
+    DAT%P => WORKSPACE
+    DO I = 1, 100
+      DO J = 1, 100
+        DAT%P(I,J) = REAL ((I-1)*100+J-1)
+      END DO
+    ENDDO
+  END SUBROUTINE INIT
+END MODULE grid
+
+MODULE subgrid
+  USE :: grid, ONLY: grid_t
+  IMPLICIT NONE
+  PRIVATE
+  TYPE, PUBLIC :: subgrid_t
+    INTEGER, DIMENSION(4) :: range
+    CLASS(grid_t), POINTER    :: grd => NULL ()
+  CONTAINS
+    PROCEDURE, PASS :: INIT => LVALUE_INIT
+    PROCEDURE, PASS :: JMP => LVALUE_JMP
+  END TYPE
+CONTAINS
+  SUBROUTINE LVALUE_INIT (HOBJ, P, D)
+    IMPLICIT NONE
+    CLASS(subgrid_t),      INTENT(INOUT) :: HOBJ
+    TYPE(grid_t), POINTER, INTENT(INOUT) :: P
+    INTEGER, DIMENSION(4), INTENT(IN)    :: D
+    HOBJ%range = D
+    HOBJ%grd => P
+  END SUBROUTINE LVALUE_INIT
+
+  FUNCTION LVALUE_JMP(HOBJ, I, J) RESULT(P)
+    IMPLICIT NONE
+    CLASS(subgrid_t), INTENT(INOUT) :: HOBJ
+    INTEGER, INTENT(IN) :: I, J
+    REAL(KIND=8), POINTER :: P
+    P => HOBJ%grd%P(HOBJ%range(1)+I-1, HOBJ%range(3)+J-1)
+  END FUNCTION LVALUE_JMP
+END MODULE subgrid
+
+MODULE geom
+  IMPLICIT NONE
+CONTAINS
+  SUBROUTINE fillgeom_03( subgrid, value  )
+    USE :: subgrid, ONLY: subgrid_t
+    IMPLICIT NONE
+    TYPE(subgrid_T), intent(inout) :: subgrid
+    REAL(kind=8),    intent(in) :: value
+    INTEGER :: I, J
+    DO i = 1, 3
+      DO J = 1, 4
+        subgrid%jmp(i,j) = value ! Dummy argument '_F.DA0' with INTENT(IN)
+                                 ! in pointer association context or ICE
+                                 ! in trans_decl.c, depending on INTENT of
+                                 ! 'VALUE'
+      ENDDO
+    ENDDO
+  END SUBROUTINE fillgeom_03
+END MODULE geom
+
+PROGRAM test_lvalue
+  USE :: grid
+  USE :: subgrid
+  USE :: geom
+  IMPLICIT NONE
+  TYPE(grid_t), POINTER :: GRD => NULL()
+  TYPE(subgrid_t) :: STENCIL
+  REAL(KIND=8), POINTER :: real_tmp_ptr
+  REAL(KIND=8), DIMENSION(10,10), TARGET :: AA
+  REAL(KIND=8), DIMENSION(3,4) :: VAL
+  INTEGER :: I, J, chksum
+  integer, parameter :: r1 = 50
+  integer, parameter :: r2 = 52
+  integer, parameter :: r3 = 50
+  integer, parameter :: r4 = 53
+  DO I = 1, 3
+    DO J = 1, 4
+      VAL(I,J) = dble(I)*dble(J)
+    ENDDO
+  ENDDO
+
+  ALLOCATE (GRD)
+  CALL INIT (GRD)
+  chksum = sum([([((i-1)*100 + j -1, j=1,100)], i = 1,100)])
+  if (int(sum(grd%p)) .ne. chksum) stop 1
+
+  CALL STENCIL%INIT (GRD, [r1, r2, r3, r4])
+  if (.not.associated (stencil%grd, grd)) stop 2
+  if (int(sum(grd%p)) .ne. chksum) stop 3
+
+  CALL fillgeom_03(stencil, 42.0_8)
+  if (any (int (grd%p(r1:r2,r3:r4)) .ne. 42)) stop 4
+
+  chksum = chksum - sum([([((i - 1) * 100 + j -1, j=r3,r4)], i = r1,r2)]) &
+           + (r4 - r3 + 1) * (r2 - r1 +1) * 42
+  if (int(sum(grd%p)) .ne. chksum) stop 5
+
+  deallocate (grd)
+END PROGRAM test_lvalue
+
+
diff --git a/gcc/testsuite/gfortran.dg/typebound_operator_4.f03 b/gcc/testsuite/gfortran.dg/typebound_operator_4.f03
index 836505bba3d..cd0e8f602ae 100644
--- a/gcc/testsuite/gfortran.dg/typebound_operator_4.f03
+++ b/gcc/testsuite/gfortran.dg/typebound_operator_4.f03
@@ -84,6 +84,6 @@ PROGRAM main
   TYPE(myint) :: x
 
   x = 0 ! { dg-error "Can't convert" }
-  x = x + 42 ! { dg-error "Operands of" }
+  x = x + 42 ! { dg-error "binary intrinsic numeric operator" }
   x = x .PLUS. 5 ! { dg-error "Unknown operator" }
 END PROGRAM main
diff --git a/gcc/testsuite/gfortran.dg/unlimited_polymorphic_29.f90 b/gcc/testsuite/gfortran.dg/unlimited_polymorphic_29.f90
new file mode 100644
index 00000000000..d4ad39cda1e
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/unlimited_polymorphic_29.f90
@@ -0,0 +1,84 @@
+! { dg-do run }
+!
+! Test the fix for PR84546 in which the failing cases would
+! have x%vec = ['foo','b   '].
+!
+! Contributed by Neil Carlson  <neil.n.carlson@gmail.com>
+!
+module any_vector_type
+
+  type :: any_vector
+    class(*), allocatable :: vec(:)
+  end type
+
+  interface any_vector
+    procedure any_vector1
+  end interface
+
+contains
+
+  function any_vector1(vec) result(this)
+    class(*), intent(in) :: vec(:)
+    type(any_vector) :: this
+    allocate(this%vec, source=vec)
+  end function
+
+end module
+
+program main
+
+  use any_vector_type
+  implicit none
+
+  class(*), allocatable :: x
+  character(*), parameter :: vec(2) = ['foo','bar']
+  integer :: vec1(3) = [7,8,9]
+
+  call foo1
+  call foo2
+  call foo3
+  call foo4
+
+contains
+
+  subroutine foo1 ! This always worked
+    allocate (any_vector :: x)
+    select type (x)
+      type is (any_vector)
+        x = any_vector(vec)
+    end select
+    call bar(1)
+    deallocate (x)
+  end
+
+  subroutine foo2 ! Failure found during diagnosis
+    x = any_vector (vec)
+    call bar(2)
+    deallocate (x)
+  end
+
+  subroutine foo3 ! Original failure
+    allocate (x, source = any_vector (vec))
+    call bar(3)
+    deallocate (x)
+  end
+
+  subroutine foo4 ! This always worked
+    allocate (x, source = any_vector (vec1))
+    call bar(4)
+    deallocate (x)
+  end
+
+  subroutine bar (stop_flag)
+    integer :: stop_flag
+    select type (x)
+      type is (any_vector)
+        select type (xvec => x%vec)
+          type is (character(*))
+            if (any(xvec /= vec)) stop stop_flag
+          type is (integer)
+            if (any(xvec /= (vec1))) stop stop_flag
+        end select
+    end select
+  end
+end program
diff --git a/gcc/testsuite/gfortran.dg/unlimited_polymorphic_30.f03 b/gcc/testsuite/gfortran.dg/unlimited_polymorphic_30.f03
new file mode 100644
index 00000000000..4d0c2e7250b
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/unlimited_polymorphic_30.f03
@@ -0,0 +1,38 @@
+! { dg-do run }
+!
+! Test the fix for PR83318.
+!
+! Contributed by Neil Carlson  <neil.n.carlson@gmail.com>
+!
+type :: any_vector
+  class(*), allocatable :: v(:)
+end type
+type(any_vector) :: x, y
+
+! This did not work correctly
+  x%v = ['foo','bar']
+  call foo (x, 1)
+
+! This was reported as not working correctly but was OK before the above was fixed
+  y = x
+  call foo (y, 2)
+
+  x%v = [1_4,2_4]
+  call foo (x, 3)
+
+  y = x
+  call foo (y, 4)
+
+contains
+
+  subroutine foo (arg, n)
+    type (any_vector) :: arg
+    integer :: n
+    select type (v => arg%v)
+        type is (character(*))
+           if (any (v .ne. ["foo","bar"])) stop n
+        type is (integer(4))
+           if (any (v .ne. [1_4,2_4])) stop n
+    end select
+  end subroutine
+end
diff --git a/gcc/testsuite/gfortran.dg/vect/pr86421.f90 b/gcc/testsuite/gfortran.dg/vect/pr86421.f90
new file mode 100644
index 00000000000..af40f40da9e
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/vect/pr86421.f90
@@ -0,0 +1,35 @@
+! PR fortran/86421
+! { dg-require-effective-target vect_simd_clones }
+! { dg-additional-options "-fopenmp-simd" }
+! { dg-additional-options "-mavx" { target avx_runtime } }
+
+module mod86421
+  implicit none
+contains
+  subroutine foo(x, y, z)
+    real :: x
+    integer :: y, z
+    !$omp declare simd linear(ref(x)) linear(val(y)) linear(uval(z))
+    x = x + y
+    z = z + 1
+  end subroutine
+end module mod86421
+
+program pr86421
+  use mod86421
+  implicit none
+  integer :: i, j
+  real :: a(64)
+  j = 0
+  do i = 1, 64
+    a(i) = i
+  end do
+  !$omp simd
+  do i = 1, 64
+    call foo (a(i), i, j)
+  end do
+  do i = 1, 64
+    if (a(i) .ne. (2 * i)) stop 1
+  end do
+  if (j .ne. 64) stop 2
+end program pr86421
diff --git a/gcc/testsuite/gfortran.dg/warn_conversion_10.f90 b/gcc/testsuite/gfortran.dg/warn_conversion_10.f90
new file mode 100644
index 00000000000..e7d0a3ce104
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/warn_conversion_10.f90
@@ -0,0 +1,8 @@
+! { dg-do compile }
+! { dg-options "-fno-range-check -Wconversion" }
+! PR 88298 - this used to warn unnecessarily.  Original test case by
+! Harald Anlauf.
+subroutine bug (j, js)
+  integer    :: j, js(3,2)
+  js(:,:) = cshift (js(:,:), shift=j, dim=1)
+end subroutine bug
diff --git a/gcc/testsuite/gfortran.dg/warn_undefined_1.f90 b/gcc/testsuite/gfortran.dg/warn_undefined_1.f90
new file mode 100644
index 00000000000..67f7ca9cc2f
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/warn_undefined_1.f90
@@ -0,0 +1,28 @@
+! { dg-do compile }
+! { dg-options "-O2 -Wuninitialized" }
+! PR 67679 - this used to cause an undefined warning for
+! variables generated by the compiler.
+
+subroutine s(h, Gmin, r)
+
+   implicit none
+   real, intent(in) ::  Gmin(3), h(3)
+   integer, intent(inout) :: r
+
+   integer :: x_min(3), x_max(3), k, iStat
+   logical, dimension(:), allocatable :: check
+
+   do k = 1,1
+      x_min(k) = int(Gmin(k)*h(k))
+      x_max(k) = int(Gmin(k)*h(k))
+   end do
+
+   allocate(check(x_min(1):x_max(1)),stat=iStat)
+
+   check(:) = .false.
+
+   do k = x_min(1),x_max(1)
+            r = r + 1
+   end do
+
+end
diff --git a/gcc/testsuite/gfortran.dg/where_7.f90 b/gcc/testsuite/gfortran.dg/where_7.f90
new file mode 100644
index 00000000000..1c79ef50553
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/where_7.f90
@@ -0,0 +1,25 @@
+! { dg-do compile }
+! { dg-options "-ffrontend-optimize" }
+! PR fortran/88073 - this used to ICE with front-end optimization
+! Original test case by 'mecej4'
+Subroutine tfu (n, x, f)
+   Implicit None
+   Integer, Parameter :: double = Kind (0.d0)
+   Integer, Intent (In) :: n
+   Real (double), Intent (Out) :: f
+   Real (double), Intent (In) :: x (n)
+   Integer :: j
+   Logical, Dimension(n) :: l1v, l2v, l3v
+!
+   l3v = .False.
+   l2v = .False.
+   l1v = (/ (j, j=1, n) /) == 1
+   Where ( .Not. (l1v))
+      l2v = (/ (j, j=1, n) /) == n
+   End Where
+   Where ( .Not. l1v)
+      l3v = .Not. l2v
+   End Where
+   f = sum (x(1:n), mask=l3v)
+   Return
+end subroutine tfu
diff --git a/gcc/testsuite/gfortran.fortran-torture/compile/pr85878.f90 b/gcc/testsuite/gfortran.fortran-torture/compile/pr85878.f90
new file mode 100644
index 00000000000..e52e95faa00
--- /dev/null
+++ b/gcc/testsuite/gfortran.fortran-torture/compile/pr85878.f90
@@ -0,0 +1,8 @@
+! PR middle-end/85878
+
+program pr85878
+  real :: a
+  complex :: c = (2.0, 3.0)
+  print *, c
+  print *, transfer (a, c)
+end
diff --git a/gcc/testsuite/gnat.dg/aggr24.adb b/gcc/testsuite/gnat.dg/aggr24.adb
new file mode 100644
index 00000000000..b739c54fdc4
--- /dev/null
+++ b/gcc/testsuite/gnat.dg/aggr24.adb
@@ -0,0 +1,13 @@
+-- { dg-do run }
+
+with Aggr24_Pkg; use Aggr24_Pkg;
+
+procedure Aggr24 is
+  V : Rec;
+begin
+  V.S := "Hello";
+  Init (V);
+  if V.S /= "Hello" then
+    raise Program_Error;
+  end if;
+end;
diff --git a/gcc/testsuite/gnat.dg/aggr24_pkg.adb b/gcc/testsuite/gnat.dg/aggr24_pkg.adb
new file mode 100644
index 00000000000..2ae3e79e322
--- /dev/null
+++ b/gcc/testsuite/gnat.dg/aggr24_pkg.adb
@@ -0,0 +1,15 @@
+package body Aggr24_Pkg is
+
+   procedure Init (R : out Rec) is
+   begin
+      R := (I1 => 0,
+            I2 => 0,
+            I3 => 0,
+            I4 => 0,
+            I5 => 0,
+            I6 => 0,
+            I7 => 0,
+            S => <>);
+   end;
+   
+end Aggr24_Pkg;
diff --git a/gcc/testsuite/gnat.dg/aggr24_pkg.ads b/gcc/testsuite/gnat.dg/aggr24_pkg.ads
new file mode 100644
index 00000000000..5918f5e8bd4
--- /dev/null
+++ b/gcc/testsuite/gnat.dg/aggr24_pkg.ads
@@ -0,0 +1,16 @@
+package Aggr24_Pkg is
+
+   type Rec is record
+      I1 : Integer;
+      I2 : Integer;
+      I3 : Integer;
+      I4 : Integer;
+      I5 : Integer;
+      I6 : Integer;
+      I7 : Integer;
+      S : String (1 .. 5);
+   end record;
+
+   procedure Init (R : out Rec);
+
+end Aggr24_Pkg;
diff --git a/gcc/testsuite/gnat.dg/array11.adb b/gcc/testsuite/gnat.dg/array11.adb
index 7be61c4b631..aab73470092 100644
--- a/gcc/testsuite/gnat.dg/array11.adb
+++ b/gcc/testsuite/gnat.dg/array11.adb
@@ -1,15 +1,17 @@
 -- { dg-do compile }
 
+with System;
+
 procedure Array11 is
 
   type Rec is null record;
-  type Ptr is access all Rec;
+  type Index_T is mod System.Memory_Size;
 
-  type Arr1 is array (1..8) of aliased Rec; -- { dg-warning "padded" }
-  type Arr2 is array (Long_Integer) of aliased Rec; -- { dg-warning "padded" }
+  type Arr1 is array (1 .. 8) of aliased Rec; -- { dg-warning "padded" }
+  type Arr2 is array (Index_T) of aliased Rec; -- { dg-warning "padded" }
 
   A1 : Arr1;
-  A2 : Arr2; -- { dg-warning "Storage_Error" }
+  A2 : Arr2;
 
 begin
   null;
diff --git a/gcc/testsuite/gnat.dg/array34.adb b/gcc/testsuite/gnat.dg/array34.adb
new file mode 100644
index 00000000000..62809cd0269
--- /dev/null
+++ b/gcc/testsuite/gnat.dg/array34.adb
@@ -0,0 +1,22 @@
+--  { dg-do run }
+
+procedure Array34 is
+
+  type Arr is array (1 .. 6) of Short_Short_Integer;
+  for Arr'Alignment use 4;
+
+  type Rec is record
+    A : Arr;
+    B: Short_Integer;
+  end record;
+  pragma Pack (Rec);
+
+  R : Rec;
+
+begin
+  R.B := 31415;
+  R.A := (others => 0);
+  if R.B /= 31415 then
+    raise Program_Error;
+  end if;
+end;
diff --git a/gcc/testsuite/gnat.dg/discr53.adb b/gcc/testsuite/gnat.dg/discr53.adb
new file mode 100644
index 00000000000..2e362a7fd29
--- /dev/null
+++ b/gcc/testsuite/gnat.dg/discr53.adb
@@ -0,0 +1,19 @@
+--  { dg-do compile }
+
+package body Discr53 is
+
+   function F return Rec is
+      Data : Rec;
+   begin
+      return Data;
+   end;
+
+   type Ptr is access Rec;
+
+   procedure Proc is
+      Local : Ptr;
+   begin
+      Local := new Rec'(F);
+   end;
+
+end Discr53;
diff --git a/gcc/testsuite/gnat.dg/discr53.ads b/gcc/testsuite/gnat.dg/discr53.ads
new file mode 100644
index 00000000000..3fa9f0f4845
--- /dev/null
+++ b/gcc/testsuite/gnat.dg/discr53.ads
@@ -0,0 +1,16 @@
+with Discr53_Pkg;
+
+package Discr53 is
+
+   type Rec (D : Boolean := False) is record
+      case D is
+         when True  => S : String (1 .. Discr53_Pkg.Max);
+         when False => null;
+      end case;
+   end record;
+
+   function F return Rec;
+
+   procedure Proc;
+
+end Discr53;
diff --git a/gcc/testsuite/gnat.dg/discr53_pkg.ads b/gcc/testsuite/gnat.dg/discr53_pkg.ads
new file mode 100644
index 00000000000..d36e1ba2a12
--- /dev/null
+++ b/gcc/testsuite/gnat.dg/discr53_pkg.ads
@@ -0,0 +1,5 @@
+package Discr53_Pkg is
+
+  function Max return Natural;
+
+end Discr53_Pkg;
diff --git a/gcc/testsuite/gnat.dg/discr55.adb b/gcc/testsuite/gnat.dg/discr55.adb
new file mode 100644
index 00000000000..0444672d96d
--- /dev/null
+++ b/gcc/testsuite/gnat.dg/discr55.adb
@@ -0,0 +1,16 @@
+-- { dg-do run }
+
+procedure Discr55 is
+
+  type Rec (C : Character) is record
+    case C is
+      when 'Z' .. Character'Val (128) => I : Integer;
+      when others                     => null;
+    end case;
+  end record;
+
+  R : Rec ('Z');
+
+begin
+  R.I := 0;
+end;
diff --git a/gcc/testsuite/gnat.dg/dispatch1.adb b/gcc/testsuite/gnat.dg/disp1.adb
similarity index 65%
rename from gcc/testsuite/gnat.dg/dispatch1.adb
rename to gcc/testsuite/gnat.dg/disp1.adb
index 28e97e6e7e7..2fcefeafb42 100644
--- a/gcc/testsuite/gnat.dg/dispatch1.adb
+++ b/gcc/testsuite/gnat.dg/disp1.adb
@@ -1,7 +1,8 @@
 -- { dg-do run }
 
-with dispatch1_p; use dispatch1_p;
-procedure dispatch1 is
+with Disp1_Pkg; use Disp1_Pkg;
+
+procedure Disp1 is
    O   : DT_I1;
    Ptr : access I1'Class;
 begin
diff --git a/gcc/testsuite/gnat.dg/dispatch1_p.ads b/gcc/testsuite/gnat.dg/disp1_pkg.ads
similarity index 63%
rename from gcc/testsuite/gnat.dg/dispatch1_p.ads
rename to gcc/testsuite/gnat.dg/disp1_pkg.ads
index 73de627516a..4d80e7655e1 100644
--- a/gcc/testsuite/gnat.dg/dispatch1_p.ads
+++ b/gcc/testsuite/gnat.dg/disp1_pkg.ads
@@ -1,4 +1,6 @@
-package dispatch1_p is
+package Disp1_Pkg is
+
    type I1 is interface;
    type DT_I1 is new I1 with null record;
-end;
+
+end Disp1_Pkg;
diff --git a/gcc/testsuite/gnat.dg/dispatch2.adb b/gcc/testsuite/gnat.dg/disp2.adb
similarity index 70%
rename from gcc/testsuite/gnat.dg/dispatch2.adb
rename to gcc/testsuite/gnat.dg/disp2.adb
index ed57b13359e..2e1e6226080 100644
--- a/gcc/testsuite/gnat.dg/dispatch2.adb
+++ b/gcc/testsuite/gnat.dg/disp2.adb
@@ -1,7 +1,8 @@
 --  { dg-do run }
 
-with dispatch2_p; use dispatch2_p;
-procedure dispatch2 is
+with Disp2_Pkg; use Disp2_Pkg;
+
+procedure Disp2 is
    Obj : Object_Ptr := new Object;
 begin
    if Obj.Get_Ptr /= Obj.Impl_Of then
diff --git a/gcc/testsuite/gnat.dg/dispatch2_p.adb b/gcc/testsuite/gnat.dg/disp2_pkg.adb
similarity index 72%
rename from gcc/testsuite/gnat.dg/dispatch2_p.adb
rename to gcc/testsuite/gnat.dg/disp2_pkg.adb
index 243c3ca977a..ed460ec453f 100644
--- a/gcc/testsuite/gnat.dg/dispatch2_p.adb
+++ b/gcc/testsuite/gnat.dg/disp2_pkg.adb
@@ -1,7 +1,8 @@
---
-package body dispatch2_p is
+package body Disp2_Pkg is
+
   function Impl_Of (Self : access Object) return Object_Ptr is
   begin
     return Object_Ptr (Self);
   end Impl_Of;
-end;
+
+end Disp2_Pkg;
diff --git a/gcc/testsuite/gnat.dg/dispatch2_p.ads b/gcc/testsuite/gnat.dg/disp2_pkg.ads
similarity index 85%
rename from gcc/testsuite/gnat.dg/dispatch2_p.ads
rename to gcc/testsuite/gnat.dg/disp2_pkg.ads
index e7852b446b5..0b4903abe34 100644
--- a/gcc/testsuite/gnat.dg/dispatch2_p.ads
+++ b/gcc/testsuite/gnat.dg/disp2_pkg.ads
@@ -1,8 +1,11 @@
-package dispatch2_p is
+package Disp2_Pkg is
+
   type Object     is tagged null record;
   type Object_Ptr is access all Object'CLASS;
---
+
   function Impl_Of (Self : access Object) return Object_Ptr;
   function Get_Ptr (Self : access Object) return Object_Ptr
     renames Impl_Of;
-end;
+
+end Disp2_Pkg;
+
diff --git a/gcc/testsuite/gnat.dg/generic_dispatch.adb b/gcc/testsuite/gnat.dg/generic_disp.adb
similarity index 57%
rename from gcc/testsuite/gnat.dg/generic_dispatch.adb
rename to gcc/testsuite/gnat.dg/generic_disp.adb
index a22e495f451..2f828ff1b1b 100644
--- a/gcc/testsuite/gnat.dg/generic_dispatch.adb
+++ b/gcc/testsuite/gnat.dg/generic_disp.adb
@@ -1,9 +1,10 @@
 --  { dg-do run }
 
-with generic_dispatch_p; use generic_dispatch_p;
-procedure generic_dispatch is
+with Generic_Disp_Pkg; use Generic_Disp_Pkg;
+
+procedure Generic_Disp is
    I : aliased Integer := 0;
    D : Iface'Class := Dispatching_Constructor (DT'Tag, I'access);
 begin   
    null;   
-end generic_dispatch;
+end Generic_Disp;
diff --git a/gcc/testsuite/gnat.dg/generic_dispatch_p.adb b/gcc/testsuite/gnat.dg/generic_disp_pkg.adb
similarity index 64%
rename from gcc/testsuite/gnat.dg/generic_dispatch_p.adb
rename to gcc/testsuite/gnat.dg/generic_disp_pkg.adb
index 7a4bbbd8a2b..b3aeb3ff078 100644
--- a/gcc/testsuite/gnat.dg/generic_dispatch_p.adb
+++ b/gcc/testsuite/gnat.dg/generic_disp_pkg.adb
@@ -1,7 +1,9 @@
-package body generic_dispatch_p is
+package body Generic_Disp_Pkg is
+
    function Constructor (I : not null access Integer) return DT is
       R : DT; 
-  begin
+   begin
       return R;
    end Constructor;
-end;
+
+end Generic_Disp_Pkg;
diff --git a/gcc/testsuite/gnat.dg/generic_dispatch_p.ads b/gcc/testsuite/gnat.dg/generic_disp_pkg.ads
similarity index 90%
rename from gcc/testsuite/gnat.dg/generic_dispatch_p.ads
rename to gcc/testsuite/gnat.dg/generic_disp_pkg.ads
index fe6115dd9c7..5be54921d83 100644
--- a/gcc/testsuite/gnat.dg/generic_dispatch_p.ads
+++ b/gcc/testsuite/gnat.dg/generic_disp_pkg.ads
@@ -1,5 +1,6 @@
 with Ada.Tags.Generic_Dispatching_Constructor;
-package generic_dispatch_p is
+
+package Generic_Disp_Pkg is
    type Iface is interface;
    function Constructor (I : not null access Integer) return Iface is abstract;
    function Dispatching_Constructor
@@ -10,4 +11,4 @@ package generic_dispatch_p is
    type DT is new Iface with null record; 
    overriding
    function Constructor (I : not null access Integer) return DT;
-end;
+end Generic_Disp_Pkg;
diff --git a/gcc/testsuite/gnat.dg/null_pointer_deref1.adb b/gcc/testsuite/gnat.dg/null_pointer_deref1.adb
index 6e7bf14e5df..0f030b001bd 100644
--- a/gcc/testsuite/gnat.dg/null_pointer_deref1.adb
+++ b/gcc/testsuite/gnat.dg/null_pointer_deref1.adb
@@ -1,11 +1,13 @@
 -- { dg-do run }
--- { dg-options "-gnatp" }
 
 -- This test requires architecture- and OS-specific support code for unwinding
 -- through signal frames (typically located in *-unwind.h) to pass.  Feel free
 -- to disable it if this code hasn't been implemented yet.
 
 procedure Null_Pointer_Deref1 is
+
+   pragma Suppress (All_Checks);
+
    type Int_Ptr is access all Integer;
 
    function Ident return Int_Ptr is
@@ -17,5 +19,5 @@ procedure Null_Pointer_Deref1 is
 begin
    Data.all := 1;
 exception
-   when Constraint_Error | Storage_Error => null;
+   when others => null;
 end;
diff --git a/gcc/testsuite/gnat.dg/null_pointer_deref2.adb b/gcc/testsuite/gnat.dg/null_pointer_deref2.adb
index 63e2dd11f39..2a4ed0954bb 100644
--- a/gcc/testsuite/gnat.dg/null_pointer_deref2.adb
+++ b/gcc/testsuite/gnat.dg/null_pointer_deref2.adb
@@ -1,5 +1,4 @@
 -- { dg-do run }
--- { dg-options "-gnatp" }
 
 -- This test requires architecture- and OS-specific support code for unwinding
 -- through signal frames (typically located in *-unwind.h) to pass.  Feel free
@@ -7,6 +6,8 @@
 
 procedure Null_Pointer_Deref2 is
 
+   pragma Suppress (All_Checks);
+
    task T;
 
    task body T is
@@ -20,7 +21,7 @@ procedure Null_Pointer_Deref2 is
    begin
       Data.all := 1;
    exception
-      when Constraint_Error | Storage_Error => null;
+      when others => null;
    end T;
 
 begin
diff --git a/gcc/testsuite/gnat.dg/null_pointer_deref3.adb b/gcc/testsuite/gnat.dg/null_pointer_deref3.adb
index f92242e7e67..c8e66a6c94a 100644
--- a/gcc/testsuite/gnat.dg/null_pointer_deref3.adb
+++ b/gcc/testsuite/gnat.dg/null_pointer_deref3.adb
@@ -1,5 +1,4 @@
 -- { dg-do run }
--- { dg-options "-O -gnatp" }
 
 -- This test requires architecture- and OS-specific support code for unwinding
 -- through signal frames (typically located in *-unwind.h) to pass.  Feel free
@@ -7,6 +6,8 @@
 
 procedure Null_Pointer_Deref3 is
 
+   pragma Suppress (All_Checks);
+
    procedure Leaf is
       type Int_Ptr is access all Integer;
       function n return Int_Ptr is
diff --git a/gcc/testsuite/gnat.dg/object_overflow1.adb b/gcc/testsuite/gnat.dg/object_overflow1.adb
index ba7f657e710..d972f24a1fe 100644
--- a/gcc/testsuite/gnat.dg/object_overflow1.adb
+++ b/gcc/testsuite/gnat.dg/object_overflow1.adb
@@ -1,10 +1,12 @@
 -- { dg-do compile }
 
+with Interfaces.C; use Interfaces.C;
+
 procedure Object_Overflow1 is
 
   procedure Proc (x : Boolean) is begin null; end;
 
-  type Arr is array(Long_Integer) of Boolean;
+  type Arr is array(ptrdiff_t) of Boolean;
   Obj : Arr; -- { dg-warning "Storage_Error" }
 
 begin
diff --git a/gcc/testsuite/gnat.dg/object_overflow2.adb b/gcc/testsuite/gnat.dg/object_overflow2.adb
index 9601c563b2a..a429291e80a 100644
--- a/gcc/testsuite/gnat.dg/object_overflow2.adb
+++ b/gcc/testsuite/gnat.dg/object_overflow2.adb
@@ -1,10 +1,12 @@
 -- { dg-do compile }
 
+with Interfaces.C; use Interfaces.C;
+
 procedure Object_Overflow2 is
 
   procedure Proc (x : Boolean) is begin null; end;
 
-  type Arr is array(0 .. Long_Integer'Last) of Boolean;
+  type Arr is array(0 .. ptrdiff_t'Last) of Boolean;
   Obj : Arr; -- { dg-warning "Storage_Error" }
 
 begin
diff --git a/gcc/testsuite/gnat.dg/object_overflow3.adb b/gcc/testsuite/gnat.dg/object_overflow3.adb
index 5e27b4f0d81..d3c0c17c57d 100644
--- a/gcc/testsuite/gnat.dg/object_overflow3.adb
+++ b/gcc/testsuite/gnat.dg/object_overflow3.adb
@@ -1,10 +1,12 @@
 -- { dg-do compile }
 
+with Interfaces.C; use Interfaces.C;
+
 procedure Object_Overflow3 is
 
   procedure Proc (x : Boolean) is begin null; end;
 
-  type Arr is array(0 .. Long_Integer'Last) of Boolean;
+  type Arr is array(0 .. ptrdiff_t'Last) of Boolean;
 
   type Rec is record
     A : Arr;
diff --git a/gcc/testsuite/gnat.dg/object_overflow4.adb b/gcc/testsuite/gnat.dg/object_overflow4.adb
index 643989d348c..0e320e265ad 100644
--- a/gcc/testsuite/gnat.dg/object_overflow4.adb
+++ b/gcc/testsuite/gnat.dg/object_overflow4.adb
@@ -1,14 +1,16 @@
 -- { dg-do compile }
 
+with Interfaces.C; use Interfaces.C;
+
 procedure Object_Overflow4 is
 
   procedure Proc (x : Integer) is begin null; end;
 
-  type Index is new Long_Integer range 0 .. Long_Integer'Last;
+  type Index_T is new ptrdiff_t range 0 .. ptrdiff_t'Last;
 
-  type Arr is array(Index range <>) of Integer;
+  type Arr is array(Index_T range <>) of Integer;
 
-  type Rec (Size: Index := 6) is record -- { dg-warning "Storage_Error" }
+  type Rec (Size: Index_T := 6) is record -- { dg-warning "Storage_Error" }
     A: Arr (0..Size);
   end record;
 
diff --git a/gcc/testsuite/gnat.dg/object_overflow5.adb b/gcc/testsuite/gnat.dg/object_overflow5.adb
index 4a4f6cfe30e..42d00b24b95 100644
--- a/gcc/testsuite/gnat.dg/object_overflow5.adb
+++ b/gcc/testsuite/gnat.dg/object_overflow5.adb
@@ -1,14 +1,16 @@
 -- { dg-do compile }
 
+with Interfaces.C; use Interfaces.C;
+
 procedure Object_Overflow5 is
 
   procedure Proc (c : Character) is begin null; end;
 
-  type Index is new Long_Integer range 0 .. Long_Integer'Last;
+  type Index_T is new ptrdiff_t range 0 .. ptrdiff_t'Last;
 
-  type Arr is array(Index range <>) of Character;
+  type Arr is array(Index_T range <>) of Character;
 
-  type Rec (Size: Index := 6) is record -- { dg-warning "Storage_Error" }
+  type Rec (Size: Index_T := 6) is record -- { dg-warning "Storage_Error" }
     A: Arr (0..Size);
   end record;
 
diff --git a/gcc/testsuite/gnat.dg/opt73.adb b/gcc/testsuite/gnat.dg/opt73.adb
new file mode 100644
index 00000000000..38ab4774fb7
--- /dev/null
+++ b/gcc/testsuite/gnat.dg/opt73.adb
@@ -0,0 +1,34 @@
+-- { dg-do run }
+-- { dg-options "-O" }
+
+procedure Opt73 is
+
+   type Terminal_Set_Indexed_By_Non_Terminal is
+     array (Natural range <>, Natural  range <>) of Boolean with Pack;
+
+   type Terminal_Set_Per_Non_Terminal
+     (Last_Terminal     : Natural;
+      Last_Non_Terminal : Natural) is
+   record
+      Map : Terminal_Set_Indexed_By_Non_Terminal
+        (1 .. Last_Non_Terminal, 0 .. Last_Terminal);
+   end record;
+
+   Follow : Terminal_Set_Per_Non_Terminal (5, 4);
+   Expect : Terminal_Set_Per_Non_Terminal :=
+     (5, 4, (1 => (2 => True, others => False),
+             others => (others => False)));
+
+   procedure Get_Follow (Value : out Terminal_Set_Per_Non_Terminal) is
+   begin
+      Value.Map := (others => (others => False));
+      Value.Map (1, 2) := True;
+      Value.Map (2, 0) := Value.Map (2, 0) or Value.Map (1, 0);
+   end;
+
+begin
+   Get_Follow (Follow);
+   if Follow /= Expect then
+      raise Program_Error;
+   end if;
+end;
diff --git a/gcc/testsuite/gnat.dg/opt74.adb b/gcc/testsuite/gnat.dg/opt74.adb
new file mode 100644
index 00000000000..8eacaa5b49e
--- /dev/null
+++ b/gcc/testsuite/gnat.dg/opt74.adb
@@ -0,0 +1,13 @@
+-- { dg-do run }
+-- { dg-options "-O2" }
+
+with Opt74_Pkg; use Opt74_Pkg;
+
+procedure Opt74 is
+   Index, Found : Integer;
+begin
+   Proc (Found, Index);
+   if Found = 1 then
+      raise Program_Error;
+   end if;
+end;
diff --git a/gcc/testsuite/gnat.dg/opt74_pkg.adb b/gcc/testsuite/gnat.dg/opt74_pkg.adb
new file mode 100644
index 00000000000..4d5ce4fa822
--- /dev/null
+++ b/gcc/testsuite/gnat.dg/opt74_pkg.adb
@@ -0,0 +1,16 @@
+package body Opt74_Pkg is
+
+   procedure Proc (Found : out Integer; Index : out Integer) is
+   begin
+      Index := 1;
+      Found := 0;
+      while (Index <= A'Last) and (Found = 0) loop
+         if A (Index) = 2 then
+            Found := 1;
+         else
+            Index := Index + 1;
+         end if;
+      end loop;
+   end;
+
+end Opt74_Pkg;
diff --git a/gcc/testsuite/gnat.dg/opt74_pkg.ads b/gcc/testsuite/gnat.dg/opt74_pkg.ads
new file mode 100644
index 00000000000..7c8e85e85d7
--- /dev/null
+++ b/gcc/testsuite/gnat.dg/opt74_pkg.ads
@@ -0,0 +1,7 @@
+package Opt74_Pkg is
+
+   A : array (1 .. 10) of Integer := (others => 0);
+
+   procedure Proc (Found : out Integer; Index : out Integer);
+
+end Opt74_Pkg;
diff --git a/gcc/testsuite/gnat.dg/opt75.adb b/gcc/testsuite/gnat.dg/opt75.adb
new file mode 100644
index 00000000000..080a5183f23
--- /dev/null
+++ b/gcc/testsuite/gnat.dg/opt75.adb
@@ -0,0 +1,9 @@
+-- { dg-do run }
+-- { dg-options "-O3" }
+
+with Opt75_Pkg; use Opt75_Pkg;
+
+procedure Opt75 is
+begin
+  null;
+end;
diff --git a/gcc/testsuite/gnat.dg/opt75_pkg.adb b/gcc/testsuite/gnat.dg/opt75_pkg.adb
new file mode 100644
index 00000000000..4424e70ec8d
--- /dev/null
+++ b/gcc/testsuite/gnat.dg/opt75_pkg.adb
@@ -0,0 +1,12 @@
+package body Opt75_Pkg is
+
+  overriding procedure Adjust (Object : in out T) is
+  begin
+    if Object.Ref /= Empty_Rec'Access then
+      System.Atomic_Counters.Increment (Object.Ref.Counter);
+    end if;
+  end;
+
+  A : constant Arr := (others => (others => Empty));
+
+end Opt75_Pkg;
diff --git a/gcc/testsuite/gnat.dg/opt75_pkg.ads b/gcc/testsuite/gnat.dg/opt75_pkg.ads
new file mode 100644
index 00000000000..4fae165e77f
--- /dev/null
+++ b/gcc/testsuite/gnat.dg/opt75_pkg.ads
@@ -0,0 +1,27 @@
+pragma Restrictions (No_Abort_Statements);
+pragma Restrictions (Max_Asynchronous_Select_Nesting => 0);
+
+with Ada.Finalization;
+with System.Atomic_Counters;
+
+package Opt75_Pkg is
+
+  type Rec is record
+    Counter : System.Atomic_Counters.Atomic_Counter;
+  end record;
+
+  type Rec_Ptr is access all Rec;
+
+  Empty_Rec : aliased Rec;
+
+  type T is new Ada.Finalization.Controlled with record
+    Ref : Rec_Ptr := Empty_Rec'Access;
+  end record;
+
+  overriding procedure Adjust (Object : in out T);
+
+  Empty : constant T := (Ada.Finalization.Controlled with Ref => Empty_Rec'Access);
+
+  type Arr is array (Integer range 1 .. 8, Integer range 1 .. 4) of T;
+
+end Opt75_Pkg;
diff --git a/gcc/testsuite/gnat.dg/opt76.adb b/gcc/testsuite/gnat.dg/opt76.adb
new file mode 100644
index 00000000000..50f3cee9ed9
--- /dev/null
+++ b/gcc/testsuite/gnat.dg/opt76.adb
@@ -0,0 +1,36 @@
+-- { dg-do run }
+-- { dg-options "-O2 -gnatp -fno-omit-frame-pointer" }
+
+procedure Opt76 is
+
+   type Integer_Access is access Integer;
+   type Registry_Array is array (Natural range <>) of Integer_Access;
+
+   procedure Nested (Input, Parser : Integer; A, B : Boolean) is
+
+      Index : Registry_Array (1 .. 1024);
+      Not_B : constant Boolean := not B;
+
+      procedure Inner (Input : Integer) is
+      begin
+         if Input /= 1 then
+            raise Program_Error;
+         end if;
+
+         if Parser = 128 and then A and then Not_B then
+            Inner (Input);
+            Index (Index'First) := null;
+         end if;
+      end;
+
+   begin
+      Inner (Input);
+   end;
+
+   Input : Integer := 1 with Volatile;
+   Parser : Integer := 2 with Volatile;
+      
+begin
+   Nested (Input, Parser, False, True);
+   Nested (Input, Parser, True, False);
+end;
diff --git a/gcc/testsuite/gnat.dg/prot3.adb b/gcc/testsuite/gnat.dg/prot3.adb
new file mode 100644
index 00000000000..25390659238
--- /dev/null
+++ b/gcc/testsuite/gnat.dg/prot3.adb
@@ -0,0 +1,8 @@
+--  { dg-do run }
+
+with Prot3_Pkg; use Prot3_Pkg;
+
+procedure Prot3 is
+begin
+   P.Foo (4);
+end;
diff --git a/gcc/testsuite/gnat.dg/prot3_pkg.adb b/gcc/testsuite/gnat.dg/prot3_pkg.adb
new file mode 100644
index 00000000000..07ae1829f60
--- /dev/null
+++ b/gcc/testsuite/gnat.dg/prot3_pkg.adb
@@ -0,0 +1,17 @@
+package body Prot3_Pkg is
+   
+   protected body Prot is
+      function Fn (J : Short_Integer) return Rec
+      is
+      begin
+	 return (V1 => J * J,
+		 V2 => J);
+      end;
+      
+      procedure Foo (J : Short_Integer) is
+      begin
+	 Val := Fn (J);
+      end;
+   end Prot;
+   
+end Prot3_Pkg;
diff --git a/gcc/testsuite/gnat.dg/prot3_pkg.ads b/gcc/testsuite/gnat.dg/prot3_pkg.ads
new file mode 100644
index 00000000000..b4cce90a543
--- /dev/null
+++ b/gcc/testsuite/gnat.dg/prot3_pkg.ads
@@ -0,0 +1,16 @@
+package Prot3_Pkg is
+   
+   type Rec is record
+      V1 : Short_Integer;
+      V2 : Short_Integer;
+   end record with Volatile_Full_Access;
+   
+   protected type Prot is
+      procedure Foo (J : Short_Integer);
+   private
+      Val : Rec;
+   end Prot;
+   
+   P : Prot;
+   
+end Prot3_Pkg;
diff --git a/gcc/testsuite/gnat.dg/specs/opt3.ads b/gcc/testsuite/gnat.dg/specs/opt3.ads
new file mode 100644
index 00000000000..531cf59eae3
--- /dev/null
+++ b/gcc/testsuite/gnat.dg/specs/opt3.ads
@@ -0,0 +1,13 @@
+-- { dg-do compile }
+-- { dg-options "-O3" }
+
+with Ada.Containers.Vectors;
+with Opt3_Pkg;
+
+package Opt3 is
+
+  type Arr is array (1 .. Opt3_Pkg.Max) of Integer;
+
+  package Arr_Container is new Ada.Containers.Vectors (Natural, Arr);
+
+end Opt3;
diff --git a/gcc/testsuite/gnat.dg/specs/opt3_pkg.ads b/gcc/testsuite/gnat.dg/specs/opt3_pkg.ads
new file mode 100644
index 00000000000..4145ac4abaa
--- /dev/null
+++ b/gcc/testsuite/gnat.dg/specs/opt3_pkg.ads
@@ -0,0 +1,7 @@
+-- { dg-excess-errors "no code generated" }
+
+package Opt3_Pkg is
+
+  function Max return Natural;
+
+end Opt3_Pkg;
diff --git a/gcc/testsuite/gnat.dg/sso14.adb b/gcc/testsuite/gnat.dg/sso14.adb
new file mode 100644
index 00000000000..6c50f152524
--- /dev/null
+++ b/gcc/testsuite/gnat.dg/sso14.adb
@@ -0,0 +1,52 @@
+--  { dg-do run }
+--  { dg-options "-gnatws" }
+
+with System;
+with Ada.Unchecked_Conversion;
+
+procedure SSO14 is
+
+   type Arr is array (1 .. Integer'Size) of Boolean;
+   pragma Pack (Arr);
+   for Arr'Scalar_Storage_Order use System.High_Order_First;
+
+   function From_Float is new Ada.Unchecked_Conversion (Float, Arr);
+   function From_Int is new Ada.Unchecked_Conversion (Integer, Arr);
+
+   type R_Float is record
+     F : Float;
+   end record;
+   for R_Float'Bit_Order use System.High_Order_First;
+   for R_Float'Scalar_Storage_Order use System.High_Order_First;
+
+   type R_Int is record
+     I : Integer;
+   end record;
+   for R_Int'Bit_Order use System.High_Order_First;
+   for R_Int'Scalar_Storage_Order use System.High_Order_First;
+
+   F1 : Float := 1.234567;
+   FA : Arr;
+   F2 : R_Float;
+   for F2'Address use FA'Address;
+   pragma Import (Ada, F2);
+
+   I1 : Integer := 1234567;
+   IA : Arr;
+   I2 : R_Int;
+   for I2'Address use IA'Address;
+   pragma Import (Ada, I2);
+
+begin
+   -- Check that converting a FP value yields a big-endian array
+   FA := From_Float (F1);
+   if F2.F /= F1 then
+      raise Program_Error;
+   end if;
+
+   -- Check that converting an integer value yields a big-endian array.
+   IA := From_Int (I1);
+   if I2.I /= I1 then
+      raise Program_Error;
+   end if;
+end;
diff --git a/gcc/testsuite/gnat.dg/sso15.adb b/gcc/testsuite/gnat.dg/sso15.adb
new file mode 100644
index 00000000000..19d255a6395
--- /dev/null
+++ b/gcc/testsuite/gnat.dg/sso15.adb
@@ -0,0 +1,52 @@
+--  { dg-do run }
+--  { dg-options "-gnatws" }
+
+with System;
+with Ada.Unchecked_Conversion;
+
+procedure SSO15 is
+
+   type Arr is array (1 .. Integer'Size) of Boolean;
+   pragma Pack (Arr);
+   for Arr'Scalar_Storage_Order use System.High_Order_First;
+
+   function To_Float is new Ada.Unchecked_Conversion (Arr, Float);
+   function To_Int is new Ada.Unchecked_Conversion (Arr, Integer);
+
+   type R_Float is record
+     F : Float;
+   end record;
+   for R_Float'Bit_Order use System.High_Order_First;
+   for R_Float'Scalar_Storage_Order use System.High_Order_First;
+
+   type R_Int is record
+     I : Integer;
+   end record;
+   for R_Int'Bit_Order use System.High_Order_First;
+   for R_Int'Scalar_Storage_Order use System.High_Order_First;
+
+   A : Arr := (1 .. 2 => True, others => False);
+
+   F1 : Float;
+   F2 : R_Float;
+   for F2'Address use A'Address;
+   pragma Import (Ada, F2);
+
+   I1 : Integer;
+   I2 : R_Int;
+   for I2'Address use A'Address;
+   pragma Import (Ada, I2);
+
+begin
+   -- Check that converting to FP yields a big-endian value.
+   F1 := To_Float (A);
+   if F2.F /= F1 then
+      raise Program_Error;
+   end if;
+
+   -- Check that converting to integer yields a big-endian value.
+   I1 := To_Int (A);
+   if I2.I /= I1 then
+      raise Program_Error;
+   end if;
+end;
diff --git a/gcc/testsuite/gnat.dg/warn12.adb b/gcc/testsuite/gnat.dg/warn12.adb
deleted file mode 100644
index 8ffd0c7dff0..00000000000
--- a/gcc/testsuite/gnat.dg/warn12.adb
+++ /dev/null
@@ -1,48 +0,0 @@
--- { dg-do compile }
--- { dg-options "-O2" }
-
-with Text_IO; use Text_IO;
-with System.Storage_Elements; use System.Storage_Elements;
-with Warn12_Pkg; use Warn12_Pkg;
-
-procedure Warn12 (N : Natural) is
-
-   Buffer_Size : constant Storage_Offset
-      := Token_Groups'Size/System.Storage_Unit + 4096;
-
-   Buffer : Storage_Array (1 .. Buffer_Size);
-   for Buffer'Alignment use 8;
-
-   Tg1 : Token_Groups;
-   for Tg1'Address use Buffer'Address;
-
-   Tg2 : Token_Groups;
-   pragma Warnings (Off, Tg2);
-
-   sid : Sid_And_Attributes;
-
-   pragma Suppress (Index_Check, Sid_And_Attributes_Array);
-
-begin
-
-   for I in 0 .. 7 loop
-      sid :=  Tg1.Groups(I);  -- { dg-bogus "out-of-bounds access" }
-      Put_Line("Iteration");
-   end loop;
-
-   for I in 0 .. N loop
-      sid :=  Tg1.Groups(I);  -- { dg-bogus "out-of-bounds access" }
-      Put_Line("Iteration");
-   end loop;
-
-   for I in 0 .. 7 loop
-      sid :=  Tg2.Groups(I);  -- { dg-warning "out-of-bounds access" }
-      Put_Line("Iteration");
-   end loop;
-
-   for I in 0 .. N loop
-      sid :=  Tg2.Groups(I);  -- { dg-warning "out-of-bounds access" }
-      Put_Line("Iteration");
-   end loop;
-
-end;
diff --git a/gcc/testsuite/gnat.dg/warn12_pkg.ads b/gcc/testsuite/gnat.dg/warn12_pkg.ads
deleted file mode 100644
index b3191cc304f..00000000000
--- a/gcc/testsuite/gnat.dg/warn12_pkg.ads
+++ /dev/null
@@ -1,21 +0,0 @@
-with Interfaces.C; use Interfaces.C;
-with System;
-
-package Warn12_Pkg is
-
-   Anysize_Array: constant := 0;
-
-   type Sid_And_Attributes is record
-      Sid        : System.Address;
-      Attributes : Interfaces.C.Unsigned_Long;
-   end record;
-
-   type Sid_And_Attributes_Array
-      is array (Integer range 0..Anysize_Array) of aliased Sid_And_Attributes;
-
-   type Token_Groups is record
-      GroupCount : Interfaces.C.Unsigned_Long;
-      Groups     : Sid_And_Attributes_Array;
-   end record;
-
-end Warn12_Pkg;
diff --git a/gcc/testsuite/go.dg/pr85436.go b/gcc/testsuite/go.dg/pr85436.go
new file mode 100644
index 00000000000..225c2734561
--- /dev/null
+++ b/gcc/testsuite/go.dg/pr85436.go
@@ -0,0 +1,21 @@
+/* { dg-do compile } */
+/* { dg-options "-O3 -mcpu=power9" { target { powerpc*-*-* } } } */
+
+package main
+import (
+	"go/ast"
+	"go/parser"
+	"go/token"
+)
+type testFuncs struct { }
+func (t *testFuncs) load(filename, pkg string, doImport, seen *bool) {
+	var testFileSet = token.NewFileSet()
+	f, err := parser.ParseFile(testFileSet, filename, nil, parser.ParseComments)
+	if err != nil { }
+	for _, d := range f.Decls {
+		n, ok := d.(*ast.FuncDecl)
+		if !ok { }
+		ptr := n.Type.Params.List[0].Type.(*ast.StarExpr)
+		if sel := ptr.X.(*ast.SelectorExpr); sel.Sel.Name == "M" { }
+	}
+}
diff --git a/gcc/testsuite/jit.dg/test-long-names.c b/gcc/testsuite/jit.dg/test-long-names.c
index 0fc7e676b39..8f4aa7e7026 100644
--- a/gcc/testsuite/jit.dg/test-long-names.c
+++ b/gcc/testsuite/jit.dg/test-long-names.c
@@ -24,7 +24,7 @@ populate_name (const char *prefix, char *buffer)
   int i;
 
   /* Begin with the given prefix: */
-  sprintf (buffer, prefix);
+  sprintf (buffer, "%s", prefix);
 
   /* Populate the rest of the buffer with 0123456789 repeatedly: */
   for (i = strlen (prefix); i < NAME_LENGTH - 1; i++)
diff --git a/gcc/testsuite/lib/prune.exp b/gcc/testsuite/lib/prune.exp
index afc1a696393..844530bf4b3 100644
--- a/gcc/testsuite/lib/prune.exp
+++ b/gcc/testsuite/lib/prune.exp
@@ -28,7 +28,7 @@ proc prune_gcc_output { text } {
 
     #send_user "Before:$text\n"
 
-    regsub -all "(^|\n)(\[^\n\]*: )?In ((static member |lambda )?function|member|method|(copy )?constructor|destructor|instantiation|substitution|program|subroutine|block-data)\[^\n\]*" $text "" text
+    regsub -all "(^|\n)(\[^\n\]*: \[iI\]|I)n ((static member |lambda )?function|member|method|(copy )?constructor|destructor|instantiation|substitution|program|subroutine|block-data)\[^\n\]*" $text "" text
     regsub -all "(^|\n)\[^\n\]*(: )?At (top level|global scope):\[^\n\]*" $text "" text
     regsub -all "(^|\n)\[^\n\]*:   (recursively )?required \[^\n\]*" $text "" text
     regsub -all "(^|\n)\[^\n\]*:   . skipping \[0-9\]* instantiation contexts \[^\n\]*" $text "" text
diff --git a/gcc/testsuite/lib/target-supports.exp b/gcc/testsuite/lib/target-supports.exp
index 063f339e510..546edfd8db8 100644
--- a/gcc/testsuite/lib/target-supports.exp
+++ b/gcc/testsuite/lib/target-supports.exp
@@ -2365,6 +2365,22 @@ proc check_effective_target_next_runtime { } {
     }]
 }
 
+# Return 1 if we're generating code for big-endian memory order.
+
+proc check_effective_target_be { } {
+    return [check_no_compiler_messages be object {
+	int dummy[__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__ ? 1 : -1];
+    }]
+}
+
+# Return 1 if we're generating code for little-endian memory order.
+
+proc check_effective_target_le { } {
+    return [check_no_compiler_messages le object {
+	int dummy[__BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__ ? 1 : -1];
+    }]
+}
+
 # Return 1 if we're generating 32-bit code using default options, 0
 # otherwise.
 
@@ -5940,7 +5956,8 @@ proc check_effective_target_vect_load_lanes { } {
 	verbose "check_effective_target_vect_load_lanes: using cached result" 2
     } else {
 	set et_vect_load_lanes 0
-	if { ([istarget arm*-*-*] && [check_effective_target_arm_neon_ok])
+	# We don't support load_lanes correctly on big-endian arm.
+	if { ([check_effective_target_arm_little_endian] && [check_effective_target_arm_neon_ok])
 	     || [istarget aarch64*-*-*] } {
 	    set et_vect_load_lanes 1
 	}
@@ -7348,11 +7365,22 @@ proc check_prefer_avx128 { } {
 proc check_effective_target_avx512f { } {
     return [check_no_compiler_messages avx512f object {
 	typedef double __m512d __attribute__ ((__vector_size__ (64)));
+	typedef double __m128d __attribute__ ((__vector_size__ (16)));
 
 	__m512d _mm512_add (__m512d a)
 	{
 	  return __builtin_ia32_addpd512_mask (a, a, a, 1, 4);
 	}
+
+	__m128d _mm128_add (__m128d a)
+	{
+	  return __builtin_ia32_addsd_round (a, a, 8);
+	}
+
+	__m128d _mm128_getmant (__m128d a)
+	{
+	  return __builtin_ia32_getmantsd_round (a, a, 0, 8);
+	}
     } "-O2 -mavx512f" ]
 }
 
diff --git a/gcc/tree-cfg.c b/gcc/tree-cfg.c
index 4f09c827d9e..f9d75c5f64d 100644
--- a/gcc/tree-cfg.c
+++ b/gcc/tree-cfg.c
@@ -6640,7 +6640,16 @@ move_stmt_op (tree *tp, int *walk_subtrees, void *data)
 	;
       else if (block == p->orig_block
 	       || p->orig_block == NULL_TREE)
-	TREE_SET_BLOCK (t, p->new_block);
+	{
+	  /* tree_node_can_be_shared says we can share invariant
+	     addresses but unshare_expr copies them anyways.  Make sure
+	     to unshare before adjusting the block in place - we do not
+	     always see a copy here.  */
+	  if (TREE_CODE (t) == ADDR_EXPR
+	      && is_gimple_min_invariant (t))
+	    *tp = t = unshare_expr (t);
+	  TREE_SET_BLOCK (t, p->new_block);
+	}
       else if (flag_checking)
 	{
 	  while (block && TREE_CODE (block) == BLOCK && block != p->orig_block)
diff --git a/gcc/tree-core.h b/gcc/tree-core.h
index a646ecb5c95..38154e384c0 100644
--- a/gcc/tree-core.h
+++ b/gcc/tree-core.h
@@ -1138,6 +1138,9 @@ struct GTY(()) tree_base {
        OMP_CLAUSE_LINEAR_VARIABLE_STRIDE in
 	   OMP_CLAUSE_LINEAR
 
+       ASM_INLINE_P in
+	   ASM_EXPR
+
    side_effects_flag:
 
        TREE_SIDE_EFFECTS in
diff --git a/gcc/tree-data-ref.c b/gcc/tree-data-ref.c
index 2480f4e5561..a349e3ec5f1 100644
--- a/gcc/tree-data-ref.c
+++ b/gcc/tree-data-ref.c
@@ -2118,6 +2118,8 @@ initialize_matrix_A (lambda_matrix A, tree chrec, unsigned index, int mult)
   switch (TREE_CODE (chrec))
     {
     case POLYNOMIAL_CHREC:
+      if (!cst_and_fits_in_hwi (CHREC_RIGHT (chrec)))
+	return chrec_dont_know;
       A[index][0] = mult * int_cst_value (CHREC_RIGHT (chrec));
       return initialize_matrix_A (A, CHREC_LEFT (chrec), index + 1, mult);
 
@@ -2499,7 +2501,7 @@ analyze_subscript_affine_affine (tree chrec_a,
 				 tree *last_conflicts)
 {
   unsigned nb_vars_a, nb_vars_b, dim;
-  HOST_WIDE_INT init_a, init_b, gamma, gcd_alpha_beta;
+  HOST_WIDE_INT gamma, gcd_alpha_beta;
   lambda_matrix A, U, S;
   struct obstack scratch_obstack;
 
@@ -2536,9 +2538,20 @@ analyze_subscript_affine_affine (tree chrec_a,
   A = lambda_matrix_new (dim, 1, &scratch_obstack);
   S = lambda_matrix_new (dim, 1, &scratch_obstack);
 
-  init_a = int_cst_value (initialize_matrix_A (A, chrec_a, 0, 1));
-  init_b = int_cst_value (initialize_matrix_A (A, chrec_b, nb_vars_a, -1));
-  gamma = init_b - init_a;
+  tree init_a = initialize_matrix_A (A, chrec_a, 0, 1);
+  tree init_b = initialize_matrix_A (A, chrec_b, nb_vars_a, -1);
+  if (init_a == chrec_dont_know
+      || init_b == chrec_dont_know)
+    {
+      if (dump_file && (dump_flags & TDF_DETAILS))
+	fprintf (dump_file, "affine-affine test failed: "
+		 "representation issue.\n");
+      *overlaps_a = conflict_fn_not_known ();
+      *overlaps_b = conflict_fn_not_known ();
+      *last_conflicts = chrec_dont_know;
+      goto end_analyze_subs_aa;
+    }
+  gamma = int_cst_value (init_b) - int_cst_value (init_a);
 
   /* Don't do all the hard work of solving the Diophantine equation
      when we already know the solution: for example,
diff --git a/gcc/tree-dfa.c b/gcc/tree-dfa.c
index 4e47be1dc05..645db9e1459 100644
--- a/gcc/tree-dfa.c
+++ b/gcc/tree-dfa.c
@@ -438,7 +438,7 @@ get_ref_base_and_extent (tree exp, HOST_WIDE_INT *poffset,
 		   referenced the last field of a struct or a union member
 		   then we have to adjust maxsize by the padding at the end
 		   of our field.  */
-		if (seen_variable_array_ref && maxsize != -1)
+		if (seen_variable_array_ref)
 		  {
 		    tree stype = TREE_TYPE (TREE_OPERAND (exp, 0));
 		    tree next = DECL_CHAIN (field);
@@ -454,7 +454,7 @@ get_ref_base_and_extent (tree exp, HOST_WIDE_INT *poffset,
 			    || ssize == NULL
 			    || TREE_CODE (ssize) != INTEGER_CST)
 			  maxsize = -1;
-			else
+			else if (maxsize != -1)
 			  {
 			    offset_int tem = (wi::to_offset (ssize)
 					      - wi::to_offset (fsize));
@@ -463,6 +463,11 @@ get_ref_base_and_extent (tree exp, HOST_WIDE_INT *poffset,
 			    maxsize += tem;
 			  }
 		      }
+		    /* An component ref with an adjacent field up in the
+		       structure hierarchy constrains the size of any variable
+		       array ref lower in the access hierarchy.  */
+		    else
+		      seen_variable_array_ref = false;
 		  }
 	      }
 	    else
@@ -617,7 +622,9 @@ get_ref_base_and_extent (tree exp, HOST_WIDE_INT *poffset,
 
   if (DECL_P (exp))
     {
-      if (flag_unconstrained_commons && VAR_P (exp) && DECL_COMMON (exp))
+      if (VAR_P (exp)
+	  && ((flag_unconstrained_commons && DECL_COMMON (exp))
+	      || (DECL_EXTERNAL (exp) && seen_variable_array_ref)))
 	{
 	  tree sz_tree = TYPE_SIZE (TREE_TYPE (exp));
 	  /* If size is unknown, or we have read to the end, assume there
diff --git a/gcc/tree-eh.c b/gcc/tree-eh.c
index ad50b32220e..f9b2395fcad 100644
--- a/gcc/tree-eh.c
+++ b/gcc/tree-eh.c
@@ -44,6 +44,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "cfgloop.h"
 #include "gimple-low.h"
 #include "asan.h"
+#include "gimplify.h"
 
 /* In some instances a tree and a gimple need to be stored in a same table,
    i.e. in hash tables. This is a structure to do this. */
@@ -2438,7 +2439,7 @@ operation_could_trap_helper_p (enum tree_code op,
     case ROUND_MOD_EXPR:
     case TRUNC_MOD_EXPR:
     case RDIV_EXPR:
-      if (honor_snans || honor_trapv)
+      if (honor_snans)
 	return true;
       if (fp_operation)
 	return flag_trapping_math;
@@ -2722,6 +2723,91 @@ tree_could_trap_p (tree expr)
     }
 }
 
+/* Return non-NULL if there is an integer operation with trapping overflow
+   we can rewrite into non-trapping.  Called via walk_tree from
+   rewrite_to_non_trapping_overflow.  */
+
+static tree
+find_trapping_overflow (tree *tp, int *walk_subtrees, void *data)
+{
+  if (EXPR_P (*tp)
+      && !operation_no_trapping_overflow (TREE_TYPE (*tp), TREE_CODE (*tp)))
+    return *tp;
+  if (IS_TYPE_OR_DECL_P (*tp)
+      || (TREE_CODE (*tp) == SAVE_EXPR && data == NULL))
+    *walk_subtrees = 0;
+  return NULL_TREE;
+}
+
+/* Rewrite selected operations into unsigned arithmetics, so that they
+   don't trap on overflow.  */
+
+static tree
+replace_trapping_overflow (tree *tp, int *walk_subtrees, void *data)
+{
+  if (find_trapping_overflow (tp, walk_subtrees, data))
+    {
+      tree type = TREE_TYPE (*tp);
+      tree utype = unsigned_type_for (type);
+      *walk_subtrees = 0;
+      int len = TREE_OPERAND_LENGTH (*tp);
+      for (int i = 0; i < len; ++i)
+	walk_tree (&TREE_OPERAND (*tp, i), replace_trapping_overflow,
+		   data, (hash_set<tree> *) data);
+
+      if (TREE_CODE (*tp) == ABS_EXPR)
+	{
+	  tree op = TREE_OPERAND (*tp, 0);
+	  op = save_expr (op);
+	  /* save_expr skips simple arithmetics, which is undesirable
+	     here, if it might trap due to flag_trapv.  We need to
+	     force a SAVE_EXPR in the COND_EXPR condition, to evaluate
+	     it before the comparison.  */
+	  if (EXPR_P (op)
+	      && TREE_CODE (op) != SAVE_EXPR
+	      && walk_tree (&op, find_trapping_overflow, NULL, NULL))
+	    {
+	      op = build1_loc (EXPR_LOCATION (op), SAVE_EXPR, type, op);
+	      TREE_SIDE_EFFECTS (op) = 1;
+	    }
+	  /* Change abs (op) to op < 0 ? -op : op and handle the NEGATE_EXPR
+	     like other signed integer trapping operations.  */
+	  tree cond = fold_build2 (LT_EXPR, boolean_type_node,
+				   op, build_int_cst (type, 0));
+	  tree neg = fold_build1 (NEGATE_EXPR, utype,
+				  fold_convert (utype, op));
+	  *tp = fold_build3 (COND_EXPR, type, cond,
+			     fold_convert (type, neg), op);
+	}
+      else
+	{
+	  TREE_TYPE (*tp) = utype;
+	  len = TREE_OPERAND_LENGTH (*tp);
+	  for (int i = 0; i < len; ++i)
+	    TREE_OPERAND (*tp, i)
+	      = fold_convert (utype, TREE_OPERAND (*tp, i));
+	  *tp = fold_convert (type, *tp);
+	}
+    }
+  return NULL_TREE;
+}
+
+/* If any subexpression of EXPR can trap due to -ftrapv, rewrite it
+   using unsigned arithmetics to avoid traps in it.  */
+
+tree
+rewrite_to_non_trapping_overflow (tree expr)
+{
+  if (!flag_trapv)
+    return expr;
+  hash_set<tree> pset;
+  if (!walk_tree (&expr, find_trapping_overflow, &pset, &pset))
+    return expr;
+  expr = unshare_expr (expr);
+  hash_set<tree> pset2;
+  walk_tree (&expr, replace_trapping_overflow, &pset2, &pset2);
+  return expr;
+}
 
 /* Helper for stmt_could_throw_p.  Return true if STMT (assumed to be a
    an assignment or a conditional) may throw.  */
diff --git a/gcc/tree-eh.h b/gcc/tree-eh.h
index 2883628ec35..f639282bee5 100644
--- a/gcc/tree-eh.h
+++ b/gcc/tree-eh.h
@@ -37,6 +37,7 @@ extern bool operation_could_trap_helper_p (enum tree_code, bool, bool, bool,
 					   bool, tree, bool *);
 extern bool operation_could_trap_p (enum tree_code, bool, bool, tree);
 extern bool tree_could_trap_p (tree);
+extern tree rewrite_to_non_trapping_overflow (tree);
 extern bool stmt_could_throw_p (gimple *);
 extern bool tree_could_throw_p (tree);
 extern bool stmt_can_throw_external (gimple *);
diff --git a/gcc/tree-emutls.c b/gcc/tree-emutls.c
index 951e7d3f513..883ca2465a8 100644
--- a/gcc/tree-emutls.c
+++ b/gcc/tree-emutls.c
@@ -34,6 +34,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "gimple-walk.h"
 #include "langhooks.h"
 #include "tree-iterator.h"
+#include "gimplify.h"
 
 /* Whenever a target does not support thread-local storage (TLS) natively,
    we can emulate it with some run-time support in libgcc.  This will in
@@ -430,6 +431,20 @@ gen_emutls_addr (tree decl, struct lower_emutls_data *d)
   return addr;
 }
 
+/* Callback for lower_emutls_1, return non-NULL if there is any TLS
+   VAR_DECL in the subexpressions.  */
+
+static tree
+lower_emutls_2 (tree *ptr, int *walk_subtrees, void *)
+{
+  tree t = *ptr;
+  if (TREE_CODE (t) == VAR_DECL)
+    return DECL_THREAD_LOCAL_P (t) ? t : NULL_TREE;
+  else if (!EXPR_P (t))
+    *walk_subtrees = 0;
+  return NULL_TREE;
+}
+
 /* Callback for walk_gimple_op.  D = WI->INFO is a struct lower_emutls_data.
    Given an operand *PTR within D->STMT, if the operand references a TLS
    variable, then lower the reference to a call to the runtime.  Insert
@@ -456,6 +471,13 @@ lower_emutls_1 (tree *ptr, int *walk_subtrees, void *cb_data)
 	{
 	  bool save_changed;
 
+	  /* Gimple invariants are shareable trees, so before changing
+	     anything in them if we will need to change anything, unshare
+	     them.  */
+	  if (is_gimple_min_invariant (t)
+	      && walk_tree (&TREE_OPERAND (t, 0), lower_emutls_2, NULL, NULL))
+	    *ptr = t = unshare_expr (t);
+
 	  /* If we're allowed more than just is_gimple_val, continue.  */
 	  if (!wi->val_only)
 	    {
diff --git a/gcc/tree-if-conv.c b/gcc/tree-if-conv.c
index e3f3768c013..8ec10f9173e 100644
--- a/gcc/tree-if-conv.c
+++ b/gcc/tree-if-conv.c
@@ -2248,10 +2248,7 @@ predicate_mem_writes (loop_p loop)
 					 TREE_OPERAND (cond, 0),
 					 TREE_OPERAND (cond, 1));
 		  else
-		    {
-		      gcc_assert (TREE_CODE (cond) == SSA_NAME);
-		      mask = cond;
-		    }
+		    mask = cond;
 
 		  if (swap)
 		    {
diff --git a/gcc/tree-inline.c b/gcc/tree-inline.c
index f56d09e1bdb..e12d2e9f5d6 100644
--- a/gcc/tree-inline.c
+++ b/gcc/tree-inline.c
@@ -57,6 +57,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "cfgloop.h"
 #include "builtins.h"
 #include "tree-chkp.h"
+#include "attribs.h"
 
 
 /* I'm not real happy about this, but we need to handle gimple and
@@ -1182,6 +1183,7 @@ copy_tree_body_r (tree *tp, int *walk_subtrees, void *data)
 	      *tp = gimple_fold_indirect_ref (ptr);
 	      if (! *tp)
 	        {
+		  type = remap_type (type, id);
 		  if (TREE_CODE (ptr) == ADDR_EXPR)
 		    {
 		      *tp
@@ -1941,8 +1943,7 @@ copy_bb (copy_body_data *id, basic_block bb, int frequency_scale,
 		   && id->call_stmt
 		   && (decl = gimple_call_fndecl (stmt))
 		   && DECL_BUILT_IN_CLASS (decl) == BUILT_IN_NORMAL
-		   && DECL_FUNCTION_CODE (decl) == BUILT_IN_VA_ARG_PACK_LEN
-		   && ! gimple_call_va_arg_pack_p (id->call_stmt))
+		   && DECL_FUNCTION_CODE (decl) == BUILT_IN_VA_ARG_PACK_LEN)
 	    {
 	      /* __builtin_va_arg_pack_len () should be replaced by
 		 the number of anonymous arguments.  */
@@ -1960,10 +1961,32 @@ copy_bb (copy_body_data *id, basic_block bb, int frequency_scale,
 		if (POINTER_BOUNDS_P (gimple_call_arg (id->call_stmt, i)))
 		  nargs--;
 
-	      count = build_int_cst (integer_type_node, nargs);
-	      new_stmt = gimple_build_assign (gimple_call_lhs (stmt), count);
-	      gsi_replace (&copy_gsi, new_stmt, false);
-	      stmt = new_stmt;
+	      if (!gimple_call_lhs (stmt))
+		{
+		  /* Drop unused calls.  */
+		  gsi_remove (&copy_gsi, false);
+		  continue;
+		}
+	      else if (!gimple_call_va_arg_pack_p (id->call_stmt))
+		{
+		  count = build_int_cst (integer_type_node, nargs);
+		  new_stmt = gimple_build_assign (gimple_call_lhs (stmt), count);
+		  gsi_replace (&copy_gsi, new_stmt, false);
+		  stmt = new_stmt;
+		}
+	      else if (nargs != 0)
+		{
+		  tree newlhs;
+		  if (gimple_in_ssa_p (cfun))
+		    newlhs = make_ssa_name (integer_type_node, NULL);
+		  else
+		    newlhs = create_tmp_reg (integer_type_node);
+		  count = build_int_cst (integer_type_node, nargs);
+		  new_stmt = gimple_build_assign (gimple_call_lhs (stmt),
+						  PLUS_EXPR, newlhs, count);
+		  gimple_call_set_lhs (stmt, newlhs);
+		  gsi_insert_after (&copy_gsi, new_stmt, GSI_NEW_STMT);
+		}
 	    }
 	  else if (call_stmt
 		   && id->call_stmt
@@ -4150,6 +4173,9 @@ estimate_num_insns (gimple *stmt, eni_weights *weights)
 	   with very long asm statements.  */
 	if (count > 1000)
 	  count = 1000;
+	/* If this asm is asm inline, count anything as minimum size.  */
+	if (gimple_asm_inline_p (as_a <gasm *> (stmt)))
+	  count = MIN (1, count);
 	return count;
       }
 
@@ -6024,6 +6050,25 @@ tree_function_versioning (tree old_decl, tree new_decl,
       = copy_arguments_for_versioning (DECL_ARGUMENTS (old_decl), &id,
 				       args_to_skip, &vars);
 
+  /* Remove omp declare simd attribute from the new attributes.  */
+  if (tree a = lookup_attribute ("omp declare simd",
+				 DECL_ATTRIBUTES (new_decl)))
+    {
+      while (tree a2 = lookup_attribute ("omp declare simd", TREE_CHAIN (a)))
+	a = a2;
+      a = TREE_CHAIN (a);
+      for (tree *p = &DECL_ATTRIBUTES (new_decl); *p != a;)
+	if (is_attribute_p ("omp declare simd", get_attribute_name (*p)))
+	  *p = TREE_CHAIN (*p);
+	else
+	  {
+	    tree chain = TREE_CHAIN (*p);
+	    *p = copy_node (*p);
+	    p = &TREE_CHAIN (*p);
+	    *p = chain;
+	  }
+    }
+
   DECL_INITIAL (new_decl) = remap_blocks (DECL_INITIAL (id.src_fn), &id);
   BLOCK_SUPERCONTEXT (DECL_INITIAL (new_decl)) = new_decl;
 
diff --git a/gcc/tree-scalar-evolution.c b/gcc/tree-scalar-evolution.c
index cbd17e8644f..790050a20c9 100644
--- a/gcc/tree-scalar-evolution.c
+++ b/gcc/tree-scalar-evolution.c
@@ -280,6 +280,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "params.h"
 #include "tree-ssa-propagate.h"
 #include "gimple-fold.h"
+#include "tree-into-ssa.h"
 
 static tree analyze_scalar_evolution_1 (struct loop *, tree, tree);
 static tree analyze_scalar_evolution_for_address_of (struct loop *loop,
@@ -1532,7 +1533,10 @@ static tree
 follow_copies_to_constant (tree var)
 {
   tree res = var;
-  while (TREE_CODE (res) == SSA_NAME)
+  while (TREE_CODE (res) == SSA_NAME
+	 /* We face not updated SSA form in multiple places and this walk
+	    may end up in sibling loops so we have to guard it.  */
+	 && !name_registered_for_update_p (res))
     {
       gimple *def = SSA_NAME_DEF_STMT (res);
       if (gphi *phi = dyn_cast <gphi *> (def))
diff --git a/gcc/tree-ssa-dom.c b/gcc/tree-ssa-dom.c
index 22ac57e1f75..10e4ec705a6 100644
--- a/gcc/tree-ssa-dom.c
+++ b/gcc/tree-ssa-dom.c
@@ -531,7 +531,8 @@ pass_dominator::execute (function *fun)
 	  if (bb == NULL)
 	    continue;
 	  while (single_succ_p (bb)
-		 && (single_succ_edge (bb)->flags & EDGE_EH) == 0)
+		 && (single_succ_edge (bb)->flags
+		     & (EDGE_EH|EDGE_DFS_BACK)) == 0)
 	    bb = single_succ (bb);
 	  if (bb == EXIT_BLOCK_PTR_FOR_FN (fun))
 	    continue;
diff --git a/gcc/tree-ssa-loop-ch.c b/gcc/tree-ssa-loop-ch.c
index 86be34a1ac7..923efa42a69 100644
--- a/gcc/tree-ssa-loop-ch.c
+++ b/gcc/tree-ssa-loop-ch.c
@@ -57,7 +57,8 @@ should_duplicate_loop_header_p (basic_block header, struct loop *loop,
      be true, since quite often it is possible to verify that the condition is
      satisfied in the first iteration and therefore to eliminate it.  Jump
      threading handles these cases now.  */
-  if (optimize_loop_for_size_p (loop))
+  if (optimize_loop_for_size_p (loop)
+      && !loop->force_vectorize)
     {
       if (dump_file && (dump_flags & TDF_DETAILS))
 	fprintf (dump_file,
diff --git a/gcc/tree-ssa-loop-niter.c b/gcc/tree-ssa-loop-niter.c
index 6b829cc4d79..3f51cb98788 100644
--- a/gcc/tree-ssa-loop-niter.c
+++ b/gcc/tree-ssa-loop-niter.c
@@ -2320,11 +2320,11 @@ number_of_iterations_exit_assumptions (struct loop *loop, edge exit,
 
   tree iv0_niters = NULL_TREE;
   if (!simple_iv_with_niters (loop, loop_containing_stmt (stmt),
-			      op0, &iv0, &iv0_niters, false))
+			      op0, &iv0, safe ? &iv0_niters : NULL, false))
     return false;
   tree iv1_niters = NULL_TREE;
   if (!simple_iv_with_niters (loop, loop_containing_stmt (stmt),
-			      op1, &iv1, &iv1_niters, false))
+			      op1, &iv1, safe ? &iv1_niters : NULL, false))
     return false;
   /* Give up on complicated case.  */
   if (iv0_niters && iv1_niters)
diff --git a/gcc/tree-ssa-loop-split.c b/gcc/tree-ssa-loop-split.c
index fd972137749..3992597e241 100644
--- a/gcc/tree-ssa-loop-split.c
+++ b/gcc/tree-ssa-loop-split.c
@@ -649,7 +649,8 @@ tree_ssa_split_loops (void)
 					false, true)
 	  && niter.cmp != ERROR_MARK
 	  /* We can't yet handle loops controlled by a != predicate.  */
-	  && niter.cmp != NE_EXPR)
+	  && niter.cmp != NE_EXPR
+	  && can_duplicate_loop_p (loop))
 	{
 	  if (split_loop (loop, &niter))
 	    {
diff --git a/gcc/tree-ssa-phiprop.c b/gcc/tree-ssa-phiprop.c
index 63c3c164894..97eec627d47 100644
--- a/gcc/tree-ssa-phiprop.c
+++ b/gcc/tree-ssa-phiprop.c
@@ -270,6 +270,7 @@ propagate_with_phi (basic_block bb, gphi *phi, struct phiprop_d *phivn,
   use_operand_p arg_p, use;
   ssa_op_iter i;
   bool phi_inserted;
+  bool changed;
   tree type = NULL_TREE;
 
   if (!POINTER_TYPE_P (TREE_TYPE (ptr))
@@ -317,6 +318,7 @@ propagate_with_phi (basic_block bb, gphi *phi, struct phiprop_d *phivn,
   /* Replace the first dereference of *ptr if there is one and if we
      can move the loads to the place of the ptr phi node.  */
   phi_inserted = false;
+  changed = false;
   FOR_EACH_IMM_USE_STMT (use_stmt, ui, ptr)
     {
       gimple *def_stmt;
@@ -403,7 +405,7 @@ propagate_with_phi (basic_block bb, gphi *phi, struct phiprop_d *phivn,
 	  unlink_stmt_vdef (use_stmt);
 	  gsi_remove (&gsi, true);
 
-	  phi_inserted = true;
+	  changed = true;
 	}
 
       /* Found a proper dereference.  Insert a phi node if this
@@ -424,6 +426,7 @@ propagate_with_phi (basic_block bb, gphi *phi, struct phiprop_d *phivn,
 	  gsi_remove (&gsi, true);
 
 	  phi_inserted = true;
+	  changed = true;
 	}
       else
 	{
@@ -431,13 +434,14 @@ propagate_with_phi (basic_block bb, gphi *phi, struct phiprop_d *phivn,
 	     load.  */
 	  gimple_assign_set_rhs1 (use_stmt, res);
 	  update_stmt (use_stmt);
+	  changed = true;
 	}
 
 next:;
       /* Continue searching for a proper dereference.  */
     }
 
-  return phi_inserted;
+  return changed;
 }
 
 /* Main entry for phiprop pass.  */
diff --git a/gcc/tree-ssa-pre.c b/gcc/tree-ssa-pre.c
index 443193dca78..b0524233669 100644
--- a/gcc/tree-ssa-pre.c
+++ b/gcc/tree-ssa-pre.c
@@ -2787,11 +2787,7 @@ create_expression_by_pieces (basic_block block, pre_expr expr,
 	  unsigned int operand = 1;
 	  vn_reference_op_t currop = &ref->operands[0];
 	  tree sc = NULL_TREE;
-	  tree fn;
-	  if (TREE_CODE (currop->op0) == FUNCTION_DECL)
-	    fn = currop->op0;
-	  else
-	    fn = find_or_generate_expression (block, currop->op0, stmts);
+	  tree fn  = find_or_generate_expression (block, currop->op0, stmts);
 	  if (!fn)
 	    return NULL_TREE;
 	  if (currop->op1)
@@ -2809,14 +2805,27 @@ create_expression_by_pieces (basic_block block, pre_expr expr,
 		return NULL_TREE;
 	      args.quick_push (arg);
 	    }
-	  gcall *call
-	    = gimple_build_call_vec ((TREE_CODE (fn) == FUNCTION_DECL
-				      ? build_fold_addr_expr (fn) : fn), args);
+	  gcall *call = gimple_build_call_vec (fn, args);
 	  gimple_call_set_with_bounds (call, currop->with_bounds);
 	  if (sc)
 	    gimple_call_set_chain (call, sc);
 	  tree forcedname = make_ssa_name (currop->type);
 	  gimple_call_set_lhs (call, forcedname);
+	  /* There's no CCP pass after PRE which would re-compute alignment
+	     information so make sure we re-materialize this here.  */
+	  if (gimple_call_builtin_p (call, BUILT_IN_ASSUME_ALIGNED)
+	      && args.length () - 2 <= 1
+	      && tree_fits_uhwi_p (args[1])
+	      && (args.length () != 3 || tree_fits_uhwi_p (args[2])))
+	    {
+	      unsigned HOST_WIDE_INT halign = tree_to_uhwi (args[1]);
+	      unsigned HOST_WIDE_INT hmisalign
+		= args.length () == 3 ? tree_to_uhwi (args[2]) : 0;
+	      if ((halign & (halign - 1)) == 0
+		  && (hmisalign & ~(halign - 1)) == 0)
+		set_ptr_info_alignment (get_ptr_info (forcedname),
+					halign, hmisalign);
+	    }
 	  gimple_set_vuse (call, BB_LIVE_VOP_ON_EXIT (block));
 	  gimple_seq_add_stmt_without_update (&forced_stmts, call);
 	  folded = forcedname;
diff --git a/gcc/tree-ssa-reassoc.c b/gcc/tree-ssa-reassoc.c
index e57a343c532..b4f13ef75c4 100644
--- a/gcc/tree-ssa-reassoc.c
+++ b/gcc/tree-ssa-reassoc.c
@@ -470,7 +470,8 @@ get_rank (tree e)
 
 /* We want integer ones to end up last no matter what, since they are
    the ones we can do the most with.  */
-#define INTEGER_CONST_TYPE 1 << 3
+#define INTEGER_CONST_TYPE 1 << 4
+#define FLOAT_ONE_CONST_TYPE 1 << 3
 #define FLOAT_CONST_TYPE 1 << 2
 #define OTHER_CONST_TYPE 1 << 1
 
@@ -482,7 +483,14 @@ constant_type (tree t)
   if (INTEGRAL_TYPE_P (TREE_TYPE (t)))
     return INTEGER_CONST_TYPE;
   else if (SCALAR_FLOAT_TYPE_P (TREE_TYPE (t)))
-    return FLOAT_CONST_TYPE;
+    {
+      /* Sort -1.0 and 1.0 constants last, while in some cases
+	 const_binop can't optimize some inexact operations, multiplication
+	 by -1.0 or 1.0 can be always merged with others.  */
+      if (real_onep (t) || real_minus_onep (t))
+	return FLOAT_ONE_CONST_TYPE;
+      return FLOAT_CONST_TYPE;
+    }
   else
     return OTHER_CONST_TYPE;
 }
@@ -501,7 +509,7 @@ sort_by_operand_rank (const void *pa, const void *pb)
   if (oeb->rank == 0 && oea->rank == 0)
     {
       if (constant_type (oeb->op) != constant_type (oea->op))
-	return constant_type (oeb->op) - constant_type (oea->op);
+	return constant_type (oea->op) - constant_type (oeb->op);
       else
 	/* To make sorting result stable, we use unique IDs to determine
 	   order.  */
@@ -1004,7 +1012,7 @@ eliminate_using_constants (enum tree_code opcode,
 		    fprintf (dump_file, "Found * 0, removing all other ops\n");
 
 		  reassociate_stats.ops_eliminated += ops->length () - 1;
-		  ops->truncate (1);
+		  ops->truncate (0);
 		  ops->quick_push (oelast);
 		  return;
 		}
@@ -2870,7 +2878,8 @@ optimize_range_tests_to_bit_test (enum tree_code opcode, int first, int length,
 static bool
 optimize_range_tests_var_bound (enum tree_code opcode, int first, int length,
 				vec<operand_entry *> *ops,
-				struct range_entry *ranges)
+				struct range_entry *ranges,
+				basic_block first_bb)
 {
   int i;
   bool any_changes = false;
@@ -2967,6 +2976,60 @@ optimize_range_tests_var_bound (enum tree_code opcode, int first, int length,
       if (idx == NULL)
 	continue;
 
+      /* maybe_optimize_range_tests allows statements without side-effects
+	 in the basic blocks as long as they are consumed in the same bb.
+	 Make sure rhs2's def stmt is not among them, otherwise we can't
+	 use safely get_nonzero_bits on it.  E.g. in:
+	  # RANGE [-83, 1] NONZERO 173
+	  # k_32 = PHI <k_47(13), k_12(9)>
+	 ...
+	  if (k_32 >= 0)
+	    goto <bb 5>; [26.46%]
+	  else
+	    goto <bb 9>; [73.54%]
+
+	  <bb 5> [local count: 140323371]:
+	  # RANGE [0, 1] NONZERO 1
+	  _5 = (int) k_32;
+	  # RANGE [0, 4] NONZERO 4
+	  _21 = _5 << 2;
+	  # RANGE [0, 4] NONZERO 4
+	  iftmp.0_44 = (char) _21;
+	  if (k_32 < iftmp.0_44)
+	    goto <bb 6>; [84.48%]
+	  else
+	    goto <bb 9>; [15.52%]
+	 the ranges on _5/_21/iftmp.0_44 are flow sensitive, assume that
+	 k_32 >= 0.  If we'd optimize k_32 >= 0 to true and k_32 < iftmp.0_44
+	 to (unsigned) k_32 < (unsigned) iftmp.0_44, then we would execute
+	 those stmts even for negative k_32 and the value ranges would be no
+	 longer guaranteed and so the optimization would be invalid.  */
+      if (opcode == ERROR_MARK)
+	{
+	  gimple *g = SSA_NAME_DEF_STMT (rhs2);
+	  basic_block bb2 = gimple_bb (g);
+	  if (bb2
+	      && bb2 != first_bb
+	      && dominated_by_p (CDI_DOMINATORS, bb2, first_bb))
+	    {
+	      /* As an exception, handle a few common cases.  */
+	      if (gimple_assign_cast_p (g)
+		  && INTEGRAL_TYPE_P (TREE_TYPE (gimple_assign_rhs1 (g)))
+		  && TYPE_UNSIGNED (TREE_TYPE (gimple_assign_rhs1 (g)))
+		  && (TYPE_PRECISION (TREE_TYPE (rhs2))
+		      > TYPE_PRECISION (TREE_TYPE (gimple_assign_rhs1 (g)))))
+		/* Zero-extension is always ok.  */ ;
+	      else if (is_gimple_assign (g)
+		       && gimple_assign_rhs_code (g) == BIT_AND_EXPR
+		       && TREE_CODE (gimple_assign_rhs2 (g)) == INTEGER_CST
+		       && !wi::neg_p (gimple_assign_rhs2 (g)))
+		/* Masking with INTEGER_CST with MSB clear is always ok
+		   too.  */ ;
+	      else
+		continue;
+	    }
+	}
+
       wide_int nz = get_nonzero_bits (rhs2);
       if (wi::neg_p (nz))
 	continue;
@@ -3093,11 +3156,12 @@ optimize_range_tests_var_bound (enum tree_code opcode, int first, int length,
    maybe_optimize_range_tests for inter-bb range optimization.
    In that case if oe->op is NULL, oe->id is bb->index whose
    GIMPLE_COND is && or ||ed into the test, and oe->rank says
-   the actual opcode.  */
+   the actual opcode.
+   FIRST_BB is the first basic block if OPCODE is ERROR_MARK.  */
 
 static bool
 optimize_range_tests (enum tree_code opcode,
-		      vec<operand_entry *> *ops)
+		      vec<operand_entry *> *ops, basic_block first_bb)
 {
   unsigned int length = ops->length (), i, j, first;
   operand_entry *oe;
@@ -3175,7 +3239,7 @@ optimize_range_tests (enum tree_code opcode,
     any_changes |= optimize_range_tests_to_bit_test (opcode, first, length,
 						     ops, ranges);
   any_changes |= optimize_range_tests_var_bound (opcode, first, length, ops,
-						 ranges);
+						 ranges, first_bb);
 
   if (any_changes && opcode != ERROR_MARK)
     {
@@ -3922,7 +3986,7 @@ maybe_optimize_range_tests (gimple *stmt)
 	break;
     }
   if (ops.length () > 1)
-    any_changes = optimize_range_tests (ERROR_MARK, &ops);
+    any_changes = optimize_range_tests (ERROR_MARK, &ops, first_bb);
   if (any_changes)
     {
       unsigned int idx, max_idx = 0;
@@ -5674,7 +5738,7 @@ reassociate_bb (basic_block bb)
 		  if (is_vector)
 		    optimize_vec_cond_expr (rhs_code, &ops);
 		  else
-		    optimize_range_tests (rhs_code, &ops);
+		    optimize_range_tests (rhs_code, &ops, NULL);
 	        }
 
 	      if (rhs_code == MULT_EXPR && !is_vector)
diff --git a/gcc/tree-ssa-sccvn.c b/gcc/tree-ssa-sccvn.c
index 01e060b6690..a2e3ce26dcb 100644
--- a/gcc/tree-ssa-sccvn.c
+++ b/gcc/tree-ssa-sccvn.c
@@ -1245,7 +1245,9 @@ vn_reference_maybe_forwprop_address (vec<vn_reference_op_s> *ops,
 	  return true;
 	}
       if (!addr_base
-	  || TREE_CODE (addr_base) != MEM_REF)
+	  || TREE_CODE (addr_base) != MEM_REF
+	  || (TREE_CODE (TREE_OPERAND (addr_base, 0)) == SSA_NAME
+	      && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (TREE_OPERAND (addr_base, 0))))
 	return false;
 
       off += addr_offset;
@@ -1258,6 +1260,7 @@ vn_reference_maybe_forwprop_address (vec<vn_reference_op_s> *ops,
       ptr = gimple_assign_rhs1 (def_stmt);
       ptroff = gimple_assign_rhs2 (def_stmt);
       if (TREE_CODE (ptr) != SSA_NAME
+	  || SSA_NAME_OCCURS_IN_ABNORMAL_PHI (ptr)
 	  || TREE_CODE (ptroff) != INTEGER_CST)
 	return false;
 
@@ -1933,6 +1936,7 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *vr_,
       base2 = get_ref_base_and_extent (gimple_assign_lhs (def_stmt),
 				       &offset2, &size2, &maxsize2, &reverse);
       if (maxsize2 != -1
+	  && maxsize2 == size2
 	  && operand_equal_p (base, base2, 0)
 	  && offset2 <= offset
 	  && offset2 + size2 >= offset + maxsize)
@@ -1978,8 +1982,9 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *vr_,
 	  if (TREE_CODE (rhs) == SSA_NAME)
 	    rhs = SSA_VAL (rhs);
 	  len = native_encode_expr (gimple_assign_rhs1 (def_stmt),
-				    buffer, sizeof (buffer));
-	  if (len > 0)
+				    buffer, sizeof (buffer),
+				    (offset - offset2) / BITS_PER_UNIT);
+	  if (len > 0 && len * BITS_PER_UNIT >= ref->size)
 	    {
 	      tree type = vr->type;
 	      /* Make sure to interpret in a type that has a range
@@ -1988,10 +1993,7 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *vr_,
 		  && ref->size != TYPE_PRECISION (vr->type))
 		type = build_nonstandard_integer_type (ref->size,
 						       TYPE_UNSIGNED (type));
-	      tree val = native_interpret_expr (type,
-						buffer
-						+ ((offset - offset2)
-						   / BITS_PER_UNIT),
+	      tree val = native_interpret_expr (type, buffer,
 						ref->size / BITS_PER_UNIT);
 	      /* If we chop off bits because the types precision doesn't
 		 match the memory access size this is ok when optimizing
@@ -2027,6 +2029,7 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *vr_,
       base2 = get_ref_base_and_extent (gimple_assign_lhs (def_stmt),
 				       &offset2, &size2, &maxsize2,
 				       &reverse);
+      tree def_rhs = gimple_assign_rhs1 (def_stmt);
       if (!reverse
 	  && maxsize2 != -1
 	  && maxsize2 == size2
@@ -2039,11 +2042,14 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *vr_,
 	     according to endianness.  */
 	  && (! INTEGRAL_TYPE_P (vr->type)
 	      || ref->size == TYPE_PRECISION (vr->type))
-	  && ref->size % BITS_PER_UNIT == 0)
+	  && ref->size % BITS_PER_UNIT == 0
+	  && (! INTEGRAL_TYPE_P (TREE_TYPE (def_rhs))
+	      || (TYPE_PRECISION (TREE_TYPE (def_rhs))
+		  == GET_MODE_PRECISION (TYPE_MODE (TREE_TYPE (def_rhs))))))
 	{
 	  code_helper rcode = BIT_FIELD_REF;
 	  tree ops[3];
-	  ops[0] = SSA_VAL (gimple_assign_rhs1 (def_stmt));
+	  ops[0] = SSA_VAL (def_rhs);
 	  ops[1] = bitsize_int (ref->size);
 	  ops[2] = bitsize_int (offset - offset2);
 	  tree val = vn_nary_build_or_lookup (rcode, vr->type, ops);
@@ -3570,7 +3576,17 @@ visit_nary_op (tree lhs, gassign *stmt)
 		  ops[0] = vn_nary_op_lookup_pieces
 		      (2, gimple_assign_rhs_code (def), type, ops, NULL);
 		  /* We have wider operation available.  */
-		  if (ops[0])
+		  if (ops[0]
+		      /* If the leader is a wrapping operation we can
+			 insert it for code hoisting w/o introducing
+			 undefined overflow.  If it is not it has to
+			 be available.  See PR86554.  */
+		      && (TYPE_OVERFLOW_WRAPS (TREE_TYPE (ops[0]))
+			  || TREE_CODE (ops[0]) != SSA_NAME
+			  || SSA_NAME_IS_DEFAULT_DEF (ops[0])
+			  || dominated_by_p_w_unex
+			       (gimple_bb (stmt),
+				gimple_bb (SSA_NAME_DEF_STMT (ops[0])))))
 		    {
 		      unsigned lhs_prec = TYPE_PRECISION (type);
 		      unsigned rhs_prec = TYPE_PRECISION (TREE_TYPE (rhs1));
diff --git a/gcc/tree-ssa-structalias.c b/gcc/tree-ssa-structalias.c
index 33ad80efe3c..bffa7dad4b4 100644
--- a/gcc/tree-ssa-structalias.c
+++ b/gcc/tree-ssa-structalias.c
@@ -7274,6 +7274,7 @@ delete_points_to_sets (void)
 struct vls_data
 {
   unsigned short clique;
+  bool escaped_p;
   bitmap rvars;
 };
 
@@ -7285,6 +7286,7 @@ visit_loadstore (gimple *, tree base, tree ref, void *data)
 {
   unsigned short clique = ((vls_data *) data)->clique;
   bitmap rvars = ((vls_data *) data)->rvars;
+  bool escaped_p = ((vls_data *) data)->escaped_p;
   if (TREE_CODE (base) == MEM_REF
       || TREE_CODE (base) == TARGET_MEM_REF)
     {
@@ -7305,7 +7307,8 @@ visit_loadstore (gimple *, tree base, tree ref, void *data)
 	    return false;
 
 	  vi = get_varinfo (find (vi->id));
-	  if (bitmap_intersect_p (rvars, vi->solution))
+	  if (bitmap_intersect_p (rvars, vi->solution)
+	      || (escaped_p && bitmap_bit_p (vi->solution, escaped_id)))
 	    return false;
 	}
 
@@ -7382,6 +7385,7 @@ compute_dependence_clique (void)
   unsigned short clique = 0;
   unsigned short last_ruid = 0;
   bitmap rvars = BITMAP_ALLOC (NULL);
+  bool escaped_p = false;
   for (unsigned i = 0; i < num_ssa_names; ++i)
     {
       tree ptr = ssa_name (i);
@@ -7451,7 +7455,15 @@ compute_dependence_clique (void)
 						 last_ruid);
 	    }
 	  if (used)
-	    bitmap_set_bit (rvars, restrict_var->id);
+	    {
+	      /* Add all subvars to the set of restrict pointed-to set. */
+	      for (unsigned sv = restrict_var->head; sv != 0;
+		   sv = get_varinfo (sv)->next)
+		bitmap_set_bit (rvars, sv);
+	      varinfo_t escaped = get_varinfo (find (escaped_id));
+	      if (bitmap_bit_p (escaped->solution, restrict_var->id))
+		escaped_p = true;
+	    }
 	}
     }
 
@@ -7464,7 +7476,7 @@ compute_dependence_clique (void)
 	 parameters) we can't restrict scoping properly thus the following
 	 is too aggressive there.  For now we have excluded those globals from
 	 getting into the MR_DEPENDENCE machinery.  */
-      vls_data data = { clique, rvars };
+      vls_data data = { clique, escaped_p, rvars };
       basic_block bb;
       FOR_EACH_BB_FN (bb, cfun)
 	for (gimple_stmt_iterator gsi = gsi_start_bb (bb);
diff --git a/gcc/tree-ssa-tail-merge.c b/gcc/tree-ssa-tail-merge.c
index 01c25d43e0d..541b6673448 100644
--- a/gcc/tree-ssa-tail-merge.c
+++ b/gcc/tree-ssa-tail-merge.c
@@ -298,7 +298,15 @@ stmt_local_def (gimple *stmt)
   if (gimple_vdef (stmt) != NULL_TREE
       || gimple_has_side_effects (stmt)
       || gimple_could_trap_p_1 (stmt, false, false)
-      || gimple_vuse (stmt) != NULL_TREE)
+      || gimple_vuse (stmt) != NULL_TREE
+      /* Copied from tree-ssa-ifcombine.c:bb_no_side_effects_p():
+	 const calls don't match any of the above, yet they could
+	 still have some side-effects - they could contain
+	 gimple_could_trap_p statements, like floating point
+	 exceptions or integer division by zero.  See PR70586.
+	 FIXME: perhaps gimple_has_side_effects or gimple_could_trap_p
+	 should handle this.  */
+      || is_gimple_call (stmt))
     return false;
 
   def_p = SINGLE_SSA_DEF_OPERAND (stmt, SSA_OP_DEF);
@@ -1454,7 +1462,8 @@ find_clusters_1 (same_succ *same_succ)
       /* TODO: handle blocks with phi-nodes.  We'll have to find corresponding
 	 phi-nodes in bb1 and bb2, with the same alternatives for the same
 	 preds.  */
-      if (bb_has_non_vop_phi (bb1) || bb_has_eh_pred (bb1))
+      if (bb_has_non_vop_phi (bb1) || bb_has_eh_pred (bb1)
+	  || bb_has_abnormal_pred (bb1))
 	continue;
 
       nr_comparisons = 0;
@@ -1462,7 +1471,8 @@ find_clusters_1 (same_succ *same_succ)
 	{
 	  bb2 = BASIC_BLOCK_FOR_FN (cfun, j);
 
-	  if (bb_has_non_vop_phi (bb2) || bb_has_eh_pred (bb2))
+	  if (bb_has_non_vop_phi (bb2) || bb_has_eh_pred (bb2)
+	      || bb_has_abnormal_pred (bb2))
 	    continue;
 
 	  if (BB_CLUSTER (bb1) != NULL && BB_CLUSTER (bb1) == BB_CLUSTER (bb2))
diff --git a/gcc/tree-ssa.c b/gcc/tree-ssa.c
index 42e708ed673..66920e20fde 100644
--- a/gcc/tree-ssa.c
+++ b/gcc/tree-ssa.c
@@ -1423,7 +1423,8 @@ non_rewritable_mem_ref_base (tree ref)
       if (! DECL_P (decl))
 	return NULL_TREE;
       if (! is_gimple_reg_type (TREE_TYPE (base))
-	  || VOID_TYPE_P (TREE_TYPE (base)))
+	  || VOID_TYPE_P (TREE_TYPE (base))
+	  || TREE_THIS_VOLATILE (decl) != TREE_THIS_VOLATILE (base))
 	return decl;
       if ((TREE_CODE (TREE_TYPE (decl)) == VECTOR_TYPE
 	   || TREE_CODE (TREE_TYPE (decl)) == COMPLEX_TYPE)
diff --git a/gcc/tree-tailcall.c b/gcc/tree-tailcall.c
index f586edcd730..ed443fa0883 100644
--- a/gcc/tree-tailcall.c
+++ b/gcc/tree-tailcall.c
@@ -473,7 +473,7 @@ find_tail_calls (basic_block bb, struct tailcall **ret)
     {
       tree arg;
 
-      for (param = DECL_ARGUMENTS (func), idx = 0;
+      for (param = DECL_ARGUMENTS (current_function_decl), idx = 0;
 	   param && idx < gimple_call_num_args (call);
 	   param = DECL_CHAIN (param), idx ++)
 	{
diff --git a/gcc/tree-vect-data-refs.c b/gcc/tree-vect-data-refs.c
index ccaa945bffb..9c32d9a90ee 100644
--- a/gcc/tree-vect-data-refs.c
+++ b/gcc/tree-vect-data-refs.c
@@ -195,6 +195,45 @@ vect_mark_for_runtime_alias_test (ddr_p ddr, loop_vec_info loop_vinfo)
 }
 
 
+/* Return true if we know that the order of vectorized STMT_A and
+   vectorized STMT_B will be the same as the order of STMT_A and STMT_B.
+   At least one of the statements is a write.  */
+
+static bool
+vect_preserves_scalar_order_p (gimple *stmt_a, gimple *stmt_b)
+{
+  stmt_vec_info stmtinfo_a = vinfo_for_stmt (stmt_a);
+  stmt_vec_info stmtinfo_b = vinfo_for_stmt (stmt_b);
+
+  /* Single statements are always kept in their original order.  */
+  if (!STMT_VINFO_GROUPED_ACCESS (stmtinfo_a)
+      && !STMT_VINFO_GROUPED_ACCESS (stmtinfo_b))
+    return true;
+
+  /* STMT_A and STMT_B belong to overlapping groups.  All loads in a
+     group are emitted at the position of the last scalar load and all
+     stores in a group are emitted at the position of the last scalar store.
+     Compute that position and check whether the resulting order matches
+     the current one.  */
+  gimple *last_a = GROUP_FIRST_ELEMENT (stmtinfo_a);
+  if (last_a)
+    for (gimple *s = GROUP_NEXT_ELEMENT (vinfo_for_stmt (last_a)); s;
+	 s = GROUP_NEXT_ELEMENT (vinfo_for_stmt (s)))
+      last_a = get_later_stmt (last_a, s);
+  else
+    last_a = stmt_a;
+  gimple *last_b = GROUP_FIRST_ELEMENT (stmtinfo_b);
+  if (last_b)
+    for (gimple *s = GROUP_NEXT_ELEMENT (vinfo_for_stmt (last_b)); s;
+	 s = GROUP_NEXT_ELEMENT (vinfo_for_stmt (s)))
+      last_b = get_later_stmt (last_b, s);
+  else
+    last_b = stmt_b;
+  return ((get_later_stmt (last_a, last_b) == last_a)
+	  == (get_later_stmt (stmt_a, stmt_b) == stmt_a));
+}
+
+
 /* Function vect_analyze_data_ref_dependence.
 
    Return TRUE if there (might) exist a dependence between a memory-reference
@@ -378,20 +417,23 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,
 		... = a[i];
 		a[i+1] = ...;
 	     where loads from the group interleave with the store.  */
-	  if (STMT_VINFO_GROUPED_ACCESS (stmtinfo_a)
-	      || STMT_VINFO_GROUPED_ACCESS (stmtinfo_b))
+	  if (!vect_preserves_scalar_order_p (DR_STMT (dra), DR_STMT (drb)))
 	    {
-	      gimple *earlier_stmt;
-	      earlier_stmt = get_earlier_stmt (DR_STMT (dra), DR_STMT (drb));
-	      if (DR_IS_WRITE
-		    (STMT_VINFO_DATA_REF (vinfo_for_stmt (earlier_stmt))))
-		{
-		  if (dump_enabled_p ())
-		    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,
-				     "READ_WRITE dependence in interleaving."
-				     "\n");
-		  return true;
-		}
+	      if (dump_enabled_p ())
+		dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,
+				 "READ_WRITE dependence in interleaving."
+				 "\n");
+	      return true;
+	    }
+
+	  unsigned int step_prec = TYPE_PRECISION (TREE_TYPE (DR_STEP (dra)));
+	  if (loop->safelen < 2
+	      && !expr_not_equal_to (DR_STEP (dra), wi::zero (step_prec)))
+	    {
+	      if (dump_enabled_p ())
+		dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,
+				 "step could be zero.\n");
+	      return true;
 	    }
 
 	  continue;
@@ -2515,7 +2557,7 @@ vect_analyze_data_ref_access (struct data_reference *dr)
       /* Allow references with zero step for outer loops marked
 	 with pragma omp simd only - it guarantees absence of
 	 loop-carried dependencies between inner loop iterations.  */
-      if (!loop->force_vectorize)
+      if (!loop->force_vectorize || loop->safelen < 2)
 	{
 	  if (dump_enabled_p ())
 	    dump_printf_loc (MSG_NOTE, vect_location,
diff --git a/gcc/tree-vect-generic.c b/gcc/tree-vect-generic.c
index c1b3c24a0b4..2e6dbcc0215 100644
--- a/gcc/tree-vect-generic.c
+++ b/gcc/tree-vect-generic.c
@@ -89,12 +89,8 @@ build_word_mode_vector_type (int nunits)
       return vector_last_type;
     }
 
-  /* We build a new type, but we canonicalize it nevertheless,
-     because it still saves some memory.  */
   vector_last_nunits = nunits;
-  vector_last_type = type_hash_canon (nunits,
-				      build_vector_type (vector_inner_type,
-							 nunits));
+  vector_last_type = build_vector_type (vector_inner_type, nunits);
   return vector_last_type;
 }
 
diff --git a/gcc/tree-vect-loop.c b/gcc/tree-vect-loop.c
index a6ec5396345..6f2245c526b 100644
--- a/gcc/tree-vect-loop.c
+++ b/gcc/tree-vect-loop.c
@@ -50,6 +50,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "cgraph.h"
 #include "tree-cfg.h"
 #include "tree-if-conv.h"
+#include "tree-eh.h"
 
 /* Loop Vectorization Pass.
 
@@ -1055,7 +1056,8 @@ vect_get_loop_niters (struct loop *loop, tree *assumptions,
 							  may_be_zero));
 	  else
 	    niter = fold_build3 (COND_EXPR, TREE_TYPE (niter), may_be_zero,
-				 build_int_cst (TREE_TYPE (niter), 0), niter);
+				 build_int_cst (TREE_TYPE (niter), 0),
+				 rewrite_to_non_trapping_overflow (niter));
 
 	  may_be_zero = NULL_TREE;
 	}
diff --git a/gcc/tree-vect-stmts.c b/gcc/tree-vect-stmts.c
index 5096d03b625..04237dbb9fe 100644
--- a/gcc/tree-vect-stmts.c
+++ b/gcc/tree-vect-stmts.c
@@ -2753,7 +2753,7 @@ vectorizable_call (gimple *gs, gimple_stmt_iterator *gsi, gimple **vec_stmt,
       if (cfn != CFN_LAST)
 	fndecl = targetm.vectorize.builtin_vectorized_function
 	  (cfn, vectype_out, vectype_in);
-      else
+      else if (callee)
 	fndecl = targetm.vectorize.builtin_md_vectorized_function
 	  (callee, vectype_out, vectype_in);
     }
@@ -5479,15 +5479,34 @@ vectorizable_operation (gimple *stmt, gimple_stmt_iterator *gsi,
       /* Handle uses.  */
       if (j == 0)
 	{
-	  if (op_type == binary_op || op_type == ternary_op)
+	  if (op_type == binary_op)
 	    vect_get_vec_defs (op0, op1, stmt, &vec_oprnds0, &vec_oprnds1,
 			       slp_node, -1);
+	  else if (op_type == ternary_op)
+	    {
+	      if (slp_node)
+		{
+		  auto_vec<tree> ops(3);
+		  ops.quick_push (op0);
+		  ops.quick_push (op1);
+		  ops.quick_push (op2);
+		  auto_vec<vec<tree> > vec_defs(3);
+		  vect_get_slp_defs (ops, slp_node, &vec_defs, -1);
+		  vec_oprnds0 = vec_defs[0];
+		  vec_oprnds1 = vec_defs[1];
+		  vec_oprnds2 = vec_defs[2];
+		}
+	      else
+		{ 
+		  vect_get_vec_defs (op0, op1, stmt, &vec_oprnds0, &vec_oprnds1,
+				     NULL, -1);
+		  vect_get_vec_defs (op2, NULL_TREE, stmt, &vec_oprnds2, NULL,
+				     NULL, -1);
+		}
+	    }
 	  else
 	    vect_get_vec_defs (op0, NULL_TREE, stmt, &vec_oprnds0, NULL,
 			       slp_node, -1);
-	  if (op_type == ternary_op)
-	    vect_get_vec_defs (op2, NULL_TREE, stmt, &vec_oprnds2, NULL,
-			       slp_node, -1);
 	}
       else
 	{
diff --git a/gcc/tree-vectorizer.h b/gcc/tree-vectorizer.h
index 12bb904abee..276289bd8cf 100644
--- a/gcc/tree-vectorizer.h
+++ b/gcc/tree-vectorizer.h
@@ -833,32 +833,22 @@ set_vinfo_for_stmt (gimple *stmt, stmt_vec_info info)
     }
 }
 
-/* Return the earlier statement between STMT1 and STMT2.  */
+/* Return TRUE if a statement represented by STMT_INFO is a part of a
+   pattern.  */
 
-static inline gimple *
-get_earlier_stmt (gimple *stmt1, gimple *stmt2)
+static inline bool
+is_pattern_stmt_p (stmt_vec_info stmt_info)
 {
-  unsigned int uid1, uid2;
-
-  if (stmt1 == NULL)
-    return stmt2;
-
-  if (stmt2 == NULL)
-    return stmt1;
-
-  uid1 = gimple_uid (stmt1);
-  uid2 = gimple_uid (stmt2);
-
-  if (uid1 == 0 || uid2 == 0)
-    return NULL;
+  gimple *related_stmt;
+  stmt_vec_info related_stmt_info;
 
-  gcc_checking_assert (uid1 <= stmt_vec_info_vec.length ()
-		       && uid2 <= stmt_vec_info_vec.length ());
+  related_stmt = STMT_VINFO_RELATED_STMT (stmt_info);
+  if (related_stmt
+      && (related_stmt_info = vinfo_for_stmt (related_stmt))
+      && STMT_VINFO_IN_PATTERN_P (related_stmt_info))
+    return true;
 
-  if (uid1 < uid2)
-    return stmt1;
-  else
-    return stmt2;
+  return false;
 }
 
 /* Return the later statement between STMT1 and STMT2.  */
@@ -874,8 +864,12 @@ get_later_stmt (gimple *stmt1, gimple *stmt2)
   if (stmt2 == NULL)
     return stmt1;
 
-  uid1 = gimple_uid (stmt1);
-  uid2 = gimple_uid (stmt2);
+  stmt_vec_info stmt_info1 = vinfo_for_stmt (stmt1);
+  stmt_vec_info stmt_info2 = vinfo_for_stmt (stmt2);
+  uid1 = gimple_uid (is_pattern_stmt_p (stmt_info1)
+		     ? STMT_VINFO_RELATED_STMT (stmt_info1) : stmt1);
+  uid2 = gimple_uid (is_pattern_stmt_p (stmt_info2)
+		     ? STMT_VINFO_RELATED_STMT (stmt_info2) : stmt2);
 
   if (uid1 == 0 || uid2 == 0)
     return NULL;
@@ -889,24 +883,6 @@ get_later_stmt (gimple *stmt1, gimple *stmt2)
     return stmt2;
 }
 
-/* Return TRUE if a statement represented by STMT_INFO is a part of a
-   pattern.  */
-
-static inline bool
-is_pattern_stmt_p (stmt_vec_info stmt_info)
-{
-  gimple *related_stmt;
-  stmt_vec_info related_stmt_info;
-
-  related_stmt = STMT_VINFO_RELATED_STMT (stmt_info);
-  if (related_stmt
-      && (related_stmt_info = vinfo_for_stmt (related_stmt))
-      && STMT_VINFO_IN_PATTERN_P (related_stmt_info))
-    return true;
-
-  return false;
-}
-
 /* Return true if BB is a loop header.  */
 
 static inline bool
diff --git a/gcc/tree-vrp.c b/gcc/tree-vrp.c
index 9431b90cf52..b5424befc78 100644
--- a/gcc/tree-vrp.c
+++ b/gcc/tree-vrp.c
@@ -8671,9 +8671,9 @@ union_ranges (enum value_range_type *vr0type,
 	  if (TREE_CODE (*vr0min) == INTEGER_CST)
 	    {
 	      *vr0type = vr1type;
-	      *vr0min = vr1min;
 	      *vr0max = int_const_binop (MINUS_EXPR, *vr0min,
 					 build_int_cst (TREE_TYPE (*vr0min), 1));
+	      *vr0min = vr1min;
 	    }
 	  else
 	    goto give_up;
diff --git a/gcc/tree.c b/gcc/tree.c
index 698213c3501..d0075348264 100644
--- a/gcc/tree.c
+++ b/gcc/tree.c
@@ -5454,9 +5454,10 @@ free_lang_data_in_decl (tree decl)
 	 At this point, it is not needed anymore.  */
       DECL_SAVED_TREE (decl) = NULL_TREE;
 
-      /* Clear the abstract origin if it refers to a method.  Otherwise
-         dwarf2out.c will ICE as we clear TYPE_METHODS and thus the
-	 origin will not be output correctly.  */
+      /* Clear the abstract origin if it refers to a method.
+         Otherwise dwarf2out.c will ICE as we splice functions out of
+         TYPE_FIELDS and thus the origin will not be output
+         correctly.  */
       if (DECL_ABSTRACT_ORIGIN (decl)
 	  && DECL_CONTEXT (DECL_ABSTRACT_ORIGIN (decl))
 	  && RECORD_OR_UNION_TYPE_P
@@ -7887,6 +7888,9 @@ add_expr (const_tree t, inchash::hash &hstate, unsigned int flags)
       for (i = 0; i < TREE_VEC_LENGTH (t); ++i)
 	inchash::add_expr (TREE_VEC_ELT (t, i), hstate, flags);
       return;
+    case IDENTIFIER_NODE:
+      hstate.add_object (IDENTIFIER_HASH_VALUE (t));
+      return;
     case FUNCTION_DECL:
       /* When referring to a built-in FUNCTION_DECL, use the __builtin__ form.
 	 Otherwise nodes that compare equal according to operand_equal_p might
@@ -10305,8 +10309,7 @@ build_common_tree_nodes (bool signed_char)
       TYPE_SIZE (int_n_trees[i].signed_type) = bitsize_int (int_n_data[i].bitsize);
       TYPE_SIZE (int_n_trees[i].unsigned_type) = bitsize_int (int_n_data[i].bitsize);
 
-      if (int_n_data[i].bitsize > LONG_LONG_TYPE_SIZE
-	  && int_n_enabled_p[i])
+      if (int_n_enabled_p[i])
 	{
 	  integer_types[itk_intN_0 + i * 2] = int_n_trees[i].signed_type;
 	  integer_types[itk_unsigned_intN_0 + i * 2] = int_n_trees[i].unsigned_type;
diff --git a/gcc/tree.h b/gcc/tree.h
index f20b77f17e4..961dba39403 100644
--- a/gcc/tree.h
+++ b/gcc/tree.h
@@ -1231,6 +1231,9 @@ extern void protected_set_expr_location (tree, location_t);
    ASM_OPERAND with no operands.  */
 #define ASM_INPUT_P(NODE) (ASM_EXPR_CHECK (NODE)->base.static_flag)
 #define ASM_VOLATILE_P(NODE) (ASM_EXPR_CHECK (NODE)->base.public_flag)
+/* Nonzero if we want to consider this asm as minimum length and cost
+   for inlining decisions.  */
+#define ASM_INLINE_P(NODE) (ASM_EXPR_CHECK (NODE)->base.protected_flag)
 
 /* COND_EXPR accessors.  */
 #define COND_EXPR_COND(NODE)	(TREE_OPERAND (COND_EXPR_CHECK (NODE), 0))
diff --git a/gcc/varasm.c b/gcc/varasm.c
index e240ba77430..e554cf56bc0 100644
--- a/gcc/varasm.c
+++ b/gcc/varasm.c
@@ -1241,10 +1241,9 @@ use_blocks_for_decl_p (tree decl)
   if (!VAR_P (decl) && TREE_CODE (decl) != CONST_DECL)
     return false;
 
-  /* Detect decls created by dw2_force_const_mem.  Such decls are
-     special because DECL_INITIAL doesn't specify the decl's true value.
-     dw2_output_indirect_constants will instead call assemble_variable
-     with dont_output_data set to 1 and then print the contents itself.  */
+  /* DECL_INITIAL (decl) set to decl is a hack used for some decls that
+     are never used from code directly and we never want object block handling
+     for those.  */
   if (DECL_INITIAL (decl) == decl)
     return false;
 
@@ -5176,7 +5175,7 @@ output_constructor_bitfield (oc_local_state *local, unsigned int bit_offset)
     {
       int this_time;
       int shift;
-      HOST_WIDE_INT value;
+      unsigned HOST_WIDE_INT value;
       HOST_WIDE_INT next_byte = next_offset / BITS_PER_UNIT;
       HOST_WIDE_INT next_bit = next_offset % BITS_PER_UNIT;
 
@@ -5208,15 +5207,13 @@ output_constructor_bitfield (oc_local_state *local, unsigned int bit_offset)
 	      this_time = end - shift + 1;
 	    }
 
-	  /* Now get the bits from the appropriate constant word.  */
-	  value = TREE_INT_CST_ELT (local->val, shift / HOST_BITS_PER_WIDE_INT);
-	  shift = shift & (HOST_BITS_PER_WIDE_INT - 1);
+	  /* Now get the bits we want to insert.  */
+	  value = wi::extract_uhwi (wi::to_widest (local->val),
+				    shift, this_time);
 
 	  /* Get the result.  This works only when:
 	     1 <= this_time <= HOST_BITS_PER_WIDE_INT.  */
-	  local->byte |= (((value >> shift)
-			   & (((HOST_WIDE_INT) 2 << (this_time - 1)) - 1))
-			  << (BITS_PER_UNIT - this_time - next_bit));
+	  local->byte |= value << (BITS_PER_UNIT - this_time - next_bit);
 	}
       else
 	{
@@ -5233,15 +5230,13 @@ output_constructor_bitfield (oc_local_state *local, unsigned int bit_offset)
 	    this_time
 	      = HOST_BITS_PER_WIDE_INT - (shift & (HOST_BITS_PER_WIDE_INT - 1));
 
-	  /* Now get the bits from the appropriate constant word.  */
-	  value = TREE_INT_CST_ELT (local->val, shift / HOST_BITS_PER_WIDE_INT);
-	  shift = shift & (HOST_BITS_PER_WIDE_INT - 1);
+	  /* Now get the bits we want to insert.  */
+	  value = wi::extract_uhwi (wi::to_widest (local->val),
+				    shift, this_time);
 
 	  /* Get the result.  This works only when:
 	     1 <= this_time <= HOST_BITS_PER_WIDE_INT.  */
-	  local->byte |= (((value >> shift)
-			   & (((HOST_WIDE_INT) 2 << (this_time - 1)) - 1))
-			  << next_bit);
+	  local->byte |= value << next_bit;
 	}
 
       next_offset += this_time;
diff --git a/gcc/vmsdbgout.c b/gcc/vmsdbgout.c
index 41928a400a9..aef4013d1f4 100644
--- a/gcc/vmsdbgout.c
+++ b/gcc/vmsdbgout.c
@@ -147,6 +147,7 @@ static int write_srccorrs (int);
 
 static void vmsdbgout_init (const char *);
 static void vmsdbgout_finish (const char *);
+static void vmsdbgout_early_finish (const char *);
 static void vmsdbgout_assembly_start (void);
 static void vmsdbgout_define (unsigned int, const char *);
 static void vmsdbgout_undef (unsigned int, const char *);
@@ -176,7 +177,7 @@ static void vmsdbgout_abstract_function (tree);
 const struct gcc_debug_hooks vmsdbg_debug_hooks
 = {vmsdbgout_init,
    vmsdbgout_finish,
-   debug_nothing_charstar,
+   vmsdbgout_early_finish,
    vmsdbgout_assembly_start,
    vmsdbgout_define,
    vmsdbgout_undef,
@@ -1554,6 +1555,13 @@ vmsdbgout_abstract_function (tree decl)
     (*dwarf2_debug_hooks.outlining_inline_function) (decl);
 }
 
+static void
+vmsdbgout_early_finish (const char *filename)
+{
+  if (write_symbols == VMS_AND_DWARF2_DEBUG)
+    (*dwarf2_debug_hooks.early_finish) (filename);
+}
+
 /* Output stuff that Debug requires at the end of every file and generate the
    VMS Debug debugging info.  */
 
diff --git a/gcc/xcoffout.c b/gcc/xcoffout.c
index c6eab21a55d..a83638d7f51 100644
--- a/gcc/xcoffout.c
+++ b/gcc/xcoffout.c
@@ -63,6 +63,7 @@ static const char *xcoff_current_function_file;
 
 char *xcoff_bss_section_name;
 char *xcoff_private_data_section_name;
+char *xcoff_private_rodata_section_name;
 char *xcoff_tls_data_section_name;
 char *xcoff_tbss_section_name;
 char *xcoff_read_only_section_name;
diff --git a/gcc/xcoffout.h b/gcc/xcoffout.h
index 6b0b0a07d8b..ec74824554d 100644
--- a/gcc/xcoffout.h
+++ b/gcc/xcoffout.h
@@ -127,6 +127,7 @@ extern const char *xcoff_current_include_file;
 
 extern char *xcoff_bss_section_name;
 extern char *xcoff_private_data_section_name;
+extern char *xcoff_private_rodata_section_name;
 extern char *xcoff_tls_data_section_name;
 extern char *xcoff_tbss_section_name;
 extern char *xcoff_read_only_section_name;
diff --git a/gnattools/ChangeLog b/gnattools/ChangeLog
index 9139933defa..3a5970ccba5 100644
--- a/gnattools/ChangeLog
+++ b/gnattools/ChangeLog
@@ -1,3 +1,7 @@
+2018-12-06  Release Manager
+
+	* GCC 7.4.0 released.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
diff --git a/gotools/ChangeLog b/gotools/ChangeLog
index 870fca90988..8172b5aac0b 100644
--- a/gotools/ChangeLog
+++ b/gotools/ChangeLog
@@ -1,3 +1,7 @@
+2018-12-06  Release Manager
+
+	* GCC 7.4.0 released.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
diff --git a/include/ChangeLog b/include/ChangeLog
index 2bea3cbfe37..7e3c033bfab 100644
--- a/include/ChangeLog
+++ b/include/ChangeLog
@@ -1,3 +1,7 @@
+2018-12-06  Release Manager
+
+	* GCC 7.4.0 released.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
diff --git a/intl/ChangeLog b/intl/ChangeLog
index b835f641642..b3b02c97b36 100644
--- a/intl/ChangeLog
+++ b/intl/ChangeLog
@@ -1,3 +1,7 @@
+2018-12-06  Release Manager
+
+	* GCC 7.4.0 released.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
diff --git a/libada/ChangeLog b/libada/ChangeLog
index 6a950729892..e55648ad480 100644
--- a/libada/ChangeLog
+++ b/libada/ChangeLog
@@ -1,3 +1,15 @@
+2018-12-06  Release Manager
+
+	* GCC 7.4.0 released.
+
+2018-06-22  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-04-18  David Malcolm  <dmalcolm@redhat.com>
+
+	PR jit/85384
+	* configure: Regenerate.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
diff --git a/libada/configure b/libada/configure
index 17a52c81db2..13e267a7f4e 100755
--- a/libada/configure
+++ b/libada/configure
@@ -3018,7 +3018,7 @@ fi
 # Check whether --with-gcc-major-version-only was given.
 if test "${with_gcc_major_version_only+set}" = set; then :
   withval=$with_gcc_major_version_only; if test x$with_gcc_major_version_only = xyes ; then
-        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*\$\$/\1/'"
+        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*/\1/'"
       fi
 
 fi
diff --git a/libatomic/ChangeLog b/libatomic/ChangeLog
index 77297253a79..a76c095b1b7 100644
--- a/libatomic/ChangeLog
+++ b/libatomic/ChangeLog
@@ -1,3 +1,23 @@
+2018-12-06  Release Manager
+
+	* GCC 7.4.0 released.
+
+2018-06-22  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-04-18  David Malcolm  <dmalcolm@redhat.com>
+
+	PR jit/85384
+	* configure: Regenerate.
+
+2018-03-09  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2018-03-09  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	* config/s390/exch_n.c: New file.
+	* configure.tgt: Add the config directory for s390.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
diff --git a/libatomic/config/s390/exch_n.c b/libatomic/config/s390/exch_n.c
new file mode 100644
index 00000000000..b2340b4aa6a
--- /dev/null
+++ b/libatomic/config/s390/exch_n.c
@@ -0,0 +1,69 @@
+/* Copyright (C) 2018 Free Software Foundation, Inc.
+   Contributed by Andreas Krebbel <krebbel@linux.vnet.ibm.com>
+
+   This file is part of the GNU Atomic Library (libatomic).
+
+   Libatomic is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   Libatomic is distributed in the hope that it will be useful, but WITHOUT ANY
+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+   more details.
+
+   Under Section 7 of GPL version 3, you are granted additional
+   permissions described in the GCC Runtime Library Exception, version
+   3.1, as published by the Free Software Foundation.
+
+   You should have received a copy of the GNU General Public License and
+   a copy of the GCC Runtime Library Exception along with this program;
+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <libatomic_i.h>
+
+
+/* The compiler builtin will use the hardware instruction cdsg if the
+   memory operand is properly aligned and will fall back to the
+   library call otherwise.
+
+   In case the compiler for one part is able to detect that the
+   location is aligned and fails to do so for another usage of the hw
+   instruction and the sw fall back would be mixed on the same memory
+   location.  To avoid this the library fall back also has to use the
+   hardware instruction if possible.  */
+
+#if !DONE && N == 16
+UTYPE
+SIZE(libat_exchange) (UTYPE *mptr, UTYPE newval, int smodel UNUSED)
+{
+  if (!((uintptr_t)mptr & 0xf))
+    {
+      /* Use the builtin only if the memory operand is 16 byte
+	 aligned.  */
+      return __atomic_exchange_n ((UTYPE *)__builtin_assume_aligned (mptr, 16),
+				  newval, __ATOMIC_SEQ_CST);
+    }
+  else
+    {
+      UTYPE oldval;
+      UWORD magic;
+
+      pre_seq_barrier (smodel);
+      magic = protect_start (mptr);
+
+      oldval = *mptr;
+      *mptr = newval;
+
+      protect_end (mptr, magic);
+      post_seq_barrier (smodel);
+
+      return oldval;
+    }
+}
+#define DONE 1
+#endif /* N == 16 */
+
+#include "../../exch_n.c"
diff --git a/libatomic/configure b/libatomic/configure
index c05fc9d1141..2ae9b8d40f3 100755
--- a/libatomic/configure
+++ b/libatomic/configure
@@ -12333,6 +12333,7 @@ _ACEOF
 
 
 
+
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for __atomic_load/store for size 2" >&5
 $as_echo_n "checking for __atomic_load/store for size 2... " >&6; }
 if test "${libat_cv_have_at_ldst_2+set}" = set; then :
@@ -12400,6 +12401,7 @@ _ACEOF
 
 
 
+
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for __atomic_load/store for size 4" >&5
 $as_echo_n "checking for __atomic_load/store for size 4... " >&6; }
 if test "${libat_cv_have_at_ldst_4+set}" = set; then :
@@ -12467,6 +12469,7 @@ _ACEOF
 
 
 
+
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for __atomic_load/store for size 8" >&5
 $as_echo_n "checking for __atomic_load/store for size 8... " >&6; }
 if test "${libat_cv_have_at_ldst_8+set}" = set; then :
@@ -12534,6 +12537,7 @@ _ACEOF
 
 
 
+
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for __atomic_load/store for size 16" >&5
 $as_echo_n "checking for __atomic_load/store for size 16... " >&6; }
 if test "${libat_cv_have_at_ldst_16+set}" = set; then :
@@ -12602,6 +12606,7 @@ _ACEOF
 
 
 
+
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for __atomic_test_and_set for size 1" >&5
 $as_echo_n "checking for __atomic_test_and_set for size 1... " >&6; }
 if test "${libat_cv_have_at_tas_1+set}" = set; then :
@@ -15267,7 +15272,7 @@ fi
 # Check whether --with-gcc-major-version-only was given.
 if test "${with_gcc_major_version_only+set}" = set; then :
   withval=$with_gcc_major_version_only; if test x$with_gcc_major_version_only = xyes ; then
-        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*\$\$/\1/'"
+        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*/\1/'"
       fi
 
 fi
diff --git a/libatomic/configure.tgt b/libatomic/configure.tgt
index b8af3ab2546..30ae29248cd 100644
--- a/libatomic/configure.tgt
+++ b/libatomic/configure.tgt
@@ -114,6 +114,11 @@ case "${target}" in
 	config_path="${config_path} linux/arm posix"
 	;;
 
+  s390*-*-linux*)
+	# OS support for atomic primitives.
+	config_path="${config_path} s390 posix"
+	;;
+
   *-*-linux* | *-*-gnu* | *-*-k*bsd*-gnu \
   | *-*-netbsd* | *-*-freebsd* | *-*-openbsd* | *-*-dragonfly* \
   | *-*-solaris2* | *-*-sysv4* | *-*-irix6* | *-*-osf* | *-*-hpux11* \
diff --git a/libbacktrace/ChangeLog b/libbacktrace/ChangeLog
index 2d8810bd83f..0bd76863013 100644
--- a/libbacktrace/ChangeLog
+++ b/libbacktrace/ChangeLog
@@ -1,3 +1,7 @@
+2018-12-06  Release Manager
+
+	* GCC 7.4.0 released.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
diff --git a/libcc1/ChangeLog b/libcc1/ChangeLog
index c61190f7a7f..45a9fc935b3 100644
--- a/libcc1/ChangeLog
+++ b/libcc1/ChangeLog
@@ -1,3 +1,15 @@
+2018-12-06  Release Manager
+
+	* GCC 7.4.0 released.
+
+2018-06-22  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-04-18  David Malcolm  <dmalcolm@redhat.com>
+
+	PR jit/85384
+	* configure: Regenerate.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
diff --git a/libcc1/configure b/libcc1/configure
index d6f480fe930..962d34d9271 100755
--- a/libcc1/configure
+++ b/libcc1/configure
@@ -14315,7 +14315,7 @@ _ACEOF
 # Check whether --with-gcc-major-version-only was given.
 if test "${with_gcc_major_version_only+set}" = set; then :
   withval=$with_gcc_major_version_only; if test x$with_gcc_major_version_only = xyes ; then
-        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*\$\$/\1/'"
+        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*/\1/'"
       fi
 
 fi
diff --git a/libcilkrts/ChangeLog b/libcilkrts/ChangeLog
index ec16da84f00..2fd6f1c6f36 100644
--- a/libcilkrts/ChangeLog
+++ b/libcilkrts/ChangeLog
@@ -1,3 +1,15 @@
+2018-12-06  Release Manager
+
+	* GCC 7.4.0 released.
+
+2018-06-22  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-04-18  David Malcolm  <dmalcolm@redhat.com>
+
+	PR jit/85384
+	* configure: Regenerate.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
diff --git a/libcilkrts/configure b/libcilkrts/configure
index 3cc8c999733..503337dc4b4 100644
--- a/libcilkrts/configure
+++ b/libcilkrts/configure
@@ -15413,7 +15413,7 @@ fi
 # Check whether --with-gcc-major-version-only was given.
 if test "${with_gcc_major_version_only+set}" = set; then :
   withval=$with_gcc_major_version_only; if test x$with_gcc_major_version_only = xyes ; then
-        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*\$\$/\1/'"
+        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*/\1/'"
       fi
 
 fi
diff --git a/libcpp/ChangeLog b/libcpp/ChangeLog
index 0ff9b69f61a..ee3cdb2cfd6 100644
--- a/libcpp/ChangeLog
+++ b/libcpp/ChangeLog
@@ -1,3 +1,42 @@
+2019-03-11  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2019-02-18  Martin Liska  <mliska@suse.cz>
+
+	PR c++/89383
+	* line-map.c (linemap_line_start): Use 1UL in order
+	to not overflow.
+
+2019-03-11  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2019-02-11  Martin Liska  <mliska@suse.cz>
+
+	PR lto/88147
+	* line-map.c (linemap_line_start): Don't reuse the existing line
+	map if the line offset is sufficiently large to cause overflow
+	when computing location_t values.
+
+2018-12-06  Release Manager
+
+	* GCC 7.4.0 released.
+
+2018-03-03  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-01-31  Jakub Jelinek  <jakub@redhat.com>
+
+	PR preprocessor/69869
+	* traditional.c (skip_macro_block_comment): Return bool, true if
+	the macro block comment is unterminated.
+	(copy_comment): Use return value from skip_macro_block_comment instead
+	of always false.
+
+	2018-01-27  Jakub Jelinek  <jakub@redhat.com>
+
+	* include/cpplib.h (enum cpp_builtin_type): Change BT_LAST_USER from
+	BT_FIRST_USER + 31 to BT_FIRST_USER + 63.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
diff --git a/libcpp/include/cpplib.h b/libcpp/include/cpplib.h
index b843992b0cd..1e15d6d71ae 100644
--- a/libcpp/include/cpplib.h
+++ b/libcpp/include/cpplib.h
@@ -702,7 +702,7 @@ enum cpp_builtin_type
   BT_COUNTER,			/* `__COUNTER__' */
   BT_HAS_ATTRIBUTE,		/* `__has_attribute__(x)' */
   BT_FIRST_USER,		/* User defined builtin macros.  */
-  BT_LAST_USER = BT_FIRST_USER + 31
+  BT_LAST_USER = BT_FIRST_USER + 63
 };
 
 #define CPP_HASHNODE(HNODE)	((cpp_hashnode *) (HNODE))
diff --git a/libcpp/lex.c b/libcpp/lex.c
index 097c78002cb..e0fb9e822c4 100644
--- a/libcpp/lex.c
+++ b/libcpp/lex.c
@@ -568,7 +568,7 @@ search_line_fast (const uchar *s, const uchar *end ATTRIBUTE_UNUSED)
     {
       vc m_nl, m_cr, m_bs, m_qm;
 
-      data = *((const vc *)s);
+      data = __builtin_vec_vsx_ld (0, s);
       s += 16;
 
       m_nl = (vc) __builtin_vec_cmpeq(data, repl_nl);
diff --git a/libcpp/line-map.c b/libcpp/line-map.c
index 949489eb1a1..ddcb0111f4b 100644
--- a/libcpp/line-map.c
+++ b/libcpp/line-map.c
@@ -753,6 +753,11 @@ linemap_line_start (struct line_maps *set, linenum_type to_line,
       if (line_delta < 0
 	  || last_line != ORDINARY_MAP_STARTING_LINE_NUMBER (map)
 	  || SOURCE_COLUMN (map, highest) >= (1U << (column_bits - range_bits))
+	  || ( /* We can't reuse the map if the line offset is sufficiently
+		  large to cause overflow when computing location_t values.  */
+	      (to_line - ORDINARY_MAP_STARTING_LINE_NUMBER (map))
+	      >= (((uint64_t) 1)
+		  << (CHAR_BIT * sizeof (linenum_type) - column_bits)))
 	  || range_bits < map->m_range_bits)
 	map = linemap_check_ordinary
 	        (const_cast <line_map *>
diff --git a/libcpp/po/ChangeLog b/libcpp/po/ChangeLog
index df61ee5fe50..17b719d7978 100644
--- a/libcpp/po/ChangeLog
+++ b/libcpp/po/ChangeLog
@@ -1,3 +1,7 @@
+2018-12-06  Release Manager
+
+	* GCC 7.4.0 released.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
diff --git a/libcpp/traditional.c b/libcpp/traditional.c
index e6004357ca3..91d33d651ca 100644
--- a/libcpp/traditional.c
+++ b/libcpp/traditional.c
@@ -119,8 +119,11 @@ check_output_buffer (cpp_reader *pfile, size_t n)
 }
 
 /* Skip a C-style block comment in a macro as a result of -CC.
-   Buffer->cur points to the initial asterisk of the comment.  */
-static void
+   PFILE->buffer->cur points to the initial asterisk of the comment,
+   change it to point to after the '*' and '/' characters that terminate it.
+   Return true if the macro has not been termined, in that case set
+   PFILE->buffer->cur to the end of the buffer.  */
+static bool
 skip_macro_block_comment (cpp_reader *pfile)
 {
   const uchar *cur = pfile->buffer->cur;
@@ -131,10 +134,15 @@ skip_macro_block_comment (cpp_reader *pfile)
 
   /* People like decorating comments with '*', so check for '/'
      instead for efficiency.  */
-  while(! (*cur++ == '/' && cur[-2] == '*') )
-    ;
+  while (! (*cur++ == '/' && cur[-2] == '*'))
+    if (cur[-1] == '\n')
+      {
+	pfile->buffer->cur = cur - 1;
+	return true;
+      }
 
   pfile->buffer->cur = cur;
+  return false;
 }
 
 /* CUR points to the asterisk introducing a comment in the current
@@ -158,7 +166,7 @@ copy_comment (cpp_reader *pfile, const uchar *cur, int in_define)
 
   buffer->cur = cur;
   if (pfile->context->prev)
-    unterminated = false, skip_macro_block_comment (pfile);
+    unterminated = skip_macro_block_comment (pfile);
   else
     unterminated = _cpp_skip_block_comment (pfile);
     
diff --git a/libdecnumber/ChangeLog b/libdecnumber/ChangeLog
index 008d54f5652..13cda41ec8a 100644
--- a/libdecnumber/ChangeLog
+++ b/libdecnumber/ChangeLog
@@ -1,3 +1,7 @@
+2018-12-06  Release Manager
+
+	* GCC 7.4.0 released.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
diff --git a/libffi/ChangeLog b/libffi/ChangeLog
index ec5dc75d463..944b6085cb2 100644
--- a/libffi/ChangeLog
+++ b/libffi/ChangeLog
@@ -1,3 +1,15 @@
+2018-12-06  Release Manager
+
+	* GCC 7.4.0 released.
+
+2018-06-22  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-04-18  David Malcolm  <dmalcolm@redhat.com>
+
+	PR jit/85384
+	* configure: Regenerate.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
diff --git a/libffi/configure b/libffi/configure
index 74b747b3b7e..790a291011f 100755
--- a/libffi/configure
+++ b/libffi/configure
@@ -16444,7 +16444,7 @@ $as_echo "$as_me: versioning on shared library symbols is $enable_symvers" >&6;}
 # Check whether --with-gcc-major-version-only was given.
 if test "${with_gcc_major_version_only+set}" = set; then :
   withval=$with_gcc_major_version_only; if test x$with_gcc_major_version_only = xyes ; then
-        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*\$\$/\1/'"
+        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*/\1/'"
       fi
 
 fi
diff --git a/libgcc/ChangeLog b/libgcc/ChangeLog
index 2fc6dedeb35..64fb43fdd27 100644
--- a/libgcc/ChangeLog
+++ b/libgcc/ChangeLog
@@ -1,3 +1,73 @@
+2018-12-06  Release Manager
+
+	* GCC 7.4.0 released.
+
+2018-08-17  John David Anglin  <danglin@gcc.gnu.org>
+
+	Backport from mainline
+	2018-08-11  John David Anglin  <danglin@gcc.gnu.org>
+
+	* config/pa/linux-atomic.c: Update comment.
+	(FETCH_AND_OP_2, OP_AND_FETCH_2, FETCH_AND_OP_WORD, OP_AND_FETCH_WORD,
+	COMPARE_AND_SWAP_2, __sync_val_compare_and_swap_4,
+	SYNC_LOCK_TEST_AND_SET_2, __sync_lock_test_and_set_4): Use
+	__ATOMIC_RELAXED for atomic loads.
+	(SYNC_LOCK_RELEASE_1): New define.  Use __sync_synchronize() and
+	unordered store to release lock.
+	(__sync_lock_release_8): Likewise.
+	(SYNC_LOCK_RELEASE_2): Remove define.
+	 
+2018-06-22  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-04-18  David Malcolm  <dmalcolm@redhat.com>
+
+	PR jit/85384
+	* configure: Regenerate.
+
+2018-06-22  Andre Vieira  <andre.simoesdiasvieira@arm.com>
+
+	Backport from mainline
+	2018-05-17  Jerome Lambourg  <lambourg@adacore.com>
+
+	* config/arm/cmse.c (cmse_check_address_range): Replace
+	UINTPTR_MAX with __UINTPTR_MAX__ and uintptr_t with __UINTPTR_TYPE__.
+
+2018-04-02  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline
+	2018-03-29  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR target/85100
+	* config/i386/cpuinfo.c (XCR_XFEATURE_ENABLED_MASK): New.
+	(XSTATE_FP): Likewise.
+	(XSTATE_SSE): Likewise.
+	(XSTATE_YMM): Likewise.
+	(XSTATE_OPMASK): Likewise.
+	(XSTATE_ZMM): Likewise.
+	(XSTATE_HI_ZMM): Likewise.
+	(XCR_AVX_ENABLED_MASK): Likewise.
+	(XCR_AVX512F_ENABLED_MASK): Likewise.
+	(get_available_features): Enable AVX and AVX512 features only
+	if their states are supported by OSXSAVE.
+
+2018-03-11  John David Anglin  <danglin@gcc.gnu.org>
+
+	Backport from mainline
+	2018-03-06  John David Anglin  <danglin@gcc.gnu.org>
+
+	* config/pa/fptr.c (_dl_read_access_allowed): New.
+	(__canonicalize_funcptr_for_compare): Use it.
+	
+2018-02-20  Max Filippov  <jcmvbkbc@gmail.com>
+
+	Backport from mainline
+	2018-02-20  Max Filippov  <jcmvbkbc@gmail.com>
+
+	* config/xtensa/ieee754-df.S (__adddf3_aux): Add
+	.literal_position directive.
+	* config/xtensa/ieee754-sf.S (__addsf3_aux): Likewise.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
diff --git a/libgcc/config/arm/cmse.c b/libgcc/config/arm/cmse.c
index 4ef7102064e..e284bae4293 100644
--- a/libgcc/config/arm/cmse.c
+++ b/libgcc/config/arm/cmse.c
@@ -36,7 +36,7 @@ cmse_check_address_range (void *p, size_t size, int flags)
   char *pb = (char *) p, *pe;
 
   /* Check if the range wraps around.  */
-  if (UINTPTR_MAX - (uintptr_t) p < size)
+  if (__UINTPTR_MAX__ - (__UINTPTR_TYPE__) p < size)
     return NULL;
 
   /* Check if an unknown flag is present.  */
@@ -51,7 +51,8 @@ cmse_check_address_range (void *p, size_t size, int flags)
 
   /* Execute the right variant of the TT instructions.  */
   pe = pb + size - 1;
-  const int singleCheck = (((uintptr_t) pb ^ (uintptr_t) pe) < 32);
+  const int singleCheck
+    = (((__UINTPTR_TYPE__) pb ^ (__UINTPTR_TYPE__) pe) < 32);
   switch (flags & known_secure_level)
     {
     case 0:
diff --git a/libgcc/config/i386/cpuinfo.c b/libgcc/config/i386/cpuinfo.c
index a1dc011525f..29a1f80b1ad 100644
--- a/libgcc/config/i386/cpuinfo.c
+++ b/libgcc/config/i386/cpuinfo.c
@@ -220,6 +220,40 @@ get_available_features (unsigned int ecx, unsigned int edx,
 
   unsigned int features = 0;
 
+  /* Get XCR_XFEATURE_ENABLED_MASK register with xgetbv.  */
+#define XCR_XFEATURE_ENABLED_MASK	0x0
+#define XSTATE_FP			0x1
+#define XSTATE_SSE			0x2
+#define XSTATE_YMM			0x4
+#define XSTATE_OPMASK			0x20
+#define XSTATE_ZMM			0x40
+#define XSTATE_HI_ZMM			0x80
+
+#define XCR_AVX_ENABLED_MASK \
+  (XSTATE_SSE | XSTATE_YMM)
+#define XCR_AVX512F_ENABLED_MASK \
+  (XSTATE_SSE | XSTATE_YMM | XSTATE_OPMASK | XSTATE_ZMM | XSTATE_HI_ZMM)
+
+  /* Check if AVX and AVX512 are usable.  */
+  int avx_usable = 0;
+  int avx512_usable = 0;
+  if ((ecx & bit_OSXSAVE))
+    {
+      /* Check if XMM, YMM, OPMASK, upper 256 bits of ZMM0-ZMM15 and
+         ZMM16-ZMM31 states are supported by OSXSAVE.  */
+      unsigned int xcrlow;
+      unsigned int xcrhigh;
+      asm (".byte 0x0f, 0x01, 0xd0"
+	   : "=a" (xcrlow), "=d" (xcrhigh)
+	   : "c" (XCR_XFEATURE_ENABLED_MASK));
+      if ((xcrlow & XCR_AVX_ENABLED_MASK) == XCR_AVX_ENABLED_MASK)
+	{
+	  avx_usable = 1;
+	  avx512_usable = ((xcrlow & XCR_AVX512F_ENABLED_MASK)
+			   == XCR_AVX512F_ENABLED_MASK);
+	}
+    }
+
   if (edx & bit_CMOV)
     features |= (1 << FEATURE_CMOV);
   if (edx & bit_MMX)
@@ -242,10 +276,13 @@ get_available_features (unsigned int ecx, unsigned int edx,
     features |= (1 << FEATURE_SSE4_1);
   if (ecx & bit_SSE4_2)
     features |= (1 << FEATURE_SSE4_2);
-  if (ecx & bit_AVX)
-    features |= (1 << FEATURE_AVX);
-  if (ecx & bit_FMA)
-    features |= (1 << FEATURE_FMA);
+  if (avx_usable)
+    {
+      if (ecx & bit_AVX)
+	features |= (1 << FEATURE_AVX);
+      if (ecx & bit_FMA)
+	features |= (1 << FEATURE_FMA);
+    }
 
   /* Get Advanced Features at level 7 (eax = 7, ecx = 0). */
   if (max_cpuid_level >= 7)
@@ -253,34 +290,40 @@ get_available_features (unsigned int ecx, unsigned int edx,
       __cpuid_count (7, 0, eax, ebx, ecx, edx);
       if (ebx & bit_BMI)
         features |= (1 << FEATURE_BMI);
-      if (ebx & bit_AVX2)
-	features |= (1 << FEATURE_AVX2);
+      if (avx_usable)
+	{
+	  if (ebx & bit_AVX2)
+	    features |= (1 << FEATURE_AVX2);
+	}
       if (ebx & bit_BMI2)
         features |= (1 << FEATURE_BMI2);
-      if (ebx & bit_AVX512F)
-	features |= (1 << FEATURE_AVX512F);
-      if (ebx & bit_AVX512VL)
-	features |= (1 << FEATURE_AVX512VL);
-      if (ebx & bit_AVX512BW)
-	features |= (1 << FEATURE_AVX512BW);
-      if (ebx & bit_AVX512DQ)
-	features |= (1 << FEATURE_AVX512DQ);
-      if (ebx & bit_AVX512CD)
-	features |= (1 << FEATURE_AVX512CD);
-      if (ebx & bit_AVX512PF)
-	features |= (1 << FEATURE_AVX512PF);
-      if (ebx & bit_AVX512ER)
-	features |= (1 << FEATURE_AVX512ER);
-      if (ebx & bit_AVX512IFMA)
-	features |= (1 << FEATURE_AVX512IFMA);
-      if (ecx & bit_AVX512VBMI)
-	features |= (1 << FEATURE_AVX512VBMI);
-      if (ecx & bit_AVX512VPOPCNTDQ)
-	features |= (1 << FEATURE_AVX512VPOPCNTDQ);
-      if (edx & bit_AVX5124VNNIW)
-	features |= (1 << FEATURE_AVX5124VNNIW);
-      if (edx & bit_AVX5124FMAPS)
-	features |= (1 << FEATURE_AVX5124FMAPS);
+      if (avx512_usable)
+	{
+	  if (ebx & bit_AVX512F)
+	    features |= (1 << FEATURE_AVX512F);
+	  if (ebx & bit_AVX512VL)
+	    features |= (1 << FEATURE_AVX512VL);
+	  if (ebx & bit_AVX512BW)
+	    features |= (1 << FEATURE_AVX512BW);
+	  if (ebx & bit_AVX512DQ)
+	    features |= (1 << FEATURE_AVX512DQ);
+	  if (ebx & bit_AVX512CD)
+	    features |= (1 << FEATURE_AVX512CD);
+	  if (ebx & bit_AVX512PF)
+	    features |= (1 << FEATURE_AVX512PF);
+	  if (ebx & bit_AVX512ER)
+	    features |= (1 << FEATURE_AVX512ER);
+	  if (ebx & bit_AVX512IFMA)
+	    features |= (1 << FEATURE_AVX512IFMA);
+	  if (ecx & bit_AVX512VBMI)
+	    features |= (1 << FEATURE_AVX512VBMI);
+	  if (ecx & bit_AVX512VPOPCNTDQ)
+	    features |= (1 << FEATURE_AVX512VPOPCNTDQ);
+	  if (edx & bit_AVX5124VNNIW)
+	    features |= (1 << FEATURE_AVX5124VNNIW);
+	  if (edx & bit_AVX5124FMAPS)
+	    features |= (1 << FEATURE_AVX5124FMAPS);
+	}
     }
 
   /* Check cpuid level of extended features.  */
@@ -292,10 +335,13 @@ get_available_features (unsigned int ecx, unsigned int edx,
 
       if (ecx & bit_SSE4a)
 	features |= (1 << FEATURE_SSE4_A);
-      if (ecx & bit_FMA4)
-	features |= (1 << FEATURE_FMA4);
-      if (ecx & bit_XOP)
-	features |= (1 << FEATURE_XOP);
+      if (avx_usable)
+	{
+	  if (ecx & bit_FMA4)
+	    features |= (1 << FEATURE_FMA4);
+	  if (ecx & bit_XOP)
+	    features |= (1 << FEATURE_XOP);
+	}
     }
     
   __cpu_model.__cpu_features[0] = features;
diff --git a/libgcc/config/libbid/ChangeLog b/libgcc/config/libbid/ChangeLog
index 3d38f5fde4a..8e3fd557305 100644
--- a/libgcc/config/libbid/ChangeLog
+++ b/libgcc/config/libbid/ChangeLog
@@ -1,3 +1,7 @@
+2018-12-06  Release Manager
+
+	* GCC 7.4.0 released.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
diff --git a/libgcc/config/pa/fptr.c b/libgcc/config/pa/fptr.c
index 645fa5d833a..e145026df3e 100644
--- a/libgcc/config/pa/fptr.c
+++ b/libgcc/config/pa/fptr.c
@@ -52,6 +52,16 @@ typedef int (*fptr_t) (void);
 typedef int (*fixup_t) (struct link_map *, unsigned int);
 extern unsigned int _GLOBAL_OFFSET_TABLE_;
 
+static inline int
+_dl_read_access_allowed (unsigned int *addr)
+{
+  int result;
+
+  asm ("proberi (%1),3,%0" : "=r" (result) : "r" (addr) : );
+
+  return result;
+}
+
 /* __canonicalize_funcptr_for_compare must be hidden so that it is not
    placed in the dynamic symbol table.  Like millicode functions, it
    must be linked into all binaries in order access the got table of 
@@ -82,6 +92,16 @@ __canonicalize_funcptr_for_compare (fptr_t fptr)
      The second word in the plabel contains the relocation offset for the
      function.  */
   plabel = (unsigned int *) ((unsigned int) fptr & ~3);
+  if (!_dl_read_access_allowed (plabel))
+    return (unsigned int) fptr;
+
+  /* Load first word of candidate descriptor.  It should be a pointer
+     with word alignment and point to memory that can be read.  */
+  got = (unsigned int *) plabel[0];
+  if (((unsigned int) got & 3) != 0
+      || !_dl_read_access_allowed (got))
+    return (unsigned int) fptr;
+
   got = (unsigned int *) (plabel[0] + GOT_FROM_PLT_STUB);
 
   /* Return the address of the function if the plabel has been resolved.  */
diff --git a/libgcc/config/pa/linux-atomic.c b/libgcc/config/pa/linux-atomic.c
index e4cdb1fa25d..0e4262c69e8 100644
--- a/libgcc/config/pa/linux-atomic.c
+++ b/libgcc/config/pa/linux-atomic.c
@@ -28,14 +28,9 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 #define EBUSY   16
 #define ENOSYS 251 
 
-/* All PA-RISC implementations supported by linux have strongly
-   ordered loads and stores.  Only cache flushes and purges can be
-   delayed.  The data cache implementations are all globally
-   coherent.  Thus, there is no need to synchonize memory accesses.
-
-   GCC automatically issues a asm memory barrier when it encounters
-   a __sync_synchronize builtin.  Thus, we do not need to define this
-   builtin.
+/* PA-RISC 2.0 supports out-of-order execution for loads and stores.
+   Thus, we need to synchonize memory accesses.  For more info, see:
+   "Advanced Performance Features of the 64-bit PA-8000" by Doug Hunt.
 
    We implement byte, short and int versions of each atomic operation
    using the kernel helper defined below.  There is no support for
@@ -119,7 +114,7 @@ __kernel_cmpxchg2 (void *mem, const void *oldval, const void *newval,
     long failure;							\
 									\
     do {								\
-      tmp = __atomic_load_n (ptr, __ATOMIC_SEQ_CST);			\
+      tmp = __atomic_load_n (ptr, __ATOMIC_RELAXED);			\
       newval = PFX_OP (tmp INF_OP val);					\
       failure = __kernel_cmpxchg2 (ptr, &tmp, &newval, INDEX);		\
     } while (failure != 0);						\
@@ -156,7 +151,7 @@ FETCH_AND_OP_2 (nand, ~, &, signed char, 1, 0)
     long failure;							\
 									\
     do {								\
-      tmp = __atomic_load_n (ptr, __ATOMIC_SEQ_CST);			\
+      tmp = __atomic_load_n (ptr, __ATOMIC_RELAXED);			\
       newval = PFX_OP (tmp INF_OP val);					\
       failure = __kernel_cmpxchg2 (ptr, &tmp, &newval, INDEX);		\
     } while (failure != 0);						\
@@ -193,7 +188,7 @@ OP_AND_FETCH_2 (nand, ~, &, signed char, 1, 0)
     long failure;							\
 									\
     do {								\
-      tmp = __atomic_load_n (ptr, __ATOMIC_SEQ_CST);			\
+      tmp = __atomic_load_n (ptr, __ATOMIC_RELAXED);			\
       failure = __kernel_cmpxchg (ptr, tmp, PFX_OP (tmp INF_OP val));	\
     } while (failure != 0);						\
 									\
@@ -215,7 +210,7 @@ FETCH_AND_OP_WORD (nand, ~, &)
     long failure;							\
 									\
     do {								\
-      tmp = __atomic_load_n (ptr, __ATOMIC_SEQ_CST);			\
+      tmp = __atomic_load_n (ptr, __ATOMIC_RELAXED);			\
       failure = __kernel_cmpxchg (ptr, tmp, PFX_OP (tmp INF_OP val));	\
     } while (failure != 0);						\
 									\
@@ -241,7 +236,7 @@ typedef unsigned char bool;
 									\
     while (1)								\
       {									\
-	actual_oldval = __atomic_load_n (ptr, __ATOMIC_SEQ_CST);	\
+	actual_oldval = __atomic_load_n (ptr, __ATOMIC_RELAXED);	\
 									\
 	if (__builtin_expect (oldval != actual_oldval, 0))		\
 	  return actual_oldval;						\
@@ -273,7 +268,7 @@ __sync_val_compare_and_swap_4 (int *ptr, int oldval, int newval)
     
   while (1)
     {
-      actual_oldval = __atomic_load_n (ptr, __ATOMIC_SEQ_CST);
+      actual_oldval = __atomic_load_n (ptr, __ATOMIC_RELAXED);
 
       if (__builtin_expect (oldval != actual_oldval, 0))
 	return actual_oldval;
@@ -300,7 +295,7 @@ TYPE HIDDEN								\
     long failure;							\
 									\
     do {								\
-      oldval = __atomic_load_n (ptr, __ATOMIC_SEQ_CST);			\
+      oldval = __atomic_load_n (ptr, __ATOMIC_RELAXED);			\
       failure = __kernel_cmpxchg2 (ptr, &oldval, &val, INDEX);		\
     } while (failure != 0);						\
 									\
@@ -318,38 +313,31 @@ __sync_lock_test_and_set_4 (int *ptr, int val)
   int oldval;
 
   do {
-    oldval = __atomic_load_n (ptr, __ATOMIC_SEQ_CST);
+    oldval = __atomic_load_n (ptr, __ATOMIC_RELAXED);
     failure = __kernel_cmpxchg (ptr, oldval, val);
   } while (failure != 0);
 
   return oldval;
 }
 
-#define SYNC_LOCK_RELEASE_2(TYPE, WIDTH, INDEX)			\
+void HIDDEN
+__sync_lock_release_8 (long long *ptr)
+{
+  /* All accesses must be complete before we release the lock.  */
+  __sync_synchronize ();
+  *(double *)ptr = 0;
+}
+
+#define SYNC_LOCK_RELEASE_1(TYPE, WIDTH)			\
   void HIDDEN							\
   __sync_lock_release_##WIDTH (TYPE *ptr)			\
   {								\
-    TYPE oldval, zero = 0;					\
-    long failure;						\
-								\
-    do {							\
-      oldval = __atomic_load_n (ptr, __ATOMIC_SEQ_CST);		\
-      failure = __kernel_cmpxchg2 (ptr, &oldval, &zero, INDEX);	\
-    } while (failure != 0);					\
+    /* All accesses must be complete before we release		\
+       the lock.  */						\
+    __sync_synchronize ();					\
+    *ptr = 0;							\
   }
 
-SYNC_LOCK_RELEASE_2 (long long, 8, 3)
-SYNC_LOCK_RELEASE_2 (short, 2, 1)
-SYNC_LOCK_RELEASE_2 (signed char, 1, 0)
-
-void HIDDEN
-__sync_lock_release_4 (int *ptr)
-{
-  long failure;
-  int oldval;
-
-  do {
-    oldval = __atomic_load_n (ptr, __ATOMIC_SEQ_CST);
-    failure = __kernel_cmpxchg (ptr, oldval, 0);
-  } while (failure != 0);
-}
+SYNC_LOCK_RELEASE_1 (int, 4)
+SYNC_LOCK_RELEASE_1 (short, 2)
+SYNC_LOCK_RELEASE_1 (signed char, 1)
diff --git a/libgcc/config/xtensa/ieee754-df.S b/libgcc/config/xtensa/ieee754-df.S
index 8493dc0372f..73fa55c7b90 100644
--- a/libgcc/config/xtensa/ieee754-df.S
+++ b/libgcc/config/xtensa/ieee754-df.S
@@ -55,6 +55,7 @@ __negdf2:
 
 #ifdef L_addsubdf3
 
+	.literal_position
 	/* Addition */
 __adddf3_aux:
 	
diff --git a/libgcc/config/xtensa/ieee754-sf.S b/libgcc/config/xtensa/ieee754-sf.S
index 1db8e01b9cc..c3bf98fa9e1 100644
--- a/libgcc/config/xtensa/ieee754-sf.S
+++ b/libgcc/config/xtensa/ieee754-sf.S
@@ -55,6 +55,7 @@ __negsf2:
 
 #ifdef L_addsubsf3
 
+	.literal_position
 	/* Addition */
 __addsf3_aux:
 
diff --git a/libgcc/configure b/libgcc/configure
index 9a7eb8446bb..441601a1f76 100644
--- a/libgcc/configure
+++ b/libgcc/configure
@@ -5298,7 +5298,7 @@ esac
 # Check whether --with-gcc-major-version-only was given.
 if test "${with_gcc_major_version_only+set}" = set; then :
   withval=$with_gcc_major_version_only; if test x$with_gcc_major_version_only = xyes ; then
-        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*\$\$/\1/'"
+        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*/\1/'"
       fi
 
 fi
diff --git a/libgfortran/ChangeLog b/libgfortran/ChangeLog
index 370f08f546a..5ead90f9e4c 100644
--- a/libgfortran/ChangeLog
+++ b/libgfortran/ChangeLog
@@ -1,3 +1,89 @@
+2019-04-16  John David Anglin  <danglin@gcc.gnu.org>
+
+	Backport from mainline
+	2019-03-25  John David Anglin  <danglin@gcc.gnu.org>
+
+	PR libgfortran/79540
+	* io/write_float.def (build_float_string): Don't copy digits when
+	ndigits is negative.
+
+2019-02-03  Uroš Bizjak  <ubizjak@gmail.com>
+
+	PR libfortran/88678
+	Revert:
+	2016-11-16  Szabolcs Nagy  <szabolcs.nagy@arm.com>
+
+	PR libfortran/78314
+	* config/fpu-glibc.h (support_fpu_trap): Use feenableexcept.
+
+2019-02-03  Uroš Bizjak  <ubizjak@gmail.com>
+
+	PR libfortran/88678
+	* config/fpu-glibc.h (set_fpu_trap_exceptions): Clear stalled
+	exception flags before changing trap mode.  Optimize to call
+	feenableexcept and fedisableexcept only once.
+
+2019-01-13  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	PR libfortran/88776
+	* io/list_read.c (namelist_read): Use nml_err_ret path on read error
+	not based on stdin_unit.
+	* io/open.c (newunit): Free format buffer if the unit specified is for
+	stdin, stdout, or stderr.
+
+2018-12-06  Janne Blomqvist  <jb@gcc.gnu.org>
+
+	Backport from trunk
+	PR libfortran/88137
+	* runtime/backtrace.c (show_backtrace): Store backtrace state in a
+	static variable, initialize once.
+
+2018-12-06  Release Manager
+
+	* GCC 7.4.0 released.
+
+2018-10-13  Gerald Pfeifer  <gerald@pfeifer.com>
+
+	Backport from trunk
+	* io/close.c [!HAVE_UNLINK_OPEN_FILE]: Include <string.h>.
+
+2018-09-18  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backport from trunk
+	2018-09-14  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	* io/unix.c (fallback_access): Avoid calling close on
+	uninitialized file descriptor.
+
+2018-06-22  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-04-18  David Malcolm  <dmalcolm@redhat.com>
+
+	PR jit/85384
+	* configure: Regenerate.
+
+2018-06-09  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	Backport from trunk.
+	PR libgfortran/86070
+	* io/write_float.def (build_float_string): Initialize *len.
+
+2018-06-01  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	Backport from trunk.
+	PR libgfortran/85840
+	* io/write.c (write_float_0, write_real, write_real_g0,
+	write_complex): Use separate local variables for the float
+	string length.
+
+2018-02-18  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	Backport from trunk
+	PR libgfortran/84412
+	* io/transfer.c (finalize_transfer): After completng an internal unit
+	I/O operation, clear internal_unit_kind.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
diff --git a/libgfortran/config/fpu-glibc.h b/libgfortran/config/fpu-glibc.h
index a00a153be79..2f076be6587 100644
--- a/libgfortran/config/fpu-glibc.h
+++ b/libgfortran/config/fpu-glibc.h
@@ -39,48 +39,56 @@ _Static_assert (sizeof(fenv_t) <= (size_t) GFC_FPE_STATE_BUFFER_SIZE,
 
 void set_fpu_trap_exceptions (int trap, int notrap)
 {
+  int mode_set = 0, mode_clr = 0;
+
 #ifdef FE_INVALID
   if (trap & GFC_FPE_INVALID)
-    feenableexcept (FE_INVALID);
+    mode_set |= FE_INVALID;
   if (notrap & GFC_FPE_INVALID)
-    fedisableexcept (FE_INVALID);
+    mode_clr |= FE_INVALID;
 #endif
 
 /* Some glibc targets (like alpha) have FE_DENORMAL, but not many.  */
 #ifdef FE_DENORMAL
   if (trap & GFC_FPE_DENORMAL)
-    feenableexcept (FE_DENORMAL);
+    mode_set |= FE_DENORMAL;
   if (notrap & GFC_FPE_DENORMAL)
-    fedisableexcept (FE_DENORMAL);
+    mode_clr |= FE_DENORMAL;
 #endif
 
 #ifdef FE_DIVBYZERO
   if (trap & GFC_FPE_ZERO)
-    feenableexcept (FE_DIVBYZERO);
+    mode_set |= FE_DIVBYZERO;
   if (notrap & GFC_FPE_ZERO)
-    fedisableexcept (FE_DIVBYZERO);
+    mode_clr |= FE_DIVBYZERO;
 #endif
 
 #ifdef FE_OVERFLOW
   if (trap & GFC_FPE_OVERFLOW)
-    feenableexcept (FE_OVERFLOW);
+    mode_set |= FE_OVERFLOW;
   if (notrap & GFC_FPE_OVERFLOW)
-    fedisableexcept (FE_OVERFLOW);
+    mode_clr |= FE_OVERFLOW;
 #endif
 
 #ifdef FE_UNDERFLOW
   if (trap & GFC_FPE_UNDERFLOW)
-    feenableexcept (FE_UNDERFLOW);
+    mode_set |= FE_UNDERFLOW;
   if (notrap & GFC_FPE_UNDERFLOW)
-    fedisableexcept (FE_UNDERFLOW);
+    mode_clr |= FE_UNDERFLOW;
 #endif
 
 #ifdef FE_INEXACT
   if (trap & GFC_FPE_INEXACT)
-    feenableexcept (FE_INEXACT);
+    mode_set |= FE_INEXACT;
   if (notrap & GFC_FPE_INEXACT)
-    fedisableexcept (FE_INEXACT);
+    mode_clr |= FE_INEXACT;
 #endif
+
+  /* Clear stalled exception flags.  */
+  feclearexcept (FE_ALL_EXCEPT);
+
+  feenableexcept (mode_set);
+  fedisableexcept (mode_clr);
 }
 
 
@@ -121,41 +129,7 @@ get_fpu_trap_exceptions (void)
 int
 support_fpu_trap (int flag)
 {
-  int exceptions = 0;
-  int old;
-
-  if (!support_fpu_flag (flag))
-    return 0;
-
-#ifdef FE_INVALID
-  if (flag & GFC_FPE_INVALID) exceptions |= FE_INVALID;
-#endif
-
-#ifdef FE_DIVBYZERO
-  if (flag & GFC_FPE_ZERO) exceptions |= FE_DIVBYZERO;
-#endif
-
-#ifdef FE_OVERFLOW
-  if (flag & GFC_FPE_OVERFLOW) exceptions |= FE_OVERFLOW;
-#endif
-
-#ifdef FE_UNDERFLOW
-  if (flag & GFC_FPE_UNDERFLOW) exceptions |= FE_UNDERFLOW;
-#endif
-
-#ifdef FE_DENORMAL
-  if (flag & GFC_FPE_DENORMAL) exceptions |= FE_DENORMAL;
-#endif
-
-#ifdef FE_INEXACT
-  if (flag & GFC_FPE_INEXACT) exceptions |= FE_INEXACT;
-#endif
-
-  old = feenableexcept (exceptions);
-  if (old == -1)
-    return 0;
-  fedisableexcept (exceptions & ~old);
-  return 1;
+  return support_fpu_flag (flag);
 }
 
 
diff --git a/libgfortran/configure b/libgfortran/configure
index 81238fcb79c..1db8f5f5224 100755
--- a/libgfortran/configure
+++ b/libgfortran/configure
@@ -26370,7 +26370,7 @@ rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
 # Check whether --with-gcc-major-version-only was given.
 if test "${with_gcc_major_version_only+set}" = set; then :
   withval=$with_gcc_major_version_only; if test x$with_gcc_major_version_only = xyes ; then
-        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*\$\$/\1/'"
+        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*/\1/'"
       fi
 
 fi
diff --git a/libgfortran/io/close.c b/libgfortran/io/close.c
index e40fd92b8bf..3bf96cd57ae 100644
--- a/libgfortran/io/close.c
+++ b/libgfortran/io/close.c
@@ -25,6 +25,9 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 #include "io.h"
 #include "unix.h"
 #include <limits.h>
+#if !HAVE_UNLINK_OPEN_FILE
+#include <string.h>
+#endif
 
 typedef enum
 { CLOSE_DELETE, CLOSE_KEEP, CLOSE_UNSPECIFIED }
diff --git a/libgfortran/io/list_read.c b/libgfortran/io/list_read.c
index f907818f379..dd8a9ffa573 100644
--- a/libgfortran/io/list_read.c
+++ b/libgfortran/io/list_read.c
@@ -3613,11 +3613,7 @@ find_nml_name:
   while (!dtp->u.p.input_complete)
     {
       if (!nml_get_obj_data (dtp, &prev_nl, nml_err_msg, sizeof nml_err_msg))
-	{
-	  if (dtp->u.p.current_unit->unit_number != options.stdin_unit)
-	    goto nml_err_ret;
-	  generate_error (&dtp->common, LIBERROR_READ_VALUE, nml_err_msg);
-        }
+	goto nml_err_ret;
 
       /* Reset the previous namelist pointer if we know we are not going
 	 to be doing multiple reads within a single namelist object.  */
diff --git a/libgfortran/io/open.c b/libgfortran/io/open.c
index 9d3988a7c21..158ae69548d 100644
--- a/libgfortran/io/open.c
+++ b/libgfortran/io/open.c
@@ -529,6 +529,14 @@ new_unit (st_parameter_open *opp, gfc_unit *u, unit_flags *flags)
   if (u2 != NULL)
     unlock_unit (u2);
 
+  /* If the unit specified is preconnected with a file specified to be open,
+     then clear the format buffer.  */
+  if ((opp->common.unit == options.stdin_unit ||
+       opp->common.unit == options.stdout_unit ||
+       opp->common.unit == options.stderr_unit)
+      && (opp->common.flags & IOPARM_OPEN_HAS_FILE) != 0)
+    fbuf_destroy (u);
+
   /* Open file.  */
 
   s = open_external (opp, flags);
diff --git a/libgfortran/io/transfer.c b/libgfortran/io/transfer.c
index 7d270fb8b36..5565188358b 100644
--- a/libgfortran/io/transfer.c
+++ b/libgfortran/io/transfer.c
@@ -3987,6 +3987,10 @@ finalize_transfer (st_parameter_dt *dtp)
 
   if (dtp->u.p.unit_is_internal)
     {
+      /* The unit structure may be reused later so clear the
+	 internal unit kind.  */
+      dtp->u.p.current_unit->internal_unit_kind = 0;
+
       fbuf_destroy (dtp->u.p.current_unit);
       if (dtp->u.p.current_unit
 	  && (dtp->u.p.current_unit->child_dtio  == 0)
diff --git a/libgfortran/io/unix.c b/libgfortran/io/unix.c
index bb9bc9a5c12..993797e6d1f 100644
--- a/libgfortran/io/unix.c
+++ b/libgfortran/io/unix.c
@@ -149,13 +149,21 @@ fallback_access (const char *path, int mode)
 {
   int fd;
 
-  if ((mode & R_OK) && (fd = open (path, O_RDONLY)) < 0)
-    return -1;
-  close (fd);
+  if (mode & R_OK)
+    {
+      if ((fd = open (path, O_RDONLY)) < 0)
+	return -1;
+      else
+	close (fd);
+    }
 
-  if ((mode & W_OK) && (fd = open (path, O_WRONLY)) < 0)
-    return -1;
-  close (fd);
+  if (mode & W_OK)
+    {
+      if ((fd = open (path, O_WRONLY)) < 0)
+	return -1;
+      else
+	close (fd);
+    }
 
   if (mode == F_OK)
     {
diff --git a/libgfortran/io/write.c b/libgfortran/io/write.c
index a7307a8f762..70af7703b7e 100644
--- a/libgfortran/io/write.c
+++ b/libgfortran/io/write.c
@@ -1483,7 +1483,7 @@ write_character (st_parameter_dt *dtp, const char *source, int kind, int length,
 
 /* Floating point helper functions.  */
 
-#define BUF_STACK_SZ 256
+#define BUF_STACK_SZ 384
 
 static int
 get_precision (st_parameter_dt *dtp, const fnode *f, const char *source, int kind)
@@ -1584,7 +1584,7 @@ write_float_0 (st_parameter_dt *dtp, const fnode *f, const char *source, int kin
   char buf_stack[BUF_STACK_SZ];
   char str_buf[BUF_STACK_SZ];
   char *buffer, *result;
-  size_t buf_size, res_len;
+  size_t buf_size, res_len, flt_str_len;
 
   /* Precision for snprintf call.  */
   int precision = get_precision (dtp, f, source, kind);
@@ -1595,8 +1595,8 @@ write_float_0 (st_parameter_dt *dtp, const fnode *f, const char *source, int kin
   buffer = select_buffer (dtp, f, precision, buf_stack, &buf_size, kind);
   
   get_float_string (dtp, f, source , kind, 0, buffer,
-                           precision, buf_size, result, &res_len);
-  write_float_string (dtp, result, res_len);
+                           precision, buf_size, result, &flt_str_len);
+  write_float_string (dtp, result, flt_str_len);
 
   if (buf_size > BUF_STACK_SZ)
     free (buffer);
@@ -1699,7 +1699,7 @@ write_real (st_parameter_dt *dtp, const char *source, int kind)
   char buf_stack[BUF_STACK_SZ];
   char str_buf[BUF_STACK_SZ];
   char *buffer, *result;
-  size_t buf_size, res_len;
+  size_t buf_size, res_len, flt_str_len;
   int orig_scale = dtp->u.p.scale_factor;
   dtp->u.p.scale_factor = 1;
   set_fnode_default (dtp, &f, kind);
@@ -1714,8 +1714,8 @@ write_real (st_parameter_dt *dtp, const char *source, int kind)
   buffer = select_buffer (dtp, &f, precision, buf_stack, &buf_size, kind);
   
   get_float_string (dtp, &f, source , kind, 1, buffer,
-                           precision, buf_size, result, &res_len);
-  write_float_string (dtp, result, res_len);
+                           precision, buf_size, result, &flt_str_len);
+  write_float_string (dtp, result, flt_str_len);
 
   dtp->u.p.scale_factor = orig_scale;
   if (buf_size > BUF_STACK_SZ)
@@ -1734,7 +1734,7 @@ write_real_g0 (st_parameter_dt *dtp, const char *source, int kind, int d)
   char buf_stack[BUF_STACK_SZ];
   char str_buf[BUF_STACK_SZ];
   char *buffer, *result;
-  size_t buf_size, res_len;
+  size_t buf_size, res_len, flt_str_len;
   int comp_d;
   set_fnode_default (dtp, &f, kind);
 
@@ -1758,8 +1758,8 @@ write_real_g0 (st_parameter_dt *dtp, const char *source, int kind, int d)
   buffer = select_buffer (dtp, &f, precision, buf_stack, &buf_size, kind);
 
   get_float_string (dtp, &f, source , kind, comp_d, buffer,
-                           precision, buf_size, result, &res_len);
-  write_float_string (dtp, result, res_len);
+                           precision, buf_size, result, &flt_str_len);
+  write_float_string (dtp, result, flt_str_len);
 
   dtp->u.p.g0_no_blanks = 0;
   if (buf_size > BUF_STACK_SZ)
@@ -1784,7 +1784,7 @@ write_complex (st_parameter_dt *dtp, const char *source, int kind, size_t size)
   char str1_buf[BUF_STACK_SZ];
   char str2_buf[BUF_STACK_SZ];
   char *buffer, *result1, *result2;
-  size_t buf_size, res_len1, res_len2;
+  size_t buf_size, res_len1, res_len2, flt_str_len1, flt_str_len2;
   int width, lblanks, orig_scale = dtp->u.p.scale_factor;
 
   dtp->u.p.scale_factor = 1;
@@ -1807,18 +1807,18 @@ write_complex (st_parameter_dt *dtp, const char *source, int kind, size_t size)
   buffer = select_buffer (dtp, &f, precision, buf_stack, &buf_size, kind);
 
   get_float_string (dtp, &f, source , kind, 0, buffer,
-                           precision, buf_size, result1, &res_len1);
+                           precision, buf_size, result1, &flt_str_len1);
   get_float_string (dtp, &f, source + size / 2 , kind, 0, buffer,
-                           precision, buf_size, result2, &res_len2);
+                           precision, buf_size, result2, &flt_str_len2);
   if (!dtp->u.p.namelist_mode)
     {
-      lblanks = width - res_len1 - res_len2 - 3;
+      lblanks = width - flt_str_len1 - flt_str_len2 - 3;
       write_x (dtp, lblanks, lblanks);
     }
   write_char (dtp, '(');
-  write_float_string (dtp, result1, res_len1);
+  write_float_string (dtp, result1, flt_str_len1);
   write_char (dtp, semi_comma);
-  write_float_string (dtp, result2, res_len2);
+  write_float_string (dtp, result2, flt_str_len2);
   write_char (dtp, ')');
 
   dtp->u.p.scale_factor = orig_scale;
diff --git a/libgfortran/io/write_float.def b/libgfortran/io/write_float.def
index 7f0aa1d6143..e303f7d73a8 100644
--- a/libgfortran/io/write_float.def
+++ b/libgfortran/io/write_float.def
@@ -135,6 +135,7 @@ build_float_string (st_parameter_dt *dtp, const fnode *f, char *buffer,
   w = f->u.real.w;
   d = f->u.real.d;
   p = dtp->u.p.scale_factor;
+  *len = 0;
 
   rchar = '5';
 
@@ -619,14 +620,15 @@ build_float_string (st_parameter_dt *dtp, const fnode *f, char *buffer,
     }
 
   /* Set digits after the decimal point, padding with zeros.  */
-  if (nafter > 0)
+  if (ndigits >= 0 && nafter > 0)
     {
       if (nafter > ndigits)
 	i = ndigits;
       else
 	i = nafter;
 
-      memcpy (put, digits, i);
+      if (i > 0)
+	memcpy (put, digits, i);
       while (i < nafter)
 	put[i++] = '0';
 
diff --git a/libgfortran/runtime/backtrace.c b/libgfortran/runtime/backtrace.c
index 77dd4d5f0ac..d7e72c80460 100644
--- a/libgfortran/runtime/backtrace.c
+++ b/libgfortran/runtime/backtrace.c
@@ -135,14 +135,23 @@ full_callback (void *data, uintptr_t pc, const char *filename,
 void
 show_backtrace (bool in_signal_handler)
 {
+  /* Note that libbacktrace allows the state to be accessed from
+     multiple threads, so we don't need to use a TLS variable for the
+     state here.  */
+  static struct backtrace_state *lbstate_saved;
   struct backtrace_state *lbstate;
   struct mystate state = { 0, false, in_signal_handler };
- 
-  lbstate = backtrace_create_state (NULL, __gthread_active_p (),
-				    error_callback, NULL);
 
-  if (lbstate == NULL)
-    return;
+  lbstate = __atomic_load_n (&lbstate_saved, __ATOMIC_RELAXED);
+  if (!lbstate)
+    {
+      lbstate = backtrace_create_state (NULL, __gthread_active_p (),
+					error_callback, NULL);
+      if (lbstate)
+	__atomic_store_n (&lbstate_saved, lbstate, __ATOMIC_RELAXED);
+      else
+	return;
+    }
 
   if (!BACKTRACE_SUPPORTED || (in_signal_handler && BACKTRACE_USES_MALLOC))
     {
diff --git a/libgo/config.h.in b/libgo/config.h.in
index a7b1d47ac9b..312da8b2837 100644
--- a/libgo/config.h.in
+++ b/libgo/config.h.in
@@ -340,9 +340,6 @@
 /* Define to 1 if you have the `unshare' function. */
 #undef HAVE_UNSHARE
 
-/* Define to 1 if you have the <ustat.h> header file and it works. */
-#undef HAVE_USTAT_H
-
 /* Define to 1 if you have the `utimensat' function. */
 #undef HAVE_UTIMENSAT
 
diff --git a/libgo/configure b/libgo/configure
index 1d3d714fc05..94c42f67e82 100755
--- a/libgo/configure
+++ b/libgo/configure
@@ -14784,39 +14784,6 @@ fi
 done
 
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether <ustat.h> can be used" >&5
-$as_echo_n "checking whether <ustat.h> can be used... " >&6; }
-if test "${libgo_cv_c_ustat_h+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  CFLAGS_hold=$CFLAGS
-CFLAGS="$CFLAGS -D_LARGEFILE_SOURCE -D_LARGEFILE64_SOURCE $OSCFLAGS"
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-#include <sys/types.h>
-#ifdef HAVE_LINUX_FILTER_H
-#include <linux/filter.h>
-#endif
-#include <ustat.h>
-
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-  libgo_cv_c_ustat_h=yes
-else
-  libgo_cv_c_ustat_h=no
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-CFLAGS=$CFLAGS_hold
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $libgo_cv_c_ustat_h" >&5
-$as_echo "$libgo_cv_c_ustat_h" >&6; }
-if test $libgo_cv_c_ustat_h = yes; then
-
-$as_echo "#define HAVE_USTAT_H 1" >>confdefs.h
-
-fi
-
  if test "$ac_cv_header_sys_mman_h" = yes; then
   HAVE_SYS_MMAN_H_TRUE=
   HAVE_SYS_MMAN_H_FALSE='#'
diff --git a/libgo/configure.ac b/libgo/configure.ac
index 51b2c161846..0adbadf20d4 100644
--- a/libgo/configure.ac
+++ b/libgo/configure.ac
@@ -572,24 +572,6 @@ AC_CHECK_HEADERS([linux/filter.h linux/if_addr.h linux/if_ether.h linux/if_tun.h
 #endif
 ])
 
-AC_CACHE_CHECK([whether <ustat.h> can be used],
-[libgo_cv_c_ustat_h],
-[CFLAGS_hold=$CFLAGS
-CFLAGS="$CFLAGS -D_LARGEFILE_SOURCE -D_LARGEFILE64_SOURCE $OSCFLAGS"
-AC_COMPILE_IFELSE(
-[AC_LANG_SOURCE([
-#include <sys/types.h>
-#ifdef HAVE_LINUX_FILTER_H
-#include <linux/filter.h>
-#endif
-#include <ustat.h>
-])], [libgo_cv_c_ustat_h=yes], [libgo_cv_c_ustat_h=no])
-CFLAGS=$CFLAGS_hold])
-if test $libgo_cv_c_ustat_h = yes; then
-  AC_DEFINE(HAVE_USTAT_H, 1,
-    [Define to 1 if you have the <ustat.h> header file and it works.])
-fi
-
 AM_CONDITIONAL(HAVE_SYS_MMAN_H, test "$ac_cv_header_sys_mman_h" = yes)
 
 AC_CHECK_FUNCS(strerror_r strsignal wait4 mincore setenv unsetenv dl_iterate_phdr)
diff --git a/libgo/go/os/wait_waitid.go b/libgo/go/os/wait_waitid.go
index 3337395510e..6eb487b11af 100644
--- a/libgo/go/os/wait_waitid.go
+++ b/libgo/go/os/wait_waitid.go
@@ -25,9 +25,12 @@ func (p *Process) blockUntilWaitable() (bool, error) {
 	// We don't care about the values it returns.
 	var siginfo [16]uint64
 	psig := &siginfo[0]
-	_, _, e := syscall.Syscall6(syscall.SYS_WAITID, _P_PID, uintptr(p.Pid), uintptr(unsafe.Pointer(psig)), syscall.WEXITED|syscall.WNOWAIT, 0, 0)
+	r, _, e := syscall.Syscall6(syscall.SYS_WAITID, _P_PID, uintptr(p.Pid), uintptr(unsafe.Pointer(psig)), syscall.WEXITED|syscall.WNOWAIT, 0, 0)
 	runtime.KeepAlive(p)
-	if e != 0 {
+	// Check r as well as e because syscall.Syscall6 currently
+	// just returns errno, and the SIGCHLD signal handler may
+	// change errno. See https://gcc.gnu.org/PR86331.
+	if r != 0 && e != 0 {
 		// waitid has been available since Linux 2.6.9, but
 		// reportedly is not available in Ubuntu on Windows.
 		// See issue 16610.
diff --git a/libgo/go/syscall/libcall_linux_ustat.go b/libgo/go/syscall/libcall_linux_ustat.go
deleted file mode 100644
index 261f086f47e..00000000000
--- a/libgo/go/syscall/libcall_linux_ustat.go
+++ /dev/null
@@ -1,12 +0,0 @@
-// Copyright 2015 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// GNU/Linux library ustat call.
-// This is not supported on some kernels, such as arm64.
-// +build !arm64
-
-package syscall
-
-//sys	Ustat(dev int, ubuf *Ustat_t) (err error)
-//ustat(dev _dev_t, ubuf *Ustat_t) _C_int
diff --git a/libgo/mksysinfo.sh b/libgo/mksysinfo.sh
index 61d39d7e2dd..3c2c2d2ad01 100755
--- a/libgo/mksysinfo.sh
+++ b/libgo/mksysinfo.sh
@@ -1088,7 +1088,20 @@ grep '^type _rlimit ' gen-sysinfo.go | \
 grep '^const _RLIMIT_' gen-sysinfo.go |
     sed -e 's/^\(const \)_\(RLIMIT_[^= ]*\)\(.*\)$/\1\2 = _\2/' >> ${OUT}
 grep '^const _RLIM_' gen-sysinfo.go |
+    grep -v '^const _RLIM_INFINITY ' |
     sed -e 's/^\(const \)_\(RLIM_[^= ]*\)\(.*\)$/\1\2 = _\2/' >> ${OUT}
+rliminf=""
+if test "${rlimit}" = "_rlimit64" && grep '^const _RLIM64_INFINITY ' gen-sysinfo.go > /dev/null 2>&1; then
+  rliminf=`grep '^const _RLIM64_INFINITY ' gen-sysinfo.go | sed -e 's/.* //'`
+else
+  rliminf=`grep '^const _RLIM_INFINITY ' gen-sysinfo.go | sed -e 's/.* //'`
+fi
+# For compatibility with the gc syscall package, treat 0xffffffffffffffff as -1.
+if test "$rliminf" = "0xffffffffffffffff"; then
+  echo "const RLIM_INFINITY = -1" >> ${OUT}
+elif test -n "$rliminf"; then
+  echo "const RLIM_INFINITY = $rliminf" >> ${OUT}
+fi
 
 # The sysinfo struct.
 grep '^type _sysinfo ' gen-sysinfo.go | \
@@ -1107,20 +1120,6 @@ grep '^type _sysinfo ' gen-sysinfo.go | \
       -e 's/mem_unit/Unit/' \
     >> ${OUT}
 
-# The ustat struct.
-grep '^type _ustat ' gen-sysinfo.go | \
-    sed -e 's/_ustat/Ustat_t/' \
-      -e 's/f_tfree/Tfree/' \
-      -e 's/f_tinode/Tinoe/' \
-      -e 's/f_fname/Fname/' \
-      -e 's/f_fpack/Fpack/' \
-    >> ${OUT}
-# Force it to be defined, as on some older GNU/Linux systems the
-# header file fails when using with <linux/filter.h>.
-if ! grep 'type _ustat ' gen-sysinfo.go >/dev/null 2>&1; then
-  echo 'type Ustat_t struct { Tfree int32; Tinoe uint64; Fname [5+1]int8; Fpack [5+1]int8; }' >> ${OUT}
-fi
-
 # The utimbuf struct.
 grep '^type _utimbuf ' gen-sysinfo.go | \
     sed -e 's/_utimbuf/Utimbuf/' \
diff --git a/libgo/sysinfo.c b/libgo/sysinfo.c
index a1afc7d119c..7ff721816f9 100644
--- a/libgo/sysinfo.c
+++ b/libgo/sysinfo.c
@@ -135,9 +135,6 @@
 #if defined(HAVE_SYS_SYSINFO_H)
 #include <sys/sysinfo.h>
 #endif
-#if defined(HAVE_USTAT_H)
-#include <ustat.h>
-#endif
 #if defined(HAVE_UTIME_H)
 #include <utime.h>
 #endif
diff --git a/libgomp/ChangeLog b/libgomp/ChangeLog
index 22a088ec20d..24d1d0a719f 100644
--- a/libgomp/ChangeLog
+++ b/libgomp/ChangeLog
@@ -1,3 +1,69 @@
+2018-12-06  Release Manager
+
+	* GCC 7.4.0 released.
+
+2018-10-12  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-07-17  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/86542
+	* testsuite/libgomp.c++/pr86542.C: New test.
+
+	PR middle-end/86539
+	* testsuite/libgomp.c++/pr86539.C: New test.
+
+	2018-07-26  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/86660
+	* testsuite/libgomp.c/pr86660.c: New test.
+
+2018-06-26  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/86291
+	* testsuite/libgomp.c++/pr86291.C: New test.
+
+2018-06-22  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-04-18  David Malcolm  <dmalcolm@redhat.com>
+
+	PR jit/85384
+	* configure: Regenerate.
+
+2018-05-01  Tom de Vries  <tom@codesourcery.com>
+
+	backport from trunk:
+	2018-04-16  Cesar Philippidis  <cesar@codesourcery.com>
+		    Tom de Vries  <tom@codesourcery.com>
+
+	PR middle-end/84955
+	* testsuite/libgomp.oacc-c-c++-common/pr84955.c: New test.
+	* testsuite/libgomp.oacc-fortran/pr84955.f90: New test.
+
+2018-03-03  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-02-16  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/84418
+	* libgomp.fortran/pr84418-1.f90: New test.
+	* libgomp.fortran/pr84418-2.f90: New test.
+
+	2018-01-29  Christoph Spiel  <cspiel@freenet.de>
+		    Jakub Jelinek  <jakub@redhat.com>
+
+	PR libgomp/84096
+	* omp.h.in (omp_init_nest_lock_with_hint): Use omp_nest_lock_t
+	instead of omp_lock_t.
+
+2018-02-09  Martin Jambor  <mjambor@suse.cz>
+
+	Backport from mainline
+	2018-02-08  Martin Jambor  <mjambor@suse.cz>
+
+	* testsuite/libgomp.hsa.c/staticvar.c: New test.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
diff --git a/libgomp/configure b/libgomp/configure
index b7e9f40b852..06166c66120 100755
--- a/libgomp/configure
+++ b/libgomp/configure
@@ -16823,7 +16823,7 @@ CFLAGS="$save_CFLAGS"
 # Check whether --with-gcc-major-version-only was given.
 if test "${with_gcc_major_version_only+set}" = set; then :
   withval=$with_gcc_major_version_only; if test x$with_gcc_major_version_only = xyes ; then
-        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*\$\$/\1/'"
+        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*/\1/'"
       fi
 
 fi
diff --git a/libgomp/omp.h.in b/libgomp/omp.h.in
index bf400f88393..fb29b775adc 100644
--- a/libgomp/omp.h.in
+++ b/libgomp/omp.h.in
@@ -101,7 +101,7 @@ extern void omp_unset_lock (omp_lock_t *) __GOMP_NOTHROW;
 extern int omp_test_lock (omp_lock_t *) __GOMP_NOTHROW;
 
 extern void omp_init_nest_lock (omp_nest_lock_t *) __GOMP_NOTHROW;
-extern void omp_init_nest_lock_with_hint (omp_lock_t *, omp_lock_hint_t)
+extern void omp_init_nest_lock_with_hint (omp_nest_lock_t *, omp_lock_hint_t)
   __GOMP_NOTHROW;
 extern void omp_destroy_nest_lock (omp_nest_lock_t *) __GOMP_NOTHROW;
 extern void omp_set_nest_lock (omp_nest_lock_t *) __GOMP_NOTHROW;
diff --git a/libgomp/testsuite/libgomp.c++/pr86291.C b/libgomp/testsuite/libgomp.c++/pr86291.C
new file mode 100644
index 00000000000..89c4b2d37cd
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c++/pr86291.C
@@ -0,0 +1,51 @@
+// PR c++/86291
+// { dg-do run }
+// { dg-additional-options "-std=c++11" }
+
+extern "C" void abort ();
+
+struct I
+{
+  using size_type = __SIZE_TYPE__;
+  using difference_type = __PTRDIFF_TYPE__;
+  using value_type = int;
+  using reference = int &;
+  using pointer = int *;
+  static I begin () { return I{}; }
+  static I end () { I res; res.pos = res.num; return res; }
+  I &operator++ () { ++pos; return *this; }
+  reference operator* () const { return val; }
+  I &operator+= (size_type diff) { pos += diff; return *this; }
+  friend bool operator< (const I &a, const I &b) { return a.pos < b.pos; }
+  friend difference_type operator- (const I &a, const I &b) { return a.pos - b.pos; }
+  size_type pos = 0;
+  size_type num = 1;
+  mutable int val = 0;
+};
+
+int c;
+
+int
+main ()
+{
+#pragma omp parallel for collapse(10)
+  for (auto i = I::begin (); i < I::end (); ++i)
+    for (auto j = I::begin (); j < I::end (); ++j)
+      for (auto k = I::begin (); k < I::end (); ++k)
+	for (auto l = I::begin (); l < I::end (); ++l)
+	  for (auto m = I::begin (); m < I::end (); ++m)
+	    for (auto n = I::begin (); n < I::end (); ++n)
+	      for (auto o = I::begin (); o < I::end (); ++o)
+		for (auto p = I::begin (); p < I::end (); ++p)
+		  for (auto q = I::begin (); q < I::end (); ++q)
+		    for (auto r = I::begin (); r < I::end (); ++r)
+		      {
+			if (*i != 0 || *j != 0 || *k != 0 || *l != 0 || *m != 0
+			    || *n != 0 || *o != 0 || *p != 0 || *q != 0 || *r != 0)
+			  abort ();
+			#pragma omp atomic
+			  c++;
+		      }
+  if (c != 1)
+    abort ();
+}
diff --git a/libgomp/testsuite/libgomp.c++/pr86539.C b/libgomp/testsuite/libgomp.c++/pr86539.C
new file mode 100644
index 00000000000..ed0d63e4b76
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c++/pr86539.C
@@ -0,0 +1,28 @@
+// PR middle-end/86539
+
+int a[384];
+
+__attribute__((noinline, noclone)) void
+foo (int &b, int &c)
+{
+  #pragma omp taskloop shared (a) collapse(3)
+  for (int i = 0; i < 1; i++)
+    for (int *p = &b; p < &c; p++)
+      for (int j = 0; j < 1; j++)
+	if (p < &a[128] || p >= &a[256])
+	  __builtin_abort ();
+	else
+	  p[0]++;
+}
+
+int
+main ()
+{
+  #pragma omp parallel
+  #pragma omp single
+    foo (a[128], a[256]);
+  for (int i = 0; i < 384; i++)
+    if (a[i] != (i >= 128 && i < 256))
+      __builtin_abort ();
+  return 0;
+}
diff --git a/libgomp/testsuite/libgomp.c++/pr86542.C b/libgomp/testsuite/libgomp.c++/pr86542.C
new file mode 100644
index 00000000000..a8ebe574012
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c++/pr86542.C
@@ -0,0 +1,37 @@
+// PR middle-end/86542
+
+struct S { int s; S (); ~S (); S (const S &); };
+S s;
+
+S::S ()
+{
+}
+
+S::~S ()
+{
+}
+
+S::S (const S &x)
+{
+  s = x.s;
+}
+
+__attribute__((noinline, noclone)) void
+foo (int i, int j, int k, S s)
+{
+  if (i != 0 || j != 0 || k != 0 || s.s != 12)
+    __builtin_abort ();
+}
+
+int
+main ()
+{
+  volatile int inc = 16, jnc = 16, knc = 16;
+  s.s = 12;
+  #pragma omp taskloop collapse (3) firstprivate (s)
+  for (int i = 0; i < 16; i += inc)
+    for (int j = 0; j < 16; j += jnc)
+      for (int k = 0; k < 16; k += knc)
+	foo (i, j, k, s);
+  return 0;
+}
diff --git a/libgomp/testsuite/libgomp.c/pr86660.c b/libgomp/testsuite/libgomp.c/pr86660.c
new file mode 100644
index 00000000000..bea6b15270b
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c/pr86660.c
@@ -0,0 +1,28 @@
+/* PR middle-end/86660 */
+
+#pragma omp declare target
+int v[20];
+
+void
+foo (void)
+{
+  if (v[7] != 2)
+    __builtin_abort ();
+  v[7] = 1;
+}
+#pragma omp end declare target
+
+int
+main ()
+{
+  v[5] = 8;
+  v[7] = 2;
+  #pragma omp target map (always, tofrom: v)
+  {
+    foo ();
+    v[5] = 3;
+  }
+  if (v[7] != 1 || v[5] != 3)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/libgomp/testsuite/libgomp.fortran/pr84418-1.f90 b/libgomp/testsuite/libgomp.fortran/pr84418-1.f90
new file mode 100644
index 00000000000..e56c022446c
--- /dev/null
+++ b/libgomp/testsuite/libgomp.fortran/pr84418-1.f90
@@ -0,0 +1,26 @@
+! PR fortran/84418
+! { dg-do run { target vect_simd_clones } }
+! { dg-options "-fno-inline" }
+! { dg-additional-options "-msse2" { target sse2_runtime } }
+! { dg-additional-options "-mavx" { target avx_runtime } }
+
+  real :: a(1024), b(1024), c(1024)
+  integer :: i
+  do i = 1, 1024
+    a(i) = 0.5 * i
+    b(i) = 1.5 * i
+  end do
+  !$omp simd
+  do i = 1, 1024
+    c(i) = foo (a(i), b(i))
+  end do
+  do i = 1, 1024
+    if (c(i).ne.(2 * i)) call abort
+  end do
+contains
+  real function foo (x, y)
+    real :: x, y
+    !$omp declare simd linear (ref (x, y))
+    foo = x + y
+  end function
+end
diff --git a/libgomp/testsuite/libgomp.fortran/pr84418-2.f90 b/libgomp/testsuite/libgomp.fortran/pr84418-2.f90
new file mode 100644
index 00000000000..a6657d18095
--- /dev/null
+++ b/libgomp/testsuite/libgomp.fortran/pr84418-2.f90
@@ -0,0 +1,35 @@
+! PR fortran/84418
+! { dg-do run { target vect_simd_clones } }
+! { dg-options "-fno-inline" }
+! { dg-additional-options "-msse2" { target sse2_runtime } }
+! { dg-additional-options "-mavx" { target avx_runtime } }
+
+  type p
+    integer :: i, j
+  end type
+  type(p) :: a(1024)
+  integer :: b(4,1024), c(1024)
+  integer :: i
+  do i = 1, 1024
+    a(i)%i = 2 * i
+    a(i)%j = 3 * i
+    b(1,i) = 4 * i
+    b(2,i) = 5 * i
+    b(3,i) = 6 * i
+    b(4,i) = 7 * i
+  end do
+  !$omp simd
+  do i = 1, 1024
+    c(i) = foo (a(i), b(:,i))
+  end do
+  do i = 1, 1024
+    if (c(i).ne.(6 * i)) call abort
+  end do
+contains  
+  function foo (x, y)
+    type (p) :: x
+    integer :: y(4), foo
+    !$omp declare simd linear (ref (x, y))
+    foo = x%i + y(1)
+  end function
+end
diff --git a/libgomp/testsuite/libgomp.hsa.c/staticvar.c b/libgomp/testsuite/libgomp.hsa.c/staticvar.c
new file mode 100644
index 00000000000..6d20c9aa328
--- /dev/null
+++ b/libgomp/testsuite/libgomp.hsa.c/staticvar.c
@@ -0,0 +1,23 @@
+extern void abort (void);
+
+#pragma omp declare target
+int
+foo (void)
+{
+  static int s;
+  return ++s;
+}
+#pragma omp end declare target
+
+int
+main ()
+{
+  int r;
+  #pragma omp target map(from:r)
+  {
+    r = foo ();
+  }
+  if (r != 1)
+    abort ();
+  return 0;
+}
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/pr84955.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/pr84955.c
new file mode 100644
index 00000000000..e528faad0c4
--- /dev/null
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/pr84955.c
@@ -0,0 +1,15 @@
+/* { dg-do compile }  */
+
+int
+main (void)
+{
+  int i, j;
+
+#pragma acc parallel loop tile(2,3)
+  for (i = 1; i < 10; i++)
+    for (j = 1; j < 10; j++)
+      for (;;)
+	;
+
+  return i + j;
+}
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/pr84955.f90 b/libgomp/testsuite/libgomp.oacc-fortran/pr84955.f90
new file mode 100644
index 00000000000..dc858653808
--- /dev/null
+++ b/libgomp/testsuite/libgomp.oacc-fortran/pr84955.f90
@@ -0,0 +1,13 @@
+! { dg-do compile }
+
+subroutine s
+   integer :: i, j
+   !$acc parallel loop tile(2,3)
+   do i = 1, 10
+      do j = 1, 10
+         do
+         end do
+      end do
+   end do
+  !$acc end parallel loop
+end subroutine s
diff --git a/libhsail-rt/ChangeLog b/libhsail-rt/ChangeLog
index ae7bfb6854c..7ff52019a9a 100644
--- a/libhsail-rt/ChangeLog
+++ b/libhsail-rt/ChangeLog
@@ -1,3 +1,15 @@
+2018-12-06  Release Manager
+
+	* GCC 7.4.0 released.
+
+2018-06-22  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-04-18  David Malcolm  <dmalcolm@redhat.com>
+
+	PR jit/85384
+	* configure: Regenerate.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
diff --git a/libhsail-rt/configure b/libhsail-rt/configure
index a490125f5b3..a4fcc10c1f9 100755
--- a/libhsail-rt/configure
+++ b/libhsail-rt/configure
@@ -14414,7 +14414,7 @@ _ACEOF
 # Check whether --with-gcc-major-version-only was given.
 if test "${with_gcc_major_version_only+set}" = set; then :
   withval=$with_gcc_major_version_only; if test x$with_gcc_major_version_only = xyes ; then
-        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*\$\$/\1/'"
+        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*/\1/'"
       fi
 
 fi
diff --git a/libiberty/ChangeLog b/libiberty/ChangeLog
index 400b33b7527..b785e710df3 100644
--- a/libiberty/ChangeLog
+++ b/libiberty/ChangeLog
@@ -1,3 +1,7 @@
+2018-12-06  Release Manager
+
+	* GCC 7.4.0 released.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
diff --git a/libitm/ChangeLog b/libitm/ChangeLog
index f66dd31b03a..38d259671db 100644
--- a/libitm/ChangeLog
+++ b/libitm/ChangeLog
@@ -1,3 +1,23 @@
+2018-12-13  Peter Bergner  <bergner@linux.ibm.com>
+
+	Backport from mainline
+	2018-12-13  Peter Bergner  <bergner@linux.ibm.com>
+
+	* config/powerpc/target.h (htm_available):  Add support for
+	PPC_FEATURE2_HTM_NO_SUSPEND.  Use __builtin_cpu_supports if available.
+
+2018-12-06  Release Manager
+
+	* GCC 7.4.0 released.
+
+2018-06-22  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-04-18  David Malcolm  <dmalcolm@redhat.com>
+
+	PR jit/85384
+	* configure: Regenerate.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
diff --git a/libitm/config/powerpc/target.h b/libitm/config/powerpc/target.h
index 542aa3489cc..58cea96cca0 100644
--- a/libitm/config/powerpc/target.h
+++ b/libitm/config/powerpc/target.h
@@ -81,7 +81,20 @@ cpu_relax (void)
 static inline bool
 htm_available (void)
 {
-  return (getauxval (AT_HWCAP2) & PPC_FEATURE2_HAS_HTM) ? true : false;
+#ifdef __BUILTIN_CPU_SUPPORTS__
+  if (__builtin_cpu_supports ("htm-no-suspend")
+      || __builtin_cpu_supports ("htm"))
+    return true;
+#else
+  unsigned long htm_flags = PPC_FEATURE2_HAS_HTM
+#ifdef PPC_FEATURE2_HTM_NO_SUSPEND
+			    | PPC_FEATURE2_HTM_NO_SUSPEND
+#endif
+			    | 0;
+  if (getauxval (AT_HWCAP2) & htm_flags)
+    return true;
+#endif
+  return false;
 }
 
 static inline uint32_t
diff --git a/libitm/configure b/libitm/configure
index 775f370fbb5..96c494d4a3f 100644
--- a/libitm/configure
+++ b/libitm/configure
@@ -17647,7 +17647,7 @@ fi
 # Check whether --with-gcc-major-version-only was given.
 if test "${with_gcc_major_version_only+set}" = set; then :
   withval=$with_gcc_major_version_only; if test x$with_gcc_major_version_only = xyes ; then
-        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*\$\$/\1/'"
+        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*/\1/'"
       fi
 
 fi
diff --git a/libmpx/ChangeLog b/libmpx/ChangeLog
index af0595017c9..04d36796899 100644
--- a/libmpx/ChangeLog
+++ b/libmpx/ChangeLog
@@ -1,3 +1,15 @@
+2018-12-06  Release Manager
+
+	* GCC 7.4.0 released.
+
+2018-06-22  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-04-18  David Malcolm  <dmalcolm@redhat.com>
+
+	PR jit/85384
+	* configure: Regenerate.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
diff --git a/libmpx/configure b/libmpx/configure
index 853993a522f..2fd71ca89f6 100644
--- a/libmpx/configure
+++ b/libmpx/configure
@@ -11596,7 +11596,7 @@ fi
 # Check whether --with-gcc-major-version-only was given.
 if test "${with_gcc_major_version_only+set}" = set; then :
   withval=$with_gcc_major_version_only; if test x$with_gcc_major_version_only = xyes ; then
-        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*\$\$/\1/'"
+        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*/\1/'"
       fi
 
 fi
diff --git a/libobjc/ChangeLog b/libobjc/ChangeLog
index 78121927ba0..74053657fe1 100644
--- a/libobjc/ChangeLog
+++ b/libobjc/ChangeLog
@@ -1,3 +1,15 @@
+2018-12-06  Release Manager
+
+	* GCC 7.4.0 released.
+
+2018-06-22  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-04-18  David Malcolm  <dmalcolm@redhat.com>
+
+	PR jit/85384
+	* configure: Regenerate.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
diff --git a/libobjc/configure b/libobjc/configure
index abf5aed71cf..84862a82864 100755
--- a/libobjc/configure
+++ b/libobjc/configure
@@ -11708,7 +11708,7 @@ fi
 # Check whether --with-gcc-major-version-only was given.
 if test "${with_gcc_major_version_only+set}" = set; then :
   withval=$with_gcc_major_version_only; if test x$with_gcc_major_version_only = xyes ; then
-        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*\$\$/\1/'"
+        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*/\1/'"
       fi
 
 fi
diff --git a/liboffloadmic/ChangeLog b/liboffloadmic/ChangeLog
index 42d03b2e7be..309efad6602 100644
--- a/liboffloadmic/ChangeLog
+++ b/liboffloadmic/ChangeLog
@@ -1,3 +1,16 @@
+2018-12-06  Release Manager
+
+	* GCC 7.4.0 released.
+
+2018-06-22  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-04-18  David Malcolm  <dmalcolm@redhat.com>
+
+	PR jit/85384
+	* configure: Regenerate.
+	* plugin/confugure: Regenerate.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
diff --git a/liboffloadmic/configure b/liboffloadmic/configure
index e22b214ddbc..f873716991b 100644
--- a/liboffloadmic/configure
+++ b/liboffloadmic/configure
@@ -14492,7 +14492,7 @@ fi
 # Check whether --with-gcc-major-version-only was given.
 if test "${with_gcc_major_version_only+set}" = set; then :
   withval=$with_gcc_major_version_only; if test x$with_gcc_major_version_only = xyes ; then
-        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*\$\$/\1/'"
+        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*/\1/'"
       fi
 
 fi
diff --git a/liboffloadmic/plugin/configure b/liboffloadmic/plugin/configure
index 8b8c041d2bf..c031eb3e7fa 100644
--- a/liboffloadmic/plugin/configure
+++ b/liboffloadmic/plugin/configure
@@ -14187,7 +14187,7 @@ hardcode_into_libs=no
 # Check whether --with-gcc-major-version-only was given.
 if test "${with_gcc_major_version_only+set}" = set; then :
   withval=$with_gcc_major_version_only; if test x$with_gcc_major_version_only = xyes ; then
-        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*\$\$/\1/'"
+        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*/\1/'"
       fi
 
 fi
diff --git a/libquadmath/ChangeLog b/libquadmath/ChangeLog
index 4c66b338b2c..aea32d500bb 100644
--- a/libquadmath/ChangeLog
+++ b/libquadmath/ChangeLog
@@ -1,3 +1,15 @@
+2018-12-06  Release Manager
+
+	* GCC 7.4.0 released.
+
+2018-06-22  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-04-18  David Malcolm  <dmalcolm@redhat.com>
+
+	PR jit/85384
+	* configure: Regenerate.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
diff --git a/libquadmath/configure b/libquadmath/configure
index d2f13bf7751..76a2c20b7e1 100755
--- a/libquadmath/configure
+++ b/libquadmath/configure
@@ -12929,7 +12929,7 @@ fi
 # Check whether --with-gcc-major-version-only was given.
 if test "${with_gcc_major_version_only+set}" = set; then :
   withval=$with_gcc_major_version_only; if test x$with_gcc_major_version_only = xyes ; then
-        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*\$\$/\1/'"
+        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*/\1/'"
       fi
 
 fi
diff --git a/libsanitizer/ChangeLog b/libsanitizer/ChangeLog
index 2c213f18e0c..d2921321d7a 100644
--- a/libsanitizer/ChangeLog
+++ b/libsanitizer/ChangeLog
@@ -1,3 +1,61 @@
+2018-12-06  Release Manager
+
+	* GCC 7.4.0 released.
+
+2018-08-16  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-08-02  Martin Liska  <mliska@suse.cz>
+
+        PR sanitizer/86022
+	* sanitizer_common/sanitizer_linux_libcdep.cc (ThreadDescriptorSize):
+        Cherry-pick compiler-rt revision 338606.
+
+2018-06-22  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-04-18  David Malcolm  <dmalcolm@redhat.com>
+
+	PR jit/85384
+	* configure: Regenerate.
+
+2018-06-07  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2018-03-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR sanitizer/84761
+	* sanitizer_common/sanitizer_linux_libcdep.cc (__GLIBC_PREREQ):
+	Define if not defined.
+	(DL_INTERNAL_FUNCTION): Don't define.
+	(InitTlsSize): For __i386__ if not compiled against glibc 2.27+
+	determine at runtime whether to use regparm(3), stdcall calling
+	convention for older glibcs or normal calling convention for
+	newer glibcs for call to _dl_get_tls_static_info.
+
+2018-05-31  Matthias Klose  <doko@ubuntu.com>
+
+	PR sanitizer/86012
+	* sanitizer_common/sanitizer_platform_limits_posix.cc: Define
+	SIZEOF_STRUCT_USTAT for 32bit sparc.
+
+2018-05-24  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR sanitizer/85835
+	* sanitizer_common/sanitizer_platform_limits_posix.cc: Don't
+	include <sys/ustat.h> for Linux.
+	(SIZEOF_STRUCT_USTAT): New.
+	(struct_ustat_sz): Use SIZEOF_STRUCT_USTAT for Linux.
+
+2018-04-24  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-04-18  Bill Seurer  <seurer@linux.vnet.ibm.com>
+
+	PR sanitizer/85389
+	* asan/asan_allocator.h (kAllocatorSpace): For __powerpc64__ change
+	from 0xa0000000000ULL to ~(uptr)0.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
diff --git a/libsanitizer/asan/asan_allocator.h b/libsanitizer/asan/asan_allocator.h
index 7eeddadd547..dacfddd5ddf 100644
--- a/libsanitizer/asan/asan_allocator.h
+++ b/libsanitizer/asan/asan_allocator.h
@@ -115,7 +115,7 @@ struct AsanMapUnmapCallback {
 
 #if SANITIZER_CAN_USE_ALLOCATOR64
 # if defined(__powerpc64__)
-const uptr kAllocatorSpace =  0xa0000000000ULL;
+const uptr kAllocatorSpace = ~(uptr)0;
 const uptr kAllocatorSize  =  0x20000000000ULL;  // 2T.
 typedef DefaultSizeClassMap SizeClassMap;
 # elif defined(__aarch64__) && SANITIZER_ANDROID
diff --git a/libsanitizer/configure b/libsanitizer/configure
index 8e0c47ea838..a3a08d635f4 100755
--- a/libsanitizer/configure
+++ b/libsanitizer/configure
@@ -16511,7 +16511,7 @@ fi
 # Check whether --with-gcc-major-version-only was given.
 if test "${with_gcc_major_version_only+set}" = set; then :
   withval=$with_gcc_major_version_only; if test x$with_gcc_major_version_only = xyes ; then
-        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*\$\$/\1/'"
+        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*/\1/'"
       fi
 
 fi
diff --git a/libsanitizer/sanitizer_common/sanitizer_linux_libcdep.cc b/libsanitizer/sanitizer_common/sanitizer_linux_libcdep.cc
index 63e70660cf3..7c94a5fc615 100644
--- a/libsanitizer/sanitizer_common/sanitizer_linux_libcdep.cc
+++ b/libsanitizer/sanitizer_common/sanitizer_linux_libcdep.cc
@@ -153,28 +153,43 @@ bool SanitizerGetThreadName(char *name, int max_len) {
 #endif
 }
 
+#ifndef __GLIBC_PREREQ
+#define __GLIBC_PREREQ(x, y) 0
+#endif
+
 #if !SANITIZER_FREEBSD && !SANITIZER_ANDROID && !SANITIZER_GO
 static uptr g_tls_size;
 
-#ifdef __i386__
-# define DL_INTERNAL_FUNCTION __attribute__((regparm(3), stdcall))
-#else
-# define DL_INTERNAL_FUNCTION
-#endif
-
 void InitTlsSize() {
 // all current supported platforms have 16 bytes stack alignment
   const size_t kStackAlign = 16;
-  typedef void (*get_tls_func)(size_t*, size_t*) DL_INTERNAL_FUNCTION;
-  get_tls_func get_tls;
-  void *get_tls_static_info_ptr = dlsym(RTLD_NEXT, "_dl_get_tls_static_info");
-  CHECK_EQ(sizeof(get_tls), sizeof(get_tls_static_info_ptr));
-  internal_memcpy(&get_tls, &get_tls_static_info_ptr,
-                  sizeof(get_tls_static_info_ptr));
-  CHECK_NE(get_tls, 0);
   size_t tls_size = 0;
   size_t tls_align = 0;
-  get_tls(&tls_size, &tls_align);
+  void *get_tls_static_info_ptr = dlsym(RTLD_NEXT, "_dl_get_tls_static_info");
+#if defined(__i386__) && !__GLIBC_PREREQ(2, 27)
+  /* On i?86, _dl_get_tls_static_info used to be internal_function, i.e.
+     __attribute__((regparm(3), stdcall)) before glibc 2.27 and is normal
+     function in 2.27 and later.  */
+  if (!dlvsym(RTLD_NEXT, "glob", "GLIBC_2.27")) {
+    typedef void (*get_tls_func)(size_t*, size_t*)
+      __attribute__((regparm(3), stdcall));
+    get_tls_func get_tls;
+    CHECK_EQ(sizeof(get_tls), sizeof(get_tls_static_info_ptr));
+    internal_memcpy(&get_tls, &get_tls_static_info_ptr,
+                    sizeof(get_tls_static_info_ptr));
+    CHECK_NE(get_tls, 0);
+    get_tls(&tls_size, &tls_align);
+  } else
+#endif
+  {
+    typedef void (*get_tls_func)(size_t*, size_t*);
+    get_tls_func get_tls;
+    CHECK_EQ(sizeof(get_tls), sizeof(get_tls_static_info_ptr));
+    internal_memcpy(&get_tls, &get_tls_static_info_ptr,
+                    sizeof(get_tls_static_info_ptr));
+    CHECK_NE(get_tls, 0);
+    get_tls(&tls_size, &tls_align);
+  }
   if (tls_align < kStackAlign)
     tls_align = kStackAlign;
   g_tls_size = RoundUpTo(tls_size, tls_align);
@@ -221,7 +236,7 @@ uptr ThreadDescriptorSize() {
         val = FIRST_32_SECOND_64(1168, 1776);
       else if (minor == 11 || (minor == 12 && patch == 1))
         val = FIRST_32_SECOND_64(1168, 2288);
-      else if (minor <= 13)
+      else if (minor <= 14)
         val = FIRST_32_SECOND_64(1168, 2304);
       else
         val = FIRST_32_SECOND_64(1216, 2304);
diff --git a/libsanitizer/sanitizer_common/sanitizer_platform_limits_posix.cc b/libsanitizer/sanitizer_common/sanitizer_platform_limits_posix.cc
index 31a5e697eae..97eae3fc7bc 100644
--- a/libsanitizer/sanitizer_common/sanitizer_platform_limits_posix.cc
+++ b/libsanitizer/sanitizer_common/sanitizer_platform_limits_posix.cc
@@ -154,7 +154,6 @@ typedef struct user_fpregs elf_fpregset_t;
 # include <sys/procfs.h>
 #endif
 #include <sys/user.h>
-#include <sys/ustat.h>
 #include <linux/cyclades.h>
 #include <linux/if_eql.h>
 #include <linux/if_plip.h>
@@ -247,7 +246,19 @@ namespace __sanitizer {
 #endif // SANITIZER_LINUX || SANITIZER_FREEBSD
 
 #if SANITIZER_LINUX && !SANITIZER_ANDROID
-  unsigned struct_ustat_sz = sizeof(struct ustat);
+  // Use pre-computed size of struct ustat to avoid <sys/ustat.h> which
+  // has been removed from glibc 2.28.
+#if defined(__aarch64__) || defined(__s390x__) || defined (__mips64) \
+  || defined(__powerpc64__) || defined(__arch64__) || defined(__sparcv9) \
+  || defined(__x86_64__)
+#define SIZEOF_STRUCT_USTAT 32
+#elif defined(__arm__) || defined(__i386__) || defined(__mips__) \
+  || defined(__powerpc__) || defined(__s390__) || defined(__sparc__)
+#define SIZEOF_STRUCT_USTAT 20
+#else
+#error Unknown size of struct ustat
+#endif
+  unsigned struct_ustat_sz = SIZEOF_STRUCT_USTAT;
   unsigned struct_rlimit64_sz = sizeof(struct rlimit64);
   unsigned struct_statvfs64_sz = sizeof(struct statvfs64);
 #endif // SANITIZER_LINUX && !SANITIZER_ANDROID
diff --git a/libssp/ChangeLog b/libssp/ChangeLog
index 299029f8521..e77959abbc7 100644
--- a/libssp/ChangeLog
+++ b/libssp/ChangeLog
@@ -1,3 +1,15 @@
+2018-12-06  Release Manager
+
+	* GCC 7.4.0 released.
+
+2018-06-22  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-04-18  David Malcolm  <dmalcolm@redhat.com>
+
+	PR jit/85384
+	* configure: Regenerate.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
diff --git a/libssp/configure b/libssp/configure
index b14e922e6f1..ee1751d20db 100755
--- a/libssp/configure
+++ b/libssp/configure
@@ -11082,7 +11082,7 @@ fi
 # Check whether --with-gcc-major-version-only was given.
 if test "${with_gcc_major_version_only+set}" = set; then :
   withval=$with_gcc_major_version_only; if test x$with_gcc_major_version_only = xyes ; then
-        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*\$\$/\1/'"
+        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*/\1/'"
       fi
 
 fi
diff --git a/libstdc++-v3/ChangeLog b/libstdc++-v3/ChangeLog
index bcef45dd024..028ab8defd5 100644
--- a/libstdc++-v3/ChangeLog
+++ b/libstdc++-v3/ChangeLog
@@ -1,3 +1,891 @@
+2019-05-08  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2019-04-17  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/90105
+	* include/bits/forward_list.tcc (operator==): Do not use operator!= to
+	compare elements.
+	(forward_list<T, A>::sort(Comp)): When elements are equal take the one
+	earlier in the list, so that sort is stable.
+	* testsuite/23_containers/forward_list/operations/90105.cc: New test.
+	* testsuite/23_containers/forward_list/comparable.cc: Test with
+	types that meet the minimum EqualityComparable and LessThanComparable
+	requirements. Remove irrelevant comment.
+
+	Backport from mainline
+	2019-03-11  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/89629
+	* libsupc++/hash_bytes.cc [__SIZEOF_SIZE_T__ == 8] (_Hash_bytes):
+	Use correct type for len_aligned.
+	* testsuite/20_util/hash/89629.cc: New test.
+
+2019-02-22  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/89446
+	* include/bits/char_traits.h (__constant_char_array): Check index is
+	in range before dereferencing.
+	* testsuite/21_strings/basic_string_view/operators/char/89446.cc:
+	New test.
+
+2018-12-24  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2018-12-06  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* scripts/make_exports.pl (check names): Don’t try to export
+	construction vtable symbols.
+
+2018-12-24  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2018-12-06  Jonathan Wakely  <jwakely@redhat.com>
+		    Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR libstdc++/64883
+	* testsuite/17_intro/headers/c++1998/all_attributes.cc: Don't test
+	always_inline on Darwin.
+	* testsuite/17_intro/headers/c++2011/all_attributes.cc: Likewise.
+	* testsuite/17_intro/headers/c++2014/all_attributes.cc: Likewise.
+	* testsuite/17_intro/headers/c++2017/all_attributes.cc: Likewise.
+	* testsuite/17_intro/headers/c++2020/all_attributes.cc: Likewise.
+
+2018-12-24  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2018-08-25  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR libstdc++/70694
+	* configure.host (OPT_LDFLAGS): Don't append
+	-fvisibility-inlines-hidden for newer Darwin.
+
+2018-12-06  Release Manager
+
+	* GCC 7.4.0 released.
+
+2018-11-28  François Dumont  <fdumont@gcc.gnu.org>
+
+	PR libstdc++/88199
+	* include/bits/hashtable.h
+	(_Hashtable<>::_M_move_assign(_Hashtable&&, false_type)): Deallocate
+	former buckets after assignment.
+	* testsuite/23_containers/unordered_set/allocator/move_assign.cc
+	(test03): New.
+
+2018-10-31  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2018-10-31  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/87822
+	* include/bits/stl_pair.h (__pair_base): Change to class template.
+	(pair): Make base class type depend on template parameters.
+	* testsuite/20_util/pair/87822.cc: New test.
+
+2018-10-25  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/87749
+	* include/bits/basic_string.h [_GLIBCXX_USE_CXX11_ABI]
+	(basic_string::operator=(basic_string&&)): For short strings copy the
+	buffer inline. Only fall back to using assign(const basic_string&) to
+	do a deep copy when reallocation is needed.
+	* testsuite/21_strings/basic_string/modifiers/assign/char/87749.cc:
+	New test.
+	* testsuite/21_strings/basic_string/modifiers/assign/char/
+	move_assign_optim.cc: New test.
+	* testsuite/21_strings/basic_string/modifiers/assign/wchar_t/87749.cc:
+	New test.
+	* testsuite/21_strings/basic_string/modifiers/assign/wchar_t/
+	move_assign_optim.cc: New test.
+
+2018-10-23  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/87704
+	* include/bits/unique_ptr.h (unique_ptr::unique_ptr(nullptr_t)): Do
+	not delegate to default constructor.
+	(unique_ptr<T[], D>::unique_ptr(nullptr_t)): Likewise.
+	* testsuite/20_util/unique_ptr/cons/incomplete.cc: New test.
+
+2018-10-22  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2017-09-12  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/79433
+	* include/Makefile.am: Remove <bits/c++14_warning.h>.
+	* include/Makefile.in: Regenerate.
+	* include/bits/c++14_warning.h: Remove.
+	* include/experimental/algorithm: Do not include <c++14_warning.h>.
+	* include/experimental/any: Likewise.
+	* include/experimental/array: Likewise.
+	* include/experimental/bits/erase_if.h: Likewise.
+	* include/experimental/bits/lfts_config.h: Likewise.
+	* include/experimental/bits/shared_ptr.h: Likewise.
+	* include/experimental/bits/string_view.tcc: Likewise.
+	* include/experimental/chrono: Likewise.
+	* include/experimental/deque: Likewise.
+	* include/experimental/filesystem: Do not include <c++0x_warning.h>.
+	* include/experimental/forward_list: Do not include <c++14_warning.h>.
+	* include/experimental/functional: Likewise.
+	* include/experimental/iterator: Likewise.
+	* include/experimental/list: Likewise.
+	* include/experimental/map: Likewise.
+	* include/experimental/memory: Likewise.
+	* include/experimental/numeric: Likewise.
+	* include/experimental/optional: Likewise.
+	* include/experimental/propagate_const: Likewise.
+	* include/experimental/ratio: Likewise.
+	* include/experimental/regex: Likewise.
+	* include/experimental/set: Likewise.
+	* include/experimental/string: Likewise.
+	* include/experimental/string_view: Likewise.
+	* include/experimental/system_error: Likewise.
+	* include/experimental/tuple: Likewise.
+	* include/experimental/type_traits: Likewise.
+	* include/experimental/unordered_map: Likewise.
+	* include/experimental/unordered_set: Likewise.
+	* include/experimental/vector: Likewise.
+	* testsuite/experimental/any/misc/any_cast_neg.cc: Adjust dg-error
+	line number.
+	* testsuite/experimental/array/neg.cc: Likewise.
+	* testsuite/experimental/propagate_const/assignment/move_neg.cc:
+	Likewise.
+	* testsuite/experimental/propagate_const/cons/move_neg.cc: Likewise.
+	* testsuite/experimental/propagate_const/requirements2.cc: Likewise.
+	* testsuite/experimental/propagate_const/requirements3.cc: Likewise.
+	* testsuite/experimental/propagate_const/requirements4.cc: Likewise.
+	* testsuite/experimental/propagate_const/requirements5.cc: Likewise.
+
+2018-10-18  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2018-10-18  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/87641
+	* include/bits/valarray_array.h (__valarray_sum): Use first element
+	to initialize accumulator instead of value-initializing it.
+	* testsuite/26_numerics/valarray/87641.cc: New test.
+
+2018-10-15  Jonathan Wakely  <jwakely@redhat.com>
+
+	* testsuite/22_locale/numpunct/members/char/3.cc: Adjust test to
+	account for change to glibc it_IT localedata (glibc bz#10797).
+
+2018-10-12  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2018-07-31  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/86751
+	* include/bits/stl_pair.h (__pair_base): New class with deleted copy
+	assignment operator.
+	(pair): Derive from __pair_base.
+	(pair::operator=): Remove deleted overload.
+	* python/libstdcxx/v6/printers.py (StdPairPrinter): New pretty printer
+	so that new base class isn't shown in GDB.
+	* testsuite/20_util/pair/86751.cc: New test.
+	* testsuite/20_util/pair/ref_assign.cc: New test.
+
+2018-10-12  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2018-09-03  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/78595
+	* include/bits/stl_map.h (map::insert(_Pair&&))
+	(map::insert(const_iterator, _Pair&&)): Do emplace instead of insert.
+	* include/bits/stl_multimap.h (multimap::insert(_Pair&&))
+	(multimap::insert(const_iterator, _Pair&&)): Likewise.
+	* include/bits/unordered_map.h (unordered_map::insert(_Pair&&))
+	(unordered_map::insert(const_iterator, _Pair&&))
+	(unordered_multimap::insert(_Pair&&))
+	(unordered_multimap::insert(const_iterator, _Pair&&)): Likewise.
+	* include/std/type_traits (__enable_if_t): Define for C++11.
+	* testsuite/23_containers/map/modifiers/insert/78595.cc: New test.
+	* testsuite/23_containers/multimap/modifiers/insert/78595.cc: New test.
+	* testsuite/23_containers/unordered_map/modifiers/78595.cc: New test.
+	* testsuite/23_containers/unordered_multimap/modifiers/78595.cc: New
+	test.
+
+2018-10-12  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2018-08-30  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/ext/pointer.h (_Pointer_adapter): Define operators for
+	pointer arithmetic using long long offsets.
+	* testsuite/ext/ext_pointer/1.cc: Test pointer arithmetic using
+	long long values.
+
+2018-10-12  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2018-08-23  Jonathan Wakely  <jwakely@redhat.com>
+
+	* testsuite/21_strings/basic_string/init-list.cc:
+	Require cxx11-abi.
+	* testsuite/experimental/polymorphic_allocator/pmr_typedefs_match.cc:
+	Likewise.
+	* testsuite/experimental/polymorphic_allocator/pmr_typedefs_string.cc:
+	Likewise.
+
+	Backport from mainline
+	2018-08-22  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/87061
+	* include/experimental/regex [!_GLIBCXX_USE_CXX11_ABI]
+	(experimental::pmr::match_results, experimental::pmr::cmatch)
+	(experimental::pmr::smatch, experimental::pmr::wcmatch)
+	(experimental::pmr::wsmatch): Do not declare for gcc4-compatible ABI,
+	because COW strings don't support C++11 allocator model.
+	* include/experimental/string [!_GLIBCXX_USE_CXX11_ABI]
+	(experimental::pmr::basic_string, experimental::pmr::string)
+	(experimental::pmr::u16string, experimental::pmr::u32string)
+	(experimental::pmr::wstring): Likewise.
+
+	Backport from mainline
+	2018-08-15  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/experimental/regex: Remove begin/end macros for namespace.
+	* include/experimental/string: Likewise.
+	* testsuite/experimental/polymorphic_allocator/pmr_typedefs_deque.cc:
+	New test.
+	* testsuite/experimental/polymorphic_allocator/
+	pmr_typedefs_forward_list.cc: New test.
+	* testsuite/experimental/polymorphic_allocator/pmr_typedefs_list.cc:
+	New test.
+	* testsuite/experimental/polymorphic_allocator/pmr_typedefs_map.cc:
+	New test.
+	* testsuite/experimental/polymorphic_allocator/pmr_typedefs_match.cc:
+	New test.
+	* testsuite/experimental/polymorphic_allocator/
+	pmr_typedefs_multimap.cc: New test.
+	* testsuite/experimental/polymorphic_allocator/
+	pmr_typedefs_multiset.cc: New test.
+	* testsuite/experimental/polymorphic_allocator/pmr_typedefs_set.cc:
+	New test.
+	* testsuite/experimental/polymorphic_allocator/pmr_typedefs_string.cc:
+	New test.
+	* testsuite/experimental/polymorphic_allocator/
+	pmr_typedefs_unordered_map.cc: New test.
+	* testsuite/experimental/polymorphic_allocator/
+	pmr_typedefs_unordered_multimap.cc: New test.
+	* testsuite/experimental/polymorphic_allocator/
+	pmr_typedefs_unordered_multiset.cc: New test.
+	* testsuite/experimental/polymorphic_allocator/
+	pmr_typedefs_unordered_set.cc: New test.
+	* testsuite/experimental/polymorphic_allocator/pmr_typedefs_vector.cc:
+	New test.
+
+2018-10-12  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2018-07-24  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/70966
+	* include/experimental/memory_resource (__get_default_resource): Use
+	placement new to create an object with dynamic storage duration.
+
+	Backport from mainline
+	2018-06-20  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/70966
+	* include/experimental/memory_resource (__resource_adaptor_imp): Add
+	static assertions to enforce requirements on pointer types.
+	(__resource_adaptor_imp::get_allocator()): Add noexcept.
+	(new_delete_resource, null_memory_resource): Return address of an
+	object with dynamic storage duration.
+	(__null_memory_resource): Remove.
+	* testsuite/experimental/memory_resource/70966.cc: New.
+
+2018-10-12  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/77854
+	* doc/xml/manual/status_cxx1998.xml: Document size_type and
+	difference_type for containers.
+	* doc/html/*: Regenerate.
+
+2018-10-08  Joseph Myers  <joseph@codesourcery.com>
+
+	Backport from mainline
+	2018-10-02  Joseph Myers  <joseph@codesourcery.com>
+
+	* testsuite/lib/libstdc++.exp (libstdc++_init): Use
+	-fno-show-column in default cxxflags.
+
+2018-10-08  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2018-10-08  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/87538
+	* include/std/functional (_Not_fn::operator()): Check value of
+	__is_nothrow_invocable as well.
+	* testsuite/20_util/function_objects/not_fn/87538.cc: New test.
+	* testsuite/experimental/functional/87538.cc: New test.
+
+2018-08-13  Jonathan Wakely  <jwakely@redhat.com>
+
+	Revert
+	2018-08-10  Sebastian Huber  <sebastian.huber@embedded-brains.de>
+
+	PR target/85904
+	* configure.ac: Define HAVE_ALIGNED_ALLOC if building for
+	Newlib.
+	* configure: Regenerate.
+
+2018-08-10  Sebastian Huber  <sebastian.huber@embedded-brains.de>
+
+	Backport from mainline
+	2018-08-10  Sebastian Huber  <sebastian.huber@embedded-brains.de>
+
+	PR target/85904
+	* configure.ac: Define HAVE_ALIGNED_ALLOC if building for
+	Newlib.
+	* configure: Regenerate.
+
+2018-08-08  Jonathan Wakely  <jwakely@redhat.com>
+
+	* libsupc++/new_opa.cc (aligned_alloc): Declare inside namespace to
+	avoid clashing with an ::aligned_alloc function that was not detected
+	by configure.
+
+	* doc/xml/manual/using.xml: Remove empty table cell.
+	* doc/html/*: Regenerate.
+
+	* doc/xml/manual/using.xml: Add missing header to table and fix typo.
+	Remove C++17 and C++2a headers not present on gcc-7-branch.
+	* doc/html/*: Regenerate.
+
+2018-08-07  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2018-06-27  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/86138
+	* include/bits/basic_string.tcc: [_GLIBCXX_EXTERN_TEMPLATE < 0]
+	Declare explicit instantiations of COW empty reps and I/O functions.
+
+	Backport from mainline
+	2018-05-08  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/85672
+	* include/Makefile.am [!ENABLE_FLOAT128]: Change c++config.h entry
+	to #undef _GLIBCXX_USE_FLOAT128 instead of defining it to zero.
+	* include/Makefile.in: Regenerate.
+	* include/bits/c++config (_GLIBCXX_USE_FLOAT128): Move definition
+	within conditional block.
+
+	Backport from mainline
+	2018-05-01  Tulio Magno Quites Machado Filho  <tuliom@linux.vnet.ibm.com>
+
+	PR libstdc++/84654
+	* acinclude.m4: Set ENABLE_FLOAT128 instead of _GLIBCXX_USE_FLOAT128.
+	* config.h.in: Remove references to _GLIBCXX_USE_FLOAT128.
+	* configure: Regenerate.
+	* include/Makefile.am: Replace the value of _GLIBCXX_USE_FLOAT128
+	based on ENABLE_FLOAT128.
+	* include/Makefile.in: Regenerate.
+	* include/bits/c++config: Define _GLIBCXX_USE_FLOAT128.
+	[!defined(__FLOAT128__) && !defined(__SIZEOF_FLOAT128__)]: Undefine
+	_GLIBCXX_USE_FLOAT128.
+
+	Backport from mainline
+	2017-06-17  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/80893
+	* testsuite/23_containers/vector/bool/80893.cc: Add { target c++11 }.
+
+	Backport from mainline
+	2017-05-31  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/80893
+	* include/bits/stl_bvector.h (vector<bool>::_M_initialize): Avoid
+	null pointer dereference when size is zero.
+	* testsuite/23_containers/vector/bool/80893.cc: New.
+	* testsuite/util/testsuite_allocator.h (PointerBase::PointerBase):
+	Add non-explicit constructor from nullptr.
+	(PointerBase::derived() const): Add const-qualified overload.
+
+	Backport from mainline
+	2017-12-14  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/68519
+	* include/std/condition_variable (condition_variable::wait_for):
+	Convert duration to native clock's duration before addition.
+	* testsuite/30_threads/condition_variable/members/68519.cc: New test.
+
+	Backport from mainline
+	2018-06-25  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/86292
+	* include/bits/stl_vector.h (vector::_M_range_initialize<InputIter>):
+	Add try-catch block.
+	* testsuite/23_containers/vector/cons/86292.cc: New.
+
+	Backport from mainline
+	2018-07-31  Jonathan Wakely  <jwakely@redhat.com>
+
+	* doc/xml/manual/test.xml: Improve documentation on writing tests for
+	newer standards.
+	* doc/xml/manual/using.xml: Document all headers for C++11 and later.
+	* doc/html/*: Regenerate.
+
+	Backport from mainline
+	2018-08-03  Jonathan Wakely  <jwakely@redhat.com>
+
+	* src/c++11/system_error.cc
+	(system_error_category::default_error_condition): Add workaround for
+	ENOTEMPTY and EEXIST having the same value on AIX.
+	* testsuite/19_diagnostics/error_category/system_category.cc: Add
+	extra testcases for EDOM, EILSEQ, ERANGE, EEXIST and ENOTEMPTY.
+
+	Backport from mainline
+	2018-08-01  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/60555
+	* src/c++11/system_error.cc
+	(system_error_category::default_error_condition): New override to
+	check for POSIX errno values.
+	* testsuite/19_diagnostics/error_category/generic_category.cc: New
+	* testsuite/19_diagnostics/error_category/system_category.cc: New
+	test.
+
+	Backport from mainline
+	2018-08-07  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/86861
+	* libsupc++/new_opa.cc [_GLIBCXX_HAVE_MEMALIGN] (aligned_alloc):
+	Replace macro with inline function.
+	[__sun]: Increase alignment to meet memalign precondition.
+	[!HAVE__ALIGNED_MALLOC && !HAVE_POSIX_MEMALIGN && !HAVE_MEMALIGN]
+	(aligned_alloc): Move check for valid alignment to operator new.
+	Remove redundant check for non-zero size, it's enforced by the caller.
+	(operator new): Move check for valid alignment here. Use
+	__builtin_expect on check for zero size.
+
+	Backport from mainline
+	2018-07-30  Jonathan Wakely  <jwakely@redhat.com>
+
+	* libsupc++/new_opa.cc (operator new(size_t, align_val_t)): Add
+	workaround for aligned_alloc bug on AIX.
+	* testsuite/18_support/new_aligned.cc: New test.
+
+	Backport from mainline
+	2018-07-30  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/86734
+	* include/bits/stl_iterator.h (reverse_iterator::operator->): Use
+	addressof (LWG 2188).
+	* testsuite/24_iterators/reverse_iterator/dr2188.cc: New test.
+
+	Backport from mainline
+	2018-05-19  Jonathan Wakely  <jwakely@redhat.com>
+
+	* src/c++11/codecvt.cc (__codecvt_utf8_base<wchar_t>::do_in)
+	[__SIZEOF_WCHAR_T__==2 && __BYTE_ORDER__!=__ORDER_BIG_ENDIAN__]: Set
+	little_endian element in bitmask.
+	* testsuite/22_locale/codecvt/codecvt_utf8/69703.cc: Run all tests.
+	* testsuite/22_locale/codecvt/codecvt_utf8/wchar_t/1.cc: New.
+
+2018-07-05  François Dumont  <fdumont@gcc.gnu.org>
+
+	Backport from mainline
+	2018-07-04  François Dumont  <fdumont@gcc.gnu.org>
+
+	PR libstdc++/86272
+	* include/debug/string
+	(__gnu_debug::basic_string<>::insert<_Ite>(const_iterator, _Ite, _Ite)):
+	Use __glibcxx_check_insert_range.
+
+2018-07-04  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2018-03-09  Jonathan Wakely  <jwakely@redhat.com>
+
+	src/filesystem/ops.cc (create_dir): Pass error_code to is_directory.
+
+	Backport from mainline
+	2018-06-18  Jonathan Wakely  <jwakely@redhat.com>
+
+	LWG 3050 Fix cv-qualification of convertibility constraints
+	* include/std/chrono (duration, operator*, operator/, operator%): Use
+	const-qualified type as source type in is_convertible constraints.
+	* testsuite/20_util/duration/arithmetic/dr3050.cc: New.
+	* testsuite/20_util/duration/cons/dr3050.cc: New.
+	* testsuite/20_util/duration/literals/range.cc: Rename to...
+	* testsuite/20_util/duration/literals/range_neg.cc: Here. Adjust
+	dg-error lineno.
+
+	Backport from mainline
+	2018-06-13  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/86127
+	* include/bits/forward_list.h (_Fwd_list_base::_Tp_alloc_type): Remove
+	unused typedef.
+	(_Fwd_list_base::_M_create_node, _Fwd_list_base::_M_erase_after):
+	Use node allocator to create and destroy elements.
+	(forward_list::_Tp_alloc_type): Remove unused typedef.
+	(forward_list::_Alloc_traits): Use allocator_traits instead of
+	__gnu_cxx::__alloc_traits.
+	* include/bits/forward_list.tcc (_Fwd_list_base::_M_erase_after):
+	Use node allocator to create and destroy elements.
+
+	Backport from mainline
+	2018-05-29  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/std/variant (__erased_dtor): Qualify call to __get.
+
+	Backport from mainline
+	2018-05-15  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/std/variant (__gen_vtable_impl::__visit_invoke): Qualify
+	__invoke to prevent ADL.
+
+	Backport from mainline
+	2018-04-05  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/std/variant (_VARIANT_RELATION_FUNCTION_TEMPLATE): Qualify
+	__get calls to avoid ADL and avoid ambiguity due to Clang bug.
+
+	Backport from mainline
+	2018-03-26  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/std/variant (__get): Qualify calls to avoid ADL.
+	(__select_index): Adjust whitespace.
+	(variant): Add using-declaration to workaround Clang bug.
+
+	Backport from mainline
+	2018-05-24  Maya Rashish  <coypu@sdf.org>
+
+	PR target/85904
+	* crossconfig.m4: Test for aligned_alloc on netbsd.
+	* configure: Regenerate.
+
+	Backport from mainline
+	2018-05-18  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/85098
+	* include/bits/regex.h [__cplusplus < 201703L] (basic_regex::icase)
+	(basic_regex::nosubs, basic_regex::optimize, basic_regex::collate)
+	(basic_regex::ECMAScript, basic_regex::basic, basic_regex::extended)
+	(basic_regex::awk, basic_regex::grep, basic_regex::egrep): Add
+	definitions.
+	* include/bits/regex_automaton.h (_NFA::_M_insert_state): Adjust
+	whitespace.
+	* testsuite/28_regex/basic_regex/85098.cc: New
+
+	Backport from mainline
+	2018-05-07  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/85671
+	* include/experimental/bits/fs_path.h (operator/): Likewise.
+
+	Backport from mainline
+	2018-06-14  Daniel Trebbien <dtrebbien@gmail.com>
+		    Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/83982
+	* include/bits/vector.tcc (vector::_M_default_append(size_type)):
+	Default-construct new elements before moving existing ones.
+	* testsuite/23_containers/vector/capacity/resize/strong_guarantee.cc:
+	New.
+
+	Backport from mainline
+	2018-05-03  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/84087 LWG DR 2268 basic_string default arguments
+	* include/bits/basic_string.h [_GLIBCXX_USE_CXX11_ABI=1]
+	(append(const basic_string&, size_type, size_type)
+	(assign(const basic_string&, size_type, size_type)
+	(insert(size_type, const basic_string&, size_type, size_type)
+	(replace(size_type,size_type,const basic_string&,size_type,size_type)
+	(compare(size_type,size_type,constbasic_string&,size_type,size_type)):
+	Add default arguments (LWG 2268).
+	[_GLIBCXX_USE_CXX11_ABI=0]
+	(append(const basic_string&, size_type, size_type)
+	(assign(const basic_string&, size_type, size_type)
+	(insert(size_type, const basic_string&, size_type, size_type)
+	(replace(size_type,size_type,const basic_string&,size_type,size_type)
+	(compare(size_type,size_type,constbasic_string&,size_type,size_type)):
+	Likewise.
+	* testsuite/21_strings/basic_string/dr2268.cc: New test.
+
+2018-06-22  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-04-18  David Malcolm  <dmalcolm@redhat.com>
+
+	PR jit/85384
+	* configure: Regenerate.
+
+2018-06-22  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2018-06-22  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/86138
+	* include/bits/basic_string.tcc:
+	[__cplusplus > 201402 && !_GLIBCXX_USE_CXX11_ABI]
+	(basic_string<char>::_Rep::_S_empty_rep_storage)
+	(basic_string<wchar_t>::_Rep::_S_empty_rep_storage): Add explicit
+	instantiation declarations.
+	[__cplusplus > 201402] (operator>>, operator<<, getline): Re-enable
+	explicit instantiation declarations.
+	* testsuite/21_strings/basic_string/cons/char/86138.cc: New.
+	* testsuite/21_strings/basic_string/cons/wchar_t/86138.cc: New.
+
+2018-06-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	* config/abi/post/x86_64-linux-gnu/baseline_symbols.txt: Update.
+
+2018-06-19  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/std/utility: Remove unused <exception> header.
+
+2018-06-15  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/86169
+	* include/bits/basic_string.h [!_GLIBCXX_USE_CXX11_ABI]
+	(basic_string::data()): Unshare string.
+	* testsuite/21_strings/basic_string/operations/data/char/86169.cc:
+	New.
+
+2018-06-15  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/char_traits.h (__cpp_lib_constexpr_char_traits): Only
+	define for C++17 and above.
+
+2018-05-17  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/85812
+	* libsupc++/cxxabi_init_exception.h (__cxa_free_exception): Declare.
+	* libsupc++/exception_ptr.h (make_exception_ptr) [__cpp_exceptions]:
+	Refactor to separate non-throwing and throwing implementations.
+	[__cpp_rtti && !_GLIBCXX_HAVE_CDTOR_CALLABI]: Deallocate the memory
+	if constructing the object throws.
+
+2018-05-14  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/67554
+	* include/bits/valarray_array.h (_Array_copy_ctor<_Tp, true>)
+	(_Array_copier<_Tp, true>): Do not pass null pointers to memcpy.
+
+	PR libstdc++/82966
+	* include/bits/node_handle.h (_Node_handle_common::_M_swap): Use value
+	instead of type.
+	* testsuite/23_containers/set/modifiers/node_swap.cc: New.
+
+2018-05-10  Jonathan Wakely  <jwakely@redhat.com>
+
+	* doc/xml/faq.xml: Link to C++17 status. Add note to outdated answer.
+	* doc/xml/manual/debug_mode.xml: Add array and forward_list to list
+	of C++11 containers with Debug Mode support.
+	* doc/xml/manual/using.xml: Document Dual ABI for ios_base::failure.
+	* doc/html/*: Regenerate.
+
+2018-05-07  Edward Smith-Rowland  <3dw4rd@verizon.net>
+	    Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2018-05-07  Edward Smith-Rowland  <3dw4rd@verizon.net>
+
+	PR libstdc++/80506
+	* include/bits/random.tcc (gamma_distribution::operator()): Fix magic
+	number used in loop condition.
+	(gamma_distribution::__generate_impl()): Ditto.
+
+2018-05-03  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/84769
+	* include/std/variant (visit): Qualify std::get call.
+
+	PR libstdc++/85632 use uintmax_t for arithmetic
+	* src/filesystem/ops.cc (experimental::filesystem::space): Perform
+	arithmetic in result type.
+	* testsuite/experimental/filesystem/operations/space.cc: New.
+
+2018-04-30  Edward Smith-Rowland  <3dw4rd@verizon.net>
+
+	PR libstdc++/pr66689 - comp_ellint_3 and ellint_3 return garbage values
+	* include/tr1/ell_integral.tcc: Correct the nu sign convention
+	in ellint_3 and comp_ellint_3.
+	* testsuite/tr1/5_numerical_facilities/special_functions/
+	06_comp_ellint_3/check_value.cc: Regen with correct values.
+	* testsuite/tr1/5_numerical_facilities/special_functions/
+	14_ellint_3/check_value.cc: Ditto.
+	* testsuite/special_functions/06_comp_ellint_3/check_value.cc: Ditto.
+	* testsuite/special_functions/13_ellint_3/check_value.cc: Ditto.
+	* testsuite/special_functions/06_comp_ellint_3/pr66689.cc: New.
+	* testsuite/special_functions/13_ellint_3/pr66689.cc: New.
+	* testsuite/tr1/5_numerical_facilities/special_functions/
+	06_comp_ellint_3/pr66689.cc: New.
+	* testsuite/tr1/5_numerical_facilities/special_functions/
+	14_ellint_3/pr66689.cc: New.
+
+2018-04-30  Edward Smith-Rowland  <3dw4rd@verizon.net>
+
+	PR libstdc++/68397 std::tr1::expint fails ... long double arguments.
+	* include/tr1/exp_integral.tcc: Increase iteration limits.
+	* testsuite/tr1/5_numerical_facilities/special_functions/15_expint/
+	pr68397.cc: New test.
+	* testsuite/special_functions/14_expint/pr68397.cc: New test.
+
+2018-04-18  Jonathan Wakely  <jwakely@redhat.com>
+	    Jakub Jelinek  <jakub@redhat.com>
+
+	PR libstdc++/85442
+	* src/c++11/Makefile.am: Don't generate debuginfo again for
+	cxx11-ios_failure-lt.s and cxx11-ios_failure.s files.
+	* src/c++11/Makefile.in: Regenerate.
+
+2018-04-13  Jonathan Wakely  <jwakely@redhat.com>
+
+	* src/c++11/Makefile.am: Fix sed command.
+	* src/c++11/Makefile.in: Regenerate.
+
+	* src/c++11/Makefile.am: Rewrite sed rule to be less fragile and to
+	handle mangled names starting with double underscores on darwin.
+	* src/c++11/Makefile.in: Regenerate.
+
+2018-04-12  Jonathan Wakely  <jwakely@redhat.com>
+
+	* src/c++11/Makefile.am: Fix comment.
+	* src/c++11/Makefile.in: Regenerate.
+	* src/c++11/cxx11-ios_failure.cc: Fix comment.
+	* src/c++98/ios_failure.cc: Likewise.
+
+	Backport from mainline
+	2018-04-10  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/85222
+	* src/c++11/Makefile.am [ENABLE_DUAL_ABI]: Add special rules for
+	cxx11-ios_failure.cc to rewrite type info for __ios_failure.
+	* src/c++11/Makefile.in: Regenerate.
+	* src/c++11/cxx11-ios_failure.cc (__ios_failure, __iosfail_type_info):
+	New types.
+	[_GLIBCXX_USE_DUAL_ABI] (__throw_ios_failure): Define here.
+	* src/c++11/ios.cc (__throw_ios_failure): Remove definition.
+	(_GLIBCXX_USE_CXX11_ABI): Don't define here.
+	* src/c++98/ios_failure.cc (__construct_ios_failure)
+	(__destroy_ios_failure, is_ios_failure_handler): New functions.
+	[!_GLIBCXX_USE_DUAL_ABI] (__throw_ios_failure): Define here.
+	* testsuite/27_io/ios_base/failure/dual_abi.cc: New.
+	* testsuite/27_io/basic_ios/copyfmt/char/1.cc: Revert changes to
+	handler types, to always catch std::ios_base::failure.
+	* testsuite/27_io/basic_ios/exceptions/char/1.cc: Likewise.
+	* testsuite/27_io/basic_istream/extractors_arithmetic/char/
+	exceptions_failbit.cc: Likewise.
+	* testsuite/27_io/basic_istream/extractors_arithmetic/wchar_t/
+	exceptions_failbit.cc: Likewise.
+	* testsuite/27_io/basic_istream/extractors_other/char/
+	exceptions_null.cc: Likewise.
+	* testsuite/27_io/basic_istream/extractors_other/wchar_t/
+	exceptions_null.cc: Likewise.
+	* testsuite/27_io/basic_istream/sentry/char/12297.cc: Likewise.
+	* testsuite/27_io/basic_istream/sentry/wchar_t/12297.cc: Likewise.
+	* testsuite/27_io/basic_ostream/inserters_other/char/
+	exceptions_null.cc: Likewise.
+	* testsuite/27_io/basic_ostream/inserters_other/wchar_t/
+	exceptions_null.cc: Likewise.
+	* testsuite/27_io/ios_base/storage/2.cc: Likewise.
+
+2018-03-22  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	PR libstdc++/77691
+	* testsuite/experimental/memory_resource/resource_adaptor.cc:
+	xfail execution on 32-bit Solaris/x86.
+
+2018-03-13  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2018-03-09  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/84769
+	* include/std/variant (get<_Tp, _Types...>, get_if<_Tp, _Types...>):
+	Qualify calls to get<_Np, Types...> and get_if<_Np, _Types...>.
+
+2018-03-12  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/84773
+	PR libstdc++/83662
+	* crossconfig.m4: Check for aligned_alloc etc. on freebsd and mingw32.
+	* configure: Regenerate.
+	* include/c_global/cstdlib [_GLIBCXX_HAVE_ALIGNED_ALLOC]
+	(aligned_alloc): Add using-declaration.
+	* testsuite/18_support/aligned_alloc/aligned_alloc.cc: New test.
+
+2018-03-02  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2018-03-02  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/84671
+	* include/bits/parse_numbers.h (_Number_help): Add partial
+	specialization to handle digit separators. Adjust partial
+	specialization for recursion temrination to require _Pow == 1ULL.
+	* testsuite/20_util/duration/literals/84671.cc: New
+
+2018-02-26  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2018-02-23  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/84532
+	* include/std/thread (thread::__make_invoker): Construct tuple
+	directly instead of using make_tuple.
+	* testsuite/30_threads/async/84532.cc: New.
+	* testsuite/30_threads/thread/84532.cc: New.
+
+2018-02-19  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2018-02-15  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/81797
+	* configure.ac (INCLUDE_DIR_NOTPARALLEL): Define.
+	* configure: Regenerate.
+	* include/Makefile.am (INCLUDE_DIR_NOTPARALLEL): Add .NOTPARALLEL when
+	defined.
+	* include/Makefile.in: Regenerate.
+
+2018-01-29  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/83833
+	* testsuite/26_numerics/random/chi_squared_distribution/83833.cc:
+	Add -ffloat-store to options for m68k and ia32.
+
+	PR libstdc++/83658
+	* include/std/any (any::__do_emplace): Only set _M_manager after
+	constructing the contained object.
+	* testsuite/20_util/any/misc/any_cast_neg.cc: Adjust dg-error line.
+	* testsuite/20_util/any/modifiers/83658.cc: New test.
+
+	Backport from mainline
+	2018-01-15  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/83833
+	* include/bits/random.h (chi_squared_distribution::param): Update
+	gamma distribution parameter.
+	* testsuite/26_numerics/random/chi_squared_distribution/83833.cc: New
+	test.
+
+2018-01-25  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/81076
+	* include/c_global/cstddef (__byte_operand): Define primary template.
+	* testsuite/18_support/byte/81076.cc: New test.
+
+	Backport from mainline
+	2018-01-15  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/83830
+	* include/std/type_traits (has_unique_object_representations_v): Add
+	variable template.
+	* testsuite/20_util/has_unique_object_representations/value.cc: Check
+	variable template.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
diff --git a/libstdc++-v3/acinclude.m4 b/libstdc++-v3/acinclude.m4
index 805148d3b7d..67d84472653 100644
--- a/libstdc++-v3/acinclude.m4
+++ b/libstdc++-v3/acinclude.m4
@@ -3062,7 +3062,7 @@ dnl Note: also checks that the types aren't standard types.
 dnl
 dnl Defines:
 dnl  _GLIBCXX_USE_INT128
-dnl  _GLIBCXX_USE_FLOAT128
+dnl  ENABLE_FLOAT128
 dnl
 AC_DEFUN([GLIBCXX_ENABLE_INT128_FLOAT128], [
 
@@ -3117,13 +3117,12 @@ EOF
 
     AC_MSG_CHECKING([for __float128])
     if AC_TRY_EVAL(ac_compile); then
-      AC_DEFINE(_GLIBCXX_USE_FLOAT128, 1,
-      [Define if __float128 is supported on this host.])
       enable_float128=yes
     else
       enable_float128=no
     fi
     AC_MSG_RESULT($enable_float128)
+    GLIBCXX_CONDITIONAL(ENABLE_FLOAT128, test $enable_float128 = yes)
     rm -f conftest*
 
   AC_LANG_RESTORE
diff --git a/libstdc++-v3/config.h.in b/libstdc++-v3/config.h.in
index f1527d9938b..198f69626bf 100644
--- a/libstdc++-v3/config.h.in
+++ b/libstdc++-v3/config.h.in
@@ -912,9 +912,6 @@
 /* Define if fchmodat is available in <sys/stat.h>. */
 #undef _GLIBCXX_USE_FCHMODAT
 
-/* Define if __float128 is supported on this host. */
-#undef _GLIBCXX_USE_FLOAT128
-
 /* Defined if gettimeofday is available. */
 #undef _GLIBCXX_USE_GETTIMEOFDAY
 
diff --git a/libstdc++-v3/config/abi/post/x86_64-linux-gnu/baseline_symbols.txt b/libstdc++-v3/config/abi/post/x86_64-linux-gnu/baseline_symbols.txt
index a31597e906f..06c61236f34 100644
--- a/libstdc++-v3/config/abi/post/x86_64-linux-gnu/baseline_symbols.txt
+++ b/libstdc++-v3/config/abi/post/x86_64-linux-gnu/baseline_symbols.txt
@@ -4004,6 +4004,7 @@ OBJECT:0:GLIBCXX_3.4.20
 OBJECT:0:GLIBCXX_3.4.21
 OBJECT:0:GLIBCXX_3.4.22
 OBJECT:0:GLIBCXX_3.4.23
+OBJECT:0:GLIBCXX_3.4.24
 OBJECT:0:GLIBCXX_3.4.3
 OBJECT:0:GLIBCXX_3.4.4
 OBJECT:0:GLIBCXX_3.4.5
diff --git a/libstdc++-v3/configure b/libstdc++-v3/configure
index e70fdd6421f..e1c55aa72ff 100755
--- a/libstdc++-v3/configure
+++ b/libstdc++-v3/configure
@@ -620,6 +620,8 @@ CPU_DEFINES_SRCDIR
 ATOMIC_FLAGS
 ATOMIC_WORD_SRCDIR
 ATOMICITY_SRCDIR
+INCLUDE_DIR_NOTPARALLEL_FALSE
+INCLUDE_DIR_NOTPARALLEL_TRUE
 BUILD_PDF_FALSE
 BUILD_PDF_TRUE
 PDFLATEX
@@ -726,6 +728,8 @@ BASIC_FILE_H
 CSTDIO_H
 SECTION_FLAGS
 WERROR
+ENABLE_FLOAT128_FALSE
+ENABLE_FLOAT128_TRUE
 thread_header
 glibcxx_PCHFLAGS
 GLIBCXX_BUILD_PCH_FALSE
@@ -11601,7 +11605,7 @@ else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 11604 "configure"
+#line 11608 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -11707,7 +11711,7 @@ else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 11710 "configure"
+#line 11714 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -15393,7 +15397,7 @@ $as_echo "$glibcxx_cv_atomic_long_long" >&6; }
   # Fake what AC_TRY_COMPILE does.
 
     cat > conftest.$ac_ext << EOF
-#line 15396 "configure"
+#line 15400 "configure"
 int main()
 {
   typedef bool atomic_type;
@@ -15428,7 +15432,7 @@ $as_echo "$glibcxx_cv_atomic_bool" >&6; }
     rm -f conftest*
 
     cat > conftest.$ac_ext << EOF
-#line 15431 "configure"
+#line 15435 "configure"
 int main()
 {
   typedef short atomic_type;
@@ -15463,7 +15467,7 @@ $as_echo "$glibcxx_cv_atomic_short" >&6; }
     rm -f conftest*
 
     cat > conftest.$ac_ext << EOF
-#line 15466 "configure"
+#line 15470 "configure"
 int main()
 {
   // NB: _Atomic_word not necessarily int.
@@ -15499,7 +15503,7 @@ $as_echo "$glibcxx_cv_atomic_int" >&6; }
     rm -f conftest*
 
     cat > conftest.$ac_ext << EOF
-#line 15502 "configure"
+#line 15506 "configure"
 int main()
 {
   typedef long long atomic_type;
@@ -15580,7 +15584,7 @@ $as_echo "$as_me: WARNING: Performance of certain classes will degrade as a resu
   # unnecessary for this test.
 
     cat > conftest.$ac_ext << EOF
-#line 15583 "configure"
+#line 15587 "configure"
 int main()
 {
   _Decimal32 d1;
@@ -15622,7 +15626,7 @@ ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
   # unnecessary for this test.
 
     cat > conftest.$ac_ext << EOF
-#line 15625 "configure"
+#line 15629 "configure"
 template<typename T1, typename T2>
   struct same
   { typedef T2 type; };
@@ -15656,7 +15660,7 @@ $as_echo "$enable_int128" >&6; }
     rm -f conftest*
 
     cat > conftest.$ac_ext << EOF
-#line 15659 "configure"
+#line 15663 "configure"
 template<typename T1, typename T2>
   struct same
   { typedef T2 type; };
@@ -15678,15 +15682,13 @@ $as_echo_n "checking for __float128... " >&6; }
   ac_status=$?
   $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
   test $ac_status = 0; }; then
-
-$as_echo "#define _GLIBCXX_USE_FLOAT128 1" >>confdefs.h
-
       enable_float128=yes
     else
       enable_float128=no
     fi
     { $as_echo "$as_me:${as_lineno-$LINENO}: result: $enable_float128" >&5
 $as_echo "$enable_float128" >&6; }
+
     rm -f conftest*
 
   ac_ext=c
@@ -53324,6 +53326,19 @@ if test "x$ac_cv_func___cxa_thread_atexit" = x""yes; then :
 #define HAVE___CXA_THREAD_ATEXIT 1
 _ACEOF
 
+fi
+done
+
+    for ac_func in aligned_alloc posix_memalign memalign _aligned_malloc
+do :
+  as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
+ac_fn_c_check_func "$LINENO" "$ac_func" "$as_ac_var"
+eval as_val=\$$as_ac_var
+   if test "x$as_val" = x""yes; then :
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
 fi
 done
 
@@ -66077,6 +66092,19 @@ done
 
   CXXFLAGS="$ac_save_CXXFLAGS"
 
+    for ac_func in aligned_alloc posix_memalign memalign _aligned_malloc
+do :
+  as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
+ac_fn_c_check_func "$LINENO" "$ac_func" "$as_ac_var"
+eval as_val=\$$as_ac_var
+   if test "x$as_val" = x""yes; then :
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
     ;;
   *-netbsd*)
     SECTION_FLAGS='-ffunction-sections -fdata-sections'
@@ -66244,6 +66272,19 @@ $as_echo "$ac_ld_relro" >&6; }
       $as_echo "#define HAVE_ISNANL 1" >>confdefs.h
 
     fi
+    for ac_func in aligned_alloc posix_memalign memalign _aligned_malloc
+do :
+  as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
+ac_fn_c_check_func "$LINENO" "$ac_func" "$as_ac_var"
+eval as_val=\$$as_ac_var
+   if test "x$as_val" = x""yes; then :
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
     ;;
   *-qnx6.1* | *-qnx6.2*)
     SECTION_FLAGS='-ffunction-sections -fdata-sections'
@@ -81219,6 +81260,18 @@ else
 fi
 
 
+case "$build" in
+ *-*-darwin* ) glibcxx_include_dir_notparallel=yes ;;
+ * ) glibcxx_include_dir_notparallel=no ;;
+esac
+ if test $glibcxx_include_dir_notparallel = "yes"; then
+  INCLUDE_DIR_NOTPARALLEL_TRUE=
+  INCLUDE_DIR_NOTPARALLEL_FALSE='#'
+else
+  INCLUDE_DIR_NOTPARALLEL_TRUE='#'
+  INCLUDE_DIR_NOTPARALLEL_FALSE=
+fi
+
 
 # Propagate the target-specific source directories through the build chain.
 ATOMICITY_SRCDIR=config/${atomicity_dir}
@@ -81262,6 +81315,15 @@ else
 fi
 
 
+    if test $enable_float128 = yes; then
+  ENABLE_FLOAT128_TRUE=
+  ENABLE_FLOAT128_FALSE='#'
+else
+  ENABLE_FLOAT128_TRUE='#'
+  ENABLE_FLOAT128_FALSE=
+fi
+
+
     if test $enable_libstdcxx_allocator_flag = new; then
   ENABLE_ALLOCATOR_NEW_TRUE=
   ENABLE_ALLOCATOR_NEW_FALSE='#'
@@ -81657,7 +81719,7 @@ $as_echo "$gxx_include_dir" >&6; }
 # Check whether --with-gcc-major-version-only was given.
 if test "${with_gcc_major_version_only+set}" = set; then :
   withval=$with_gcc_major_version_only; if test x$with_gcc_major_version_only = xyes ; then
-        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*\$\$/\1/'"
+        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*/\1/'"
       fi
 
 fi
@@ -81805,6 +81867,10 @@ if test -z "${GLIBCXX_BUILD_PCH_TRUE}" && test -z "${GLIBCXX_BUILD_PCH_FALSE}";
   as_fn_error "conditional \"GLIBCXX_BUILD_PCH\" was never defined.
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
 fi
+if test -z "${ENABLE_FLOAT128_TRUE}" && test -z "${ENABLE_FLOAT128_FALSE}"; then
+  as_fn_error "conditional \"ENABLE_FLOAT128\" was never defined.
+Usually this means the macro was only invoked conditionally." "$LINENO" 5
+fi
 if test -z "${ENABLE_ALLOCATOR_NEW_TRUE}" && test -z "${ENABLE_ALLOCATOR_NEW_FALSE}"; then
   as_fn_error "conditional \"ENABLE_ALLOCATOR_NEW\" was never defined.
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
@@ -81913,6 +81979,10 @@ if test -z "${BUILD_PDF_TRUE}" && test -z "${BUILD_PDF_FALSE}"; then
   as_fn_error "conditional \"BUILD_PDF\" was never defined.
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
 fi
+if test -z "${INCLUDE_DIR_NOTPARALLEL_TRUE}" && test -z "${INCLUDE_DIR_NOTPARALLEL_FALSE}"; then
+  as_fn_error "conditional \"INCLUDE_DIR_NOTPARALLEL\" was never defined.
+Usually this means the macro was only invoked conditionally." "$LINENO" 5
+fi
 
 : ${CONFIG_STATUS=./config.status}
 ac_write_fail=0
diff --git a/libstdc++-v3/configure.ac b/libstdc++-v3/configure.ac
index 8e973503be0..a7dbe5678bf 100644
--- a/libstdc++-v3/configure.ac
+++ b/libstdc++-v3/configure.ac
@@ -467,6 +467,12 @@ AM_CONDITIONAL(BUILD_PDF,
 	       test $ac_cv_prog_DBLATEX = "yes" &&
 	       test $ac_cv_prog_PDFLATEX = "yes")
 
+case "$build" in
+ *-*-darwin* ) glibcxx_include_dir_notparallel=yes ;;
+ * ) glibcxx_include_dir_notparallel=no ;;
+esac
+AM_CONDITIONAL(INCLUDE_DIR_NOTPARALLEL,
+               test $glibcxx_include_dir_notparallel = "yes")
 
 # Propagate the target-specific source directories through the build chain.
 ATOMICITY_SRCDIR=config/${atomicity_dir}
diff --git a/libstdc++-v3/configure.host b/libstdc++-v3/configure.host
index caea9de9c76..155a3cdea1b 100644
--- a/libstdc++-v3/configure.host
+++ b/libstdc++-v3/configure.host
@@ -230,16 +230,15 @@ case "${host_os}" in
     os_include_dir="os/newlib"
     OPT_LDFLAGS="${OPT_LDFLAGS} \$(lt_host_flags)"
     ;;
-  darwin | darwin[1-7] | darwin[1-7].*)
-    # On Darwin, performance is improved if libstdc++ is single-module.
-    # Up to at least 10.3.7, -flat_namespace is required for proper
-    # treatment of coalesced symbols.
+  darwin[4-7] | darwin[4-7].*)
+    # For earlier Darwin, performance is improved if libstdc++ is
+    # single-module. Up to at least 10.3.7, -flat_namespace is required
+    # for proper treatment of coalesced symbols.
     OPT_LDFLAGS="${OPT_LDFLAGS} -Wl,-single_module -Wl,-flat_namespace"
     os_include_dir="os/bsd/darwin"
     ;;
-  darwin[89] | darwin[89].* | darwin[1-9][0-9]* )
-    # On Darwin, performance is improved if libstdc++ is single-module,
-    # and on 8+ compatibility is better if not -flat_namespace.
+  darwin8 | darwin8.* )
+    # For 8+ compatibility is better if not -flat_namespace.
     OPT_LDFLAGS="${OPT_LDFLAGS} -Wl,-single_module"
     case "${host_cpu}" in
       i[34567]86 | x86_64)
@@ -248,6 +247,10 @@ case "${host_os}" in
     esac
     os_include_dir="os/bsd/darwin"
     ;;
+  darwin*)
+    # Post Darwin8, defaults should be sufficient.
+    os_include_dir="os/bsd/darwin"
+    ;;
   *djgpp*)      # leading * picks up "msdosdjgpp"
     os_include_dir="os/djgpp"
     error_constants_dir="os/djgpp"
diff --git a/libstdc++-v3/crossconfig.m4 b/libstdc++-v3/crossconfig.m4
index 77c9828fe91..830a00b5d2a 100644
--- a/libstdc++-v3/crossconfig.m4
+++ b/libstdc++-v3/crossconfig.m4
@@ -133,6 +133,7 @@ case "${host}" in
       AC_DEFINE(HAVE_ISNANL)
     fi
     AC_CHECK_FUNCS(__cxa_thread_atexit)
+    AC_CHECK_FUNCS(aligned_alloc posix_memalign memalign _aligned_malloc)
     ;;
 
   *-fuchsia*)
@@ -197,6 +198,7 @@ case "${host}" in
     GLIBCXX_CHECK_LINKER_FEATURES
     GLIBCXX_CHECK_MATH_SUPPORT
     GLIBCXX_CHECK_STDLIB_SUPPORT
+    AC_CHECK_FUNCS(aligned_alloc posix_memalign memalign _aligned_malloc)
     ;;
   *-netbsd*)
     SECTION_FLAGS='-ffunction-sections -fdata-sections'
@@ -215,6 +217,7 @@ case "${host}" in
       AC_DEFINE(HAVE_ISINFL)
       AC_DEFINE(HAVE_ISNANL)
     fi
+    AC_CHECK_FUNCS(aligned_alloc posix_memalign memalign _aligned_malloc)
     ;;
   *-qnx6.1* | *-qnx6.2*)
     SECTION_FLAGS='-ffunction-sections -fdata-sections'
diff --git a/libstdc++-v3/doc/html/faq.html b/libstdc++-v3/doc/html/faq.html
index f78d63cd61e..9e3924f8a60 100644
--- a/libstdc++-v3/doc/html/faq.html
+++ b/libstdc++-v3/doc/html/faq.html
@@ -534,14 +534,15 @@
     except for some corner cases.  Support for localization
     in <code class="classname">locale</code> may be incomplete on some non-GNU
     platforms. Also dependent on the underlying platform is support
-    for <span class="type">wchar_t</span> and <span class="type">long
-    long</span> specializations, and details of thread support.
+    for <span class="type">wchar_t</span> and <span class="type">long long</span> specializations,
+    and details of thread support.
     </p><p>    
     Long answer: See the implementation status pages for 
     <a class="link" href="manual/status.html#status.iso.1998" title="C++ 1998/2003">C++98</a>,
-    <a class="link" href="manual/status.html#status.iso.tr1" title="C++ TR1">TR1</a>, and 
-    <a class="link" href="manual/status.html#status.iso.2011" title="C++ 2011">C++11</a>.
-    <a class="link" href="manual/status.html#status.iso.2014" title="C++ 2014">C++14</a>.
+    <a class="link" href="manual/status.html#status.iso.tr1" title="C++ TR1">TR1</a>,
+    <a class="link" href="manual/status.html#status.iso.2011" title="C++ 2011">C++11</a>,
+    <a class="link" href="manual/status.html#status.iso.2014" title="C++ 2014">C++14</a>, and
+    <a class="link" href="manual/status.html#status.iso.2017" title="C++ 2017">C++17</a>.
     </p></td></tr><tr class="question"><td align="left" valign="top"><a id="faq.standard_bugs"></a><a id="q-standard_bugs"></a><p><strong>5.2.</strong></p></td><td align="left" valign="top"><p>
       Bugs in the ISO C++ language or library specification
     </p></td></tr><tr class="answer"><td align="left" valign="top"><a id="a-standard_bugs"></a></td><td align="left" valign="top"><p>
@@ -633,7 +634,7 @@
     without other drawbacks, send us a patch.
     </p></td></tr><tr class="question"><td align="left" valign="top"><a id="faq.ambiguous_overloads"></a><a id="q-ambiguous_overloads"></a><p><strong>6.3.</strong></p></td><td align="left" valign="top"><p>
       Ambiguous overloads after including an old-style header
-    </p></td></tr><tr class="answer"><td align="left" valign="top"><a id="a-ambiguous_overloads"></a></td><td align="left" valign="top"><p>
+    </p></td></tr><tr class="answer"><td align="left" valign="top"><a id="a-ambiguous_overloads"></a></td><td align="left" valign="top"><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>This answer is old and probably no longer be relevant.</p></div><p>
     Another problem is the <code class="literal">rel_ops</code> namespace and the template
     comparison operator functions contained therein.  If they become
     visible in the same namespace as other comparison functions
diff --git a/libstdc++-v3/doc/html/manual/debug_mode_using.html b/libstdc++-v3/doc/html/manual/debug_mode_using.html
index 99142903dfb..e4f7ea54d22 100644
--- a/libstdc++-v3/doc/html/manual/debug_mode_using.html
+++ b/libstdc++-v3/doc/html/manual/debug_mode_using.html
@@ -20,4 +20,4 @@
   containers:
 </p><div class="table"><a id="table.debug_mode_containers"></a><p class="title"><strong>Table 17.1. Debugging Containers</strong></p><div class="table-contents"><table class="table" summary="Debugging Containers" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /><col align="left" class="c4" /></colgroup><thead><tr><th align="left">Container</th><th align="left">Header</th><th align="left">Debug container</th><th align="left">Debug header</th></tr></thead><tbody><tr><td align="left"><code class="classname">std::bitset</code></td><td align="left"><code class="filename">bitset</code></td><td align="left"><code class="classname">__gnu_debug::bitset</code></td><td align="left"><code class="filename">&lt;debug/bitset&gt;</code></td></tr><tr><td align="left"><code class="classname">std::deque</code></td><td align="left"><code class="filename">deque</code></td><td align="left"><code class="classname">__gnu_debug::deque</code></td><td align="left"><code class="filename">&lt;debug/deque&gt;</code></td></tr><tr><td align="left"><code class="classname">std::list</code></td><td align="left"><code class="filename">list</code></td><td align="left"><code class="classname">__gnu_debug::list</code></td><td align="left"><code class="filename">&lt;debug/list&gt;</code></td></tr><tr><td align="left"><code class="classname">std::map</code></td><td align="left"><code class="filename">map</code></td><td align="left"><code class="classname">__gnu_debug::map</code></td><td align="left"><code class="filename">&lt;debug/map&gt;</code></td></tr><tr><td align="left"><code class="classname">std::multimap</code></td><td align="left"><code class="filename">map</code></td><td align="left"><code class="classname">__gnu_debug::multimap</code></td><td align="left"><code class="filename">&lt;debug/map&gt;</code></td></tr><tr><td align="left"><code class="classname">std::multiset</code></td><td align="left"><code class="filename">set</code></td><td align="left"><code class="classname">__gnu_debug::multiset</code></td><td align="left"><code class="filename">&lt;debug/set&gt;</code></td></tr><tr><td align="left"><code class="classname">std::set</code></td><td align="left"><code class="filename">set</code></td><td align="left"><code class="classname">__gnu_debug::set</code></td><td align="left"><code class="filename">&lt;debug/set&gt;</code></td></tr><tr><td align="left"><code class="classname">std::string</code></td><td align="left"><code class="filename">string</code></td><td align="left"><code class="classname">__gnu_debug::string</code></td><td align="left"><code class="filename">&lt;debug/string&gt;</code></td></tr><tr><td align="left"><code class="classname">std::wstring</code></td><td align="left"><code class="filename">string</code></td><td align="left"><code class="classname">__gnu_debug::wstring</code></td><td align="left"><code class="filename">&lt;debug/string&gt;</code></td></tr><tr><td align="left"><code class="classname">std::basic_string</code></td><td align="left"><code class="filename">string</code></td><td align="left"><code class="classname">__gnu_debug::basic_string</code></td><td align="left"><code class="filename">&lt;debug/string&gt;</code></td></tr><tr><td align="left"><code class="classname">std::vector</code></td><td align="left"><code class="filename">vector</code></td><td align="left"><code class="classname">__gnu_debug::vector</code></td><td align="left"><code class="filename">&lt;debug/vector&gt;</code></td></tr></tbody></table></div></div><br class="table-break" /><p>In addition, when compiling in C++11 mode, these additional
 containers have additional debug capability.
-</p><div class="table"><a id="table.debug_mode_containers_cxx11"></a><p class="title"><strong>Table 17.2. Debugging Containers C++11</strong></p><div class="table-contents"><table class="table" summary="Debugging Containers C++11" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /><col align="left" class="c4" /></colgroup><thead><tr><th align="left">Container</th><th align="left">Header</th><th align="left">Debug container</th><th align="left">Debug header</th></tr></thead><tbody><tr><td align="left"><code class="classname">std::unordered_map</code></td><td align="left"><code class="filename">unordered_map</code></td><td align="left"><code class="classname">__gnu_debug::unordered_map</code></td><td align="left"><code class="filename">&lt;debug/unordered_map&gt;</code></td></tr><tr><td align="left"><code class="classname">std::unordered_multimap</code></td><td align="left"><code class="filename">unordered_map</code></td><td align="left"><code class="classname">__gnu_debug::unordered_multimap</code></td><td align="left"><code class="filename">&lt;debug/unordered_map&gt;</code></td></tr><tr><td align="left"><code class="classname">std::unordered_set</code></td><td align="left"><code class="filename">unordered_set</code></td><td align="left"><code class="classname">__gnu_debug::unordered_set</code></td><td align="left"><code class="filename">&lt;debug/unordered_set&gt;</code></td></tr><tr><td align="left"><code class="classname">std::unordered_multiset</code></td><td align="left"><code class="filename">unordered_set</code></td><td align="left"><code class="classname">__gnu_debug::unordered_multiset</code></td><td align="left"><code class="filename">&lt;debug/unordered_set&gt;</code></td></tr></tbody></table></div></div><br class="table-break" /></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="debug_mode_semantics.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="debug_mode.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="debug_mode_design.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Semantics </td><td width="20%" align="center"><a accesskey="h" href="../index.html">Home</a></td><td width="40%" align="right" valign="top"> Design</td></tr></table></div></body></html>
\ No newline at end of file
+</p><div class="table"><a id="table.debug_mode_containers_cxx11"></a><p class="title"><strong>Table 17.2. Debugging Containers C++11</strong></p><div class="table-contents"><table class="table" summary="Debugging Containers C++11" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /><col align="left" class="c4" /></colgroup><thead><tr><th align="left">Container</th><th align="left">Header</th><th align="left">Debug container</th><th align="left">Debug header</th></tr></thead><tbody><tr><td align="left"><code class="classname">std::array</code></td><td align="left"><code class="filename">array</code></td><td align="left"><code class="classname">__gnu_debug::array</code></td><td align="left"><code class="filename">&lt;debug/array&gt;</code></td></tr><tr><td align="left"><code class="classname">std::forward_list</code></td><td align="left"><code class="filename">forward_list</code></td><td align="left"><code class="classname">__gnu_debug::forward_list</code></td><td align="left"><code class="filename">&lt;debug/forward_list&gt;</code></td></tr><tr><td align="left"><code class="classname">std::unordered_map</code></td><td align="left"><code class="filename">unordered_map</code></td><td align="left"><code class="classname">__gnu_debug::unordered_map</code></td><td align="left"><code class="filename">&lt;debug/unordered_map&gt;</code></td></tr><tr><td align="left"><code class="classname">std::unordered_multimap</code></td><td align="left"><code class="filename">unordered_map</code></td><td align="left"><code class="classname">__gnu_debug::unordered_multimap</code></td><td align="left"><code class="filename">&lt;debug/unordered_map&gt;</code></td></tr><tr><td align="left"><code class="classname">std::unordered_set</code></td><td align="left"><code class="filename">unordered_set</code></td><td align="left"><code class="classname">__gnu_debug::unordered_set</code></td><td align="left"><code class="filename">&lt;debug/unordered_set&gt;</code></td></tr><tr><td align="left"><code class="classname">std::unordered_multiset</code></td><td align="left"><code class="filename">unordered_set</code></td><td align="left"><code class="classname">__gnu_debug::unordered_multiset</code></td><td align="left"><code class="filename">&lt;debug/unordered_set&gt;</code></td></tr></tbody></table></div></div><br class="table-break" /></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="debug_mode_semantics.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="debug_mode.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="debug_mode_design.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Semantics </td><td width="20%" align="center"><a accesskey="h" href="../index.html">Home</a></td><td width="40%" align="right" valign="top"> Design</td></tr></table></div></body></html>
\ No newline at end of file
diff --git a/libstdc++-v3/doc/html/manual/index.html b/libstdc++-v3/doc/html/manual/index.html
index ec39379387d..b653fc2ae69 100644
--- a/libstdc++-v3/doc/html/manual/index.html
+++ b/libstdc++-v3/doc/html/manual/index.html
@@ -149,7 +149,7 @@ Support for C++11 dialect.
 	  </a></dt><dt>22.10. <a href="policy_data_structures_design.html#id-1.3.5.9.4.3.3.3.23">Non-unique Mapping Containers</a></dt><dt>22.11. <a href="policy_data_structures_design.html#id-1.3.5.9.4.3.4.3.5">Point Iterator Hierarchy</a></dt><dt>22.12. <a href="policy_data_structures_design.html#id-1.3.5.9.4.3.4.4.5">Invalidation Guarantee Tags Hierarchy</a></dt><dt>22.13. <a href="policy_data_structures_design.html#id-1.3.5.9.4.3.5.7.4">Container Tag Hierarchy</a></dt><dt>22.14. <a href="policy_data_structures_design.html#id-1.3.5.9.4.4.2.3.2.2.3">Hash functions, ranged-hash functions, and
 	      range-hashing functions</a></dt><dt>22.15. <a href="policy_data_structures_design.html#id-1.3.5.9.4.4.2.3.2.5.3.4">Insert hash sequence diagram</a></dt><dt>22.16. <a href="policy_data_structures_design.html#id-1.3.5.9.4.4.2.3.2.5.3.6">Insert hash sequence diagram with a null policy</a></dt><dt>22.17. <a href="policy_data_structures_design.html#id-1.3.5.9.4.4.2.3.2.5.5.5">Hash policy class diagram</a></dt><dt>22.18. <a href="policy_data_structures_design.html#id-1.3.5.9.4.4.2.3.3.4.7">Balls and bins</a></dt><dt>22.19. <a href="policy_data_structures_design.html#id-1.3.5.9.4.4.2.3.3.5.3.6">Insert resize sequence diagram</a></dt><dt>22.20. <a href="policy_data_structures_design.html#id-1.3.5.9.4.4.2.3.3.5.3.9">Standard resize policy trigger sequence
 		diagram</a></dt><dt>22.21. <a href="policy_data_structures_design.html#id-1.3.5.9.4.4.2.3.3.5.3.10">Standard resize policy size sequence
-		diagram</a></dt><dt>22.22. <a href="policy_data_structures_design.html#id-1.3.5.9.4.4.3.3.2.5">Tree node invariants</a></dt><dt>22.23. <a href="policy_data_structures_design.html#id-1.3.5.9.4.4.3.3.2.8">Tree node invalidation</a></dt><dt>22.24. <a href="policy_data_structures_design.html#id-1.3.5.9.4.4.3.3.2.11.3">A tree and its update policy</a></dt><dt>22.25. <a href="policy_data_structures_design.html#id-1.3.5.9.4.4.3.3.2.11.8">Restoring node invariants</a></dt><dt>22.26. <a href="policy_data_structures_design.html#id-1.3.5.9.4.4.3.3.2.11.10">Insert update sequence</a></dt><dt>22.27. <a href="policy_data_structures_design.html#id-1.3.5.9.4.4.3.3.2.11.20">Useless update path</a></dt><dt>22.28. <a href="policy_data_structures_design.html#id-1.3.5.9.4.4.4.3.2.10">A PATRICIA trie</a></dt><dt>22.29. <a href="policy_data_structures_design.html#id-1.3.5.9.4.4.4.3.3.5">A trie and its update policy</a></dt><dt>22.30. <a href="policy_data_structures_design.html#id-1.3.5.9.4.4.5.3.3.3">A simple list</a></dt><dt>22.31. <a href="policy_data_structures_design.html#id-1.3.5.9.4.4.5.3.3.6">The counter algorithm</a></dt><dt>22.32. <a href="policy_data_structures_design.html#id-1.3.5.9.4.4.6.3.3.3">Underlying Priority-Queue Data-Structures.</a></dt><dt>22.33. <a href="policy_data_structures_design.html#id-1.3.5.9.4.4.6.3.4.4">Priority-Queue Data-Structure Tags.</a></dt><dt>B.1. <a href="appendix_porting.html#fig.build_hacking.deps">Configure and Build File Dependencies</a></dt></dl></div><div class="list-of-tables"><p><strong>List of Tables</strong></p><dl><dt>1.1. <a href="status.html#table.cxx98_status">C++ 1998/2003 Implementation Status</a></dt><dt>1.2. <a href="status.html#table.cxx11_status">C++ 2011 Implementation Status</a></dt><dt>1.3. <a href="status.html#table.cxx14_status">C++ 2014 Implementation Status</a></dt><dt>1.4. <a href="status.html#table.ts_status">C++ Technical Specifications Implementation Status</a></dt><dt>1.5. <a href="status.html#table.cxx17_status">C++ 2017 Implementation Status</a></dt><dt>1.6. <a href="status.html#table.cxx17_ts_status">C++ Technical Specifications Implementation Status</a></dt><dt>1.7. <a href="status.html#table.tr1_status">C++ TR1 Implementation Status</a></dt><dt>1.8. <a href="status.html#table.decfp_status">C++ TR 24733 Implementation Status</a></dt><dt>1.9. <a href="status.html#table.specfun_status">C++ Special Functions Implementation Status</a></dt><dt>3.1. <a href="using.html#table.cmd_options">C++ Command Options</a></dt><dt>3.2. <a href="using_headers.html#table.cxx98_headers">C++ 1998 Library Headers</a></dt><dt>3.3. <a href="using_headers.html#table.cxx98_cheaders">C++ 1998 Library Headers for C Library Facilities</a></dt><dt>3.4. <a href="using_headers.html#table.cxx11_headers">C++ 2011 Library Headers</a></dt><dt>3.5. <a href="using_headers.html#table.cxx11_cheaders">C++ 2011 Library Headers for C Library Facilities</a></dt><dt>3.6. <a href="using_headers.html#table.tr1_headers">C++ TR 1 Library Headers</a></dt><dt>3.7. <a href="using_headers.html#table.tr1_cheaders">C++ TR 1 Library Headers for C Library Facilities</a></dt><dt>3.8. <a href="using_headers.html#table.decfp_headers">C++ TR 24733 Decimal Floating-Point Header</a></dt><dt>3.9. <a href="using_headers.html#table.abi_headers">C++ ABI Headers</a></dt><dt>3.10. <a href="using_headers.html#table.ext_headers">Extension Headers</a></dt><dt>3.11. <a href="using_headers.html#table.debug_headers">Extension Debug Headers</a></dt><dt>3.12. <a href="using_headers.html#table.profile_headers">Extension Profile Headers</a></dt><dt>3.13. <a href="using_headers.html#table.parallel_headers">Extension Parallel Headers</a></dt><dt>17.1. <a href="debug_mode_using.html#table.debug_mode_containers">Debugging Containers</a></dt><dt>17.2. <a href="debug_mode_using.html#table.debug_mode_containers_cxx11">Debugging Containers C++11</a></dt><dt>18.1. <a href="parallel_mode_using.html#table.parallel_algos">Parallel Algorithms</a></dt><dt>19.1. <a href="profile_mode_design.html#table.profile_code_loc">Profile Code Location</a></dt><dt>19.2. <a href="profile_mode_diagnostics.html#table.profile_diagnostics">Profile Diagnostics</a></dt><dt>21.1. <a href="bitmap_allocator_impl.html#table.bitmap_alloc">Bitmap Allocator Memory Map</a></dt><dt>B.1. <a href="documentation_hacking.html#table.doxygen_prereq">Doxygen Prerequisites</a></dt><dt>B.2. <a href="documentation_hacking.html#table.doxygen_cmp">HTML to Doxygen Markup Comparison</a></dt><dt>B.3. <a href="documentation_hacking.html#table.docbook_prereq">Docbook Prerequisites</a></dt><dt>B.4. <a href="documentation_hacking.html#table.docbook_cmp">HTML to Docbook XML Markup Comparison</a></dt><dt>B.5. <a href="documentation_hacking.html#table.docbook_elem">Docbook XML Element Use</a></dt><dt>B.6. <a href="api.html#table.extension_allocators">Extension Allocators</a></dt><dt>B.7. <a href="api.html#table.extension_allocators2">Extension Allocators Continued</a></dt></dl></div><div class="list-of-equations"><p><strong>List of Equations</strong></p><dl><dt>22.1. <a href="policy_data_structures_design.html#id-1.3.5.9.4.4.2.3.2.2.15">Ranged Hash Function</a></dt><dt>22.2. <a href="policy_data_structures_design.html#id-1.3.5.9.4.4.2.3.2.3.3">Range-Hashing, Division Method</a></dt><dt>22.3. <a href="policy_data_structures_design.html#id-1.3.5.9.4.4.2.3.2.3.9">Division via Prime Modulo</a></dt><dt>22.4. <a href="policy_data_structures_design.html#id-1.3.5.9.4.4.2.3.2.3.11">Division via Bit Mask</a></dt><dt>22.5. <a href="policy_data_structures_design.html#id-1.3.5.9.4.4.2.3.2.4.7">
+		diagram</a></dt><dt>22.22. <a href="policy_data_structures_design.html#id-1.3.5.9.4.4.3.3.2.5">Tree node invariants</a></dt><dt>22.23. <a href="policy_data_structures_design.html#id-1.3.5.9.4.4.3.3.2.8">Tree node invalidation</a></dt><dt>22.24. <a href="policy_data_structures_design.html#id-1.3.5.9.4.4.3.3.2.11.3">A tree and its update policy</a></dt><dt>22.25. <a href="policy_data_structures_design.html#id-1.3.5.9.4.4.3.3.2.11.8">Restoring node invariants</a></dt><dt>22.26. <a href="policy_data_structures_design.html#id-1.3.5.9.4.4.3.3.2.11.10">Insert update sequence</a></dt><dt>22.27. <a href="policy_data_structures_design.html#id-1.3.5.9.4.4.3.3.2.11.20">Useless update path</a></dt><dt>22.28. <a href="policy_data_structures_design.html#id-1.3.5.9.4.4.4.3.2.10">A PATRICIA trie</a></dt><dt>22.29. <a href="policy_data_structures_design.html#id-1.3.5.9.4.4.4.3.3.5">A trie and its update policy</a></dt><dt>22.30. <a href="policy_data_structures_design.html#id-1.3.5.9.4.4.5.3.3.3">A simple list</a></dt><dt>22.31. <a href="policy_data_structures_design.html#id-1.3.5.9.4.4.5.3.3.6">The counter algorithm</a></dt><dt>22.32. <a href="policy_data_structures_design.html#id-1.3.5.9.4.4.6.3.3.3">Underlying Priority-Queue Data-Structures.</a></dt><dt>22.33. <a href="policy_data_structures_design.html#id-1.3.5.9.4.4.6.3.4.4">Priority-Queue Data-Structure Tags.</a></dt><dt>B.1. <a href="appendix_porting.html#fig.build_hacking.deps">Configure and Build File Dependencies</a></dt></dl></div><div class="list-of-tables"><p><strong>List of Tables</strong></p><dl><dt>1.1. <a href="status.html#table.cxx98_status">C++ 1998/2003 Implementation Status</a></dt><dt>1.2. <a href="status.html#table.cxx11_status">C++ 2011 Implementation Status</a></dt><dt>1.3. <a href="status.html#table.cxx14_status">C++ 2014 Implementation Status</a></dt><dt>1.4. <a href="status.html#table.ts_status">C++ Technical Specifications Implementation Status</a></dt><dt>1.5. <a href="status.html#table.cxx17_status">C++ 2017 Implementation Status</a></dt><dt>1.6. <a href="status.html#table.cxx17_ts_status">C++ Technical Specifications Implementation Status</a></dt><dt>1.7. <a href="status.html#table.tr1_status">C++ TR1 Implementation Status</a></dt><dt>1.8. <a href="status.html#table.decfp_status">C++ TR 24733 Implementation Status</a></dt><dt>1.9. <a href="status.html#table.specfun_status">C++ Special Functions Implementation Status</a></dt><dt>3.1. <a href="using.html#table.cmd_options">C++ Command Options</a></dt><dt>3.2. <a href="using_headers.html#table.cxx98_headers">C++ 1998 Library Headers</a></dt><dt>3.3. <a href="using_headers.html#table.cxx98_cheaders">C++ 1998 Library Headers for C Library Facilities</a></dt><dt>3.4. <a href="using_headers.html#table.cxx98_deprheaders">C++ 1998 Deprecated Library Header</a></dt><dt>3.5. <a href="using_headers.html#table.cxx11_headers">C++ 2011 Library Headers</a></dt><dt>3.6. <a href="using_headers.html#table.cxx11_cheaders">C++ 2011 Library Headers for C Library Facilities</a></dt><dt>3.7. <a href="using_headers.html#table.cxx14_headers">C++ 2014 Library Header</a></dt><dt>3.8. <a href="using_headers.html#table.cxx17_headers">C++ 2017 Library Headers</a></dt><dt>3.9. <a href="using_headers.html#table.filesystemts_headers">File System TS Header</a></dt><dt>3.10. <a href="using_headers.html#table.libfundts_headers">Library Fundamentals TS Headers</a></dt><dt>3.11. <a href="using_headers.html#table.tr1_headers">C++ TR 1 Library Headers</a></dt><dt>3.12. <a href="using_headers.html#table.tr1_cheaders">C++ TR 1 Library Headers for C Library Facilities</a></dt><dt>3.13. <a href="using_headers.html#table.decfp_headers">C++ TR 24733 Decimal Floating-Point Header</a></dt><dt>3.14. <a href="using_headers.html#table.abi_headers">C++ ABI Headers</a></dt><dt>3.15. <a href="using_headers.html#table.ext_headers">Extension Headers</a></dt><dt>3.16. <a href="using_headers.html#table.debug_headers">Extension Debug Headers</a></dt><dt>3.17. <a href="using_headers.html#table.profile_headers">Extension Profile Headers</a></dt><dt>3.18. <a href="using_headers.html#table.parallel_headers">Extension Parallel Headers</a></dt><dt>17.1. <a href="debug_mode_using.html#table.debug_mode_containers">Debugging Containers</a></dt><dt>17.2. <a href="debug_mode_using.html#table.debug_mode_containers_cxx11">Debugging Containers C++11</a></dt><dt>18.1. <a href="parallel_mode_using.html#table.parallel_algos">Parallel Algorithms</a></dt><dt>19.1. <a href="profile_mode_design.html#table.profile_code_loc">Profile Code Location</a></dt><dt>19.2. <a href="profile_mode_diagnostics.html#table.profile_diagnostics">Profile Diagnostics</a></dt><dt>21.1. <a href="bitmap_allocator_impl.html#table.bitmap_alloc">Bitmap Allocator Memory Map</a></dt><dt>B.1. <a href="documentation_hacking.html#table.doxygen_prereq">Doxygen Prerequisites</a></dt><dt>B.2. <a href="documentation_hacking.html#table.doxygen_cmp">HTML to Doxygen Markup Comparison</a></dt><dt>B.3. <a href="documentation_hacking.html#table.docbook_prereq">Docbook Prerequisites</a></dt><dt>B.4. <a href="documentation_hacking.html#table.docbook_cmp">HTML to Docbook XML Markup Comparison</a></dt><dt>B.5. <a href="documentation_hacking.html#table.docbook_elem">Docbook XML Element Use</a></dt><dt>B.6. <a href="api.html#table.extension_allocators">Extension Allocators</a></dt><dt>B.7. <a href="api.html#table.extension_allocators2">Extension Allocators Continued</a></dt></dl></div><div class="list-of-equations"><p><strong>List of Equations</strong></p><dl><dt>22.1. <a href="policy_data_structures_design.html#id-1.3.5.9.4.4.2.3.2.2.15">Ranged Hash Function</a></dt><dt>22.2. <a href="policy_data_structures_design.html#id-1.3.5.9.4.4.2.3.2.3.3">Range-Hashing, Division Method</a></dt><dt>22.3. <a href="policy_data_structures_design.html#id-1.3.5.9.4.4.2.3.2.3.9">Division via Prime Modulo</a></dt><dt>22.4. <a href="policy_data_structures_design.html#id-1.3.5.9.4.4.2.3.2.3.11">Division via Bit Mask</a></dt><dt>22.5. <a href="policy_data_structures_design.html#id-1.3.5.9.4.4.2.3.2.4.7">
 		A Standard String Hash Function
 	      </a></dt><dt>22.6. <a href="policy_data_structures_design.html#id-1.3.5.9.4.4.2.3.2.4.12">
 		Only k String DNA Hash
diff --git a/libstdc++-v3/doc/html/manual/status.html b/libstdc++-v3/doc/html/manual/status.html
index ad4134ed55f..014760a2f64 100644
--- a/libstdc++-v3/doc/html/manual/status.html
+++ b/libstdc++-v3/doc/html/manual/status.html
@@ -117,6 +117,9 @@ This page describes the C++ support in the GCC 7 series.
    </p><p><span class="emphasis"><em>[22.*]</em></span> Anything and everything we have on locale
       implementation will be described under
       <a class="link" href="localization.html#std.localization.locales.locale" title="locale">Localization</a>.
+   </p><p><span class="emphasis"><em>[23.*]</em></span> All of the containers in this clause
+     define <span class="type">size_type</span> as <span class="type">std::size_t</span> and
+     <span class="type">difference_type</span> as <span class="type">std::ptrdiff_t</span>.
    </p><p><span class="emphasis"><em>[26.2.8]/9</em></span> I have no idea what
       <code class="code">complex&lt;T&gt;</code>'s <code class="code">pow(0,0)</code> returns.
    </p><p><span class="emphasis"><em>[27.4.2.4]/2</em></span> Calling
diff --git a/libstdc++-v3/doc/html/manual/test.html b/libstdc++-v3/doc/html/manual/test.html
index aed5a320b56..0d419b8f00b 100644
--- a/libstdc++-v3/doc/html/manual/test.html
+++ b/libstdc++-v3/doc/html/manual/test.html
@@ -456,12 +456,15 @@ cat 27_io/objects/char/3_xin.in | a.out</pre></dd><dt><span class="term"><code c
     possible variations.
   </p><p>
     Similarly, tests which depend on a newer standard than the default
-    should use <code class="literal">dg-options</code> instead of an effective target,
-    so that they are not skipped by default.
+    must use <code class="literal">dg-options</code> instead of (or in addition to)
+    an effective target, so that they are not skipped by default.
     For example, tests for C++17 features should use
 </p><pre class="programlisting">    // { dg-options "-std=gnu++17" }</pre><p>
-    and not
-</p><pre class="programlisting">    // { dg-do run "c++1z" }</pre><p>
+    before any <code class="literal">dg-do</code> such as:
+</p><pre class="programlisting">    // { dg-do run "c++17" }</pre><p>
+    The <code class="literal">dg-options</code> directive must come first, so that
+    the <code class="literal">-std</code> flag has already been added to the options
+    before checking the <code class="literal">c++17</code> target.
   </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="tests.dg.examples"></a>Examples of Test Directives</h4></div></div></div><p>
 Example 1: Testing compilation only:
 </p><pre class="programlisting">
diff --git a/libstdc++-v3/doc/html/manual/using_dual_abi.html b/libstdc++-v3/doc/html/manual/using_dual_abi.html
index 4a62c0267be..916ac575f64 100644
--- a/libstdc++-v3/doc/html/manual/using_dual_abi.html
+++ b/libstdc++-v3/doc/html/manual/using_dual_abi.html
@@ -14,7 +14,7 @@
   for the new implementations have different names the definitions for both
   versions can be present in the same library.
 </p><p> The <span class="symbol">_GLIBCXX_USE_CXX11_ABI</span> macro (see
-<a class="xref" href="using_macros.html" title="Macros">Macros</a>) controls whether
+  <a class="xref" href="using_macros.html" title="Macros">Macros</a>) controls whether
   the declarations in the library headers use the old or new ABI.
   So the decision of which ABI to use can be made separately for each
   source file being compiled.
@@ -43,10 +43,35 @@
   facet that derives from one or other version of
   <code class="classname">time_get</code> is installed in the locale).
 </p><p> Although the standard exception types defined in
-  <code class="filename">&lt;stdexcept&gt;</code> use strings, they
+  <code class="filename">&lt;stdexcept&gt;</code> use strings, most
   are not defined twice, so that a <code class="classname">std::out_of_range</code>
   exception thrown in one file can always be caught by a suitable handler in
   another file, even if the two files are compiled with different ABIs.
+</p><p> One exception type does change when using the new ABI, namely
+  <code class="classname">std::ios_base::failure</code>.
+  This is necessary because the 2011 standard changed its base class from
+  <code class="classname">std::exception</code> to
+  <code class="classname">std::system_error</code>, which causes its layout to change.
+  Exceptions due to iostream errors are thrown by a function inside
+  <code class="filename">libstdc++.so</code>, so whether the thrown
+  exception uses the old <code class="classname">std::ios_base::failure</code> type
+  or the new one depends on the ABI that was active when
+  <code class="filename">libstdc++.so</code> was built,
+  <span class="emphasis"><em>not</em></span> the ABI active in the user code that is using
+  iostreams.
+  This means that for a given build of GCC the type thrown is fixed.
+  In current releases the library throws a special type that can be caught
+  by handlers for either the old or new type,
+  but for GCC 7.1, 7.2 and 7.3 the library throws the new
+  <code class="classname">std::ios_base::failure</code> type,
+  and for GCC 5.x and 6.x the library throws the old type.
+  Catch handlers of type <code class="classname">std::ios_base::failure</code>
+  will only catch the exceptions if using a newer release,
+  or if the handler is compiled with the same ABI as the type thrown by
+  the library.
+  Handlers for <code class="classname">std::exception</code> will always catch
+  iostreams exceptions, because the old and new type both inherit from
+  <code class="classname">std::exception</code>.
 </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="manual.intro.using.abi.trouble"></a>Troubleshooting</h3></div></div></div><p> If you get linker errors about undefined references to symbols
   that involve types in the <code class="code">std::__cxx11</code> namespace or the tag
   <code class="code">[abi:cxx11]</code> then it probably indicates that you are trying to
diff --git a/libstdc++-v3/doc/html/manual/using_headers.html b/libstdc++-v3/doc/html/manual/using_headers.html
index a25323d40ec..836716fb52e 100644
--- a/libstdc++-v3/doc/html/manual/using_headers.html
+++ b/libstdc++-v3/doc/html/manual/using_headers.html
@@ -4,7 +4,7 @@
      must be available to all hosted implementations.  Actually, the
      word "files" is a misnomer, since the contents of the
      headers don't necessarily have to be in any kind of external
-     file.  The only rule is that when one <code class="code">#include</code>'s a
+     file.  The only rule is that when one <code class="code">#include</code>s a
      header, the contents of that header become available, no matter
      how.
    </p><p>
@@ -12,25 +12,71 @@
    </p><p>
      There are two main types of include files: header files related
      to a specific version of the ISO C++ standard (called Standard
-     Headers), and all others (TR1, C++ ABI, and Extensions).
+     Headers), and all others (TS, TR1, C++ ABI, and Extensions).
    </p><p>
-     Two dialects of standard headers are supported, corresponding to
-     the 1998 standard as updated for 2003, and the current 2011 standard.
+     Multiple dialects of standard headers are supported, corresponding to
+     the 1998 standard as updated for 2003, the 2011 standard, the 2014
+     standard, and so on.
    </p><p>
-     C++98/03 include files. These are available in the default compilation mode, i.e. <code class="code">-std=c++98</code> or <code class="code">-std=gnu++98</code>.
-   </p><div class="table"><a id="table.cxx98_headers"></a><p class="title"><strong>Table 3.2. C++ 1998 Library Headers</strong></p><div class="table-contents"><table class="table" summary="C++ 1998 Library Headers" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /><col align="left" class="c4" /><col align="left" class="c5" /></colgroup><tbody><tr><td align="left"><code class="filename">algorithm</code></td><td align="left"><code class="filename">bitset</code></td><td align="left"><code class="filename">complex</code></td><td align="left"><code class="filename">deque</code></td><td align="left"><code class="filename">exception</code></td></tr><tr><td align="left"><code class="filename">fstream</code></td><td align="left"><code class="filename">functional</code></td><td align="left"><code class="filename">iomanip</code></td><td align="left"><code class="filename">ios</code></td><td align="left"><code class="filename">iosfwd</code></td></tr><tr><td align="left"><code class="filename">iostream</code></td><td align="left"><code class="filename">istream</code></td><td align="left"><code class="filename">iterator</code></td><td align="left"><code class="filename">limits</code></td><td align="left"><code class="filename">list</code></td></tr><tr><td align="left"><code class="filename">locale</code></td><td align="left"><code class="filename">map</code></td><td align="left"><code class="filename">memory</code></td><td align="left"><code class="filename">new</code></td><td align="left"><code class="filename">numeric</code></td></tr><tr><td align="left"><code class="filename">ostream</code></td><td align="left"><code class="filename">queue</code></td><td align="left"><code class="filename">set</code></td><td align="left"><code class="filename">sstream</code></td><td align="left"><code class="filename">stack</code></td></tr><tr><td align="left"><code class="filename">stdexcept</code></td><td align="left"><code class="filename">streambuf</code></td><td align="left"><code class="filename">string</code></td><td align="left"><code class="filename">utility</code></td><td align="left"><code class="filename">typeinfo</code></td></tr><tr><td align="left"><code class="filename">valarray</code></td><td align="left"><code class="filename">vector</code></td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr></tbody></table></div></div><br class="table-break" /><p></p><div class="table"><a id="table.cxx98_cheaders"></a><p class="title"><strong>Table 3.3. C++ 1998 Library Headers for C Library Facilities</strong></p><div class="table-contents"><table class="table" summary="C++ 1998 Library Headers for C Library Facilities" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /><col align="left" class="c4" /><col align="left" class="c5" /></colgroup><tbody><tr><td align="left"><code class="filename">cassert</code></td><td align="left"><code class="filename">cerrno</code></td><td align="left"><code class="filename">cctype</code></td><td align="left"><code class="filename">cfloat</code></td><td align="left"><code class="filename">ciso646</code></td></tr><tr><td align="left"><code class="filename">climits</code></td><td align="left"><code class="filename">clocale</code></td><td align="left"><code class="filename">cmath</code></td><td align="left"><code class="filename">csetjmp</code></td><td align="left"><code class="filename">csignal</code></td></tr><tr><td align="left"><code class="filename">cstdarg</code></td><td align="left"><code class="filename">cstddef</code></td><td align="left"><code class="filename">cstdio</code></td><td align="left"><code class="filename">cstdlib</code></td><td align="left"><code class="filename">cstring</code></td></tr><tr><td align="left"><code class="filename">ctime</code></td><td align="left"><code class="filename">cwchar</code></td><td align="left"><code class="filename">cwctype</code></td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr></tbody></table></div></div><br class="table-break" /><p>
-C++11 include files. These are only available in C++11 compilation
+     <a class="xref" href="using_headers.html#table.cxx98_headers" title="Table 3.2. C++ 1998 Library Headers">Table 3.2, “C++ 1998 Library Headers”</a> and
+     <a class="xref" href="using_headers.html#table.cxx98_cheaders" title="Table 3.3. C++ 1998 Library Headers for C Library Facilities">Table 3.3, “C++ 1998 Library Headers for C Library Facilities”</a> and
+     <a class="xref" href="using_headers.html#table.cxx98_deprheaders" title="Table 3.4. C++ 1998 Deprecated Library Header">Table 3.4, “C++ 1998 Deprecated Library Header”</a>
+     show the C++98/03 include files.
+     These are available in the C++98 compilation mode,
+     i.e. <code class="code">-std=c++98</code> or <code class="code">-std=gnu++98</code>.
+     Unless specified otherwise below, they are also available in later modes
+     (C++11, C++14 etc).
+   </p><div class="table"><a id="table.cxx98_headers"></a><p class="title"><strong>Table 3.2. C++ 1998 Library Headers</strong></p><div class="table-contents"><table class="table" summary="C++ 1998 Library Headers" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /><col align="left" class="c4" /><col align="left" class="c5" /></colgroup><tbody><tr><td align="left"><code class="filename">algorithm</code></td><td align="left"><code class="filename">bitset</code></td><td align="left"><code class="filename">complex</code></td><td align="left"><code class="filename">deque</code></td><td align="left"><code class="filename">exception</code></td></tr><tr><td align="left"><code class="filename">fstream</code></td><td align="left"><code class="filename">functional</code></td><td align="left"><code class="filename">iomanip</code></td><td align="left"><code class="filename">ios</code></td><td align="left"><code class="filename">iosfwd</code></td></tr><tr><td align="left"><code class="filename">iostream</code></td><td align="left"><code class="filename">istream</code></td><td align="left"><code class="filename">iterator</code></td><td align="left"><code class="filename">limits</code></td><td align="left"><code class="filename">list</code></td></tr><tr><td align="left"><code class="filename">locale</code></td><td align="left"><code class="filename">map</code></td><td align="left"><code class="filename">memory</code></td><td align="left"><code class="filename">new</code></td><td align="left"><code class="filename">numeric</code></td></tr><tr><td align="left"><code class="filename">ostream</code></td><td align="left"><code class="filename">queue</code></td><td align="left"><code class="filename">set</code></td><td align="left"><code class="filename">sstream</code></td><td align="left"><code class="filename">stack</code></td></tr><tr><td align="left"><code class="filename">stdexcept</code></td><td align="left"><code class="filename">streambuf</code></td><td align="left"><code class="filename">string</code></td><td align="left"><code class="filename">utility</code></td><td align="left"><code class="filename">typeinfo</code></td></tr><tr><td align="left"><code class="filename">valarray</code></td><td align="left"><code class="filename">vector</code></td><td colspan="3" align="left"> </td></tr></tbody></table></div></div><br class="table-break" /><p></p><div class="table"><a id="table.cxx98_cheaders"></a><p class="title"><strong>Table 3.3. C++ 1998 Library Headers for C Library Facilities</strong></p><div class="table-contents"><table class="table" summary="C++ 1998 Library Headers for C Library Facilities" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /><col align="left" class="c4" /><col align="left" class="c5" /></colgroup><tbody><tr><td align="left"><code class="filename">cassert</code></td><td align="left"><code class="filename">cerrno</code></td><td align="left"><code class="filename">cctype</code></td><td align="left"><code class="filename">cfloat</code></td><td align="left"><code class="filename">ciso646</code></td></tr><tr><td align="left"><code class="filename">climits</code></td><td align="left"><code class="filename">clocale</code></td><td align="left"><code class="filename">cmath</code></td><td align="left"><code class="filename">csetjmp</code></td><td align="left"><code class="filename">csignal</code></td></tr><tr><td align="left"><code class="filename">cstdarg</code></td><td align="left"><code class="filename">cstddef</code></td><td align="left"><code class="filename">cstdio</code></td><td align="left"><code class="filename">cstdlib</code></td><td align="left"><code class="filename">cstring</code></td></tr><tr><td align="left"><code class="filename">ctime</code></td><td align="left"><code class="filename">cwchar</code></td><td align="left"><code class="filename">cwctype</code></td><td colspan="2" align="left"> </td></tr></tbody></table></div></div><br class="table-break" /><p>
+  The following header is deprecated
+  and might be removed from a future C++ standard.
+</p><div class="table"><a id="table.cxx98_deprheaders"></a><p class="title"><strong>Table 3.4. C++ 1998 Deprecated Library Header</strong></p><div class="table-contents"><table class="table" summary="C++ 1998 Deprecated Library Header" border="1"><colgroup><col align="left" class="c1" /></colgroup><tbody><tr><td align="left"><code class="filename">strstream</code></td></tr></tbody></table></div></div><br class="table-break" /><p>
+<a class="xref" href="using_headers.html#table.cxx11_headers" title="Table 3.5. C++ 2011 Library Headers">Table 3.5, “C++ 2011 Library Headers”</a> and
+<a class="xref" href="using_headers.html#table.cxx11_cheaders" title="Table 3.6. C++ 2011 Library Headers for C Library Facilities">Table 3.6, “C++ 2011 Library Headers for C Library Facilities”</a> show the C++11 include files.
+These are available in C++11 compilation
 mode, i.e. <code class="literal">-std=c++11</code> or <code class="literal">-std=gnu++11</code>.
-</p><p></p><div class="table"><a id="table.cxx11_headers"></a><p class="title"><strong>Table 3.4. C++ 2011 Library Headers</strong></p><div class="table-contents"><table class="table" summary="C++ 2011 Library Headers" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /><col align="left" class="c4" /><col align="left" class="c5" /></colgroup><tbody><tr><td align="left"><code class="filename">algorithm</code></td><td align="left"><code class="filename">array</code></td><td align="left"><code class="filename">bitset</code></td><td align="left"><code class="filename">chrono</code></td><td align="left"><code class="filename">complex</code></td></tr><tr><td align="left"><code class="filename">condition_variable</code></td><td align="left"><code class="filename">deque</code></td><td align="left"><code class="filename">exception</code></td><td align="left"><code class="filename">forward_list</code></td><td align="left"><code class="filename">fstream</code></td></tr><tr><td align="left"><code class="filename">functional</code></td><td align="left"><code class="filename">future</code></td><td align="left"><code class="filename">initalizer_list</code></td><td align="left"><code class="filename">iomanip</code></td><td align="left"><code class="filename">ios</code></td></tr><tr><td align="left"><code class="filename">iosfwd</code></td><td align="left"><code class="filename">iostream</code></td><td align="left"><code class="filename">istream</code></td><td align="left"><code class="filename">iterator</code></td><td align="left"><code class="filename">limits</code></td></tr><tr><td align="left"><code class="filename">list</code></td><td align="left"><code class="filename">locale</code></td><td align="left"><code class="filename">map</code></td><td align="left"><code class="filename">memory</code></td><td align="left"><code class="filename">mutex</code></td></tr><tr><td align="left"><code class="filename">new</code></td><td align="left"><code class="filename">numeric</code></td><td align="left"><code class="filename">ostream</code></td><td align="left"><code class="filename">queue</code></td><td align="left"><code class="filename">random</code></td></tr><tr><td align="left"><code class="filename">ratio</code></td><td align="left"><code class="filename">regex</code></td><td align="left"><code class="filename">set</code></td><td align="left"><code class="filename">sstream</code></td><td align="left"><code class="filename">stack</code></td></tr><tr><td align="left"><code class="filename">stdexcept</code></td><td align="left"><code class="filename">streambuf</code></td><td align="left"><code class="filename">string</code></td><td align="left"><code class="filename">system_error</code></td><td align="left"><code class="filename">thread</code></td></tr><tr><td align="left"><code class="filename">tuple</code></td><td align="left"><code class="filename">type_traits</code></td><td align="left"><code class="filename">typeinfo</code></td><td align="left"><code class="filename">unordered_map</code></td><td align="left"><code class="filename">unordered_set</code></td></tr><tr><td align="left"><code class="filename">utility</code></td><td align="left"><code class="filename">valarray</code></td><td align="left"><code class="filename">vector</code></td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr></tbody></table></div></div><br class="table-break" /><p></p><div class="table"><a id="table.cxx11_cheaders"></a><p class="title"><strong>Table 3.5. C++ 2011 Library Headers for C Library Facilities</strong></p><div class="table-contents"><table class="table" summary="C++ 2011 Library Headers for C Library Facilities" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /><col align="left" class="c4" /><col align="left" class="c5" /></colgroup><tbody><tr><td align="left"><code class="filename">cassert</code></td><td align="left"><code class="filename">ccomplex</code></td><td align="left"><code class="filename">cctype</code></td><td align="left"><code class="filename">cerrno</code></td><td align="left"><code class="filename">cfenv</code></td></tr><tr><td align="left"><code class="filename">cfloat</code></td><td align="left"><code class="filename">cinttypes</code></td><td align="left"><code class="filename">ciso646</code></td><td align="left"><code class="filename">climits</code></td><td align="left"><code class="filename">clocale</code></td></tr><tr><td align="left"><code class="filename">cmath</code></td><td align="left"><code class="filename">csetjmp</code></td><td align="left"><code class="filename">csignal</code></td><td align="left"><code class="filename">cstdarg</code></td><td align="left"><code class="filename">cstdbool</code></td></tr><tr><td align="left"><code class="filename">cstddef</code></td><td align="left"><code class="filename">cstdint</code></td><td align="left"><code class="filename">cstdlib</code></td><td align="left"><code class="filename">cstdio</code></td><td align="left"><code class="filename">cstring</code></td></tr><tr><td align="left"><code class="filename">ctgmath</code></td><td align="left"><code class="filename">ctime</code></td><td align="left"><code class="filename">cuchar</code></td><td align="left"><code class="filename">cwchar</code></td><td align="left"><code class="filename">cwctype</code></td></tr></tbody></table></div></div><br class="table-break" /><p>
+Including these headers in C++98/03 mode may result in compilation errors.
+Unless specified otherwise below, they are also available in later modes
+(C++14 etc).
+</p><p></p><div class="table"><a id="table.cxx11_headers"></a><p class="title"><strong>Table 3.5. C++ 2011 Library Headers</strong></p><div class="table-contents"><table class="table" summary="C++ 2011 Library Headers" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /><col align="left" class="c4" /><col align="left" class="c5" /></colgroup><tbody><tr><td align="left"><code class="filename">array</code></td><td align="left"><code class="filename">atomic</code></td><td align="left"><code class="filename">chrono</code></td><td align="left"><code class="filename">codecvt</code></td><td align="left"><code class="filename">condition_variable</code></td></tr><tr><td align="left"><code class="filename">forward_list</code></td><td align="left"><code class="filename">future</code></td><td align="left"><code class="filename">initalizer_list</code></td><td align="left"><code class="filename">mutex</code></td><td align="left"><code class="filename">random</code></td></tr><tr><td align="left"><code class="filename">ratio</code></td><td align="left"><code class="filename">regex</code></td><td align="left"><code class="filename">scoped_allocator</code></td><td align="left"><code class="filename">system_error</code></td><td align="left"><code class="filename">thread</code></td></tr><tr><td align="left"><code class="filename">tuple</code></td><td align="left"><code class="filename">typeindex</code></td><td align="left"><code class="filename">type_traits</code></td><td align="left"><code class="filename">unordered_map</code></td><td align="left"><code class="filename">unordered_set</code></td></tr></tbody></table></div></div><br class="table-break" /><p></p><div class="table"><a id="table.cxx11_cheaders"></a><p class="title"><strong>Table 3.6. C++ 2011 Library Headers for C Library Facilities</strong></p><div class="table-contents"><table class="table" summary="C++ 2011 Library Headers for C Library Facilities" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /><col align="left" class="c4" /><col align="left" class="c5" /></colgroup><tbody><tr><td align="left"><code class="filename">ccomplex</code></td><td align="left"><code class="filename">cfenv</code></td><td align="left"><code class="filename">cinttypes</code></td><td align="left"><code class="filename">cstdalign</code></td><td align="left"><code class="filename">cstdbool</code></td></tr><tr><td align="left"><code class="filename">cstdint</code></td><td align="left"><code class="filename">ctgmath</code></td><td align="left"><code class="filename">cuchar</code></td><td colspan="2" align="left"> </td></tr></tbody></table></div></div><br class="table-break" /><p>
+<a class="xref" href="using_headers.html#table.cxx14_headers" title="Table 3.7. C++ 2014 Library Header">Table 3.7, “C++ 2014 Library Header”</a> shows the C++14 include file.
+This is available in C++14 compilation
+mode, i.e. <code class="literal">-std=c++14</code> or <code class="literal">-std=gnu++14</code>.
+Including this header in C++98/03 mode or C++11 will not result in
+compilation errors, but will not define anything.
+Unless specified otherwise below, it is also available in later modes
+(C++17 etc).
+</p><p></p><div class="table"><a id="table.cxx14_headers"></a><p class="title"><strong>Table 3.7. C++ 2014 Library Header</strong></p><div class="table-contents"><table class="table" summary="C++ 2014 Library Header" border="1"><colgroup><col align="left" class="c1" /></colgroup><tbody><tr><td align="left"><code class="filename">shared_mutex</code></td></tr></tbody></table></div></div><br class="table-break" /><p>
+<a class="xref" href="using_headers.html#table.cxx17_headers" title="Table 3.8. C++ 2017 Library Headers">Table 3.8, “C++ 2017 Library Headers”</a> shows the C++17 include files.
+These are available in C++17 compilation
+mode, i.e. <code class="literal">-std=c++17</code> or <code class="literal">-std=gnu++17</code>.
+Including these headers in earlier modes will not result in
+compilation errors, but will not define anything.
+Unless specified otherwise below, they are also available in later modes
+(C++20 etc).
+</p><p></p><div class="table"><a id="table.cxx17_headers"></a><p class="title"><strong>Table 3.8. C++ 2017 Library Headers</strong></p><div class="table-contents"><table class="table" summary="C++ 2017 Library Headers" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /><col align="left" class="c4" /></colgroup><tbody><tr><td align="left"><code class="filename">any</code></td><td align="left"><code class="filename">optional</code></td><td align="left"><code class="filename">string_view</code></td><td align="left"><code class="filename">variant</code></td></tr></tbody></table></div></div><br class="table-break" /><p>
+<a class="xref" href="using_headers.html#table.filesystemts_headers" title="Table 3.9. File System TS Header">Table 3.9, “File System TS Header”</a>,
+shows the additional include file define by the
+File System Technical Specification, ISO/IEC TS 18822.
+This is available in C++11 and later compilation modes.
+Including this header in earlier modes will not result in
+compilation errors, but will not define anything.
+</p><p></p><div class="table"><a id="table.filesystemts_headers"></a><p class="title"><strong>Table 3.9. File System TS Header</strong></p><div class="table-contents"><table class="table" summary="File System TS Header" border="1"><colgroup><col align="left" class="c1" /></colgroup><tbody><tr><td align="left"><code class="filename">experimental/filesystem</code></td></tr></tbody></table></div></div><br class="table-break" /><p>
+<a class="xref" href="using_headers.html#table.libfundts_headers" title="Table 3.10. Library Fundamentals TS Headers">Table 3.10, “Library Fundamentals TS Headers”</a>,
+shows the additional include files define by the C++ Extensions for 
+Library Fundamentals Technical Specification, ISO/IEC TS 19568.
+These are available in C++14 and later compilation modes.
+Including these headers in earlier modes will not result in
+compilation errors, but will not define anything.
+</p><p></p><div class="table"><a id="table.libfundts_headers"></a><p class="title"><strong>Table 3.10. Library Fundamentals TS Headers</strong></p><div class="table-contents"><table class="table" summary="Library Fundamentals TS Headers" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /><col align="left" class="c4" /><col align="left" class="c5" /></colgroup><tbody><tr><td align="left"><code class="filename">experimental/algorithm</code></td><td align="left"><code class="filename">experimental/any</code></td><td align="left"><code class="filename">experimental/array</code></td><td align="left"><code class="filename">experimental/chrono</code></td><td align="left"><code class="filename">experimental/deque</code></td></tr><tr><td align="left"><code class="filename">experimental/forward_list</code></td><td align="left"><code class="filename">experimental/functional</code></td><td align="left"><code class="filename">experimental/iterator</code></td><td align="left"><code class="filename">experimental/list</code></td><td align="left"><code class="filename">experimental/map</code></td></tr><tr><td align="left"><code class="filename">experimental/memory</code></td><td align="left"><code class="filename">experimental/memory_resource</code></td><td align="left"><code class="filename">experimental/numeric</code></td><td align="left"><code class="filename">experimental/optional</code></td><td align="left"><code class="filename">experimental/propagate_const</code></td></tr><tr><td align="left"><code class="filename">experimental/random</code></td><td align="left"><code class="filename">experimental/ratio</code></td><td align="left"><code class="filename">experimental/regex</code></td><td align="left"><code class="filename">experimental/set</code></td><td align="left"><code class="filename">experimental/source_location</code></td></tr><tr><td align="left"><code class="filename">experimental/string</code></td><td align="left"><code class="filename">experimental/string_view</code></td><td align="left"><code class="filename">experimental/system_error</code></td><td align="left"><code class="filename">experimental/tuple</code></td><td align="left"><code class="filename">experimental/type_traits</code></td></tr><tr><td align="left"><code class="filename">experimental/unordered_map</code></td><td align="left"><code class="filename">experimental/unordered_set</code></td><td align="left"><code class="filename">experimental/utility</code></td><td align="left"><code class="filename">experimental/vector</code></td><td align="left"> </td></tr></tbody></table></div></div><br class="table-break" /><p>
   In addition, TR1 includes as:
-</p><div class="table"><a id="table.tr1_headers"></a><p class="title"><strong>Table 3.6. C++ TR 1 Library Headers</strong></p><div class="table-contents"><table class="table" summary="C++ TR 1 Library Headers" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /><col align="left" class="c4" /><col align="left" class="c5" /></colgroup><tbody><tr><td align="left"><code class="filename">tr1/array</code></td><td align="left"><code class="filename">tr1/complex</code></td><td align="left"><code class="filename">tr1/memory</code></td><td align="left"><code class="filename">tr1/functional</code></td><td align="left"><code class="filename">tr1/random</code></td></tr><tr><td align="left"><code class="filename">tr1/regex</code></td><td align="left"><code class="filename">tr1/tuple</code></td><td align="left"><code class="filename">tr1/type_traits</code></td><td align="left"><code class="filename">tr1/unordered_map</code></td><td align="left"><code class="filename">tr1/unordered_set</code></td></tr><tr><td align="left"><code class="filename">tr1/utility</code></td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr></tbody></table></div></div><br class="table-break" /><p></p><div class="table"><a id="table.tr1_cheaders"></a><p class="title"><strong>Table 3.7. C++ TR 1 Library Headers for C Library Facilities</strong></p><div class="table-contents"><table class="table" summary="C++ TR 1 Library Headers for C Library Facilities" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /><col align="left" class="c4" /><col align="left" class="c5" /></colgroup><tbody><tr><td align="left"><code class="filename">tr1/ccomplex</code></td><td align="left"><code class="filename">tr1/cfenv</code></td><td align="left"><code class="filename">tr1/cfloat</code></td><td align="left"><code class="filename">tr1/cmath</code></td><td align="left"><code class="filename">tr1/cinttypes</code></td></tr><tr><td align="left"><code class="filename">tr1/climits</code></td><td align="left"><code class="filename">tr1/cstdarg</code></td><td align="left"><code class="filename">tr1/cstdbool</code></td><td align="left"><code class="filename">tr1/cstdint</code></td><td align="left"><code class="filename">tr1/cstdio</code></td></tr><tr><td align="left"><code class="filename">tr1/cstdlib</code></td><td align="left"><code class="filename">tr1/ctgmath</code></td><td align="left"><code class="filename">tr1/ctime</code></td><td align="left"><code class="filename">tr1/cwchar</code></td><td align="left"><code class="filename">tr1/cwctype</code></td></tr></tbody></table></div></div><br class="table-break" /><p>Decimal floating-point arithmetic is available if the C++
+</p><div class="table"><a id="table.tr1_headers"></a><p class="title"><strong>Table 3.11. C++ TR 1 Library Headers</strong></p><div class="table-contents"><table class="table" summary="C++ TR 1 Library Headers" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /><col align="left" class="c4" /><col align="left" class="c5" /></colgroup><tbody><tr><td align="left"><code class="filename">tr1/array</code></td><td align="left"><code class="filename">tr1/complex</code></td><td align="left"><code class="filename">tr1/memory</code></td><td align="left"><code class="filename">tr1/functional</code></td><td align="left"><code class="filename">tr1/random</code></td></tr><tr><td align="left"><code class="filename">tr1/regex</code></td><td align="left"><code class="filename">tr1/tuple</code></td><td align="left"><code class="filename">tr1/type_traits</code></td><td align="left"><code class="filename">tr1/unordered_map</code></td><td align="left"><code class="filename">tr1/unordered_set</code></td></tr><tr><td align="left"><code class="filename">tr1/utility</code></td><td colspan="4" align="left"> </td></tr></tbody></table></div></div><br class="table-break" /><p></p><div class="table"><a id="table.tr1_cheaders"></a><p class="title"><strong>Table 3.12. C++ TR 1 Library Headers for C Library Facilities</strong></p><div class="table-contents"><table class="table" summary="C++ TR 1 Library Headers for C Library Facilities" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /><col align="left" class="c4" /><col align="left" class="c5" /></colgroup><tbody><tr><td align="left"><code class="filename">tr1/ccomplex</code></td><td align="left"><code class="filename">tr1/cfenv</code></td><td align="left"><code class="filename">tr1/cfloat</code></td><td align="left"><code class="filename">tr1/cmath</code></td><td align="left"><code class="filename">tr1/cinttypes</code></td></tr><tr><td align="left"><code class="filename">tr1/climits</code></td><td align="left"><code class="filename">tr1/cstdarg</code></td><td align="left"><code class="filename">tr1/cstdbool</code></td><td align="left"><code class="filename">tr1/cstdint</code></td><td align="left"><code class="filename">tr1/cstdio</code></td></tr><tr><td align="left"><code class="filename">tr1/cstdlib</code></td><td align="left"><code class="filename">tr1/ctgmath</code></td><td align="left"><code class="filename">tr1/ctime</code></td><td align="left"><code class="filename">tr1/cwchar</code></td><td align="left"><code class="filename">tr1/cwctype</code></td></tr></tbody></table></div></div><br class="table-break" /><p>Decimal floating-point arithmetic is available if the C++
 compiler supports scalar decimal floating-point types defined via
 <code class="code">__attribute__((mode(SD|DD|LD)))</code>.
-</p><div class="table"><a id="table.decfp_headers"></a><p class="title"><strong>Table 3.8. C++ TR 24733 Decimal Floating-Point Header</strong></p><div class="table-contents"><table class="table" summary="C++ TR 24733 Decimal Floating-Point Header" border="1"><colgroup><col align="left" class="c1" /></colgroup><tbody><tr><td align="left"><code class="filename">decimal/decimal</code></td></tr></tbody></table></div></div><br class="table-break" /><p>
+</p><div class="table"><a id="table.decfp_headers"></a><p class="title"><strong>Table 3.13. C++ TR 24733 Decimal Floating-Point Header</strong></p><div class="table-contents"><table class="table" summary="C++ TR 24733 Decimal Floating-Point Header" border="1"><colgroup><col align="left" class="c1" /></colgroup><tbody><tr><td align="left"><code class="filename">decimal/decimal</code></td></tr></tbody></table></div></div><br class="table-break" /><p>
   Also included are files for the C++ ABI interface:
-</p><div class="table"><a id="table.abi_headers"></a><p class="title"><strong>Table 3.9. C++ ABI Headers</strong></p><div class="table-contents"><table class="table" summary="C++ ABI Headers" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /></colgroup><tbody><tr><td align="left"><code class="filename">cxxabi.h</code></td><td align="left"><code class="filename">cxxabi_forced.h</code></td></tr></tbody></table></div></div><br class="table-break" /><p>
+</p><div class="table"><a id="table.abi_headers"></a><p class="title"><strong>Table 3.14. C++ ABI Headers</strong></p><div class="table-contents"><table class="table" summary="C++ ABI Headers" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /></colgroup><tbody><tr><td align="left"><code class="filename">cxxabi.h</code></td><td align="left"><code class="filename">cxxabi_forced.h</code></td></tr></tbody></table></div></div><br class="table-break" /><p>
   And a large variety of extensions.
-</p><div class="table"><a id="table.ext_headers"></a><p class="title"><strong>Table 3.10. Extension Headers</strong></p><div class="table-contents"><table class="table" summary="Extension Headers" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /><col align="left" class="c4" /><col align="left" class="c5" /></colgroup><tbody><tr><td align="left"><code class="filename">ext/algorithm</code></td><td align="left"><code class="filename">ext/atomicity.h</code></td><td align="left"><code class="filename">ext/array_allocator.h</code></td><td align="left"><code class="filename">ext/bitmap_allocator.h</code></td><td align="left"><code class="filename">ext/cast.h</code></td></tr><tr><td align="left"><code class="filename">ext/codecvt_specializations.h</code></td><td align="left"><code class="filename">ext/concurrence.h</code></td><td align="left"><code class="filename">ext/debug_allocator.h</code></td><td align="left"><code class="filename">ext/enc_filebuf.h</code></td><td align="left"><code class="filename">ext/extptr_allocator.h</code></td></tr><tr><td align="left"><code class="filename">ext/functional</code></td><td align="left"><code class="filename">ext/iterator</code></td><td align="left"><code class="filename">ext/malloc_allocator.h</code></td><td align="left"><code class="filename">ext/memory</code></td><td align="left"><code class="filename">ext/mt_allocator.h</code></td></tr><tr><td align="left"><code class="filename">ext/new_allocator.h</code></td><td align="left"><code class="filename">ext/numeric</code></td><td align="left"><code class="filename">ext/numeric_traits.h</code></td><td align="left"><code class="filename">ext/pb_ds/assoc_container.h</code></td><td align="left"><code class="filename">ext/pb_ds/priority_queue.h</code></td></tr><tr><td align="left"><code class="filename">ext/pod_char_traits.h</code></td><td align="left"><code class="filename">ext/pool_allocator.h</code></td><td align="left"><code class="filename">ext/rb_tree</code></td><td align="left"><code class="filename">ext/rope</code></td><td align="left"><code class="filename">ext/slist</code></td></tr><tr><td align="left"><code class="filename">ext/stdio_filebuf.h</code></td><td align="left"><code class="filename">ext/stdio_sync_filebuf.h</code></td><td align="left"><code class="filename">ext/throw_allocator.h</code></td><td align="left"><code class="filename">ext/typelist.h</code></td><td align="left"><code class="filename">ext/type_traits.h</code></td></tr><tr><td align="left"><code class="filename">ext/vstring.h</code></td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr></tbody></table></div></div><br class="table-break" /><p></p><div class="table"><a id="table.debug_headers"></a><p class="title"><strong>Table 3.11. Extension Debug Headers</strong></p><div class="table-contents"><table class="table" summary="Extension Debug Headers" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /><col align="left" class="c4" /><col align="left" class="c5" /></colgroup><tbody><tr><td align="left"><code class="filename">debug/bitset</code></td><td align="left"><code class="filename">debug/deque</code></td><td align="left"><code class="filename">debug/list</code></td><td align="left"><code class="filename">debug/map</code></td><td align="left"><code class="filename">debug/set</code></td></tr><tr><td align="left"><code class="filename">debug/string</code></td><td align="left"><code class="filename">debug/unordered_map</code></td><td align="left"><code class="filename">debug/unordered_set</code></td><td align="left"><code class="filename">debug/vector</code></td><td class="auto-generated"> </td></tr></tbody></table></div></div><br class="table-break" /><p></p><div class="table"><a id="table.profile_headers"></a><p class="title"><strong>Table 3.12. Extension Profile Headers</strong></p><div class="table-contents"><table class="table" summary="Extension Profile Headers" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /><col align="left" class="c4" /></colgroup><tbody><tr><td align="left"><code class="filename">profile/bitset</code></td><td align="left"><code class="filename">profile/deque</code></td><td align="left"><code class="filename">profile/list</code></td><td align="left"><code class="filename">profile/map</code></td></tr><tr><td align="left"><code class="filename">profile/set</code></td><td align="left"><code class="filename">profile/unordered_map</code></td><td align="left"><code class="filename">profile/unordered_set</code></td><td align="left"><code class="filename">profile/vector</code></td></tr></tbody></table></div></div><br class="table-break" /><p></p><div class="table"><a id="table.parallel_headers"></a><p class="title"><strong>Table 3.13. Extension Parallel Headers</strong></p><div class="table-contents"><table class="table" summary="Extension Parallel Headers" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /></colgroup><tbody><tr><td align="left"><code class="filename">parallel/algorithm</code></td><td align="left"><code class="filename">parallel/numeric</code></td></tr></tbody></table></div></div><br class="table-break" /></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="manual.intro.using.headers.mixing"></a>Mixing Headers</h3></div></div></div><p> A few simple rules.
+</p><div class="table"><a id="table.ext_headers"></a><p class="title"><strong>Table 3.15. Extension Headers</strong></p><div class="table-contents"><table class="table" summary="Extension Headers" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /><col align="left" class="c4" /><col align="left" class="c5" /></colgroup><tbody><tr><td align="left"><code class="filename">ext/algorithm</code></td><td align="left"><code class="filename">ext/atomicity.h</code></td><td align="left"><code class="filename">ext/array_allocator.h</code></td><td align="left"><code class="filename">ext/bitmap_allocator.h</code></td><td align="left"><code class="filename">ext/cast.h</code></td></tr><tr><td align="left"><code class="filename">ext/codecvt_specializations.h</code></td><td align="left"><code class="filename">ext/concurrence.h</code></td><td align="left"><code class="filename">ext/debug_allocator.h</code></td><td align="left"><code class="filename">ext/enc_filebuf.h</code></td><td align="left"><code class="filename">ext/extptr_allocator.h</code></td></tr><tr><td align="left"><code class="filename">ext/functional</code></td><td align="left"><code class="filename">ext/iterator</code></td><td align="left"><code class="filename">ext/malloc_allocator.h</code></td><td align="left"><code class="filename">ext/memory</code></td><td align="left"><code class="filename">ext/mt_allocator.h</code></td></tr><tr><td align="left"><code class="filename">ext/new_allocator.h</code></td><td align="left"><code class="filename">ext/numeric</code></td><td align="left"><code class="filename">ext/numeric_traits.h</code></td><td align="left"><code class="filename">ext/pb_ds/assoc_container.h</code></td><td align="left"><code class="filename">ext/pb_ds/priority_queue.h</code></td></tr><tr><td align="left"><code class="filename">ext/pod_char_traits.h</code></td><td align="left"><code class="filename">ext/pool_allocator.h</code></td><td align="left"><code class="filename">ext/rb_tree</code></td><td align="left"><code class="filename">ext/rope</code></td><td align="left"><code class="filename">ext/slist</code></td></tr><tr><td align="left"><code class="filename">ext/stdio_filebuf.h</code></td><td align="left"><code class="filename">ext/stdio_sync_filebuf.h</code></td><td align="left"><code class="filename">ext/throw_allocator.h</code></td><td align="left"><code class="filename">ext/typelist.h</code></td><td align="left"><code class="filename">ext/type_traits.h</code></td></tr><tr><td align="left"><code class="filename">ext/vstring.h</code></td><td colspan="4" align="left"> </td></tr></tbody></table></div></div><br class="table-break" /><p></p><div class="table"><a id="table.debug_headers"></a><p class="title"><strong>Table 3.16. Extension Debug Headers</strong></p><div class="table-contents"><table class="table" summary="Extension Debug Headers" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /><col align="left" class="c4" /><col align="left" class="c5" /></colgroup><tbody><tr><td align="left"><code class="filename">debug/array</code></td><td align="left"><code class="filename">debug/bitset</code></td><td align="left"><code class="filename">debug/deque</code></td><td align="left"><code class="filename">debug/forward_list</code></td><td align="left"><code class="filename">debug/list</code></td></tr><tr><td align="left"><code class="filename">debug/map</code></td><td align="left"><code class="filename">debug/set</code></td><td align="left"><code class="filename">debug/string</code></td><td align="left"><code class="filename">debug/unordered_map</code></td><td align="left"><code class="filename">debug/unordered_set</code></td></tr><tr><td align="left"><code class="filename">debug/vector</code></td><td colspan="4" align="left"> </td></tr></tbody></table></div></div><br class="table-break" /><p></p><div class="table"><a id="table.profile_headers"></a><p class="title"><strong>Table 3.17. Extension Profile Headers</strong></p><div class="table-contents"><table class="table" summary="Extension Profile Headers" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /><col align="left" class="c4" /></colgroup><tbody><tr><td align="left"><code class="filename">profile/bitset</code></td><td align="left"><code class="filename">profile/deque</code></td><td align="left"><code class="filename">profile/list</code></td><td align="left"><code class="filename">profile/map</code></td></tr><tr><td align="left"><code class="filename">profile/set</code></td><td align="left"><code class="filename">profile/unordered_map</code></td><td align="left"><code class="filename">profile/unordered_set</code></td><td align="left"><code class="filename">profile/vector</code></td></tr></tbody></table></div></div><br class="table-break" /><p></p><div class="table"><a id="table.parallel_headers"></a><p class="title"><strong>Table 3.18. Extension Parallel Headers</strong></p><div class="table-contents"><table class="table" summary="Extension Parallel Headers" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /></colgroup><tbody><tr><td align="left"><code class="filename">parallel/algorithm</code></td><td align="left"><code class="filename">parallel/numeric</code></td></tr></tbody></table></div></div><br class="table-break" /></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="manual.intro.using.headers.mixing"></a>Mixing Headers</h3></div></div></div><p> A few simple rules.
 </p><p>First, mixing different dialects of the standard headers is not
 possible. It's an all-or-nothing affair. Thus, code like
 </p><pre class="programlisting">
diff --git a/libstdc++-v3/doc/xml/faq.xml b/libstdc++-v3/doc/xml/faq.xml
index 8041c1428e6..9f0c5c9e661 100644
--- a/libstdc++-v3/doc/xml/faq.xml
+++ b/libstdc++-v3/doc/xml/faq.xml
@@ -734,15 +734,16 @@
     except for some corner cases.  Support for localization
     in <classname>locale</classname> may be incomplete on some non-GNU
     platforms. Also dependent on the underlying platform is support
-    for <type>wchar_t</type> and <type>long
-    long</type> specializations, and details of thread support.
+    for <type>wchar_t</type> and <type>long long</type> specializations,
+    and details of thread support.
     </para>
     <para>    
     Long answer: See the implementation status pages for 
     <link linkend="status.iso.1998">C++98</link>,
-    <link linkend="status.iso.tr1">TR1</link>, and 
-    <link linkend="status.iso.2011">C++11</link>.
-    <link linkend="status.iso.2014">C++14</link>.
+    <link linkend="status.iso.tr1">TR1</link>,
+    <link linkend="status.iso.2011">C++11</link>,
+    <link linkend="status.iso.2014">C++14</link>, and
+    <link linkend="status.iso.2017">C++17</link>.
     </para> 
   </answer>
 </qandaentry>
@@ -875,6 +876,9 @@
     </para>
   </question>
   <answer xml:id="a-ambiguous_overloads">
+    <note>
+      <para>This answer is old and probably no longer be relevant.</para>
+    </note>
     <para>
     Another problem is the <literal>rel_ops</literal> namespace and the template
     comparison operator functions contained therein.  If they become
diff --git a/libstdc++-v3/doc/xml/manual/debug_mode.xml b/libstdc++-v3/doc/xml/manual/debug_mode.xml
index 65abf051674..1031171871d 100644
--- a/libstdc++-v3/doc/xml/manual/debug_mode.xml
+++ b/libstdc++-v3/doc/xml/manual/debug_mode.xml
@@ -285,7 +285,19 @@ containers have additional debug capability.
   </row>
 </thead>
 <tbody>
-    <row>
+  <row>
+    <entry><classname>std::array</classname></entry>
+    <entry><filename class="headerfile">array</filename></entry>
+    <entry><classname>__gnu_debug::array</classname></entry>
+    <entry><filename class="headerfile">&lt;debug/array&gt;</filename></entry>
+  </row>
+  <row>
+    <entry><classname>std::forward_list</classname></entry>
+    <entry><filename class="headerfile">forward_list</filename></entry>
+    <entry><classname>__gnu_debug::forward_list</classname></entry>
+    <entry><filename class="headerfile">&lt;debug/forward_list&gt;</filename></entry>
+  </row>
+  <row>
     <entry><classname>std::unordered_map</classname></entry>
     <entry><filename class="headerfile">unordered_map</filename></entry>
     <entry><classname>__gnu_debug::unordered_map</classname></entry>
diff --git a/libstdc++-v3/doc/xml/manual/status_cxx1998.xml b/libstdc++-v3/doc/xml/manual/status_cxx1998.xml
index ffdc878ffe8..5088a5a76b0 100644
--- a/libstdc++-v3/doc/xml/manual/status_cxx1998.xml
+++ b/libstdc++-v3/doc/xml/manual/status_cxx1998.xml
@@ -1125,6 +1125,10 @@ This page describes the C++ support in the GCC 7 series.
       implementation will be described under
       <link linkend="std.localization.locales.locale">Localization</link>.
    </para>
+   <para><emphasis>[23.*]</emphasis> All of the containers in this clause
+     define <type>size_type</type> as <type>std::size_t</type> and
+     <type>difference_type</type> as <type>std::ptrdiff_t</type>.
+   </para>
    <para><emphasis>[26.2.8]/9</emphasis> I have no idea what
       <code>complex&lt;T&gt;</code>'s <code>pow(0,0)</code> returns.
    </para>
diff --git a/libstdc++-v3/doc/xml/manual/test.xml b/libstdc++-v3/doc/xml/manual/test.xml
index 154b74cbf9f..ef0de795754 100644
--- a/libstdc++-v3/doc/xml/manual/test.xml
+++ b/libstdc++-v3/doc/xml/manual/test.xml
@@ -753,12 +753,15 @@ cat 27_io/objects/char/3_xin.in | a.out</programlisting>
 
   <para>
     Similarly, tests which depend on a newer standard than the default
-    should use <literal>dg-options</literal> instead of an effective target,
-    so that they are not skipped by default.
+    must use <literal>dg-options</literal> instead of (or in addition to)
+    an effective target, so that they are not skipped by default.
     For example, tests for C++17 features should use
 <programlisting>    // { dg-options "-std=gnu++17" }</programlisting>
-    and not
-<programlisting>    // { dg-do run "c++1z" }</programlisting>
+    before any <literal>dg-do</literal> such as:
+<programlisting>    // { dg-do run "c++17" }</programlisting>
+    The <literal>dg-options</literal> directive must come first, so that
+    the <literal>-std</literal> flag has already been added to the options
+    before checking the <literal>c++17</literal> target.
   </para>
 
 <section xml:id="tests.dg.examples"><info><title>Examples of Test Directives</title></info>
diff --git a/libstdc++-v3/doc/xml/manual/using.xml b/libstdc++-v3/doc/xml/manual/using.xml
index 5c0e1b9f8c1..a0c9593c32d 100644
--- a/libstdc++-v3/doc/xml/manual/using.xml
+++ b/libstdc++-v3/doc/xml/manual/using.xml
@@ -126,7 +126,7 @@
      must be available to all hosted implementations.  Actually, the
      word "files" is a misnomer, since the contents of the
      headers don't necessarily have to be in any kind of external
-     file.  The only rule is that when one <code>#include</code>'s a
+     file.  The only rule is that when one <code>#include</code>s a
      header, the contents of that header become available, no matter
      how.
    </para>
@@ -138,16 +138,24 @@
    <para>
      There are two main types of include files: header files related
      to a specific version of the ISO C++ standard (called Standard
-     Headers), and all others (TR1, C++ ABI, and Extensions).
+     Headers), and all others (TS, TR1, C++ ABI, and Extensions).
    </para>
 
    <para>
-     Two dialects of standard headers are supported, corresponding to
-     the 1998 standard as updated for 2003, and the current 2011 standard.
+     Multiple dialects of standard headers are supported, corresponding to
+     the 1998 standard as updated for 2003, the 2011 standard, the 2014
+     standard, and so on.
    </para>
 
    <para>
-     C++98/03 include files. These are available in the default compilation mode, i.e. <code>-std=c++98</code> or <code>-std=gnu++98</code>.
+     <xref linkend="table.cxx98_headers"/> and
+     <xref linkend="table.cxx98_cheaders"/> and
+     <xref linkend="table.cxx98_deprheaders"/>
+     show the C++98/03 include files.
+     These are available in the C++98 compilation mode,
+     i.e. <code>-std=c++98</code> or <code>-std=gnu++98</code>.
+     Unless specified otherwise below, they are also available in later modes
+     (C++11, C++14 etc).
    </para>
 
 <table frame="all" xml:id="table.cxx98_headers">
@@ -205,6 +213,7 @@
 <row>
 <entry><filename class="headerfile">valarray</filename></entry>
 <entry><filename class="headerfile">vector</filename></entry>
+<entry namest="c3" nameend="c5"/>
 </row>
 </tbody>
 </tgroup>
@@ -246,14 +255,38 @@
 <entry><filename class="headerfile">ctime</filename></entry>
 <entry><filename class="headerfile">cwchar</filename></entry>
 <entry><filename class="headerfile">cwctype</filename></entry>
+<entry namest="c4" nameend="c5"/>
 </row>
 </tbody>
 </tgroup>
 </table>
 
 <para>
-C++11 include files. These are only available in C++11 compilation
+  The following header is deprecated
+  and might be removed from a future C++ standard.
+</para>
+
+<table frame="all" xml:id="table.cxx98_deprheaders">
+<title>C++ 1998 Deprecated Library Header</title>
+
+<tgroup cols="1" align="left" colsep="1" rowsep="1">
+<colspec colname="c1"/>
+<tbody>
+<row>
+<entry><filename class="headerfile">strstream</filename></entry>
+</row>
+</tbody>
+</tgroup>
+</table>
+
+<para>
+<xref linkend="table.cxx11_headers"/> and
+<xref linkend="table.cxx11_cheaders"/> show the C++11 include files.
+These are available in C++11 compilation
 mode, i.e. <literal>-std=c++11</literal> or <literal>-std=gnu++11</literal>.
+Including these headers in C++98/03 mode may result in compilation errors.
+Unless specified otherwise below, they are also available in later modes
+(C++14 etc).
 </para>
 
 <para/>
@@ -269,73 +302,33 @@ mode, i.e. <literal>-std=c++11</literal> or <literal>-std=gnu++11</literal>.
 <tbody>
 
 <row>
-<entry><filename class="headerfile">algorithm</filename></entry>
 <entry><filename class="headerfile">array</filename></entry>
-<entry><filename class="headerfile">bitset</filename></entry>
+<entry><filename class="headerfile">atomic</filename></entry>
 <entry><filename class="headerfile">chrono</filename></entry>
-<entry><filename class="headerfile">complex</filename></entry>
-</row>
-<row>
+<entry><filename class="headerfile">codecvt</filename></entry>
 <entry><filename class="headerfile">condition_variable</filename></entry>
-<entry><filename class="headerfile">deque</filename></entry>
-<entry><filename class="headerfile">exception</filename></entry>
-<entry><filename class="headerfile">forward_list</filename></entry>
-<entry><filename class="headerfile">fstream</filename></entry>
 </row>
 <row>
-<entry><filename class="headerfile">functional</filename></entry>
+<entry><filename class="headerfile">forward_list</filename></entry>
 <entry><filename class="headerfile">future</filename></entry>
 <entry><filename class="headerfile">initalizer_list</filename></entry>
-<entry><filename class="headerfile">iomanip</filename></entry>
-<entry><filename class="headerfile">ios</filename></entry>
-</row>
-<row>
-<entry><filename class="headerfile">iosfwd</filename></entry>
-<entry><filename class="headerfile">iostream</filename></entry>
-<entry><filename class="headerfile">istream</filename></entry>
-<entry><filename class="headerfile">iterator</filename></entry>
-<entry><filename class="headerfile">limits</filename></entry>
-</row>
-<row>
-<entry><filename class="headerfile">list</filename></entry>
-<entry><filename class="headerfile">locale</filename></entry>
-<entry><filename class="headerfile">map</filename></entry>
-<entry><filename class="headerfile">memory</filename></entry>
 <entry><filename class="headerfile">mutex</filename></entry>
-</row>
-<row>
-<entry><filename class="headerfile">new</filename></entry>
-<entry><filename class="headerfile">numeric</filename></entry>
-<entry><filename class="headerfile">ostream</filename></entry>
-<entry><filename class="headerfile">queue</filename></entry>
 <entry><filename class="headerfile">random</filename></entry>
 </row>
 <row>
 <entry><filename class="headerfile">ratio</filename></entry>
 <entry><filename class="headerfile">regex</filename></entry>
-<entry><filename class="headerfile">set</filename></entry>
-<entry><filename class="headerfile">sstream</filename></entry>
-<entry><filename class="headerfile">stack</filename></entry>
-</row>
-<row>
-<entry><filename class="headerfile">stdexcept</filename></entry>
-<entry><filename class="headerfile">streambuf</filename></entry>
-<entry><filename class="headerfile">string</filename></entry>
+<entry><filename class="headerfile">scoped_allocator</filename></entry>
 <entry><filename class="headerfile">system_error</filename></entry>
 <entry><filename class="headerfile">thread</filename></entry>
 </row>
 <row>
 <entry><filename class="headerfile">tuple</filename></entry>
+<entry><filename class="headerfile">typeindex</filename></entry>
 <entry><filename class="headerfile">type_traits</filename></entry>
-<entry><filename class="headerfile">typeinfo</filename></entry>
 <entry><filename class="headerfile">unordered_map</filename></entry>
 <entry><filename class="headerfile">unordered_set</filename></entry>
 </row>
-<row>
-<entry><filename class="headerfile">utility</filename></entry>
-<entry><filename class="headerfile">valarray</filename></entry>
-<entry><filename class="headerfile">vector</filename></entry>
-</row>
 
 </tbody>
 </tgroup>
@@ -354,39 +347,162 @@ mode, i.e. <literal>-std=c++11</literal> or <literal>-std=gnu++11</literal>.
 <colspec colname="c5"/>
 <tbody>
 <row>
-<entry><filename class="headerfile">cassert</filename></entry>
 <entry><filename class="headerfile">ccomplex</filename></entry>
-<entry><filename class="headerfile">cctype</filename></entry>
-<entry><filename class="headerfile">cerrno</filename></entry>
 <entry><filename class="headerfile">cfenv</filename></entry>
+<entry><filename class="headerfile">cinttypes</filename></entry>
+<entry><filename class="headerfile">cstdalign</filename></entry>
+<entry><filename class="headerfile">cstdbool</filename></entry>
 </row>
 <row>
-<entry><filename class="headerfile">cfloat</filename></entry>
-<entry><filename class="headerfile">cinttypes</filename></entry>
-<entry><filename class="headerfile">ciso646</filename></entry>
-<entry><filename class="headerfile">climits</filename></entry>
-<entry><filename class="headerfile">clocale</filename></entry>
+<entry><filename class="headerfile">cstdint</filename></entry>
+<entry><filename class="headerfile">ctgmath</filename></entry>
+<entry><filename class="headerfile">cuchar</filename></entry>
+<entry namest="c4" nameend="c5"/>
 </row>
+</tbody>
+</tgroup>
+</table>
+
+<para>
+<xref linkend="table.cxx14_headers"/> shows the C++14 include file.
+This is available in C++14 compilation
+mode, i.e. <literal>-std=c++14</literal> or <literal>-std=gnu++14</literal>.
+Including this header in C++98/03 mode or C++11 will not result in
+compilation errors, but will not define anything.
+Unless specified otherwise below, it is also available in later modes
+(C++17 etc).
+</para>
+
+<para/>
+<table frame="all" xml:id="table.cxx14_headers">
+<title>C++ 2014 Library Header</title>
+
+<tgroup cols="1" align="left" colsep="1" rowsep="1">
+<colspec colname="c1"/>
+<tbody>
 <row>
-<entry><filename class="headerfile">cmath</filename></entry>
-<entry><filename class="headerfile">csetjmp</filename></entry>
-<entry><filename class="headerfile">csignal</filename></entry>
-<entry><filename class="headerfile">cstdarg</filename></entry>
-<entry><filename class="headerfile">cstdbool</filename></entry>
+<entry><filename class="headerfile">shared_mutex</filename></entry>
 </row>
+</tbody>
+</tgroup>
+</table>
+
+<para>
+<xref linkend="table.cxx17_headers"/> shows the C++17 include files.
+These are available in C++17 compilation
+mode, i.e. <literal>-std=c++17</literal> or <literal>-std=gnu++17</literal>.
+Including these headers in earlier modes will not result in
+compilation errors, but will not define anything.
+Unless specified otherwise below, they are also available in later modes
+(C++20 etc).
+</para>
+
+<para/>
+<table frame="all" xml:id="table.cxx17_headers">
+<title>C++ 2017 Library Headers</title>
+
+<tgroup cols="4" align="left" colsep="1" rowsep="1">
+<colspec colname="c1"/>
+<colspec colname="c2"/>
+<colspec colname="c3"/>
+<colspec colname="c4"/>
+<tbody>
 <row>
-<entry><filename class="headerfile">cstddef</filename></entry>
-<entry><filename class="headerfile">cstdint</filename></entry>
-<entry><filename class="headerfile">cstdlib</filename></entry>
-<entry><filename class="headerfile">cstdio</filename></entry>
-<entry><filename class="headerfile">cstring</filename></entry>
+<entry><filename class="headerfile">any</filename></entry>
+<entry><filename class="headerfile">optional</filename></entry>
+<entry><filename class="headerfile">string_view</filename></entry>
+<entry><filename class="headerfile">variant</filename></entry>
 </row>
+</tbody>
+</tgroup>
+</table>
+
+
+<para>
+<xref linkend="table.filesystemts_headers"/>,
+shows the additional include file define by the
+File System Technical Specification, ISO/IEC TS 18822.
+This is available in C++11 and later compilation modes.
+Including this header in earlier modes will not result in
+compilation errors, but will not define anything.
+</para>
+
+<para/>
+<table frame="all" xml:id="table.filesystemts_headers">
+<title>File System TS Header</title>
+
+<tgroup cols="1" align="left" colsep="1" rowsep="1">
+<colspec colname="c1"/>
+<tbody>
 <row>
-<entry><filename class="headerfile">ctgmath</filename></entry>
-<entry><filename class="headerfile">ctime</filename></entry>
-<entry><filename class="headerfile">cuchar</filename></entry>
-<entry><filename class="headerfile">cwchar</filename></entry>
-<entry><filename class="headerfile">cwctype</filename></entry>
+<entry><filename class="headerfile">experimental/filesystem</filename></entry>
+</row>
+</tbody>
+</tgroup>
+</table>
+
+
+<para>
+<xref linkend="table.libfundts_headers"/>,
+shows the additional include files define by the C++ Extensions for 
+Library Fundamentals Technical Specification, ISO/IEC TS 19568.
+These are available in C++14 and later compilation modes.
+Including these headers in earlier modes will not result in
+compilation errors, but will not define anything.
+</para>
+
+<para/>
+<table frame="all" xml:id="table.libfundts_headers">
+<title>Library Fundamentals TS Headers</title>
+
+<tgroup cols="5" align="left" colsep="1" rowsep="1">
+<colspec colname="c1"/>
+<colspec colname="c2"/>
+<colspec colname="c3"/>
+<colspec colname="c4"/>
+<colspec colname="c5"/>
+<tbody>
+<row>
+<entry><filename class="headerfile">experimental/algorithm</filename></entry>
+<entry><filename class="headerfile">experimental/any</filename></entry>
+<entry><filename class="headerfile">experimental/array</filename></entry>
+<entry><filename class="headerfile">experimental/chrono</filename></entry>
+<entry><filename class="headerfile">experimental/deque</filename></entry>
+</row>
+<row>
+<entry><filename class="headerfile">experimental/forward_list</filename></entry>
+<entry><filename class="headerfile">experimental/functional</filename></entry>
+<entry><filename class="headerfile">experimental/iterator</filename></entry>
+<entry><filename class="headerfile">experimental/list</filename></entry>
+<entry><filename class="headerfile">experimental/map</filename></entry>
+</row>
+<row>
+<entry><filename class="headerfile">experimental/memory</filename></entry>
+<entry><filename class="headerfile">experimental/memory_resource</filename></entry>
+<entry><filename class="headerfile">experimental/numeric</filename></entry>
+<entry><filename class="headerfile">experimental/optional</filename></entry>
+<entry><filename class="headerfile">experimental/propagate_const</filename></entry>
+</row>
+<row>
+<entry><filename class="headerfile">experimental/random</filename></entry>
+<entry><filename class="headerfile">experimental/ratio</filename></entry>
+<entry><filename class="headerfile">experimental/regex</filename></entry>
+<entry><filename class="headerfile">experimental/set</filename></entry>
+<entry><filename class="headerfile">experimental/source_location</filename></entry>
+</row>
+<row>
+<entry><filename class="headerfile">experimental/string</filename></entry>
+<entry><filename class="headerfile">experimental/string_view</filename></entry>
+<entry><filename class="headerfile">experimental/system_error</filename></entry>
+<entry><filename class="headerfile">experimental/tuple</filename></entry>
+<entry><filename class="headerfile">experimental/type_traits</filename></entry>
+</row>
+<row>
+<entry><filename class="headerfile">experimental/unordered_map</filename></entry>
+<entry><filename class="headerfile">experimental/unordered_set</filename></entry>
+<entry><filename class="headerfile">experimental/utility</filename></entry>
+<entry><filename class="headerfile">experimental/vector</filename></entry>
+<entry />
 </row>
 </tbody>
 </tgroup>
@@ -424,6 +540,7 @@ mode, i.e. <literal>-std=c++11</literal> or <literal>-std=gnu++11</literal>.
 </row>
 <row>
 <entry><filename class="headerfile">tr1/utility</filename></entry>
+<entry namest="c2" nameend="c5"/>
 </row>
 
 </tbody>
@@ -564,6 +681,7 @@ compiler supports scalar decimal floating-point types defined via
 </row>
 <row>
 <entry><filename class="headerfile">ext/vstring.h</filename></entry>
+<entry namest="c2" nameend="c5"/>
 </row>
 
 </tbody>
@@ -584,18 +702,22 @@ compiler supports scalar decimal floating-point types defined via
 <tbody>
 
 <row>
+<entry><filename class="headerfile">debug/array</filename></entry>
 <entry><filename class="headerfile">debug/bitset</filename></entry>
 <entry><filename class="headerfile">debug/deque</filename></entry>
+<entry><filename class="headerfile">debug/forward_list</filename></entry>
 <entry><filename class="headerfile">debug/list</filename></entry>
-<entry><filename class="headerfile">debug/map</filename></entry>
-<entry><filename class="headerfile">debug/set</filename></entry>
 </row>
-
 <row>
+<entry><filename class="headerfile">debug/map</filename></entry>
+<entry><filename class="headerfile">debug/set</filename></entry>
 <entry><filename class="headerfile">debug/string</filename></entry>
 <entry><filename class="headerfile">debug/unordered_map</filename></entry>
 <entry><filename class="headerfile">debug/unordered_set</filename></entry>
+</row>
+<row>
 <entry><filename class="headerfile">debug/vector</filename></entry>
+<entry namest="c2" nameend="c5"/>
 </row>
 
 </tbody>
@@ -1016,7 +1138,7 @@ g++ -Winvalid-pch -I. -include stdc++.h -H -g -O2 hello.cc -o test.exe
 </para>
 
 <para> The <symbol>_GLIBCXX_USE_CXX11_ABI</symbol> macro (see
-<xref linkend="manual.intro.using.macros"/>) controls whether
+  <xref linkend="manual.intro.using.macros"/>) controls whether
   the declarations in the library headers use the old or new ABI.
   So the decision of which ABI to use can be made separately for each
   source file being compiled.
@@ -1051,12 +1173,39 @@ g++ -Winvalid-pch -I. -include stdc++.h -H -g -O2 hello.cc -o test.exe
 </para>
 
 <para> Although the standard exception types defined in
-  <filename class="headerfile">&lt;stdexcept&gt;</filename> use strings, they
+  <filename class="headerfile">&lt;stdexcept&gt;</filename> use strings, most
   are not defined twice, so that a <classname>std::out_of_range</classname>
   exception thrown in one file can always be caught by a suitable handler in
   another file, even if the two files are compiled with different ABIs.
 </para>
 
+<para> One exception type does change when using the new ABI, namely
+  <classname>std::ios_base::failure</classname>.
+  This is necessary because the 2011 standard changed its base class from
+  <classname>std::exception</classname> to
+  <classname>std::system_error</classname>, which causes its layout to change.
+  Exceptions due to iostream errors are thrown by a function inside
+  <filename class="libraryfile">libstdc++.so</filename>, so whether the thrown
+  exception uses the old <classname>std::ios_base::failure</classname> type
+  or the new one depends on the ABI that was active when
+  <filename class="libraryfile">libstdc++.so</filename> was built,
+  <emphasis>not</emphasis> the ABI active in the user code that is using
+  iostreams.
+  This means that for a given build of GCC the type thrown is fixed.
+  In current releases the library throws a special type that can be caught
+  by handlers for either the old or new type,
+  but for GCC 7.1, 7.2 and 7.3 the library throws the new
+  <classname>std::ios_base::failure</classname> type,
+  and for GCC 5.x and 6.x the library throws the old type.
+  Catch handlers of type <classname>std::ios_base::failure</classname>
+  will only catch the exceptions if using a newer release,
+  or if the handler is compiled with the same ABI as the type thrown by
+  the library.
+  Handlers for <classname>std::exception</classname> will always catch
+  iostreams exceptions, because the old and new type both inherit from
+  <classname>std::exception</classname>.
+</para>
+
 <section xml:id="manual.intro.using.abi.trouble" xreflabel="Dual ABI Troubleshooting"><info><title>Troubleshooting</title></info>
 
 <para> If you get linker errors about undefined references to symbols
diff --git a/libstdc++-v3/include/Makefile.am b/libstdc++-v3/include/Makefile.am
index 6395f1e6ae0..500a9aa7bb9 100644
--- a/libstdc++-v3/include/Makefile.am
+++ b/libstdc++-v3/include/Makefile.am
@@ -95,7 +95,6 @@ bits_headers = \
 	${bits_srcdir}/basic_string.tcc \
 	${bits_srcdir}/boost_concept_check.h \
 	${bits_srcdir}/c++0x_warning.h \
-	${bits_srcdir}/c++14_warning.h \
 	${bits_srcdir}/char_traits.h \
 	${bits_srcdir}/codecvt.h \
 	${bits_srcdir}/concept_check.h \
@@ -1225,6 +1224,14 @@ stamp-allocator-new:
 	echo 0 > stamp-allocator-new
 endif
 
+if ENABLE_FLOAT128
+stamp-float128:
+	echo 'define _GLIBCXX_USE_FLOAT128 1' > stamp-float128
+else
+stamp-float128:
+	echo 'undef _GLIBCXX_USE_FLOAT128' > stamp-float128
+endif
+
 # NB: The non-empty default ldbl_compat works around an AIX sed
 # oddity, see libstdc++/31957 for details.
 ${host_builddir}/c++config.h: ${CONFIG_HEADER} \
@@ -1236,7 +1243,8 @@ ${host_builddir}/c++config.h: ${CONFIG_HEADER} \
 			      stamp-extern-template \
 			      stamp-dual-abi \
 			      stamp-cxx11-abi \
-			      stamp-allocator-new
+			      stamp-allocator-new \
+			      stamp-float128
 	@date=`cat ${toplevel_srcdir}/gcc/DATESTAMP` ;\
 	release=`sed 's/^\([0-9]*\).*$$/\1/' ${toplevel_srcdir}/gcc/BASE-VER` ;\
 	ns_version=`cat stamp-namespace-version` ;\
@@ -1245,6 +1253,7 @@ ${host_builddir}/c++config.h: ${CONFIG_HEADER} \
 	dualabi=`cat stamp-dual-abi` ;\
 	cxx11abi=`cat stamp-cxx11-abi` ;\
 	allocatornew=`cat stamp-allocator-new` ;\
+	float128=`cat stamp-float128` ;\
 	ldbl_compat='s,g,g,' ;\
 	grep "^[	 ]*#[	 ]*define[	 ][	 ]*_GLIBCXX_LONG_DOUBLE_COMPAT[	 ][	 ]*1[	 ]*$$" \
 	${CONFIG_HEADER} > /dev/null 2>&1 \
@@ -1257,6 +1266,7 @@ ${host_builddir}/c++config.h: ${CONFIG_HEADER} \
 	-e "s,define _GLIBCXX_USE_DUAL_ABI, define _GLIBCXX_USE_DUAL_ABI $$dualabi," \
 	-e "s,define _GLIBCXX_USE_CXX11_ABI, define _GLIBCXX_USE_CXX11_ABI $$cxx11abi," \
 	-e "s,define _GLIBCXX_USE_ALLOCATOR_NEW, define _GLIBCXX_USE_ALLOCATOR_NEW $$allocatornew," \
+	-e "s,define _GLIBCXX_USE_FLOAT128,$$float128," \
 	-e "$$ldbl_compat" \
 	    < ${glibcxx_srcdir}/include/bits/c++config > $@ ;\
 	sed -e 's/HAVE_/_GLIBCXX_HAVE_/g' \
@@ -1474,3 +1484,8 @@ $(decimal_headers): ; @:
 $(ext_headers): ; @:
 $(experimental_headers): ; @:
 $(experimental_bits_headers): ; @:
+
+if INCLUDE_DIR_NOTPARALLEL
+# See https://gcc.gnu.org/bugzilla/show_bug.cgi?id=81797
+.NOTPARALLEL:
+endif
diff --git a/libstdc++-v3/include/Makefile.in b/libstdc++-v3/include/Makefile.in
index 745a8495da5..cc571a417ea 100644
--- a/libstdc++-v3/include/Makefile.in
+++ b/libstdc++-v3/include/Makefile.in
@@ -388,7 +388,6 @@ bits_headers = \
 	${bits_srcdir}/basic_string.tcc \
 	${bits_srcdir}/boost_concept_check.h \
 	${bits_srcdir}/c++0x_warning.h \
-	${bits_srcdir}/c++14_warning.h \
 	${bits_srcdir}/char_traits.h \
 	${bits_srcdir}/codecvt.h \
 	${bits_srcdir}/concept_check.h \
@@ -1656,6 +1655,11 @@ stamp-host: ${host_headers} ${bits_host_headers} ${ext_host_headers} ${host_head
 @ENABLE_ALLOCATOR_NEW_FALSE@stamp-allocator-new:
 @ENABLE_ALLOCATOR_NEW_FALSE@	echo 0 > stamp-allocator-new
 
+@ENABLE_FLOAT128_TRUE@stamp-float128:
+@ENABLE_FLOAT128_TRUE@	echo 'define _GLIBCXX_USE_FLOAT128 1' > stamp-float128
+@ENABLE_FLOAT128_FALSE@stamp-float128:
+@ENABLE_FLOAT128_FALSE@	echo 'undef _GLIBCXX_USE_FLOAT128' > stamp-float128
+
 # NB: The non-empty default ldbl_compat works around an AIX sed
 # oddity, see libstdc++/31957 for details.
 ${host_builddir}/c++config.h: ${CONFIG_HEADER} \
@@ -1667,7 +1671,8 @@ ${host_builddir}/c++config.h: ${CONFIG_HEADER} \
 			      stamp-extern-template \
 			      stamp-dual-abi \
 			      stamp-cxx11-abi \
-			      stamp-allocator-new
+			      stamp-allocator-new \
+			      stamp-float128
 	@date=`cat ${toplevel_srcdir}/gcc/DATESTAMP` ;\
 	release=`sed 's/^\([0-9]*\).*$$/\1/' ${toplevel_srcdir}/gcc/BASE-VER` ;\
 	ns_version=`cat stamp-namespace-version` ;\
@@ -1676,6 +1681,7 @@ ${host_builddir}/c++config.h: ${CONFIG_HEADER} \
 	dualabi=`cat stamp-dual-abi` ;\
 	cxx11abi=`cat stamp-cxx11-abi` ;\
 	allocatornew=`cat stamp-allocator-new` ;\
+	float128=`cat stamp-float128` ;\
 	ldbl_compat='s,g,g,' ;\
 	grep "^[	 ]*#[	 ]*define[	 ][	 ]*_GLIBCXX_LONG_DOUBLE_COMPAT[	 ][	 ]*1[	 ]*$$" \
 	${CONFIG_HEADER} > /dev/null 2>&1 \
@@ -1688,6 +1694,7 @@ ${host_builddir}/c++config.h: ${CONFIG_HEADER} \
 	-e "s,define _GLIBCXX_USE_DUAL_ABI, define _GLIBCXX_USE_DUAL_ABI $$dualabi," \
 	-e "s,define _GLIBCXX_USE_CXX11_ABI, define _GLIBCXX_USE_CXX11_ABI $$cxx11abi," \
 	-e "s,define _GLIBCXX_USE_ALLOCATOR_NEW, define _GLIBCXX_USE_ALLOCATOR_NEW $$allocatornew," \
+	-e "s,define _GLIBCXX_USE_FLOAT128,$$float128," \
 	-e "$$ldbl_compat" \
 	    < ${glibcxx_srcdir}/include/bits/c++config > $@ ;\
 	sed -e 's/HAVE_/_GLIBCXX_HAVE_/g' \
@@ -1897,6 +1904,9 @@ $(ext_headers): ; @:
 $(experimental_headers): ; @:
 $(experimental_bits_headers): ; @:
 
+# See https://gcc.gnu.org/bugzilla/show_bug.cgi?id=81797
+@INCLUDE_DIR_NOTPARALLEL_TRUE@.NOTPARALLEL:
+
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
 .NOEXPORT:
diff --git a/libstdc++-v3/include/bits/basic_string.h b/libstdc++-v3/include/bits/basic_string.h
index 7df39685ad3..6443ba9192a 100644
--- a/libstdc++-v3/include/bits/basic_string.h
+++ b/libstdc++-v3/include/bits/basic_string.h
@@ -734,20 +734,29 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
 	// Replace allocator if POCMA is true.
 	std::__alloc_on_move(_M_get_allocator(), __str._M_get_allocator());
 
-	if (!__str._M_is_local()
-	    && (_Alloc_traits::_S_propagate_on_move_assign()
-	      || _Alloc_traits::_S_always_equal()))
+	if (__str._M_is_local())
+	  {
+	    // We've always got room for a short string, just copy it.
+	    if (__str.size())
+	      this->_S_copy(_M_data(), __str._M_data(), __str.size());
+	    _M_set_length(__str.size());
+	  }
+	else if (_Alloc_traits::_S_propagate_on_move_assign()
+	    || _Alloc_traits::_S_always_equal()
+	    || _M_get_allocator() == __str._M_get_allocator())
 	  {
+	    // Just move the allocated pointer, our allocator can free it.
 	    pointer __data = nullptr;
 	    size_type __capacity;
 	    if (!_M_is_local())
 	      {
 		if (_Alloc_traits::_S_always_equal())
 		  {
+		    // __str can reuse our existing storage.
 		    __data = _M_data();
 		    __capacity = _M_allocated_capacity;
 		  }
-		else
+		else // __str can't use it, so free it.
 		  _M_destroy(_M_allocated_capacity);
 	      }
 
@@ -762,8 +771,8 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
 	    else
 	      __str._M_data(__str._M_local_buf);
 	  }
-	else
-	    assign(__str);
+	else // Need to do a deep copy
+	  assign(__str);
 	__str.clear();
 	return *this;
       }
@@ -1216,7 +1225,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
        *  remainder of @a __str is appended.
        */
       basic_string&
-      append(const basic_string& __str, size_type __pos, size_type __n)
+      append(const basic_string& __str, size_type __pos, size_type __n = npos)
       { return _M_append(__str._M_data()
 			 + __str._M_check(__pos, "basic_string::append"),
 			 __str._M_limit(__pos, __n)); }
@@ -1381,7 +1390,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
        *  __str, the remainder of @a __str is used.
        */
       basic_string&
-      assign(const basic_string& __str, size_type __pos, size_type __n)
+      assign(const basic_string& __str, size_type __pos, size_type __n = npos)
       { return _M_replace(size_type(0), this->size(), __str._M_data()
 			  + __str._M_check(__pos, "basic_string::assign"),
 			  __str._M_limit(__pos, __n)); }
@@ -1633,7 +1642,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
       */
       basic_string&
       insert(size_type __pos1, const basic_string& __str,
-	     size_type __pos2, size_type __n)
+	     size_type __pos2, size_type __n = npos)
       { return this->replace(__pos1, size_type(0), __str._M_data()
 			     + __str._M_check(__pos2, "basic_string::insert"),
 			     __str._M_limit(__pos2, __n)); }
@@ -1881,7 +1890,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
       */
       basic_string&
       replace(size_type __pos1, size_type __n1, const basic_string& __str,
-	      size_type __pos2, size_type __n2)
+	      size_type __pos2, size_type __n2 = npos)
       { return this->replace(__pos1, __n1, __str._M_data()
 			     + __str._M_check(__pos2, "basic_string::replace"),
 			     __str._M_limit(__pos2, __n2)); }
@@ -2941,7 +2950,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
       */
       int
       compare(size_type __pos1, size_type __n1, const basic_string& __str,
-	      size_type __pos2, size_type __n2) const;
+	      size_type __pos2, size_type __n2 = npos) const;
 
       /**
        *  @brief  Compare to a C string.
@@ -4135,7 +4144,7 @@ _GLIBCXX_END_NAMESPACE_CXX11
        *  remainder of @a __str is appended.
        */
       basic_string&
-      append(const basic_string& __str, size_type __pos, size_type __n);
+      append(const basic_string& __str, size_type __pos, size_type __n = npos);
 
       /**
        *  @brief  Append a C substring.
@@ -4280,7 +4289,7 @@ _GLIBCXX_END_NAMESPACE_CXX11
        *  __str, the remainder of @a __str is used.
        */
       basic_string&
-      assign(const basic_string& __str, size_type __pos, size_type __n)
+      assign(const basic_string& __str, size_type __pos, size_type __n = npos)
       { return this->assign(__str._M_data()
 			    + __str._M_check(__pos, "basic_string::assign"),
 			    __str._M_limit(__pos, __n)); }
@@ -4468,7 +4477,7 @@ _GLIBCXX_END_NAMESPACE_CXX11
       */
       basic_string&
       insert(size_type __pos1, const basic_string& __str,
-	     size_type __pos2, size_type __n)
+	     size_type __pos2, size_type __n = npos)
       { return this->insert(__pos1, __str._M_data()
 			    + __str._M_check(__pos2, "basic_string::insert"),
 			    __str._M_limit(__pos2, __n)); }
@@ -4703,7 +4712,7 @@ _GLIBCXX_END_NAMESPACE_CXX11
       */
       basic_string&
       replace(size_type __pos1, size_type __n1, const basic_string& __str,
-	      size_type __pos2, size_type __n2)
+	      size_type __pos2, size_type __n2 = npos)
       { return this->replace(__pos1, __n1, __str._M_data()
 			     + __str._M_check(__pos2, "basic_string::replace"),
 			     __str._M_limit(__pos2, __n2)); }
@@ -5130,7 +5139,10 @@ _GLIBCXX_END_NAMESPACE_CXX11
       */
       _CharT*
       data() noexcept
-      { return _M_data(); }
+      {
+	_M_leak();
+	return _M_data();
+      }
 #endif
 
       /**
@@ -5779,7 +5791,7 @@ _GLIBCXX_END_NAMESPACE_CXX11
       */
       int
       compare(size_type __pos1, size_type __n1, const basic_string& __str,
-	      size_type __pos2, size_type __n2) const;
+	      size_type __pos2, size_type __n2 = npos) const;
 
       /**
        *  @brief  Compare to a C string.
diff --git a/libstdc++-v3/include/bits/basic_string.tcc b/libstdc++-v3/include/bits/basic_string.tcc
index 41b7fa196b0..65ff2445ff0 100644
--- a/libstdc++-v3/include/bits/basic_string.tcc
+++ b/libstdc++-v3/include/bits/basic_string.tcc
@@ -1597,8 +1597,21 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
   // Inhibit implicit instantiations for required instantiations,
   // which are defined via explicit instantiations elsewhere.
-#if _GLIBCXX_EXTERN_TEMPLATE > 0 && __cplusplus <= 201402L
+#if _GLIBCXX_EXTERN_TEMPLATE
+  // The explicit instantiations definitions in src/c++11/string-inst.cc
+  // are compiled as C++14, so the new C++17 members aren't instantiated.
+  // Until those definitions are compiled as C++17 suppress the declaration,
+  // so C++17 code will implicitly instantiate std::string and std::wstring
+  // as needed.
+# if __cplusplus <= 201402L && _GLIBCXX_EXTERN_TEMPLATE > 0
   extern template class basic_string<char>;
+# elif ! _GLIBCXX_USE_CXX11_ABI
+  // Still need to prevent implicit instantiation of the COW empty rep,
+  // to ensure the definition in libstdc++.so is unique (PR 86138).
+  extern template basic_string<char>::size_type
+    basic_string<char>::_Rep::_S_empty_rep_storage[];
+# endif
+
   extern template
     basic_istream<char>&
     operator>>(basic_istream<char>&, string&);
@@ -1613,7 +1626,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     getline(basic_istream<char>&, string&);
 
 #ifdef _GLIBCXX_USE_WCHAR_T
+# if __cplusplus <= 201402L && _GLIBCXX_EXTERN_TEMPLATE > 0
   extern template class basic_string<wchar_t>;
+# elif ! _GLIBCXX_USE_CXX11_ABI
+  extern template basic_string<wchar_t>::size_type
+    basic_string<wchar_t>::_Rep::_S_empty_rep_storage[];
+# endif
+
   extern template
     basic_istream<wchar_t>&
     operator>>(basic_istream<wchar_t>&, wstring&);
@@ -1626,8 +1645,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   extern template
     basic_istream<wchar_t>&
     getline(basic_istream<wchar_t>&, wstring&);
-#endif
-#endif
+#endif // _GLIBCXX_USE_WCHAR_T
+#endif // _GLIBCXX_EXTERN_TEMPLATE
 
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace std
diff --git a/libstdc++-v3/include/bits/c++14_warning.h b/libstdc++-v3/include/bits/c++14_warning.h
deleted file mode 100644
index 5ead9c6b122..00000000000
--- a/libstdc++-v3/include/bits/c++14_warning.h
+++ /dev/null
@@ -1,37 +0,0 @@
-// Copyright (C) 2013-2017 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// Under Section 7 of GPL version 3, you are granted additional
-// permissions described in the GCC Runtime Library Exception, version
-// 3.1, as published by the Free Software Foundation.
-
-// You should have received a copy of the GNU General Public License and
-// a copy of the GCC Runtime Library Exception along with this program;
-// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
-// <http://www.gnu.org/licenses/>.
-
-/** @file bits/c++14_warning.h
- *  This is an internal header file, included by other library headers.
- *  Do not attempt to use it directly. @headername{iosfwd}
- */
-
-#ifndef _CXX14_WARNING_H
-#define _CXX14_WARNING_H 1
-
-#if __cplusplus <= 201103L
-#error This file requires compiler and library support \
-for the ISO C++ 2014 standard. This support must be enabled \
-with the -std=c++14 or -std=gnu++14 compiler options.
-#endif
-
-#endif
diff --git a/libstdc++-v3/include/bits/c++config b/libstdc++-v3/include/bits/c++config
index 8ca6b0345b1..70bb49f9eec 100644
--- a/libstdc++-v3/include/bits/c++config
+++ b/libstdc++-v3/include/bits/c++config
@@ -634,4 +634,9 @@ namespace std
 # endif
 #endif
 
+/* Define if __float128 is supported on this host. */
+#if defined(__FLOAT128__) || defined(__SIZEOF_FLOAT128__)
+#define _GLIBCXX_USE_FLOAT128
+#endif
+
 // End of prewritten config; the settings discovered at configure time follow.
diff --git a/libstdc++-v3/include/bits/char_traits.h b/libstdc++-v3/include/bits/char_traits.h
index 3ecc30e46cb..26977ea7e87 100644
--- a/libstdc++-v3/include/bits/char_traits.h
+++ b/libstdc++-v3/include/bits/char_traits.h
@@ -143,8 +143,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       { return !eq_int_type(__c, eof()) ? __c : to_int_type(char_type()); }
     };
 
-#define __cpp_lib_constexpr_char_traits 201611
-
   template<typename _CharT>
     _GLIBCXX14_CONSTEXPR int
     char_traits<_CharT>::
@@ -217,6 +215,8 @@ namespace std _GLIBCXX_VISIBILITY(default)
 _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
 #if __cplusplus > 201402
+#define __cpp_lib_constexpr_char_traits 201611
+
   /**
    *  @brief Determine whether the characters of a NULL-terminated
    *  string are known at compile time.
@@ -246,7 +246,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     __constant_char_array_p(const _CharT* __a, size_t __n)
     {
       size_t __i = 0;
-      while (__builtin_constant_p(__a[__i]) && __i < __n)
+      while (__i < __n && __builtin_constant_p(__a[__i]))
 	__i++;
       return __i == __n;
     }
diff --git a/libstdc++-v3/include/bits/forward_list.h b/libstdc++-v3/include/bits/forward_list.h
index c37bf01345a..338e7b3dc6f 100644
--- a/libstdc++-v3/include/bits/forward_list.h
+++ b/libstdc++-v3/include/bits/forward_list.h
@@ -274,7 +274,6 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
     struct _Fwd_list_base
     {
     protected:
-      typedef __alloc_rebind<_Alloc, _Tp> 		  _Tp_alloc_type;
       typedef __alloc_rebind<_Alloc, _Fwd_list_node<_Tp>> _Node_alloc_type;
       typedef __gnu_cxx::__alloc_traits<_Node_alloc_type> _Node_alloc_traits;
 
@@ -345,11 +344,10 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
           _Node* __node = this->_M_get_node();
           __try
             {
-	      _Tp_alloc_type __a(_M_get_Node_allocator());
-	      typedef allocator_traits<_Tp_alloc_type> _Alloc_traits;
 	      ::new ((void*)__node) _Node;
-	      _Alloc_traits::construct(__a, __node->_M_valptr(),
-				       std::forward<_Args>(__args)...);
+	      _Node_alloc_traits::construct(_M_get_Node_allocator(),
+					    __node->_M_valptr(),
+					    std::forward<_Args>(__args)...);
             }
           __catch(...)
             {
@@ -412,10 +410,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       typedef _Fwd_list_base<_Tp, _Alloc>                  _Base;
       typedef _Fwd_list_node<_Tp>                          _Node;
       typedef _Fwd_list_node_base                          _Node_base;
-      typedef typename _Base::_Tp_alloc_type               _Tp_alloc_type;
       typedef typename _Base::_Node_alloc_type             _Node_alloc_type;
       typedef typename _Base::_Node_alloc_traits           _Node_alloc_traits;
-      typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type>    _Alloc_traits;
+      typedef allocator_traits<__alloc_rebind<_Alloc, _Tp>>    _Alloc_traits;
 
     public:
       // types:
diff --git a/libstdc++-v3/include/bits/forward_list.tcc b/libstdc++-v3/include/bits/forward_list.tcc
index b823b09e1af..ae6a6d09698 100644
--- a/libstdc++-v3/include/bits/forward_list.tcc
+++ b/libstdc++-v3/include/bits/forward_list.tcc
@@ -69,8 +69,8 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
     {
       _Node* __curr = static_cast<_Node*>(__pos->_M_next);
       __pos->_M_next = __curr->_M_next;
-      _Tp_alloc_type __a(_M_get_Node_allocator());
-      allocator_traits<_Tp_alloc_type>::destroy(__a, __curr->_M_valptr());
+      _Node_alloc_traits::destroy(_M_get_Node_allocator(),
+				  __curr->_M_valptr());
       __curr->~_Node();
       _M_put_node(__curr);
       return __pos->_M_next;
@@ -87,8 +87,8 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
         {
           _Node* __temp = __curr;
           __curr = static_cast<_Node*>(__curr->_M_next);
-	  _Tp_alloc_type __a(_M_get_Node_allocator());
-	  allocator_traits<_Tp_alloc_type>::destroy(__a, __temp->_M_valptr());
+	  _Node_alloc_traits::destroy(_M_get_Node_allocator(),
+				      __temp->_M_valptr());
 	  __temp->~_Node();
           _M_put_node(__temp);
         }
@@ -381,7 +381,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       auto __iy = __ly.cbegin();
       while (__ix != __lx.cend() && __iy != __ly.cend())
         {
-          if (*__ix != *__iy)
+          if (!(*__ix == *__iy))
             return false;
           ++__ix;
           ++__iy;
@@ -451,9 +451,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
                         __p = static_cast<_Node*>(__p->_M_next);
                         --__psize;
                       }
-                    else if (__comp(*__p->_M_valptr(), *__q->_M_valptr()))
+                    else if (!__comp(*__q->_M_valptr(), *__p->_M_valptr()))
                       {
-                        // First node of p is lower; e must come from p.
+                        // First node of q is not lower; e must come from p.
                         __e = __p;
                         __p = static_cast<_Node*>(__p->_M_next);
                         --__psize;
diff --git a/libstdc++-v3/include/bits/hashtable.h b/libstdc++-v3/include/bits/hashtable.h
index e0806dc93a1..e9c349ac956 100644
--- a/libstdc++-v3/include/bits/hashtable.h
+++ b/libstdc++-v3/include/bits/hashtable.h
@@ -1206,6 +1206,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	      _M_assign(__ht,
 			[&__roan](__node_type* __n)
 			{ return __roan(std::move_if_noexcept(__n->_M_v())); });
+
+	      if (__former_buckets)
+		_M_deallocate_buckets(__former_buckets, __former_bucket_count);
 	      __ht.clear();
 	    }
 	  __catch(...)
diff --git a/libstdc++-v3/include/bits/node_handle.h b/libstdc++-v3/include/bits/node_handle.h
index f75f7425f47..b4f732a36f0 100644
--- a/libstdc++-v3/include/bits/node_handle.h
+++ b/libstdc++-v3/include/bits/node_handle.h
@@ -105,7 +105,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       {
 	using std::swap;
 	swap(_M_ptr, __nh._M_ptr);
-	if (_AllocTraits::propagate_on_container_swap
+	if (_AllocTraits::propagate_on_container_swap::value
 	    || !_M_alloc || !__nh._M_alloc)
 	  _M_alloc.swap(__nh._M_alloc);
 	else
diff --git a/libstdc++-v3/include/bits/parse_numbers.h b/libstdc++-v3/include/bits/parse_numbers.h
index b82df755108..e1d514aa507 100644
--- a/libstdc++-v3/include/bits/parse_numbers.h
+++ b/libstdc++-v3/include/bits/parse_numbers.h
@@ -197,6 +197,13 @@ namespace __parse_int
 		    "integer literal does not fit in unsigned long long");
     };
 
+  // Skip past digit separators:
+  template<unsigned _Base, unsigned long long _Pow, char _Dig, char..._Digs>
+    struct _Number_help<_Base, _Pow, '\'', _Dig, _Digs...>
+    : _Number_help<_Base, _Pow, _Dig, _Digs...>
+    { };
+
+  // Terminating case for recursion:
   template<unsigned _Base, unsigned long long _Pow, char _Dig>
     struct _Number_help<_Base, _Pow, _Dig>
     {
diff --git a/libstdc++-v3/include/bits/random.h b/libstdc++-v3/include/bits/random.h
index d39cc3e0666..c3fbb0fff16 100644
--- a/libstdc++-v3/include/bits/random.h
+++ b/libstdc++-v3/include/bits/random.h
@@ -2643,7 +2643,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
        */
       void
       param(const param_type& __param)
-      { _M_param = __param; }
+      {
+	_M_param = __param;
+	typedef typename std::gamma_distribution<result_type>::param_type
+	  param_type;
+	_M_gd.param(param_type{__param.n() / 2});
+      }
 
       /**
        * @brief Returns the greatest lower bound value of the distribution.
diff --git a/libstdc++-v3/include/bits/random.tcc b/libstdc++-v3/include/bits/random.tcc
index df05ebea6e9..c43d85551c3 100644
--- a/libstdc++-v3/include/bits/random.tcc
+++ b/libstdc++-v3/include/bits/random.tcc
@@ -2356,7 +2356,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	    __v = __v * __v * __v;
 	    __u = __aurng();
 	  }
-	while (__u > result_type(1.0) - 0.331 * __n * __n * __n * __n
+	while (__u > result_type(1.0) - 0.0331 * __n * __n * __n * __n
 	       && (std::log(__u) > (0.5 * __n * __n + __a1
 				    * (1.0 - __v + std::log(__v)))));
 
@@ -2405,7 +2405,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 		  __v = __v * __v * __v;
 		  __u = __aurng();
 		}
-	      while (__u > result_type(1.0) - 0.331 * __n * __n * __n * __n
+	      while (__u > result_type(1.0) - 0.0331 * __n * __n * __n * __n
 		     && (std::log(__u) > (0.5 * __n * __n + __a1
 					  * (1.0 - __v + std::log(__v)))));
 
@@ -2426,7 +2426,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 		  __v = __v * __v * __v;
 		  __u = __aurng();
 		}
-	      while (__u > result_type(1.0) - 0.331 * __n * __n * __n * __n
+	      while (__u > result_type(1.0) - 0.0331 * __n * __n * __n * __n
 		     && (std::log(__u) > (0.5 * __n * __n + __a1
 					  * (1.0 - __v + std::log(__v)))));
 
diff --git a/libstdc++-v3/include/bits/regex.h b/libstdc++-v3/include/bits/regex.h
index 14a1ae6f61d..c8e6bfcaea4 100644
--- a/libstdc++-v3/include/bits/regex.h
+++ b/libstdc++-v3/include/bits/regex.h
@@ -785,6 +785,48 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
       _AutomatonPtr          _M_automaton;
     };
 
+#if __cplusplus < 201703L
+  template<typename _Ch, typename _Tr>
+    constexpr regex_constants::syntax_option_type
+    basic_regex<_Ch, _Tr>::icase;
+
+  template<typename _Ch, typename _Tr>
+    constexpr regex_constants::syntax_option_type
+    basic_regex<_Ch, _Tr>::nosubs;
+
+  template<typename _Ch, typename _Tr>
+    constexpr regex_constants::syntax_option_type
+    basic_regex<_Ch, _Tr>::optimize;
+
+  template<typename _Ch, typename _Tr>
+    constexpr regex_constants::syntax_option_type
+    basic_regex<_Ch, _Tr>::collate;
+
+  template<typename _Ch, typename _Tr>
+    constexpr regex_constants::syntax_option_type
+    basic_regex<_Ch, _Tr>::ECMAScript;
+
+  template<typename _Ch, typename _Tr>
+    constexpr regex_constants::syntax_option_type
+    basic_regex<_Ch, _Tr>::basic;
+
+  template<typename _Ch, typename _Tr>
+    constexpr regex_constants::syntax_option_type
+    basic_regex<_Ch, _Tr>::extended;
+
+  template<typename _Ch, typename _Tr>
+    constexpr regex_constants::syntax_option_type
+    basic_regex<_Ch, _Tr>::awk;
+
+  template<typename _Ch, typename _Tr>
+    constexpr regex_constants::syntax_option_type
+    basic_regex<_Ch, _Tr>::grep;
+
+  template<typename _Ch, typename _Tr>
+    constexpr regex_constants::syntax_option_type
+    basic_regex<_Ch, _Tr>::egrep;
+#endif // ! C++17
+
   /** @brief Standard regular expressions. */
   typedef basic_regex<char>    regex;
 
diff --git a/libstdc++-v3/include/bits/regex_automaton.h b/libstdc++-v3/include/bits/regex_automaton.h
index a5fab6356cc..99b846dffc0 100644
--- a/libstdc++-v3/include/bits/regex_automaton.h
+++ b/libstdc++-v3/include/bits/regex_automaton.h
@@ -333,7 +333,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	    "Number of NFA states exceeds limit. Please use shorter regex "
 	    "string, or use smaller brace expression, or make "
 	    "_GLIBCXX_REGEX_STATE_LIMIT larger.");
-	return this->size()-1;
+	return this->size() - 1;
       }
 
       // Eliminate dummy node in this NFA to make it compact.
diff --git a/libstdc++-v3/include/bits/stl_bvector.h b/libstdc++-v3/include/bits/stl_bvector.h
index 37e000ad962..78195c1295d 100644
--- a/libstdc++-v3/include/bits/stl_bvector.h
+++ b/libstdc++-v3/include/bits/stl_bvector.h
@@ -1089,9 +1089,17 @@ template<typename _Alloc>
     void
     _M_initialize(size_type __n)
     {
-      _Bit_pointer __q = this->_M_allocate(__n);
-      this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
-      this->_M_impl._M_start = iterator(std::__addressof(*__q), 0);
+      if (__n)
+	{
+	  _Bit_pointer __q = this->_M_allocate(__n);
+	  this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
+	  this->_M_impl._M_start = iterator(std::__addressof(*__q), 0);
+	}
+      else
+	{
+	  this->_M_impl._M_end_of_storage = _Bit_pointer();
+	  this->_M_impl._M_start = iterator(0, 0);
+	}
       this->_M_impl._M_finish = this->_M_impl._M_start + difference_type(__n);
     }
 
diff --git a/libstdc++-v3/include/bits/stl_iterator.h b/libstdc++-v3/include/bits/stl_iterator.h
index e6ef784ce19..114d492fd8a 100644
--- a/libstdc++-v3/include/bits/stl_iterator.h
+++ b/libstdc++-v3/include/bits/stl_iterator.h
@@ -122,6 +122,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       */
       // _GLIBCXX_RESOLVE_LIB_DEFECTS
       // 235 No specification of default ctor for reverse_iterator
+      // 1012. reverse_iterator default ctor should value initialize
       _GLIBCXX17_CONSTEXPR
       reverse_iterator() : current() { }
 
@@ -176,9 +177,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
        *
        *  This requires that @c --current is dereferenceable.
       */
+      // _GLIBCXX_RESOLVE_LIB_DEFECTS
+      // 2188. Reverse iterator does not fully support targets that overload &
       _GLIBCXX17_CONSTEXPR pointer
       operator->() const
-      { return &(operator*()); }
+      { return std::__addressof(operator*()); }
 
       /**
        *  @return  @c *this
diff --git a/libstdc++-v3/include/bits/stl_map.h b/libstdc++-v3/include/bits/stl_map.h
index ea0e3277738..6ec885ac3be 100644
--- a/libstdc++-v3/include/bits/stl_map.h
+++ b/libstdc++-v3/include/bits/stl_map.h
@@ -802,12 +802,11 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       insert(value_type&& __x)
       { return _M_t._M_insert_unique(std::move(__x)); }
 
-      template<typename _Pair, typename = typename
-	       std::enable_if<std::is_constructible<value_type,
-						    _Pair&&>::value>::type>
-	std::pair<iterator, bool>
+      template<typename _Pair>
+	__enable_if_t<is_constructible<value_type, _Pair>::value,
+		      pair<iterator, bool>>
 	insert(_Pair&& __x)
-	{ return _M_t._M_insert_unique(std::forward<_Pair>(__x)); }
+	{ return _M_t._M_emplace_unique(std::forward<_Pair>(__x)); }
 #endif
       // @}
 
@@ -863,13 +862,13 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       insert(const_iterator __position, value_type&& __x)
       { return _M_t._M_insert_unique_(__position, std::move(__x)); }
 
-      template<typename _Pair, typename = typename
-	       std::enable_if<std::is_constructible<value_type,
-						    _Pair&&>::value>::type>
-	iterator
+      template<typename _Pair>
+	__enable_if_t<is_constructible<value_type, _Pair>::value, iterator>
 	insert(const_iterator __position, _Pair&& __x)
-	{ return _M_t._M_insert_unique_(__position,
-					std::forward<_Pair>(__x)); }
+	{
+	  return _M_t._M_emplace_hint_unique(__position,
+					     std::forward<_Pair>(__x));
+	}
 #endif
       // @}
 
diff --git a/libstdc++-v3/include/bits/stl_multimap.h b/libstdc++-v3/include/bits/stl_multimap.h
index 68ffea3adba..63f0055cdd6 100644
--- a/libstdc++-v3/include/bits/stl_multimap.h
+++ b/libstdc++-v3/include/bits/stl_multimap.h
@@ -538,12 +538,10 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       insert(value_type&& __x)
       { return _M_t._M_insert_equal(std::move(__x)); }
 
-      template<typename _Pair, typename = typename
-	       std::enable_if<std::is_constructible<value_type,
-						    _Pair&&>::value>::type>
-	iterator
+      template<typename _Pair>
+	__enable_if_t<is_constructible<value_type, _Pair>::value, iterator>
 	insert(_Pair&& __x)
-	{ return _M_t._M_insert_equal(std::forward<_Pair>(__x)); }
+	{ return _M_t._M_emplace_equal(std::forward<_Pair>(__x)); }
 #endif
       // @}
 
@@ -583,13 +581,13 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       insert(const_iterator __position, value_type&& __x)
       { return _M_t._M_insert_equal_(__position, std::move(__x)); }
 
-      template<typename _Pair, typename = typename
-	       std::enable_if<std::is_constructible<value_type,
-						    _Pair&&>::value>::type>
-	iterator
+      template<typename _Pair>
+	__enable_if_t<is_constructible<value_type, _Pair&&>::value, iterator>
 	insert(const_iterator __position, _Pair&& __x)
-	{ return _M_t._M_insert_equal_(__position,
-				       std::forward<_Pair>(__x)); }
+	{
+	  return _M_t._M_emplace_hint_equal(__position,
+					    std::forward<_Pair>(__x));
+	}
 #endif
       // @}
 
diff --git a/libstdc++-v3/include/bits/stl_pair.h b/libstdc++-v3/include/bits/stl_pair.h
index b6245b65cd1..5fd0c31ee8d 100644
--- a/libstdc++-v3/include/bits/stl_pair.h
+++ b/libstdc++-v3/include/bits/stl_pair.h
@@ -185,8 +185,18 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   struct __nonesuch_no_braces : std::__nonesuch {
     explicit __nonesuch_no_braces(const __nonesuch&) = delete;
   };
+#endif // C++11
 
-#endif
+  template<typename _U1, typename _U2> class __pair_base
+  {
+#if __cplusplus >= 201103L
+    template<typename _T1, typename _T2> friend struct pair;
+    __pair_base() = default;
+    ~__pair_base() = default;
+    __pair_base(const __pair_base&) = default;
+    __pair_base& operator=(const __pair_base&) = delete;
+#endif // C++11
+  };
 
  /**
    *  @brief Struct holding two objects of arbitrary type.
@@ -196,6 +206,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
    */
   template<typename _T1, typename _T2>
     struct pair
+    : private __pair_base<_T1, _T2>
     {
       typedef _T1 first_type;    /// @c first_type is the first bound type
       typedef _T2 second_type;   /// @c second_type is the second bound type
@@ -374,19 +385,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	return *this;
       }
 
-      pair&
-      operator=(typename conditional<
-		__not_<__and_<is_copy_assignable<_T1>,
-		              is_copy_assignable<_T2>>>::value,
-		const pair&, const __nonesuch_no_braces&>::type __p) = delete;
-
       pair&
       operator=(typename conditional<
 		__and_<is_move_assignable<_T1>,
 		       is_move_assignable<_T2>>::value,
 		pair&&, __nonesuch_no_braces&&>::type __p)
       noexcept(__and_<is_nothrow_move_assignable<_T1>,
-	              is_nothrow_move_assignable<_T2>>::value)
+		      is_nothrow_move_assignable<_T2>>::value)
       {
 	first = std::forward<first_type>(__p.first);
 	second = std::forward<second_type>(__p.second);
diff --git a/libstdc++-v3/include/bits/stl_vector.h b/libstdc++-v3/include/bits/stl_vector.h
index fb882126cf9..eac04655a38 100644
--- a/libstdc++-v3/include/bits/stl_vector.h
+++ b/libstdc++-v3/include/bits/stl_vector.h
@@ -1302,22 +1302,27 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       // Called by the second initialize_dispatch above
       template<typename _InputIterator>
 	void
-	_M_range_initialize(_InputIterator __first,
-			    _InputIterator __last, std::input_iterator_tag)
+	_M_range_initialize(_InputIterator __first, _InputIterator __last,
+			    std::input_iterator_tag)
 	{
-	  for (; __first != __last; ++__first)
+	  __try {
+	    for (; __first != __last; ++__first)
 #if __cplusplus >= 201103L
-	    emplace_back(*__first);
+	      emplace_back(*__first);
 #else
-	    push_back(*__first);
+	      push_back(*__first);
 #endif
+	  } __catch(...) {
+	    clear();
+	    __throw_exception_again;
+	  }
 	}
 
       // Called by the second initialize_dispatch above
       template<typename _ForwardIterator>
 	void
-	_M_range_initialize(_ForwardIterator __first,
-			    _ForwardIterator __last, std::forward_iterator_tag)
+	_M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,
+			    std::forward_iterator_tag)
 	{
 	  const size_type __n = std::distance(__first, __last);
 	  this->_M_impl._M_start = this->_M_allocate(__n);
diff --git a/libstdc++-v3/include/bits/unique_ptr.h b/libstdc++-v3/include/bits/unique_ptr.h
index a31cd67d6e3..99cf10ef4ee 100644
--- a/libstdc++-v3/include/bits/unique_ptr.h
+++ b/libstdc++-v3/include/bits/unique_ptr.h
@@ -187,7 +187,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 		typename = _DeleterConstraint<_Up>>
 	constexpr unique_ptr() noexcept
 	: _M_t()
-        { }
+	{ }
 
       /** Takes ownership of a pointer.
        *
@@ -230,7 +230,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       /// Creates a unique_ptr that owns nothing.
       template <typename _Up = _Dp,
 		typename = _DeleterConstraint<_Up>>
-	constexpr unique_ptr(nullptr_t) noexcept : unique_ptr() { }
+	constexpr unique_ptr(nullptr_t) noexcept : _M_t() { }
 
       // Move constructors.
 
@@ -452,7 +452,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 		typename = _DeleterConstraint<_Up>>
 	constexpr unique_ptr() noexcept
 	: _M_t()
-        { }
+	{ }
 
       /** Takes ownership of a pointer.
        *
@@ -511,7 +511,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       /// Creates a unique_ptr that owns nothing.
       template <typename _Up = _Dp,
 		typename = _DeleterConstraint<_Up>>
-	constexpr unique_ptr(nullptr_t) noexcept : unique_ptr() { }
+	constexpr unique_ptr(nullptr_t) noexcept : _M_t() { }
 
       template<typename _Up, typename _Ep,
 	       typename = _Require<__safe_conversion_up<_Up, _Ep>>>
diff --git a/libstdc++-v3/include/bits/unordered_map.h b/libstdc++-v3/include/bits/unordered_map.h
index dd881d46213..4ff54d0ef2e 100644
--- a/libstdc++-v3/include/bits/unordered_map.h
+++ b/libstdc++-v3/include/bits/unordered_map.h
@@ -584,12 +584,11 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       insert(value_type&& __x)
       { return _M_h.insert(std::move(__x)); }
 
-      template<typename _Pair, typename = typename
-	       std::enable_if<std::is_constructible<value_type,
-						    _Pair&&>::value>::type>
-	std::pair<iterator, bool>
+      template<typename _Pair>
+	__enable_if_t<is_constructible<value_type, _Pair&&>::value,
+		      pair<iterator, bool>>
 	insert(_Pair&& __x)
-        { return _M_h.insert(std::forward<_Pair>(__x)); }
+        { return _M_h.emplace(std::forward<_Pair>(__x)); }
       //@}
 
       //@{
@@ -624,12 +623,10 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       insert(const_iterator __hint, value_type&& __x)
       { return _M_h.insert(__hint, std::move(__x)); }
 
-      template<typename _Pair, typename = typename
-	       std::enable_if<std::is_constructible<value_type,
-						    _Pair&&>::value>::type>
-	iterator
+      template<typename _Pair>
+	__enable_if_t<is_constructible<value_type, _Pair&&>::value, iterator>
 	insert(const_iterator __hint, _Pair&& __x)
-	{ return _M_h.insert(__hint, std::forward<_Pair>(__x)); }
+	{ return _M_h.emplace_hint(__hint, std::forward<_Pair>(__x)); }
       //@}
 
       /**
@@ -1483,12 +1480,10 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       insert(value_type&& __x)
       { return _M_h.insert(std::move(__x)); }
 
-      template<typename _Pair, typename = typename
-	       std::enable_if<std::is_constructible<value_type,
-						    _Pair&&>::value>::type>
-	iterator
+      template<typename _Pair>
+	__enable_if_t<is_constructible<value_type, _Pair&&>::value, iterator>
 	insert(_Pair&& __x)
-        { return _M_h.insert(std::forward<_Pair>(__x)); }
+        { return _M_h.emplace(std::forward<_Pair>(__x)); }
       //@}
 
       //@{
@@ -1521,12 +1516,10 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       insert(const_iterator __hint, value_type&& __x)
       { return _M_h.insert(__hint, std::move(__x)); }
 
-      template<typename _Pair, typename = typename
-	       std::enable_if<std::is_constructible<value_type,
-						    _Pair&&>::value>::type>
-	iterator
+      template<typename _Pair>
+	__enable_if_t<is_constructible<value_type, _Pair&&>::value, iterator>
 	insert(const_iterator __hint, _Pair&& __x)
-        { return _M_h.insert(__hint, std::forward<_Pair>(__x)); }
+        { return _M_h.emplace_hint(__hint, std::forward<_Pair>(__x)); }
       //@}
 
       /**
diff --git a/libstdc++-v3/include/bits/valarray_array.h b/libstdc++-v3/include/bits/valarray_array.h
index f169edd9728..871be63c4ff 100644
--- a/libstdc++-v3/include/bits/valarray_array.h
+++ b/libstdc++-v3/include/bits/valarray_array.h
@@ -152,7 +152,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     {
       inline static void
       _S_do_it(const _Tp* __b, const _Tp* __e, _Tp* __restrict__ __o)
-      { __builtin_memcpy(__o, __b, (__e - __b) * sizeof(_Tp)); }
+      {
+	if (__b)
+	  __builtin_memcpy(__o, __b, (__e - __b) * sizeof(_Tp));
+      }
     };
 
   template<typename _Tp>
@@ -258,7 +261,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     {
       inline static void
       _S_do_it(const _Tp* __restrict__ __a, size_t __n, _Tp* __restrict__ __b)
-      { __builtin_memcpy(__b, __a, __n * sizeof (_Tp)); }
+      {
+	if (__n != 0)
+	  __builtin_memcpy(__b, __a, __n * sizeof (_Tp));
+      }
     };
 
   // Copy a plain array __a[<__n>] into a play array __b[<>]
@@ -335,17 +341,16 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     }
 
   //
-  // Compute the sum of elements in range [__f, __l)
+  // Compute the sum of elements in range [__f, __l) which must not be empty.
   // This is a naive algorithm.  It suffers from cancelling.
-  // In the future try to specialize
-  // for _Tp = float, double, long double using a more accurate
-  // algorithm.
+  // In the future try to specialize for _Tp = float, double, long double
+  // using a more accurate algorithm.
   //
   template<typename _Tp>
     inline _Tp
     __valarray_sum(const _Tp* __f, const _Tp* __l)
     {
-      _Tp __r = _Tp();
+      _Tp __r = *__f++;
       while (__f != __l)
 	__r += *__f++;
       return __r;
diff --git a/libstdc++-v3/include/bits/vector.tcc b/libstdc++-v3/include/bits/vector.tcc
index 8d688661c82..a2cc0cbf30f 100644
--- a/libstdc++-v3/include/bits/vector.tcc
+++ b/libstdc++-v3/include/bits/vector.tcc
@@ -567,23 +567,23 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	    {
 	      const size_type __len =
 		_M_check_len(__n, "vector::_M_default_append");
-	      const size_type __old_size = this->size();
+	      const size_type __size = this->size();
 	      pointer __new_start(this->_M_allocate(__len));
-	      pointer __new_finish(__new_start);
+	      pointer __destroy_from = pointer();
 	      __try
 		{
-		  __new_finish
-		    = std::__uninitialized_move_if_noexcept_a
-		    (this->_M_impl._M_start, this->_M_impl._M_finish,
-		     __new_start, _M_get_Tp_allocator());
-		  __new_finish =
-		    std::__uninitialized_default_n_a(__new_finish, __n,
-						     _M_get_Tp_allocator());
+		  std::__uninitialized_default_n_a(__new_start + __size,
+						   __n, _M_get_Tp_allocator());
+		  __destroy_from = __new_start + __size;
+		  std::__uninitialized_move_if_noexcept_a(
+		      this->_M_impl._M_start, this->_M_impl._M_finish,
+		      __new_start, _M_get_Tp_allocator());
 		}
 	      __catch(...)
 		{
-		  std::_Destroy(__new_start, __new_finish,
-				_M_get_Tp_allocator());
+		  if (__destroy_from)
+		    std::_Destroy(__destroy_from, __destroy_from + __n,
+				  _M_get_Tp_allocator());
 		  _M_deallocate(__new_start, __len);
 		  __throw_exception_again;
 		}
@@ -593,7 +593,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 			    this->_M_impl._M_end_of_storage
 			    - this->_M_impl._M_start);
 	      this->_M_impl._M_start = __new_start;
-	      this->_M_impl._M_finish = __new_finish;
+	      this->_M_impl._M_finish = __new_start + __size + __n;
 	      this->_M_impl._M_end_of_storage = __new_start + __len;
 	    }
 	}
diff --git a/libstdc++-v3/include/c_global/cstddef b/libstdc++-v3/include/c_global/cstddef
index 11d268b7f81..815d52c0778 100644
--- a/libstdc++-v3/include/c_global/cstddef
+++ b/libstdc++-v3/include/c_global/cstddef
@@ -65,7 +65,7 @@ namespace std
   /// std::byte
   enum class byte : unsigned char {};
 
-  template<typename _IntegerType> struct __byte_operand;
+  template<typename _IntegerType> struct __byte_operand { };
   template<> struct __byte_operand<bool> { using __type = byte; };
   template<> struct __byte_operand<char> { using __type = byte; };
   template<> struct __byte_operand<signed char> { using __type = byte; };
diff --git a/libstdc++-v3/include/c_global/cstdlib b/libstdc++-v3/include/c_global/cstdlib
index 006ac689763..52d5255592f 100644
--- a/libstdc++-v3/include/c_global/cstdlib
+++ b/libstdc++-v3/include/c_global/cstdlib
@@ -78,6 +78,9 @@ namespace std
 
 // Get rid of those macros defined in <stdlib.h> in lieu of real functions.
 #undef abort
+#if __cplusplus >= 201703L && defined(_GLIBCXX_HAVE_ALIGNED_ALLOC)
+# undef aligned_alloc
+#endif
 #undef atexit
 #if __cplusplus >= 201103L
 # ifdef _GLIBCXX_HAVE_AT_QUICK_EXIT
@@ -125,6 +128,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   using ::ldiv_t;
 
   using ::abort;
+#if __cplusplus >= 201703L && defined(_GLIBCXX_HAVE_ALIGNED_ALLOC)
+  using ::aligned_alloc;
+#endif
   using ::atexit;
 #if __cplusplus >= 201103L
 # ifdef _GLIBCXX_HAVE_AT_QUICK_EXIT
diff --git a/libstdc++-v3/include/debug/string b/libstdc++-v3/include/debug/string
index 9d4057b7d43..2c4f1aa3963 100644
--- a/libstdc++-v3/include/debug/string
+++ b/libstdc++-v3/include/debug/string
@@ -565,7 +565,7 @@ template<typename _CharT, typename _Traits = std::char_traits<_CharT>,
       insert(iterator __p, _InputIterator __first, _InputIterator __last)
       {
 	typename __gnu_debug::_Distance_traits<_InputIterator>::__type __dist;
-	__glibcxx_check_insert_range2(__p, __first, __last, __dist);
+	__glibcxx_check_insert_range(__p, __first, __last, __dist);
 
 	if (__dist.second >= __dp_sign)
 	  _Base::insert(__p.base(), __gnu_debug::__unsafe(__first),
diff --git a/libstdc++-v3/include/experimental/algorithm b/libstdc++-v3/include/experimental/algorithm
index a7ab0e84c12..f7c9fbe0229 100644
--- a/libstdc++-v3/include/experimental/algorithm
+++ b/libstdc++-v3/include/experimental/algorithm
@@ -31,9 +31,7 @@
 
 #pragma GCC system_header
 
-#if __cplusplus <= 201103L
-# include <bits/c++14_warning.h>
-#else
+#if __cplusplus >= 201402L
 
 #include <algorithm>
 #include <experimental/bits/lfts_config.h>
diff --git a/libstdc++-v3/include/experimental/any b/libstdc++-v3/include/experimental/any
index 36c0680c25a..b1d11398b79 100644
--- a/libstdc++-v3/include/experimental/any
+++ b/libstdc++-v3/include/experimental/any
@@ -31,9 +31,7 @@
 
 #pragma GCC system_header
 
-#if __cplusplus <= 201103L
-# include <bits/c++14_warning.h>
-#else
+#if __cplusplus >= 201402L
 
 #include <typeinfo>
 #include <new>
diff --git a/libstdc++-v3/include/experimental/array b/libstdc++-v3/include/experimental/array
index 11cb924e087..09751a4204c 100644
--- a/libstdc++-v3/include/experimental/array
+++ b/libstdc++-v3/include/experimental/array
@@ -31,9 +31,7 @@
 
 #pragma GCC system_header
 
-#if __cplusplus <= 201103L
-# include <bits/c++14_warning.h>
-#else
+#if __cplusplus >= 201402L
 
 #include <array>
 #include <experimental/type_traits>
diff --git a/libstdc++-v3/include/experimental/bits/erase_if.h b/libstdc++-v3/include/experimental/bits/erase_if.h
index 7dc47dbb3eb..2a5a520539a 100644
--- a/libstdc++-v3/include/experimental/bits/erase_if.h
+++ b/libstdc++-v3/include/experimental/bits/erase_if.h
@@ -32,9 +32,7 @@
 
 #pragma GCC system_header
 
-#if __cplusplus <= 201103L
-# include <bits/c++14_warning.h>
-#else
+#if __cplusplus >= 201402L
 #include <experimental/bits/lfts_config.h>
 
 namespace std
diff --git a/libstdc++-v3/include/experimental/bits/fs_path.h b/libstdc++-v3/include/experimental/bits/fs_path.h
index 512167f6f2d..aa4949c5e24 100644
--- a/libstdc++-v3/include/experimental/bits/fs_path.h
+++ b/libstdc++-v3/include/experimental/bits/fs_path.h
@@ -509,7 +509,11 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
 
   /// Append one path to another
   inline path operator/(const path& __lhs, const path& __rhs)
-  { return path(__lhs) /= __rhs; }
+  {
+    path __result(__lhs);
+    __result /= __rhs;
+    return __result;
+  }
 
   /// Write a path to a stream
   template<typename _CharT, typename _Traits>
diff --git a/libstdc++-v3/include/experimental/bits/lfts_config.h b/libstdc++-v3/include/experimental/bits/lfts_config.h
index a9faa47a842..cef3dc6d8ef 100644
--- a/libstdc++-v3/include/experimental/bits/lfts_config.h
+++ b/libstdc++-v3/include/experimental/bits/lfts_config.h
@@ -27,9 +27,7 @@
  *  Do not attempt to use it directly.
  */
 
-#if __cplusplus <= 201103L
-# include <bits/c++14_warning.h>
-#else
+#if __cplusplus >= 201402L
 #include <bits/c++config.h>
 
 #if _GLIBCXX_INLINE_VERSION
diff --git a/libstdc++-v3/include/experimental/bits/shared_ptr.h b/libstdc++-v3/include/experimental/bits/shared_ptr.h
index 27f22d23618..bbeccd9b010 100644
--- a/libstdc++-v3/include/experimental/bits/shared_ptr.h
+++ b/libstdc++-v3/include/experimental/bits/shared_ptr.h
@@ -32,9 +32,7 @@
 
 #pragma GCC system_header
 
-#if __cplusplus <= 201103L
-# include <bits/c++14_warning.h>
-#else
+#if __cplusplus >= 201402L
 
 #include <memory>
 #include <experimental/type_traits>
diff --git a/libstdc++-v3/include/experimental/bits/string_view.tcc b/libstdc++-v3/include/experimental/bits/string_view.tcc
index 30968fc6b83..ea0a49c1b03 100644
--- a/libstdc++-v3/include/experimental/bits/string_view.tcc
+++ b/libstdc++-v3/include/experimental/bits/string_view.tcc
@@ -36,9 +36,7 @@
 
 #pragma GCC system_header
 
-#if __cplusplus <= 201103L
-# include <bits/c++14_warning.h>
-#else
+#if __cplusplus >= 201402L
 
 namespace std _GLIBCXX_VISIBILITY(default)
 {
diff --git a/libstdc++-v3/include/experimental/chrono b/libstdc++-v3/include/experimental/chrono
index 4247c9df746..d8b6b330576 100644
--- a/libstdc++-v3/include/experimental/chrono
+++ b/libstdc++-v3/include/experimental/chrono
@@ -35,9 +35,7 @@
 
 #pragma GCC system_header
 
-#if __cplusplus <= 201103L
-# include <bits/c++14_warning.h>
-#else
+#if __cplusplus >= 201402L
 
 #include <chrono>
 #include <experimental/bits/lfts_config.h>
diff --git a/libstdc++-v3/include/experimental/deque b/libstdc++-v3/include/experimental/deque
index c92476f915d..5900648b8ab 100644
--- a/libstdc++-v3/include/experimental/deque
+++ b/libstdc++-v3/include/experimental/deque
@@ -31,9 +31,7 @@
 
 #pragma GCC system_header
 
-#if __cplusplus <= 201103L
-# include <bits/c++14_warning.h>
-#else
+#if __cplusplus >= 201402L
 
 #include <deque>
 #include <algorithm>
diff --git a/libstdc++-v3/include/experimental/filesystem b/libstdc++-v3/include/experimental/filesystem
index 2f353693dbe..0c8d5b02362 100644
--- a/libstdc++-v3/include/experimental/filesystem
+++ b/libstdc++-v3/include/experimental/filesystem
@@ -31,9 +31,7 @@
 
 #pragma GCC system_header
 
-#if __cplusplus < 201103L
-# include <bits/c++0x_warning.h>
-#else
+#if __cplusplus >= 201103L
 
 #include <experimental/bits/fs_fwd.h>
 #include <experimental/bits/fs_path.h>
diff --git a/libstdc++-v3/include/experimental/forward_list b/libstdc++-v3/include/experimental/forward_list
index 1c835aca07e..f95ca40f9fd 100644
--- a/libstdc++-v3/include/experimental/forward_list
+++ b/libstdc++-v3/include/experimental/forward_list
@@ -31,9 +31,7 @@
 
 #pragma GCC system_header
 
-#if __cplusplus <= 201103L
-# include <bits/c++14_warning.h>
-#else
+#if __cplusplus >= 201402L
 
 #include <forward_list>
 #include <experimental/memory_resource>
diff --git a/libstdc++-v3/include/experimental/functional b/libstdc++-v3/include/experimental/functional
index 4639e6f6cb3..96ecd064519 100644
--- a/libstdc++-v3/include/experimental/functional
+++ b/libstdc++-v3/include/experimental/functional
@@ -31,9 +31,7 @@
 
 #pragma GCC system_header
 
-#if __cplusplus <= 201103L
-# include <bits/c++14_warning.h>
-#else
+#if __cplusplus >= 201402L
 
 #include <functional>
 #include <tuple>
diff --git a/libstdc++-v3/include/experimental/iterator b/libstdc++-v3/include/experimental/iterator
index 8a8395da759..487b27226ce 100644
--- a/libstdc++-v3/include/experimental/iterator
+++ b/libstdc++-v3/include/experimental/iterator
@@ -35,9 +35,7 @@
 
 #pragma GCC system_header
 
-#if __cplusplus <= 201103L
-# include <bits/c++14_warning.h>
-#else
+#if __cplusplus >= 201402L
 
 #include <iterator>
 #include <iosfwd>
diff --git a/libstdc++-v3/include/experimental/list b/libstdc++-v3/include/experimental/list
index 9409431c4d8..abde37896ab 100644
--- a/libstdc++-v3/include/experimental/list
+++ b/libstdc++-v3/include/experimental/list
@@ -31,9 +31,7 @@
 
 #pragma GCC system_header
 
-#if __cplusplus <= 201103L
-# include <bits/c++14_warning.h>
-#else
+#if __cplusplus >= 201402L
 
 #include <list>
 #include <experimental/memory_resource>
diff --git a/libstdc++-v3/include/experimental/map b/libstdc++-v3/include/experimental/map
index 2bbc1bd5a11..77887457cd1 100644
--- a/libstdc++-v3/include/experimental/map
+++ b/libstdc++-v3/include/experimental/map
@@ -31,9 +31,7 @@
 
 #pragma GCC system_header
 
-#if __cplusplus <= 201103L
-# include <bits/c++14_warning.h>
-#else
+#if __cplusplus >= 201402L
 
 #include <map>
 #include <experimental/bits/erase_if.h>
diff --git a/libstdc++-v3/include/experimental/memory b/libstdc++-v3/include/experimental/memory
index 7467674db81..56d56ac0104 100644
--- a/libstdc++-v3/include/experimental/memory
+++ b/libstdc++-v3/include/experimental/memory
@@ -35,9 +35,7 @@
 
 #pragma GCC system_header
 
-#if __cplusplus <= 201103L
-# include <bits/c++14_warning.h>
-#else
+#if __cplusplus >= 201402L
 
 #include <memory>
 #include <type_traits>
diff --git a/libstdc++-v3/include/experimental/memory_resource b/libstdc++-v3/include/experimental/memory_resource
index 99ace7a7f81..450aa795e74 100644
--- a/libstdc++-v3/include/experimental/memory_resource
+++ b/libstdc++-v3/include/experimental/memory_resource
@@ -33,7 +33,6 @@
 #include <new>
 #include <atomic>
 #include <cstddef>
-#include <bits/alloc_traits.h>
 #include <experimental/bits/lfts_config.h>
 
 namespace std {
@@ -258,6 +257,22 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   template <typename _Alloc>
     class __resource_adaptor_imp : public memory_resource
     {
+      static_assert(is_same<char,
+	  typename allocator_traits<_Alloc>::value_type>::value,
+	  "Allocator's value_type is char");
+      static_assert(is_same<char*,
+	  typename allocator_traits<_Alloc>::pointer>::value,
+	  "Allocator's pointer type is value_type*");
+      static_assert(is_same<const char*,
+	  typename allocator_traits<_Alloc>::const_pointer>::value,
+	  "Allocator's const_pointer type is value_type const*");
+      static_assert(is_same<void*,
+	  typename allocator_traits<_Alloc>::void_pointer>::value,
+	  "Allocator's void_pointer type is void*");
+      static_assert(is_same<const void*,
+	  typename allocator_traits<_Alloc>::const_void_pointer>::value,
+	  "Allocator's const_void_pointer type is void const*");
+
     public:
       using allocator_type = _Alloc;
 
@@ -276,7 +291,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       __resource_adaptor_imp&
       operator=(const __resource_adaptor_imp&) = default;
 
-      allocator_type get_allocator() const { return _M_alloc; }
+      allocator_type get_allocator() const noexcept { return _M_alloc; }
 
     protected:
       virtual void*
@@ -311,13 +326,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     private:
       // Calculate Aligned Size
       // Returns a size that is larger than or equal to __size and divisible
-      // by __alignment, where __alignment is required to be the power of 2.
+      // by __alignment, where __alignment is required to be a power of 2.
       static size_t
       _S_aligned_size(size_t __size, size_t __alignment)
       { return ((__size - 1)|(__alignment - 1)) + 1; }
 
       // Determine whether alignment meets one of those preconditions:
-      // 1. Equals to Zero
+      // 1. Equal to Zero
       // 2. Is power of two
       static bool
       _S_supported (size_t __x)
@@ -327,47 +342,50 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     };
 
   // Global memory resources
-  inline std::atomic<memory_resource*>&
-  __get_default_resource()
-  {
-    static atomic<memory_resource*> _S_default_resource(new_delete_resource());
-    return _S_default_resource;
-  }
 
   inline memory_resource*
   new_delete_resource() noexcept
   {
-    static resource_adaptor<std::allocator<char>> __r;
-    return static_cast<memory_resource*>(&__r);
+    using type = resource_adaptor<std::allocator<char>>;
+    alignas(type) static unsigned char __buf[sizeof(type)];
+    static type* __r = new(__buf) type;
+    return __r;
   }
 
-  template <typename _Alloc>
-    class __null_memory_resource : private memory_resource
+  inline memory_resource*
+  null_memory_resource() noexcept
+  {
+    class type final : public memory_resource
     {
-    protected:
       void*
-      do_allocate(size_t, size_t)
+      do_allocate(size_t, size_t) override
       { std::__throw_bad_alloc(); }
 
       void
-      do_deallocate(void*, size_t, size_t) noexcept
+      do_deallocate(void*, size_t, size_t) noexcept override
       { }
 
       bool
-      do_is_equal(const memory_resource& __other) const noexcept
+      do_is_equal(const memory_resource& __other) const noexcept override
       { return this == &__other; }
-
-      friend memory_resource* null_memory_resource() noexcept;
     };
 
-  inline memory_resource*
-  null_memory_resource() noexcept
-  {
-    static __null_memory_resource<void> __r;
-    return static_cast<memory_resource*>(&__r);
+    alignas(type) static unsigned char __buf[sizeof(type)];
+    static type* __r = new(__buf) type;
+    return __r;
   }
 
   // The default memory resource
+
+  inline std::atomic<memory_resource*>&
+  __get_default_resource()
+  {
+    using type = atomic<memory_resource*>;
+    alignas(type) static unsigned char __buf[sizeof(type)];
+    static type* __r = new(__buf) type(new_delete_resource());
+    return *__r;
+  }
+
   inline memory_resource*
   get_default_resource() noexcept
   { return __get_default_resource().load(); }
diff --git a/libstdc++-v3/include/experimental/numeric b/libstdc++-v3/include/experimental/numeric
index b7b8207069f..c63bd90765d 100644
--- a/libstdc++-v3/include/experimental/numeric
+++ b/libstdc++-v3/include/experimental/numeric
@@ -35,9 +35,7 @@
 
 #pragma GCC system_header
 
-#if __cplusplus <= 201103L
-# include <bits/c++14_warning.h>
-#else
+#if __cplusplus >= 201402L
 
 #include <numeric>
 #include <experimental/type_traits>
diff --git a/libstdc++-v3/include/experimental/optional b/libstdc++-v3/include/experimental/optional
index 197a1fc7691..12b9599f1d8 100644
--- a/libstdc++-v3/include/experimental/optional
+++ b/libstdc++-v3/include/experimental/optional
@@ -41,9 +41,7 @@
  * between different GCC releases </STRONG> for these features.
  */
 
-#if __cplusplus <= 201103L
-# include <bits/c++14_warning.h>
-#else
+#if __cplusplus >= 201402L
 
 #include <utility>
 #include <type_traits>
diff --git a/libstdc++-v3/include/experimental/propagate_const b/libstdc++-v3/include/experimental/propagate_const
index 719e17aa3d0..ed9e8eb3dd8 100644
--- a/libstdc++-v3/include/experimental/propagate_const
+++ b/libstdc++-v3/include/experimental/propagate_const
@@ -31,9 +31,7 @@
 
 #pragma GCC system_header
 
-#if __cplusplus <= 201103L
-# include <bits/c++14_warning.h>
-#else
+#if __cplusplus >= 201402L
 
 #include <type_traits>
 #include <bits/functional_hash.h>
diff --git a/libstdc++-v3/include/experimental/ratio b/libstdc++-v3/include/experimental/ratio
index ffbae76ca79..708eb7af1f1 100644
--- a/libstdc++-v3/include/experimental/ratio
+++ b/libstdc++-v3/include/experimental/ratio
@@ -35,9 +35,7 @@
 
 #pragma GCC system_header
 
-#if __cplusplus <= 201103L
-# include <bits/c++14_warning.h>
-#else
+#if __cplusplus >= 201402L
 
 #include <ratio>
 #include <experimental/bits/lfts_config.h>
diff --git a/libstdc++-v3/include/experimental/regex b/libstdc++-v3/include/experimental/regex
index 9b5679fc78e..ba4d02cc69a 100644
--- a/libstdc++-v3/include/experimental/regex
+++ b/libstdc++-v3/include/experimental/regex
@@ -31,9 +31,7 @@
 
 #pragma GCC system_header
 
-#if __cplusplus <= 201103L
-# include <bits/c++14_warning.h>
-#else
+#if __cplusplus >= 201402L
 
 #include <regex>
 #include <experimental/string>
@@ -44,10 +42,10 @@ namespace experimental
 {
 inline namespace fundamentals_v2
 {
+#if _GLIBCXX_USE_CXX11_ABI
 namespace pmr
 {
 _GLIBCXX_BEGIN_NAMESPACE_VERSION
-_GLIBCXX_BEGIN_NAMESPACE_CXX11
 
   template<typename _BidirectionalIterator>
     using match_results
@@ -59,10 +57,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
   typedef match_results<string::const_iterator> smatch;
   typedef match_results<wstring::const_iterator> wsmatch;
 
-_GLIBCXX_END_NAMESPACE_CXX11
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace pmr
-
+#endif
 } // namespace fundamentals_v2
 } // namespace experimental
 } // namespace std
diff --git a/libstdc++-v3/include/experimental/set b/libstdc++-v3/include/experimental/set
index a10617bb2a9..87d6aa65a47 100644
--- a/libstdc++-v3/include/experimental/set
+++ b/libstdc++-v3/include/experimental/set
@@ -31,9 +31,7 @@
 
 #pragma GCC system_header
 
-#if __cplusplus <= 201103L
-# include <bits/c++14_warning.h>
-#else
+#if __cplusplus >= 201402L
 
 #include <set>
 #include <experimental/bits/erase_if.h>
diff --git a/libstdc++-v3/include/experimental/string b/libstdc++-v3/include/experimental/string
index 5347991959e..9e92270c79d 100644
--- a/libstdc++-v3/include/experimental/string
+++ b/libstdc++-v3/include/experimental/string
@@ -31,9 +31,7 @@
 
 #pragma GCC system_header
 
-#if __cplusplus <= 201103L
-# include <bits/c++14_warning.h>
-#else
+#if __cplusplus >= 201402L
 
 #include <string>
 #include <algorithm>
@@ -66,9 +64,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
 _GLIBCXX_END_NAMESPACE_VERSION
 
+#if _GLIBCXX_USE_CXX11_ABI
 namespace pmr {
 _GLIBCXX_BEGIN_NAMESPACE_VERSION
-_GLIBCXX_BEGIN_NAMESPACE_CXX11
 
   // basic_string using polymorphic allocator in namespace pmr
   template<typename _CharT, typename _Traits = char_traits<_CharT>>
@@ -82,10 +80,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
   typedef basic_string<char32_t> u32string;
   typedef basic_string<wchar_t> wstring;
 
-_GLIBCXX_END_NAMESPACE_CXX11
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace pmr
-
+#endif
 } // namespace fundamentals_v2
 } // namespace experimental
 } // namespace std
diff --git a/libstdc++-v3/include/experimental/string_view b/libstdc++-v3/include/experimental/string_view
index 2235a51ea5d..cdc23d17a7a 100644
--- a/libstdc++-v3/include/experimental/string_view
+++ b/libstdc++-v3/include/experimental/string_view
@@ -35,9 +35,7 @@
 
 #pragma GCC system_header
 
-#if __cplusplus <= 201103L
-# include <bits/c++14_warning.h>
-#else
+#if __cplusplus >= 201402L
 
 #include <string>
 #include <limits>
diff --git a/libstdc++-v3/include/experimental/system_error b/libstdc++-v3/include/experimental/system_error
index 2b4855dba72..085b43b7f6a 100644
--- a/libstdc++-v3/include/experimental/system_error
+++ b/libstdc++-v3/include/experimental/system_error
@@ -35,9 +35,7 @@
 
 #pragma GCC system_header
 
-#if __cplusplus <= 201103L
-# include <bits/c++14_warning.h>
-#else
+#if __cplusplus >= 201402L
 
 #include <system_error>
 #include <experimental/bits/lfts_config.h>
diff --git a/libstdc++-v3/include/experimental/tuple b/libstdc++-v3/include/experimental/tuple
index 879636eecd8..13d7bf7bd2a 100644
--- a/libstdc++-v3/include/experimental/tuple
+++ b/libstdc++-v3/include/experimental/tuple
@@ -31,9 +31,7 @@
 
 #pragma GCC system_header
 
-#if __cplusplus <= 201103L
-# include <bits/c++14_warning.h>
-#else
+#if __cplusplus >= 201402L
 
 #include <tuple>
 #include <bits/invoke.h>
diff --git a/libstdc++-v3/include/experimental/type_traits b/libstdc++-v3/include/experimental/type_traits
index 7ec06308ba9..605a92e86fe 100644
--- a/libstdc++-v3/include/experimental/type_traits
+++ b/libstdc++-v3/include/experimental/type_traits
@@ -35,9 +35,7 @@
 
 #pragma GCC system_header
 
-#if __cplusplus <= 201103L
-# include <bits/c++14_warning.h>
-#else
+#if __cplusplus >= 201402L
 
 #include <type_traits>
 #include <experimental/bits/lfts_config.h>
diff --git a/libstdc++-v3/include/experimental/unordered_map b/libstdc++-v3/include/experimental/unordered_map
index fbc44b267b5..8b640a2ad4f 100644
--- a/libstdc++-v3/include/experimental/unordered_map
+++ b/libstdc++-v3/include/experimental/unordered_map
@@ -31,9 +31,7 @@
 
 #pragma GCC system_header
 
-#if __cplusplus <= 201103L
-# include <bits/c++14_warning.h>
-#else
+#if __cplusplus >= 201402L
 
 #include <unordered_map>
 #include <experimental/bits/erase_if.h>
diff --git a/libstdc++-v3/include/experimental/unordered_set b/libstdc++-v3/include/experimental/unordered_set
index 3c8fe255275..1d78c52d446 100644
--- a/libstdc++-v3/include/experimental/unordered_set
+++ b/libstdc++-v3/include/experimental/unordered_set
@@ -31,9 +31,7 @@
 
 #pragma GCC system_header
 
-#if __cplusplus <= 201103L
-# include <bits/c++14_warning.h>
-#else
+#if __cplusplus >= 201402L
 
 #include <unordered_set>
 #include <experimental/bits/erase_if.h>
diff --git a/libstdc++-v3/include/experimental/vector b/libstdc++-v3/include/experimental/vector
index b75a3bc7ce4..5d007a22c64 100644
--- a/libstdc++-v3/include/experimental/vector
+++ b/libstdc++-v3/include/experimental/vector
@@ -31,9 +31,7 @@
 
 #pragma GCC system_header
 
-#if __cplusplus <= 201103L
-# include <bits/c++14_warning.h>
-#else
+#if __cplusplus >= 201402L
 
 #include <vector>
 #include <algorithm>
diff --git a/libstdc++-v3/include/ext/pointer.h b/libstdc++-v3/include/ext/pointer.h
index 8432da0d2a4..3924cdd98b5 100644
--- a/libstdc++-v3/include/ext/pointer.h
+++ b/libstdc++-v3/include/ext/pointer.h
@@ -437,6 +437,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       _CXX_POINTER_ARITH_OPERATOR_SET(unsigned int);
       _CXX_POINTER_ARITH_OPERATOR_SET(long);
       _CXX_POINTER_ARITH_OPERATOR_SET(unsigned long);
+#ifdef _GLIBCXX_USE_LONG_LONG
+      _CXX_POINTER_ARITH_OPERATOR_SET(long long);
+      _CXX_POINTER_ARITH_OPERATOR_SET(unsigned long long);
+#endif
 
       // Mathematical Manipulators
       inline _Pointer_adapter& 
diff --git a/libstdc++-v3/include/std/any b/libstdc++-v3/include/std/any
index eef510535d7..50daa80fcf9 100644
--- a/libstdc++-v3/include/std/any
+++ b/libstdc++-v3/include/std/any
@@ -70,7 +70,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
   /**
    *  @brief A type-safe container of any type.
-   * 
+   *
    *  An @c any object's state is either empty or it stores a contained object
    *  of CopyConstructible type.
    */
@@ -114,8 +114,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       void __do_emplace(_Args&&... __args)
       {
 	reset();
-	_M_manager = &_Mgr::_S_manage;
         _Mgr::_S_create(_M_storage, std::forward<_Args>(__args)...);
+	_M_manager = &_Mgr::_S_manage;
       }
 
     /// Emplace with an object created from @p __il and @p __args as
@@ -125,8 +125,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       void __do_emplace(initializer_list<_Up> __il, _Args&&... __args)
       {
 	reset();
-	_M_manager = &_Mgr::_S_manage;
         _Mgr::_S_create(_M_storage, __il, std::forward<_Args>(__args)...);
+	_M_manager = &_Mgr::_S_manage;
       }
 
   public:
@@ -272,8 +272,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 				   _Decay<_ValueType>, _Args&&...>::type
       emplace(_Args&&... __args)
       {
-	__do_emplace<_Decay<_ValueType>>
-	  (std::forward<_Args>(__args)...);
+	__do_emplace<_Decay<_ValueType>>(std::forward<_Args>(__args)...);
 	any::_Arg __arg;
 	this->_M_manager(any::_Op_access, this, &__arg);
 	return *static_cast<_Decay<_ValueType>*>(__arg._M_obj);
@@ -288,8 +287,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 				   _Args&&...>::type
       emplace(initializer_list<_Up> __il, _Args&&... __args)
       {
-	__do_emplace<_Decay<_ValueType>, _Up>
-	  (__il, std::forward<_Args>(__args)...);
+	__do_emplace<_Decay<_ValueType>, _Up>(__il,
+					      std::forward<_Args>(__args)...);
 	any::_Arg __arg;
 	this->_M_manager(any::_Op_access, this, &__arg);
 	return *static_cast<_Decay<_ValueType>*>(__arg._M_obj);
@@ -624,7 +623,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     }
 
   /// @}
-  
+
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace std
 
diff --git a/libstdc++-v3/include/std/chrono b/libstdc++-v3/include/std/chrono
index 5d0151857e7..2138ff027e4 100644
--- a/libstdc++-v3/include/std/chrono
+++ b/libstdc++-v3/include/std/chrono
@@ -318,8 +318,10 @@ _GLIBCXX_END_NAMESPACE_VERSION
 	// constexpr copy constructor will be ill-formed.
 	duration(const duration&) = default;
 
+	// _GLIBCXX_RESOLVE_LIB_DEFECTS
+	// 3050. Conversion specification problem in chrono::duration
 	template<typename _Rep2, typename = typename
-	       enable_if<is_convertible<_Rep2, rep>::value
+	       enable_if<is_convertible<const _Rep2&, rep>::value
 			 && (treat_as_floating_point<rep>::value
 			     || !treat_as_floating_point<_Rep2>::value)>::type>
 	  constexpr explicit duration(const _Rep2& __rep)
@@ -463,8 +465,12 @@ _GLIBCXX_END_NAMESPACE_VERSION
 	return __cd(__cd(__lhs).count() - __cd(__rhs).count());
       }
 
+    // SFINAE helper to obtain common_type<_Rep1, _Rep2> only if _Rep2
+    // is implicitly convertible to it.
+    // _GLIBCXX_RESOLVE_LIB_DEFECTS
+    // 3050. Conversion specification problem in chrono::duration constructor
     template<typename _Rep1, typename _Rep2, bool =
-	     is_convertible<_Rep2,
+	     is_convertible<const _Rep2&,
 			    typename common_type<_Rep1, _Rep2>::type>::value>
       struct __common_rep_type { };
 
diff --git a/libstdc++-v3/include/std/condition_variable b/libstdc++-v3/include/std/condition_variable
index 1d8f057ceb6..6d20d365531 100644
--- a/libstdc++-v3/include/std/condition_variable
+++ b/libstdc++-v3/include/std/condition_variable
@@ -135,14 +135,26 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       cv_status
       wait_for(unique_lock<mutex>& __lock,
 	       const chrono::duration<_Rep, _Period>& __rtime)
-      { return wait_until(__lock, __clock_t::now() + __rtime); }
+      {
+	using __dur = typename __clock_t::duration;
+	auto __reltime = chrono::duration_cast<__dur>(__rtime);
+	if (__reltime < __rtime)
+	  ++__reltime;
+	return wait_until(__lock, __clock_t::now() + __reltime);
+      }
 
     template<typename _Rep, typename _Period, typename _Predicate>
       bool
       wait_for(unique_lock<mutex>& __lock,
 	       const chrono::duration<_Rep, _Period>& __rtime,
 	       _Predicate __p)
-      { return wait_until(__lock, __clock_t::now() + __rtime, std::move(__p)); }
+      {
+	using __dur = typename __clock_t::duration;
+	auto __reltime = chrono::duration_cast<__dur>(__rtime);
+	if (__reltime < __rtime)
+	  ++__reltime;
+	return wait_until(__lock, __clock_t::now() + __reltime, std::move(__p));
+      }
 
     native_handle_type
     native_handle()
diff --git a/libstdc++-v3/include/std/functional b/libstdc++-v3/include/std/functional
index 465b3ec7792..edf6f106611 100644
--- a/libstdc++-v3/include/std/functional
+++ b/libstdc++-v3/include/std/functional
@@ -931,7 +931,8 @@ _GLIBCXX_MEM_FN_TRAITS(&& noexcept, false_type, true_type)
       template<typename... _Args>					\
 	decltype(_S_not<__inv_res_t<_Fn _QUALS, _Args...>>())		\
 	operator()(_Args&&... __args) _QUALS				\
-	noexcept(noexcept(_S_not<__inv_res_t<_Fn _QUALS, _Args...>>()))	\
+	noexcept(__is_nothrow_invocable<_Fn _QUALS, _Args...>::value	\
+	    && noexcept(_S_not<__inv_res_t<_Fn _QUALS, _Args...>>()))	\
 	{								\
 	  return !std::__invoke(std::forward< _Fn _QUALS >(_M_fn),	\
 				std::forward<_Args>(__args)...);	\
diff --git a/libstdc++-v3/include/std/thread b/libstdc++-v3/include/std/thread
index 8e2cb68e295..6e850bb8d12 100644
--- a/libstdc++-v3/include/std/thread
+++ b/libstdc++-v3/include/std/thread
@@ -243,21 +243,18 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	{ return _M_invoke(_Indices()); }
       };
 
-    // Alias for _Invoker<tuple<DECAY_COPY(_Tp)...>>
     template<typename... _Tp>
-      using __invoker_type
-	= _Invoker<decltype(std::make_tuple(std::declval<_Tp>()...))>;
+      using __decayed_tuple = tuple<typename std::decay<_Tp>::type...>;
 
   public:
-    // Returns a call wrapper that does
-    // INVOKE(DECAY_COPY(__callable), DECAY_COPY(__args)).
+    // Returns a call wrapper that stores
+    // tuple{DECAY_COPY(__callable), DECAY_COPY(__args)...}.
     template<typename _Callable, typename... _Args>
-      static __invoker_type<_Callable, _Args...>
+      static _Invoker<__decayed_tuple<_Callable, _Args...>>
       __make_invoker(_Callable&& __callable, _Args&&... __args)
       {
-	return { {
-	    std::make_tuple(std::forward<_Callable>(__callable),
-			    std::forward<_Args>(__args)...)
+	return { __decayed_tuple<_Callable, _Args...>{
+	    std::forward<_Callable>(__callable), std::forward<_Args>(__args)...
 	} };
       }
   };
diff --git a/libstdc++-v3/include/std/type_traits b/libstdc++-v3/include/std/type_traits
index baacfb006dd..80344a8bc58 100644
--- a/libstdc++-v3/include/std/type_traits
+++ b/libstdc++-v3/include/std/type_traits
@@ -2458,7 +2458,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     : public __invoke_result<_Functor, _ArgTypes...>
     { };
 
-#if __cplusplus > 201103L
+#if __cplusplus >= 201402L
   /// Alias template for aligned_storage
   template<size_t _Len, size_t _Align =
 	    __alignof__(typename __aligned_storage_msa<_Len>::__type)>
@@ -2490,11 +2490,16 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   /// Alias template for result_of
   template<typename _Tp>
     using result_of_t = typename result_of<_Tp>::type;
-#endif
+#endif // C++14
+
+  // __enable_if_t (std::enable_if_t for C++11)
+  template<bool _Cond, typename _Tp = void>
+    using __enable_if_t = typename enable_if<_Cond, _Tp>::type;
 
+  // __void_t (std::void_t for C++11)
   template<typename...> using __void_t = void;
 
-#if __cplusplus > 201402L || !defined(__STRICT_ANSI__) // c++1z or gnu++11
+#if __cplusplus >= 201703L || !defined(__STRICT_ANSI__) // c++17 or gnu++11
 #define __cpp_lib_void_t 201411
   /// A metafunction that always yields void, used for detecting valid types.
   template<typename...> using void_t = void;
@@ -3069,6 +3074,10 @@ template <typename _From, typename _To>
       remove_cv_t<remove_all_extents_t<_Tp>>
       )>
     { };
+
+  template<typename _Tp>
+    inline constexpr bool has_unique_object_representations_v
+      = has_unique_object_representations<_Tp>::value;
 #endif
 #undef _GLIBCXX_HAVE_BUILTIN_HAS_UNIQ_OBJ_REP
 
diff --git a/libstdc++-v3/include/std/utility b/libstdc++-v3/include/std/utility
index 978acb747e9..847e5184c5b 100644
--- a/libstdc++-v3/include/std/utility
+++ b/libstdc++-v3/include/std/utility
@@ -75,10 +75,6 @@
 #include <bits/move.h>
 #include <initializer_list>
 
-#if __cplusplus > 201402L
-#include <exception>
-#endif
-
 namespace std _GLIBCXX_VISIBILITY(default)
 {
 _GLIBCXX_BEGIN_NAMESPACE_VERSION
diff --git a/libstdc++-v3/include/std/variant b/libstdc++-v3/include/std/variant
index 1f1a8492323..2efe62cfe7c 100644
--- a/libstdc++-v3/include/std/variant
+++ b/libstdc++-v3/include/std/variant
@@ -229,13 +229,17 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
   template<size_t _Np, typename _Union>
     constexpr decltype(auto) __get(in_place_index_t<_Np>, _Union&& __u)
-    { return __get(in_place_index<_Np-1>, std::forward<_Union>(__u)._M_rest); }
+    {
+      return __variant::__get(in_place_index<_Np-1>,
+			      std::forward<_Union>(__u)._M_rest);
+    }
 
   // Returns the typed storage for __v.
   template<size_t _Np, typename _Variant>
     constexpr decltype(auto) __get(_Variant&& __v)
     {
-      return __get(std::in_place_index<_Np>, std::forward<_Variant>(__v)._M_u);
+      return __variant::__get(std::in_place_index<_Np>,
+			      std::forward<_Variant>(__v)._M_u);
     }
 
   // Various functions as "vtable" entries, where those vtables are used by
@@ -251,7 +255,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   template<typename _Variant, size_t _Np>
     void
     __erased_dtor(_Variant&& __v)
-    { std::_Destroy(std::__addressof(__get<_Np>(__v))); }
+    { std::_Destroy(std::__addressof(__variant::__get<_Np>(__v))); }
 
   template<typename _Lhs, typename _Rhs>
     void
@@ -274,8 +278,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     constexpr bool \
     __erased_##__NAME(const _Variant& __lhs, const _Variant& __rhs) \
     { \
-      return __get<_Np>(std::forward<_Variant>(__lhs)) \
-	  __OP __get<_Np>(std::forward<_Variant>(__rhs)); \
+      return __variant::__get<_Np>(std::forward<_Variant>(__lhs)) \
+	  __OP __variant::__get<_Np>(std::forward<_Variant>(__rhs)); \
     }
 
   _VARIANT_RELATION_FUNCTION_TEMPLATE(<, less)
@@ -324,10 +328,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
   template <typename... _Types>
   using __select_index =
-    typename __select_int::_Select_int_base<sizeof...(_Types)+1,
+    typename __select_int::_Select_int_base<sizeof...(_Types) + 1,
 					    unsigned char,
-					    unsigned short>
-    ::type::value_type;
+					    unsigned short>::type::value_type;
 
   template<typename... _Types>
     struct _Variant_storage<false, _Types...>
@@ -681,9 +684,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       decltype(auto)
       static constexpr __visit_invoke(_Visitor&& __visitor, _Variants... __vars)
       {
-	return __invoke(std::forward<_Visitor>(__visitor),
-			std::get<__indices>(
-			    std::forward<_Variants>(__vars))...);
+	return std::__invoke(std::forward<_Visitor>(__visitor),
+	    std::get<__indices>(std::forward<_Variants>(__vars))...);
       }
 
       static constexpr auto
@@ -741,7 +743,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,
 		    "T should occur for exactly once in alternatives");
       static_assert(!is_void_v<_Tp>, "_Tp should not be void");
-      return get<__detail::__variant::__index_of_v<_Tp, _Types...>>(__v);
+      return std::get<__detail::__variant::__index_of_v<_Tp, _Types...>>(__v);
     }
 
   template<typename _Tp, typename... _Types>
@@ -750,7 +752,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,
 		    "T should occur for exactly once in alternatives");
       static_assert(!is_void_v<_Tp>, "_Tp should not be void");
-      return get<__detail::__variant::__index_of_v<_Tp, _Types...>>(
+      return std::get<__detail::__variant::__index_of_v<_Tp, _Types...>>(
 	std::move(__v));
     }
 
@@ -760,7 +762,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,
 		    "T should occur for exactly once in alternatives");
       static_assert(!is_void_v<_Tp>, "_Tp should not be void");
-      return get<__detail::__variant::__index_of_v<_Tp, _Types...>>(__v);
+      return std::get<__detail::__variant::__index_of_v<_Tp, _Types...>>(__v);
     }
 
   template<typename _Tp, typename... _Types>
@@ -769,7 +771,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,
 		    "T should occur for exactly once in alternatives");
       static_assert(!is_void_v<_Tp>, "_Tp should not be void");
-      return get<__detail::__variant::__index_of_v<_Tp, _Types...>>(
+      return std::get<__detail::__variant::__index_of_v<_Tp, _Types...>>(
 	std::move(__v));
     }
 
@@ -808,7 +810,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,
 		    "T should occur for exactly once in alternatives");
       static_assert(!is_void_v<_Tp>, "_Tp should not be void");
-      return get_if<__detail::__variant::__index_of_v<_Tp, _Types...>>(__ptr);
+      return std::get_if<__detail::__variant::__index_of_v<_Tp, _Types...>>(
+	  __ptr);
     }
 
   template<typename _Tp, typename... _Types>
@@ -819,7 +822,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,
 		    "T should occur for exactly once in alternatives");
       static_assert(!is_void_v<_Tp>, "_Tp should not be void");
-      return get_if<__detail::__variant::__index_of_v<_Tp, _Types...>>(__ptr);
+      return std::get_if<__detail::__variant::__index_of_v<_Tp, _Types...>>(
+	  __ptr);
     }
 
   struct monostate { };
@@ -1157,6 +1161,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
 #undef _VARIANT_RELATION_FUNCTION_TEMPLATE
 
+#ifdef __clang__
+    public:
+      using _Base::_M_u; // See https://bugs.llvm.org/show_bug.cgi?id=31852
+    private:
+#endif
+
       template<size_t _Np, typename _Vp>
 	friend constexpr decltype(auto) __detail::__variant::
 #if _GLIBCXX_INLINE_VERSION
@@ -1240,7 +1250,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
       using _Result_type =
 	decltype(std::forward<_Visitor>(__visitor)(
-	    get<0>(std::forward<_Variants>(__variants))...));
+	    std::get<0>(std::forward<_Variants>(__variants))...));
 
       constexpr auto& __vtable = __detail::__variant::__gen_vtable<
 	_Result_type, _Visitor&&, _Variants&&...>::_S_vtable;
diff --git a/libstdc++-v3/include/tr1/ell_integral.tcc b/libstdc++-v3/include/tr1/ell_integral.tcc
index 01f9313a256..99a6b9ce691 100644
--- a/libstdc++-v3/include/tr1/ell_integral.tcc
+++ b/libstdc++-v3/include/tr1/ell_integral.tcc
@@ -685,8 +685,8 @@ namespace tr1
           const _Tp __kk = __k * __k;
 
           return __ellint_rf(_Tp(0), _Tp(1) - __kk, _Tp(1))
-               - __nu
-               * __ellint_rj(_Tp(0), _Tp(1) - __kk, _Tp(1), _Tp(1) + __nu)
+               + __nu
+               * __ellint_rj(_Tp(0), _Tp(1) - __kk, _Tp(1), _Tp(1) - __nu)
                / _Tp(3);
         }
     }
@@ -735,9 +735,9 @@ namespace tr1
 
           const _Tp __Pi = __s
                          * __ellint_rf(__cc, _Tp(1) - __kk * __ss, _Tp(1))
-                         - __nu * __sss
+                         + __nu * __sss
                          * __ellint_rj(__cc, _Tp(1) - __kk * __ss, _Tp(1),
-                                       _Tp(1) + __nu * __ss) / _Tp(3);
+                                       _Tp(1) - __nu * __ss) / _Tp(3);
 
           if (__n == 0)
             return __Pi;
diff --git a/libstdc++-v3/include/tr1/exp_integral.tcc b/libstdc++-v3/include/tr1/exp_integral.tcc
index f33f234e6f6..8e6f55178e7 100644
--- a/libstdc++-v3/include/tr1/exp_integral.tcc
+++ b/libstdc++-v3/include/tr1/exp_integral.tcc
@@ -86,7 +86,7 @@ namespace tr1
       _Tp __term = _Tp(1);
       _Tp __esum = _Tp(0);
       _Tp __osum = _Tp(0);
-      const unsigned int __max_iter = 100;
+      const unsigned int __max_iter = 1000;
       for (unsigned int __i = 1; __i < __max_iter; ++__i)
         {
           __term *= - __x / __i;
@@ -156,7 +156,7 @@ namespace tr1
     _Tp
     __expint_En_series(unsigned int __n, _Tp __x)
     {
-      const unsigned int __max_iter = 100;
+      const unsigned int __max_iter = 1000;
       const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
       const int __nm1 = __n - 1;
       _Tp __ans = (__nm1 != 0
@@ -202,7 +202,7 @@ namespace tr1
     _Tp
     __expint_En_cont_frac(unsigned int __n, _Tp __x)
     {
-      const unsigned int __max_iter = 100;
+      const unsigned int __max_iter = 1000;
       const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
       const _Tp __fp_min = std::numeric_limits<_Tp>::min();
       const int __nm1 = __n - 1;
diff --git a/libstdc++-v3/libsupc++/cxxabi_init_exception.h b/libstdc++-v3/libsupc++/cxxabi_init_exception.h
index bf7b4bada81..2cf2c257ea8 100644
--- a/libstdc++-v3/libsupc++/cxxabi_init_exception.h
+++ b/libstdc++-v3/libsupc++/cxxabi_init_exception.h
@@ -62,6 +62,9 @@ namespace __cxxabiv1
       void*
       __cxa_allocate_exception(size_t) _GLIBCXX_NOTHROW;
 
+      void
+      __cxa_free_exception(void*) _GLIBCXX_NOTHROW;
+
       // Initialize exception (this is a GNU extension)
       __cxa_refcounted_exception*
       __cxa_init_primary_exception(void *object, std::type_info *tinfo,
diff --git a/libstdc++-v3/libsupc++/exception_ptr.h b/libstdc++-v3/libsupc++/exception_ptr.h
index 0ece81d8137..faae9b77cb3 100644
--- a/libstdc++-v3/libsupc++/exception_ptr.h
+++ b/libstdc++-v3/libsupc++/exception_ptr.h
@@ -178,25 +178,31 @@ namespace std
     exception_ptr 
     make_exception_ptr(_Ex __ex) _GLIBCXX_USE_NOEXCEPT
     {
-#if __cpp_exceptions
+#if __cpp_exceptions && __cpp_rtti && !_GLIBCXX_HAVE_CDTOR_CALLABI
+      void* __e = __cxxabiv1::__cxa_allocate_exception(sizeof(_Ex));
+      (void) __cxxabiv1::__cxa_init_primary_exception(
+	  __e, const_cast<std::type_info*>(&typeid(__ex)),
+	  __exception_ptr::__dest_thunk<_Ex>);
       try
 	{
-#if __cpp_rtti && !_GLIBCXX_HAVE_CDTOR_CALLABI
-          void *__e = __cxxabiv1::__cxa_allocate_exception(sizeof(_Ex));
-          (void)__cxxabiv1::__cxa_init_primary_exception(
-	      __e, const_cast<std::type_info*>(&typeid(__ex)),
-	      __exception_ptr::__dest_thunk<_Ex>);
           ::new (__e) _Ex(__ex);
           return exception_ptr(__e);
-#else
+	}
+      catch(...)
+	{
+	  __cxxabiv1::__cxa_free_exception(__e);
+	  return current_exception();
+	}
+#elif __cpp_exceptions
+      try
+	{
           throw __ex;
-#endif
 	}
       catch(...)
 	{
 	  return current_exception();
 	}
-#else
+#else // no RTTI and no exceptions
       return exception_ptr();
 #endif
     }
diff --git a/libstdc++-v3/libsupc++/hash_bytes.cc b/libstdc++-v3/libsupc++/hash_bytes.cc
index 8ef982dbc2a..73bd179409e 100644
--- a/libstdc++-v3/libsupc++/hash_bytes.cc
+++ b/libstdc++-v3/libsupc++/hash_bytes.cc
@@ -139,7 +139,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
     // Remove the bytes not divisible by the sizeof(size_t).  This
     // allows the main loop to process the data as 64-bit integers.
-    const int len_aligned = len & ~0x7;
+    const size_t len_aligned = len & ~(size_t)0x7;
     const char* const end = buf + len_aligned;
     size_t hash = seed ^ (len * mul);
     for (const char* p = buf; p != end; p += 8)
diff --git a/libstdc++-v3/libsupc++/new_opa.cc b/libstdc++-v3/libsupc++/new_opa.cc
index e2a0d2f5371..94e79cadb0e 100644
--- a/libstdc++-v3/libsupc++/new_opa.cc
+++ b/libstdc++-v3/libsupc++/new_opa.cc
@@ -25,20 +25,36 @@
 
 #include <bits/c++config.h>
 #include <stdlib.h>
+#include <stdint.h>
 #include <bits/exception_defines.h>
 #include "new"
 
+#if !_GLIBCXX_HAVE_ALIGNED_ALLOC && !_GLIBCXX_HAVE__ALIGNED_MALLOC \
+  && !_GLIBCXX_HAVE_POSIX_MEMALIGN && _GLIBCXX_HAVE_MEMALIGN
+# if _GLIBCXX_HOSTED && __has_include(<malloc.h>)
+// Some C libraries declare memalign in <malloc.h>
+#  include <malloc.h>
+# else
+extern "C" void *memalign(std::size_t boundary, std::size_t size);
+# endif
+#endif
+
 using std::new_handler;
 using std::bad_alloc;
 
-#if !_GLIBCXX_HAVE_ALIGNED_ALLOC
-#if _GLIBCXX_HAVE__ALIGNED_MALLOC
-#define aligned_alloc(al,sz) _aligned_malloc(sz,al)
+namespace __gnu_cxx {
+#if _GLIBCXX_HAVE_ALIGNED_ALLOC
+using ::aligned_alloc;
+#elif _GLIBCXX_HAVE__ALIGNED_MALLOC
+static inline void*
+aligned_alloc (std::size_t al, std::size_t sz)
+{ return _aligned_malloc(sz, al); }
 #elif _GLIBCXX_HAVE_POSIX_MEMALIGN
 static inline void*
 aligned_alloc (std::size_t al, std::size_t sz)
 {
   void *ptr;
+  // posix_memalign has additional requirement, not present on aligned_alloc:
   // The value of alignment shall be a power of two multiple of sizeof(void *).
   if (al < sizeof(void*))
     al = sizeof(void*);
@@ -48,25 +64,23 @@ aligned_alloc (std::size_t al, std::size_t sz)
   return nullptr;
 }
 #elif _GLIBCXX_HAVE_MEMALIGN
-#if _GLIBCXX_HOSTED
-#include <malloc.h>
-#else
-extern "C" void *memalign(std::size_t boundary, std::size_t size);
+static inline void*
+aligned_alloc (std::size_t al, std::size_t sz)
+{
+#ifdef __sun
+  // Solaris 10 memalign requires that alignment is greater than or equal to
+  // the size of a word.
+  if (al < sizeof(int))
+    al = sizeof(int);
 #endif
-#define aligned_alloc memalign
-#else
-#include <stdint.h>
+  return memalign (al, sz);
+}
+#else // !HAVE__ALIGNED_MALLOC && !HAVE_POSIX_MEMALIGN && !HAVE_MEMALIGN
 // The C library doesn't provide any aligned allocation functions, define one.
 // This is a modified version of code from gcc/config/i386/gmm_malloc.h
 static inline void*
 aligned_alloc (std::size_t al, std::size_t sz)
 {
-  // Alignment must be a power of two.
-  if (al & (al - 1))
-    return nullptr;
-  else if (!sz)
-    return nullptr;
-
   // We need extra bytes to store the original value returned by malloc.
   if (al < sizeof(void*))
     al = sizeof(void*);
@@ -82,7 +96,7 @@ aligned_alloc (std::size_t al, std::size_t sz)
   return aligned_ptr;
 }
 #endif
-#endif
+} // namespace __gnu_cxx
 
 _GLIBCXX_WEAK_DEFINITION void *
 operator new (std::size_t sz, std::align_val_t al)
@@ -90,16 +104,28 @@ operator new (std::size_t sz, std::align_val_t al)
   void *p;
   std::size_t align = (std::size_t)al;
 
+  /* Alignment must be a power of two.  */
+  /* XXX This should be checked by the compiler (PR 86878).  */
+  if (__builtin_expect (align & (align - 1), false))
+    _GLIBCXX_THROW_OR_ABORT(bad_alloc());
+
   /* malloc (0) is unpredictable; avoid it.  */
-  if (sz == 0)
+  if (__builtin_expect (sz == 0, false))
     sz = 1;
 
 #if _GLIBCXX_HAVE_ALIGNED_ALLOC
+# ifdef _AIX
+  /* AIX 7.2.0.0 aligned_alloc incorrectly has posix_memalign's requirement
+   * that alignment is a multiple of sizeof(void*).  */
+  if (align < sizeof(void*))
+    align = sizeof(void*);
+# endif
   /* C11: the value of size shall be an integral multiple of alignment.  */
   if (std::size_t rem = sz & (align - 1))
     sz += align - rem;
 #endif
 
+  using __gnu_cxx::aligned_alloc;
   while (__builtin_expect ((p = aligned_alloc (align, sz)) == 0, false))
     {
       new_handler handler = std::get_new_handler ();
diff --git a/libstdc++-v3/python/libstdcxx/v6/printers.py b/libstdc++-v3/python/libstdcxx/v6/printers.py
index 8f1023949bb..e0520538019 100644
--- a/libstdc++-v3/python/libstdcxx/v6/printers.py
+++ b/libstdc++-v3/python/libstdcxx/v6/printers.py
@@ -1184,6 +1184,39 @@ class StdExpPathPrinter:
         return self._iterator(self.val['_M_cmpts'])
 
 
+class StdPairPrinter:
+    "Print a std::pair object, with 'first' and 'second' as children"
+
+    def __init__(self, typename, val):
+        self.val = val
+
+    class _iter(Iterator):
+        "An iterator for std::pair types. Returns 'first' then 'second'."
+
+        def __init__(self, val):
+            self.val = val
+            self.which = 'first'
+
+        def __iter__(self):
+            return self
+
+        def __next__(self):
+            if self.which is None:
+                raise StopIteration
+            which = self.which
+            if which == 'first':
+                self.which = 'second'
+            else:
+                self.which = None
+            return (which, self.val[which])
+
+    def children(self):
+        return self._iter(self.val)
+
+    def to_string(self):
+        return None
+
+
 # A "regular expression" printer which conforms to the
 # "SubPrettyPrinter" protocol from gdb.printing.
 class RxPrinter(object):
@@ -1515,6 +1548,7 @@ def build_libstdcxx_dictionary ():
     libstdcxx_printer.add_container('std::', 'map', StdMapPrinter)
     libstdcxx_printer.add_container('std::', 'multimap', StdMapPrinter)
     libstdcxx_printer.add_container('std::', 'multiset', StdSetPrinter)
+    libstdcxx_printer.add_version('std::', 'pair', StdPairPrinter)
     libstdcxx_printer.add_version('std::', 'priority_queue',
                                   StdStackOrQueuePrinter)
     libstdcxx_printer.add_version('std::', 'queue', StdStackOrQueuePrinter)
diff --git a/libstdc++-v3/scripts/make_exports.pl b/libstdc++-v3/scripts/make_exports.pl
index 7c9e4e31d4f..93100e17ddf 100644
--- a/libstdc++-v3/scripts/make_exports.pl
+++ b/libstdc++-v3/scripts/make_exports.pl
@@ -103,6 +103,14 @@ NAME: while (<NM>) {
     # Ignore undefined and local symbols.
     next if (/^([^ ]+) [Ua-z] /);
 
+    # GCC does not export construction vtables from shared libraries.
+    # However the symbols are marked hidden, for Darwin that makes them
+    # also external "private_extern", which means that they show up in
+    # this list.  When ld64 encounters them it generates a warning that
+    # they cannot be exported, so trim them from the set now.
+    next if (/^construction vtable.*$/);
+    next if (/^__ZTC.*$/);
+
     # $sym is the name of the symbol, $noeh_sym is the same thing with
     # any '.eh' suffix removed.
     die "unknown nm output $_" if (! /^([^ ]+) [A-Z] /);
diff --git a/libstdc++-v3/src/c++11/Makefile.am b/libstdc++-v3/src/c++11/Makefile.am
index cf73d4d5c4c..776a4ba36e3 100644
--- a/libstdc++-v3/src/c++11/Makefile.am
+++ b/libstdc++-v3/src/c++11/Makefile.am
@@ -126,6 +126,26 @@ hashtable_c++0x.lo: hashtable_c++0x.cc
 hashtable_c++0x.o: hashtable_c++0x.cc
 	$(CXXCOMPILE) -fimplicit-templates -c $<
 
+if ENABLE_DUAL_ABI
+# Rewrite the type info for __ios_failure.
+rewrite_ios_failure_typeinfo = sed -e '/^_*_ZTISt13__ios_failure:/,/_ZTVN10__cxxabiv120__si_class_type_infoE/s/_ZTVN10__cxxabiv120__si_class_type_infoE/_ZTVSt19__iosfail_type_info/'
+
+cxx11-ios_failure-lt.s: cxx11-ios_failure.cc
+	$(LTCXXCOMPILE) -S $< -o tmp-cxx11-ios_failure-lt.s
+	-test -f tmp-cxx11-ios_failure-lt.o && mv -f tmp-cxx11-ios_failure-lt.o tmp-cxx11-ios_failure-lt.s
+	$(rewrite_ios_failure_typeinfo) tmp-$@ > $@
+	-rm -f tmp-$@
+cxx11-ios_failure.s: cxx11-ios_failure.cc
+	$(CXXCOMPILE) -S $< -o tmp-$@
+	$(rewrite_ios_failure_typeinfo) tmp-$@ > $@
+	-rm -f tmp-$@
+
+cxx11-ios_failure.lo: cxx11-ios_failure-lt.s
+	$(LTCXXCOMPILE) -g0 -c $< -o $@
+cxx11-ios_failure.o: cxx11-ios_failure.s
+	$(CXXCOMPILE) -g0 -c $<
+endif
+
 # AM_CXXFLAGS needs to be in each subdirectory so that it can be
 # modified in a per-library or per-sub-library way.  Need to manually
 # set this option because CONFIG_CXXFLAGS has to be after
diff --git a/libstdc++-v3/src/c++11/Makefile.in b/libstdc++-v3/src/c++11/Makefile.in
index 295d915b436..6d78fd81f50 100644
--- a/libstdc++-v3/src/c++11/Makefile.in
+++ b/libstdc++-v3/src/c++11/Makefile.in
@@ -433,6 +433,9 @@ sources = \
 
 libc__11convenience_la_SOURCES = $(sources)  $(inst_sources)
 
+# Rewrite the type info for __ios_failure.
+@ENABLE_DUAL_ABI_TRUE@rewrite_ios_failure_typeinfo = sed -e '/^_*_ZTISt13__ios_failure:/,/_ZTVN10__cxxabiv120__si_class_type_infoE/s/_ZTVN10__cxxabiv120__si_class_type_infoE/_ZTVSt19__iosfail_type_info/'
+
 # AM_CXXFLAGS needs to be in each subdirectory so that it can be
 # modified in a per-library or per-sub-library way.  Need to manually
 # set this option because CONFIG_CXXFLAGS has to be after
@@ -748,6 +751,21 @@ hashtable_c++0x.lo: hashtable_c++0x.cc
 hashtable_c++0x.o: hashtable_c++0x.cc
 	$(CXXCOMPILE) -fimplicit-templates -c $<
 
+@ENABLE_DUAL_ABI_TRUE@cxx11-ios_failure-lt.s: cxx11-ios_failure.cc
+@ENABLE_DUAL_ABI_TRUE@	$(LTCXXCOMPILE) -S $< -o tmp-cxx11-ios_failure-lt.s
+@ENABLE_DUAL_ABI_TRUE@	-test -f tmp-cxx11-ios_failure-lt.o && mv -f tmp-cxx11-ios_failure-lt.o tmp-cxx11-ios_failure-lt.s
+@ENABLE_DUAL_ABI_TRUE@	$(rewrite_ios_failure_typeinfo) tmp-$@ > $@
+@ENABLE_DUAL_ABI_TRUE@	-rm -f tmp-$@
+@ENABLE_DUAL_ABI_TRUE@cxx11-ios_failure.s: cxx11-ios_failure.cc
+@ENABLE_DUAL_ABI_TRUE@	$(CXXCOMPILE) -S $< -o tmp-$@
+@ENABLE_DUAL_ABI_TRUE@	$(rewrite_ios_failure_typeinfo) tmp-$@ > $@
+@ENABLE_DUAL_ABI_TRUE@	-rm -f tmp-$@
+
+@ENABLE_DUAL_ABI_TRUE@cxx11-ios_failure.lo: cxx11-ios_failure-lt.s
+@ENABLE_DUAL_ABI_TRUE@	$(LTCXXCOMPILE) -g0 -c $< -o $@
+@ENABLE_DUAL_ABI_TRUE@cxx11-ios_failure.o: cxx11-ios_failure.s
+@ENABLE_DUAL_ABI_TRUE@	$(CXXCOMPILE) -g0 -c $<
+
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
 .NOEXPORT:
diff --git a/libstdc++-v3/src/c++11/codecvt.cc b/libstdc++-v3/src/c++11/codecvt.cc
index 11873397341..00ccb6afd4d 100644
--- a/libstdc++-v3/src/c++11/codecvt.cc
+++ b/libstdc++-v3/src/c++11/codecvt.cc
@@ -1086,7 +1086,12 @@ do_in(state_type&, const extern_type* __from, const extern_type* __from_end,
     reinterpret_cast<char16_t*>(__to),
     reinterpret_cast<char16_t*>(__to_end)
   };
-  auto res = ucs2_in(from, to, _M_maxcode, _M_mode);
+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
+  codecvt_mode mode = {};
+#else
+  codecvt_mode mode = little_endian;
+#endif
+  auto res = ucs2_in(from, to, _M_maxcode, mode);
 #elif __SIZEOF_WCHAR_T__ == 4
   range<char32_t> to{
     reinterpret_cast<char32_t*>(__to),
diff --git a/libstdc++-v3/src/c++11/cxx11-ios_failure.cc b/libstdc++-v3/src/c++11/cxx11-ios_failure.cc
index 2f60408782e..8833ba8c91a 100644
--- a/libstdc++-v3/src/c++11/cxx11-ios_failure.cc
+++ b/libstdc++-v3/src/c++11/cxx11-ios_failure.cc
@@ -28,6 +28,15 @@
 
 #define _GLIBCXX_USE_CXX11_ABI 1
 #include <ios>
+#include <bits/functexcept.h>
+#include <cxxabi.h>
+
+#ifdef _GLIBCXX_USE_NLS
+# include <libintl.h>
+# define _(msgid)   gettext (msgid)
+#else
+# define _(msgid)   (msgid)
+#endif
 
 #if ! _GLIBCXX_USE_DUAL_ABI
 # error This file should not be compiled for this configuration.
@@ -91,5 +100,66 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   ios_base::failure::what() const throw()
   { return runtime_error::what(); }
 
+#if __cpp_rtti
+  // These functions are defined in src/c++98/ios_failure.cc
+  extern void __construct_ios_failure(void*, const char*);
+  extern void __destroy_ios_failure(void*);
+  extern bool __is_ios_failure_handler(const __cxxabiv1::__class_type_info*);
+
+  // The type thrown to report errors during stream buffer operations.
+  // In addition to the ios::failure[abi:cxx11] base class it also has a
+  // member of the gcc4-compatible ios::failure type (in an opaque buffer).
+  struct __ios_failure : std::ios::failure
+  {
+    __ios_failure(const char* s) : failure(s)
+    { __construct_ios_failure(buf, runtime_error::what()); }
+
+    ~__ios_failure()
+    { __destroy_ios_failure(buf); }
+
+    // Use std::runtime_error as a proxy for the gcc4-compatible ios::failure
+    // (which can't be declared here because _GLIBCXX_USE_CXX11_ABI == 1).
+    // There are assertions in src/c++98/ios_failure.cc to ensure the size
+    // and alignment assumptions are valid.
+    alignas(runtime_error) unsigned char buf[sizeof(runtime_error)];
+  };
+
+  // Custom type info for __ios_failure.
+  class __iosfail_type_info : __cxxabiv1::__si_class_type_info
+  {
+    ~__iosfail_type_info();
+
+    bool
+    __do_upcast (const __class_type_info *dst_type,
+		 void **obj_ptr) const override;
+  };
+
+  __iosfail_type_info::~__iosfail_type_info() = default;
+
+  // This function gets called to see if an exception of type
+  // __ios_failure can be upcast to the type in a catch handler.
+  bool
+  __iosfail_type_info::__do_upcast(const __class_type_info *dst_type,
+				   void **obj_ptr) const
+  {
+    // If the handler is for the gcc4-compatible ios::failure type then
+    // catch the object stored in __ios_failure::buf instead of
+    // the __ios_failure exception object itself.
+    if (__is_ios_failure_handler(dst_type))
+      {
+	*obj_ptr = static_cast<__ios_failure*>(*obj_ptr)->buf;
+	return true;
+      }
+    // Otherwise proceed as normal to see if the handler matches.
+    return __class_type_info::__do_upcast(dst_type, obj_ptr);
+  }
+#else // ! __cpp_rtti
+  using __ios_failure = ios::failure;
+#endif
+
+  void
+  __throw_ios_failure(const char* __s __attribute__((unused)))
+  { _GLIBCXX_THROW_OR_ABORT(__ios_failure(_(__s))); }
+
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace
diff --git a/libstdc++-v3/src/c++11/ios.cc b/libstdc++-v3/src/c++11/ios.cc
index 9061989f806..ef0da960007 100644
--- a/libstdc++-v3/src/c++11/ios.cc
+++ b/libstdc++-v3/src/c++11/ios.cc
@@ -26,29 +26,13 @@
 // ISO C++ 14882: 27.4  Iostreams base classes
 //
 
-// Determines the version of ios_base::failure thrown by __throw_ios_failure.
-// If !_GLIBCXX_USE_DUAL_ABI this will get undefined automatically.
-#define _GLIBCXX_USE_CXX11_ABI 1
-
 #include <ios>
 #include <limits>
-#include <bits/functexcept.h>
-
-#ifdef _GLIBCXX_USE_NLS
-# include <libintl.h>
-# define _(msgid)   gettext (msgid)
-#else
-# define _(msgid)   (msgid)
-#endif
 
 namespace std _GLIBCXX_VISIBILITY(default)
 {
 _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
-  void
-  __throw_ios_failure(const char* __s __attribute__((unused)))
-  { _GLIBCXX_THROW_OR_ABORT(ios_base::failure(_(__s))); }
-
   // Definitions for static const members of ios_base.
   const ios_base::fmtflags ios_base::boolalpha;
   const ios_base::fmtflags ios_base::dec;
diff --git a/libstdc++-v3/src/c++11/system_error.cc b/libstdc++-v3/src/c++11/system_error.cc
index 61dbc3fb5bb..26386b6acf6 100644
--- a/libstdc++-v3/src/c++11/system_error.cc
+++ b/libstdc++-v3/src/c++11/system_error.cc
@@ -29,6 +29,7 @@
 #include <system_error>
 #include <bits/functexcept.h>
 #include <limits>
+#include <errno.h>
 #undef __sso_string
 
 namespace
@@ -65,6 +66,261 @@ namespace
       // _GLIBCXX_HAVE_STRERROR_L, strerror_l(i, cloc)
       return string(strerror(i));
     }
+
+    virtual std::error_condition
+    default_error_condition(int ev) const noexcept
+    {
+      switch (ev)
+      {
+      // List of errno macros from [cerrno.syn].
+      // C11 only defines EDOM, EILSEQ and ERANGE, the rest are from POSIX.
+      // They expand to integer constant expressions with type int,
+      // and distinct positive values, suitable for use in #if directives.
+      // POSIX adds more macros (but they're not defined on all targets,
+      // see config/os/*/error_constants.h), and POSIX allows
+      // EAGAIN == EWOULDBLOCK and ENOTSUP == EOPNOTSUPP.
+
+#ifdef E2BIG
+      case E2BIG:
+#endif
+#ifdef EACCES
+      case EACCES:
+#endif
+#ifdef EADDRINUSE
+      case EADDRINUSE:
+#endif
+#ifdef EADDRNOTAVAIL
+      case EADDRNOTAVAIL:
+#endif
+#ifdef EAFNOSUPPORT
+      case EAFNOSUPPORT:
+#endif
+#ifdef EAGAIN
+      case EAGAIN:
+#endif
+#ifdef EALREADY
+      case EALREADY:
+#endif
+#ifdef EBADF
+      case EBADF:
+#endif
+#ifdef EBADMSG
+      case EBADMSG:
+#endif
+#ifdef EBUSY
+      case EBUSY:
+#endif
+#ifdef ECANCELED
+      case ECANCELED:
+#endif
+#ifdef ECHILD
+      case ECHILD:
+#endif
+#ifdef ECONNABORTED
+      case ECONNABORTED:
+#endif
+#ifdef ECONNREFUSED
+      case ECONNREFUSED:
+#endif
+#ifdef ECONNRESET
+      case ECONNRESET:
+#endif
+#ifdef EDEADLK
+      case EDEADLK:
+#endif
+#ifdef EDESTADDRREQ
+      case EDESTADDRREQ:
+#endif
+      case EDOM:
+#ifdef EEXIST
+      case EEXIST:
+#endif
+#ifdef EFAULT
+      case EFAULT:
+#endif
+#ifdef EFBIG
+      case EFBIG:
+#endif
+#ifdef EHOSTUNREACH
+      case EHOSTUNREACH:
+#endif
+#ifdef EIDRM
+      case EIDRM:
+#endif
+      case EILSEQ:
+#ifdef EINPROGRESS
+      case EINPROGRESS:
+#endif
+#ifdef EINTR
+      case EINTR:
+#endif
+#ifdef EINVAL
+      case EINVAL:
+#endif
+#ifdef EIO
+      case EIO:
+#endif
+#ifdef EISCONN
+      case EISCONN:
+#endif
+#ifdef EISDIR
+      case EISDIR:
+#endif
+#ifdef ELOOP
+      case ELOOP:
+#endif
+#ifdef EMFILE
+      case EMFILE:
+#endif
+#ifdef EMLINK
+      case EMLINK:
+#endif
+#ifdef EMSGSIZE
+      case EMSGSIZE:
+#endif
+#ifdef ENAMETOOLONG
+      case ENAMETOOLONG:
+#endif
+#ifdef ENETDOWN
+      case ENETDOWN:
+#endif
+#ifdef ENETRESET
+      case ENETRESET:
+#endif
+#ifdef ENETUNREACH
+      case ENETUNREACH:
+#endif
+#ifdef ENFILE
+      case ENFILE:
+#endif
+#ifdef ENOBUFS
+      case ENOBUFS:
+#endif
+#ifdef ENODATA
+      case ENODATA:
+#endif
+#ifdef ENODEV
+      case ENODEV:
+#endif
+#ifdef ENOENT
+      case ENOENT:
+#endif
+#ifdef ENOEXEC
+      case ENOEXEC:
+#endif
+#ifdef ENOLCK
+      case ENOLCK:
+#endif
+#ifdef ENOLINK
+      case ENOLINK:
+#endif
+#ifdef ENOMEM
+      case ENOMEM:
+#endif
+#ifdef ENOMSG
+      case ENOMSG:
+#endif
+#ifdef ENOPROTOOPT
+      case ENOPROTOOPT:
+#endif
+#ifdef ENOSPC
+      case ENOSPC:
+#endif
+#ifdef ENOSR
+      case ENOSR:
+#endif
+#ifdef ENOSTR
+      case ENOSTR:
+#endif
+#ifdef ENOSYS
+      case ENOSYS:
+#endif
+#ifdef ENOTCONN
+      case ENOTCONN:
+#endif
+#ifdef ENOTDIR
+      case ENOTDIR:
+#endif
+#if defined ENOTEMPTY && (!defined EEXIST || ENOTEMPTY != EEXIST)
+      // AIX sometimes uses the same value for EEXIST and ENOTEMPTY
+      case ENOTEMPTY:
+#endif
+#ifdef ENOTRECOVERABLE
+      case ENOTRECOVERABLE:
+#endif
+#ifdef ENOTSOCK
+      case ENOTSOCK:
+#endif
+#ifdef ENOTSUP
+      case ENOTSUP:
+#endif
+#ifdef ENOTTY
+      case ENOTTY:
+#endif
+#ifdef ENXIO
+      case ENXIO:
+#endif
+#if defined EOPNOTSUPP && (!defined ENOTSUP || EOPNOTSUPP != ENOTSUP)
+      case EOPNOTSUPP:
+#endif
+#ifdef EOVERFLOW
+      case EOVERFLOW:
+#endif
+#ifdef EOWNERDEAD
+      case EOWNERDEAD:
+#endif
+#ifdef EPERM
+      case EPERM:
+#endif
+#ifdef EPIPE
+      case EPIPE:
+#endif
+#ifdef EPROTO
+      case EPROTO:
+#endif
+#ifdef EPROTONOSUPPORT
+      case EPROTONOSUPPORT:
+#endif
+#ifdef EPROTOTYPE
+      case EPROTOTYPE:
+#endif
+      case ERANGE:
+#ifdef EROFS
+      case EROFS:
+#endif
+#ifdef ESPIPE
+      case ESPIPE:
+#endif
+#ifdef ESRCH
+      case ESRCH:
+#endif
+#ifdef ETIME
+      case ETIME:
+#endif
+#ifdef ETIMEDOUT
+      case ETIMEDOUT:
+#endif
+#ifdef ETXTBSY
+      case ETXTBSY:
+#endif
+#if defined EWOULDBLOCK && (!defined EAGAIN || EWOULDBLOCK != EAGAIN)
+      case EWOULDBLOCK:
+#endif
+#ifdef EXDEV
+      case EXDEV:
+#endif
+        return std::error_condition(ev, std::generic_category());
+
+      /* Additional system-dependent mappings from non-standard error codes
+       * to one of the POSIX values above would go here, e.g.
+      case EBLAH:
+	return std::error_condition(EINVAL, std::generic_category());
+       */
+
+      default:
+	return std::error_condition(ev, std::system_category());
+      }
+    }
   };
 
   const generic_error_category generic_category_instance{};
diff --git a/libstdc++-v3/src/c++98/ios_failure.cc b/libstdc++-v3/src/c++98/ios_failure.cc
index 3ba25f81279..e7f35e21e2c 100644
--- a/libstdc++-v3/src/c++98/ios_failure.cc
+++ b/libstdc++-v3/src/c++98/ios_failure.cc
@@ -29,6 +29,18 @@
 #define _GLIBCXX_USE_CXX11_ABI 0
 #include <ios>
 
+#if _GLIBCXX_USE_DUAL_ABI && __cpp_rtti
+#include <cxxabi.h>
+#include <typeinfo>
+#endif
+
+#ifdef _GLIBCXX_USE_NLS
+# include <libintl.h>
+# define _(msgid)   gettext (msgid)
+#else
+# define _(msgid)   (msgid)
+#endif
+
 namespace std _GLIBCXX_VISIBILITY(default)
 {
 _GLIBCXX_BEGIN_NAMESPACE_VERSION
@@ -43,5 +55,40 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   ios_base::failure::what() const throw()
   { return _M_msg.c_str(); }
 
+#if _GLIBCXX_USE_DUAL_ABI
+  // When the dual ABI is enabled __throw_ios_failure() is defined in
+  // src/c++11/cxx11-ios_failure.cc
+#if __cpp_rtti
+  // If RTTI is enabled the exception type thrown will use these functions to
+  // construct/destroy a gcc4-compatible ios::failure object in a buffer,
+  // and to catch that object via a handler of the gcc4-compatible type.
+  void
+  __construct_ios_failure(void* buf, const char* msg)
+  { ::new(buf) ios_base::failure(msg); }
+
+  void
+  __destroy_ios_failure(void* buf)
+  { static_cast<ios_base::failure*>(buf)->~failure(); }
+
+  bool
+  __is_ios_failure_handler(const __cxxabiv1::__class_type_info* type)
+  { return *type == typeid(ios::failure); }
+
+  namespace {
+  // C++98-style static assertions to ensure ios::failure fits in a buffer
+  // with the same size and alignment as runtime_error:
+  typedef char S[1 / (sizeof(ios::failure) <= sizeof(runtime_error))];
+  typedef char A[1 / (__alignof(ios::failure) <= __alignof(runtime_error))];
+  }
+#endif // __cpp_rtti
+
+#else // ! _GLIBCXX_USE_DUAL_ABI
+
+  void
+  __throw_ios_failure(const char* __s __attribute__((unused)))
+  { _GLIBCXX_THROW_OR_ABORT(ios::failure(_(__s))); }
+
+#endif
+
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace
diff --git a/libstdc++-v3/src/filesystem/ops.cc b/libstdc++-v3/src/filesystem/ops.cc
index 8de3511346e..397a8d7ffe7 100644
--- a/libstdc++-v3/src/filesystem/ops.cc
+++ b/libstdc++-v3/src/filesystem/ops.cc
@@ -720,10 +720,8 @@ namespace
     if (::mkdir(p.c_str(), mode))
       {
 	const int err = errno;
-	if (err != EEXIST || !is_directory(p))
+	if (err != EEXIST || !is_directory(p, ec))
 	  ec.assign(err, std::generic_category());
-	else
-	  ec.clear();
       }
     else
       {
@@ -1391,10 +1389,11 @@ fs::space(const path& p, error_code& ec) noexcept
       ec.assign(errno, std::generic_category());
   else
     {
+      uintmax_t fragment_size = f.f_frsize;
       info = space_info{
-	f.f_blocks * f.f_frsize,
-	f.f_bfree * f.f_frsize,
-	f.f_bavail * f.f_frsize
+	f.f_blocks * fragment_size,
+	f.f_bfree * fragment_size,
+	f.f_bavail * fragment_size
       };
       ec.clear();
     }
diff --git a/libstdc++-v3/testsuite/17_intro/headers/c++1998/all_attributes.cc b/libstdc++-v3/testsuite/17_intro/headers/c++1998/all_attributes.cc
index 6d6d7980396..f5d1d4563b3 100644
--- a/libstdc++-v3/testsuite/17_intro/headers/c++1998/all_attributes.cc
+++ b/libstdc++-v3/testsuite/17_intro/headers/c++1998/all_attributes.cc
@@ -21,9 +21,9 @@
 // Ensure the library only uses the __name__ form for attributes.
 // Don't test 'const' because it is reserved anyway.
 #define abi_tag 1
-#define always_inline 1
 #ifndef __APPLE__
 // darwin headers use these, see PR 64883
+# define always_inline 1
 # define deprecated 1
 # define noreturn 1
 # define visibility 1
diff --git a/libstdc++-v3/testsuite/17_intro/headers/c++2011/all_attributes.cc b/libstdc++-v3/testsuite/17_intro/headers/c++2011/all_attributes.cc
index 415ece0296f..ef7b14a5919 100644
--- a/libstdc++-v3/testsuite/17_intro/headers/c++2011/all_attributes.cc
+++ b/libstdc++-v3/testsuite/17_intro/headers/c++2011/all_attributes.cc
@@ -21,11 +21,11 @@
 // Ensure the library only uses the __name__ form for attributes.
 // Don't test 'const' and 'noreturn' because they are reserved anyway.
 #define abi_tag 1
-#define always_inline 1
 #ifndef __APPLE__
 // darwin headers use these, see PR 64883
-# define visibility 1
+# define always_inline 1
 # define deprecated 1
+# define visibility 1
 #endif
 #define packed 1
 #define pure 1
diff --git a/libstdc++-v3/testsuite/17_intro/headers/c++2014/all_attributes.cc b/libstdc++-v3/testsuite/17_intro/headers/c++2014/all_attributes.cc
index d4ef52412a3..0f15e9cdac5 100644
--- a/libstdc++-v3/testsuite/17_intro/headers/c++2014/all_attributes.cc
+++ b/libstdc++-v3/testsuite/17_intro/headers/c++2014/all_attributes.cc
@@ -21,9 +21,9 @@
 // Ensure the library only uses the __name__ form for attributes.
 // Don't test 'const' and 'noreturn' because they are reserved anyway.
 #define abi_tag 1
-#define always_inline 1
 #ifndef __APPLE__
 // darwin headers use these, see PR 64883
+# define always_inline 1
 # define deprecated 1
 # define visibility 1
 #endif
diff --git a/libstdc++-v3/testsuite/18_support/aligned_alloc/aligned_alloc.cc b/libstdc++-v3/testsuite/18_support/aligned_alloc/aligned_alloc.cc
new file mode 100644
index 00000000000..1700df8fdda
--- /dev/null
+++ b/libstdc++-v3/testsuite/18_support/aligned_alloc/aligned_alloc.cc
@@ -0,0 +1,42 @@
+// Copyright (C) 2018 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++17" }
+// { dg-do run { target c++1z } }
+
+#include <cstdlib>
+#include <cstdint>
+#include <testsuite_hooks.h>
+
+void
+test01()
+{
+#ifdef _GLIBCXX_HAVE_ALIGNED_ALLOC
+  void* p = std::aligned_alloc(256, 1);
+  if (p)
+  {
+    VERIFY( (reinterpret_cast<std::uintptr_t>(p) % 256) == 0 );
+    std::free(p);
+  }
+#endif
+}
+
+int
+main()
+{
+  test01();
+}
diff --git a/libstdc++-v3/testsuite/18_support/byte/81076.cc b/libstdc++-v3/testsuite/18_support/byte/81076.cc
new file mode 100644
index 00000000000..6ca7063bd05
--- /dev/null
+++ b/libstdc++-v3/testsuite/18_support/byte/81076.cc
@@ -0,0 +1,26 @@
+// Copyright (C) 2018 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++17" }
+// { dg-do compile { target c++1z } }
+
+#include <cstddef>
+
+template<class> void to_integer(...);
+
+using T = decltype(to_integer<void* const>(std::byte{}));
+using T = void;
diff --git a/libstdc++-v3/testsuite/18_support/new_aligned.cc b/libstdc++-v3/testsuite/18_support/new_aligned.cc
new file mode 100644
index 00000000000..8e77422a2b2
--- /dev/null
+++ b/libstdc++-v3/testsuite/18_support/new_aligned.cc
@@ -0,0 +1,119 @@
+// Copyright (C) 2018 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++17" }
+// { dg-do run { target c++1z } }
+
+#include <new>
+#include <memory>
+#include <testsuite_hooks.h>
+
+struct Test
+{
+  Test(std::size_t size, std::size_t a)
+  : size(size), alignment(std::align_val_t{a}),
+    p(::operator new(size, alignment))
+  { }
+
+  ~Test() { ::operator delete(p, size, alignment); }
+
+  std::size_t size;
+  std::align_val_t alignment;
+  void* p;
+
+  bool valid() const { return p != nullptr; }
+
+  bool aligned() const
+  {
+    auto ptr = p;
+    auto space = size;
+    return std::align((std::size_t)alignment, size, ptr, space) == p;
+  }
+};
+
+// operator new(size_t size, align_val_t alignment) has
+// undefined behaviour if the alignment argument is not
+// a valid alignment value (i.e. not a power of two).
+//
+// Unlike posix_memalign there is no requirement that
+// alignment >= sizeof(void*).
+//
+// Unlike aligned_alloc there is no requirement that
+// size is an integer multiple of alignment.
+
+void
+test01()
+{
+  // Test small values that would not be valid for
+  // posix_memalign or aligned_alloc.
+
+  Test t11{1, 1};
+  VERIFY( t11.valid() );
+  VERIFY( t11.aligned() );
+
+  Test t21{2, 1};
+  VERIFY( t21.valid() );
+  VERIFY( t21.aligned() );
+
+  Test t12{1, 2};
+  VERIFY( t12.valid() );
+  VERIFY( t12.aligned() );
+
+  Test t22{2, 2};
+  VERIFY( t22.valid() );
+  VERIFY( t22.aligned() );
+
+  Test t32{3, 2};
+  VERIFY( t32.valid() );
+  VERIFY( t32.aligned() );
+
+  Test t42{4, 2};
+  VERIFY( t42.valid() );
+  VERIFY( t42.aligned() );
+
+  Test t24{2, 4};
+  VERIFY( t24.valid() );
+  VERIFY( t24.aligned() );
+
+  Test t34{3, 4};
+  VERIFY( t34.valid() );
+  VERIFY( t34.aligned() );
+
+  Test t44{4, 4};
+  VERIFY( t44.valid() );
+  VERIFY( t44.aligned() );
+
+  // Test some larger values.
+
+  Test t128_16{128, 16};
+  VERIFY( t128_16.valid() );
+  VERIFY( t128_16.aligned() );
+
+  Test t128_64{128, 64};
+  VERIFY( t128_64.valid() );
+  VERIFY( t128_64.aligned() );
+
+  Test t64_128{64, 128};
+  VERIFY( t64_128.valid() );
+  VERIFY( t64_128.aligned() );
+}
+
+int
+main()
+{
+  test01();
+}
diff --git a/libstdc++-v3/testsuite/19_diagnostics/error_category/generic_category.cc b/libstdc++-v3/testsuite/19_diagnostics/error_category/generic_category.cc
new file mode 100644
index 00000000000..64881f44ca0
--- /dev/null
+++ b/libstdc++-v3/testsuite/19_diagnostics/error_category/generic_category.cc
@@ -0,0 +1,69 @@
+// Copyright (C) 2018 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do run { target c++11 } }
+
+#include <system_error>
+#include <locale>
+#include <testsuite_hooks.h>
+
+void
+test01()
+{
+  const char* name = std::generic_category().name();
+  VERIFY( name == std::string("generic") );
+}
+
+void
+test02()
+{
+  const std::error_category& cat = std::generic_category();
+  std::error_condition cond;
+
+  cond = cat.default_error_condition(EBADF);
+  VERIFY( cond.value() == EBADF );
+  VERIFY( cond == std::errc::bad_file_descriptor );
+  VERIFY( cond.category() == std::generic_category() );
+  cond = cat.default_error_condition(EACCES);
+  VERIFY( cond.value() == EACCES );
+  VERIFY( cond == std::errc::permission_denied );
+  VERIFY( cond.category() == std::generic_category() );
+
+  // PR libstdc++/60555
+  VERIFY( std::error_code(EBADF, cat) == std::errc::bad_file_descriptor );
+  VERIFY( std::error_code(EACCES, cat) == std::errc::permission_denied );
+}
+
+void
+test03()
+{
+  // set "C" locale to get expected message
+  auto loc = std::locale::global(std::locale::classic());
+
+  std::string msg = std::generic_category().message(EBADF);
+  VERIFY( msg.find("file") != std::string::npos );
+
+  std::locale::global(loc);
+}
+
+int
+main()
+{
+  test01();
+  test02();
+  test03();
+}
diff --git a/libstdc++-v3/testsuite/19_diagnostics/error_category/system_category.cc b/libstdc++-v3/testsuite/19_diagnostics/error_category/system_category.cc
new file mode 100644
index 00000000000..77cd9c5df83
--- /dev/null
+++ b/libstdc++-v3/testsuite/19_diagnostics/error_category/system_category.cc
@@ -0,0 +1,114 @@
+// Copyright (C) 2018 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do run { target c++11 } }
+
+#include <system_error>
+#include <locale>
+#include <testsuite_hooks.h>
+
+void
+test01()
+{
+  const char* name = std::system_category().name();
+  VERIFY( name == std::string("system") );
+}
+
+void
+test02()
+{
+  const std::error_category& cat = std::system_category();
+  std::error_condition cond;
+
+  // As of 2011, ISO C only defines EDOM, EILSEQ and ERANGE:
+  cond = cat.default_error_condition(EDOM);
+  VERIFY( cond.value() == EDOM );
+  VERIFY( cond == std::errc::argument_out_of_domain );
+  VERIFY( cond.category() == std::generic_category() );
+  cond = cat.default_error_condition(EILSEQ);
+  VERIFY( cond.value() == EILSEQ );
+  VERIFY( cond == std::errc::illegal_byte_sequence );
+  VERIFY( cond.category() == std::generic_category() );
+  cond = cat.default_error_condition(ERANGE);
+  VERIFY( cond.value() == ERANGE );
+  VERIFY( cond == std::errc::result_out_of_range );
+  VERIFY( cond.category() == std::generic_category() );
+
+  // EBADF and EACCES are defined on all targets,
+  // according to config/os/*/error_constants.h
+  cond = cat.default_error_condition(EBADF);
+  VERIFY( cond.value() == EBADF );
+  VERIFY( cond == std::errc::bad_file_descriptor );
+  VERIFY( cond.category() == std::generic_category() );
+  cond = cat.default_error_condition(EACCES);
+  VERIFY( cond.value() == EACCES );
+  VERIFY( cond == std::errc::permission_denied );
+  VERIFY( cond.category() == std::generic_category() );
+
+  // All POSIX errno values are positive:
+  cond = cat.default_error_condition(-1);
+  VERIFY( cond.value() == -1 );
+  VERIFY( cond.category() == cat );
+  cond = cat.default_error_condition(-99);
+  VERIFY( cond.value() == -99 );
+  VERIFY( cond.category() == cat );
+
+  // PR libstdc++/60555
+  VERIFY( std::error_code(EDOM, cat) == std::errc::argument_out_of_domain );
+  VERIFY( std::error_code(EILSEQ, cat) == std::errc::illegal_byte_sequence );
+  VERIFY( std::error_code(ERANGE, cat) == std::errc::result_out_of_range );
+  VERIFY( std::error_code(EBADF, cat) == std::errc::bad_file_descriptor );
+  VERIFY( std::error_code(EACCES, cat) == std::errc::permission_denied );
+
+  // As shown at https://gcc.gnu.org/ml/libstdc++/2018-08/msg00018.html
+  // these two error codes might have the same value on AIX, but we still
+  // expect both to be matched by system_category and so use generic_category:
+#ifdef EEXIST
+  cond = cat.default_error_condition(EEXIST);
+  VERIFY( cond.value() == EEXIST );
+  VERIFY( cond == std::errc::file_exists );
+  VERIFY( cond.category() == std::generic_category() );
+  VERIFY( std::error_code(EEXIST, cat) == std::errc::file_exists );
+#endif
+#ifdef ENOTEMPTY
+  cond = cat.default_error_condition(ENOTEMPTY);
+  VERIFY( cond.value() == ENOTEMPTY );
+  VERIFY( cond == std::errc::directory_not_empty );
+  VERIFY( cond.category() == std::generic_category() );
+  VERIFY( std::error_code(ENOTEMPTY, cat) == std::errc::directory_not_empty );
+#endif
+}
+
+void
+test03()
+{
+  // set "C" locale to get expected message
+  auto loc = std::locale::global(std::locale::classic());
+
+  std::string msg = std::system_category().message(EBADF);
+  VERIFY( msg.find("file") != std::string::npos );
+
+  std::locale::global(loc);
+}
+
+int
+main()
+{
+  test01();
+  test02();
+  test03();
+}
diff --git a/libstdc++-v3/testsuite/20_util/any/misc/any_cast_neg.cc b/libstdc++-v3/testsuite/20_util/any/misc/any_cast_neg.cc
index 2d2b3d3d14c..6d0a688aace 100644
--- a/libstdc++-v3/testsuite/20_util/any/misc/any_cast_neg.cc
+++ b/libstdc++-v3/testsuite/20_util/any/misc/any_cast_neg.cc
@@ -26,5 +26,5 @@ void test01()
   using std::any_cast;
 
   const any y(1);
-  any_cast<int&>(y); // { dg-error "invalid static_cast" "" { target { *-*-* } } 461 }
+  any_cast<int&>(y); // { dg-error "invalid static_cast" "" { target { *-*-* } } 460 }
 }
diff --git a/libstdc++-v3/testsuite/20_util/any/modifiers/83658.cc b/libstdc++-v3/testsuite/20_util/any/modifiers/83658.cc
new file mode 100644
index 00000000000..121db6dc075
--- /dev/null
+++ b/libstdc++-v3/testsuite/20_util/any/modifiers/83658.cc
@@ -0,0 +1,74 @@
+// Copyright (C) 2018 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++17" }
+// { dg-do run { target c++1z } }
+
+#include <any>
+#include <new>
+#include <testsuite_hooks.h>
+
+struct E : std::bad_alloc { };
+
+struct X
+{
+    X() = default;
+    X(std::initializer_list<int>) { }
+
+    // Prevents small-object optimization:
+    X(const X&) noexcept(false) { }
+
+    static void* operator new(std::size_t) { throw E{}; }
+    static void operator delete(void*, std::size_t) noexcept { }
+};
+
+void
+test01()
+{
+  std::any a;
+  try
+  {
+    a.emplace<X>();
+    VERIFY(false);
+  }
+  catch (const E&)
+  {
+    VERIFY( !a.has_value() );
+  }
+}
+
+void
+test02()
+{
+  std::any a;
+  try
+  {
+    a.emplace<X>(std::initializer_list<int>{});
+    VERIFY(false);
+  }
+  catch (const E&)
+  {
+    VERIFY( !a.has_value() );
+  }
+}
+
+int
+main()
+{
+  test01();
+  test02();
+}
diff --git a/libstdc++-v3/testsuite/20_util/duration/cons/dr3050.cc b/libstdc++-v3/testsuite/20_util/duration/cons/dr3050.cc
new file mode 100644
index 00000000000..a4f57a38c30
--- /dev/null
+++ b/libstdc++-v3/testsuite/20_util/duration/cons/dr3050.cc
@@ -0,0 +1,24 @@
+// Copyright (C) 2018 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do compile { target c++11 } }
+
+#include <chrono>
+
+struct X { operator int64_t() /* not const */; };
+static_assert(!std::is_constructible<std::chrono::seconds, X>::value,
+	      "LWG 3050");
diff --git a/libstdc++-v3/testsuite/20_util/duration/literals/84671.cc b/libstdc++-v3/testsuite/20_util/duration/literals/84671.cc
new file mode 100644
index 00000000000..4f50ec4c9cc
--- /dev/null
+++ b/libstdc++-v3/testsuite/20_util/duration/literals/84671.cc
@@ -0,0 +1,26 @@
+// Copyright (C) 2018 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do compile { target c++14 } }
+
+#include <chrono>
+
+// PR libstdc++/84671
+using namespace std::literals::chrono_literals;
+constexpr auto ns_ok = 12113ns;
+constexpr auto ns_fail = 12'11'3ns;
+static_assert(ns_ok == ns_fail, "digit separators work in duration literals");
diff --git a/libstdc++-v3/testsuite/20_util/duration/literals/range.cc b/libstdc++-v3/testsuite/20_util/duration/literals/range_neg.cc
similarity index 94%
rename from libstdc++-v3/testsuite/20_util/duration/literals/range.cc
rename to libstdc++-v3/testsuite/20_util/duration/literals/range_neg.cc
index 531b53c42ec..bccff767ef7 100644
--- a/libstdc++-v3/testsuite/20_util/duration/literals/range.cc
+++ b/libstdc++-v3/testsuite/20_util/duration/literals/range_neg.cc
@@ -26,6 +26,6 @@ test01()
 
   // std::numeric_limits<int64_t>::max() == 9223372036854775807;
   auto h = 9223372036854775808h;
-  // { dg-error "cannot be represented" "" { target *-*-* } 893 }
+  // { dg-error "cannot be represented" "" { target *-*-* } 899 }
 }
 // { dg-prune-output "in constexpr expansion" } // needed for -O0
diff --git a/libstdc++-v3/testsuite/20_util/function_objects/not_fn/87538.cc b/libstdc++-v3/testsuite/20_util/function_objects/not_fn/87538.cc
new file mode 100644
index 00000000000..ade996d587c
--- /dev/null
+++ b/libstdc++-v3/testsuite/20_util/function_objects/not_fn/87538.cc
@@ -0,0 +1,49 @@
+// Copyright (C) 2018 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++17" }
+// { dg-do run { target c++1z } }
+
+#include <functional>
+#include <testsuite_hooks.h>
+
+struct N {
+  int operator()(int i) { if (i == 0) throw -1; return i; }
+};
+
+void
+test01()
+{
+  N n;
+  auto not_n = std::not_fn(n);
+  static_assert( !noexcept(not_n(1)) );
+  VERIFY(not_n(1) == 0);
+  int exception = 0;
+  try {
+    not_n(0);
+  }
+  catch (int e) {
+    exception = e;
+  }
+  VERIFY(exception == -1);
+}
+
+int
+main()
+{
+  test01();
+}
diff --git a/libstdc++-v3/testsuite/20_util/has_unique_object_representations/value.cc b/libstdc++-v3/testsuite/20_util/has_unique_object_representations/value.cc
index 008d59062ab..60f30a294da 100644
--- a/libstdc++-v3/testsuite/20_util/has_unique_object_representations/value.cc
+++ b/libstdc++-v3/testsuite/20_util/has_unique_object_representations/value.cc
@@ -108,3 +108,17 @@ void test01()
   static_assert(test_category<has_unique_object_representations,
 		Aligned[][1]>(false), "");
 }
+
+void
+test02()
+{
+  using std::has_unique_object_representations;
+  using std::has_unique_object_representations_v;
+
+  static_assert(has_unique_object_representations_v<int>
+		== has_unique_object_representations<int>::value);
+  static_assert(has_unique_object_representations_v<void>
+		== has_unique_object_representations<void>::value);
+  static_assert(has_unique_object_representations_v<float>
+		== has_unique_object_representations<float>::value);
+}
diff --git a/libstdc++-v3/testsuite/20_util/hash/89629.cc b/libstdc++-v3/testsuite/20_util/hash/89629.cc
new file mode 100644
index 00000000000..fd8273087fc
--- /dev/null
+++ b/libstdc++-v3/testsuite/20_util/hash/89629.cc
@@ -0,0 +1,43 @@
+// Copyright (C) 2019 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do run { target { lp64 || llp64 } } }
+// { dg-require-effective-target c++11 }
+// { dg-require-effective-target run_expensive_tests }
+
+#include <functional>
+#include <string>
+
+void
+test01()
+{
+  const std::size_t big = std::size_t(1) << 31;
+  std::string s;
+  try {
+    s.resize(big, 'a');
+  } catch (const std::bad_alloc&) {
+    return; // try to avoid a FAIL if memory allocation fails
+  }
+  // PR libstdc++/89629
+  (void) std::hash<std::string>{}(s);
+}
+
+int
+main()
+{
+  test01();
+}
diff --git a/libstdc++-v3/testsuite/20_util/pair/86751.cc b/libstdc++-v3/testsuite/20_util/pair/86751.cc
new file mode 100644
index 00000000000..76a76c0d656
--- /dev/null
+++ b/libstdc++-v3/testsuite/20_util/pair/86751.cc
@@ -0,0 +1,33 @@
+// Copyright (C) 2018 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do compile { target c++11 } }
+
+#include <utility>
+
+struct X {
+  template<typename T> operator T() const;
+};
+
+
+void
+test01()
+{
+  std::pair<int, int> p;
+  X x;
+  p = x;  // PR libstdc++/86751
+}
diff --git a/libstdc++-v3/testsuite/20_util/pair/87822.cc b/libstdc++-v3/testsuite/20_util/pair/87822.cc
new file mode 100644
index 00000000000..523d583f08a
--- /dev/null
+++ b/libstdc++-v3/testsuite/20_util/pair/87822.cc
@@ -0,0 +1,64 @@
+// Copyright (C) 2018 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+#include <utility>
+#include <testsuite_hooks.h>
+
+void
+test01()
+{
+  std::pair<std::pair<int, int>, int> p;
+#if __cplusplus >= 201103L
+  static_assert(sizeof(p) == (3 * sizeof(int)), "PR libstdc++/87822");
+#endif
+  VERIFY( (void*)&p == (void*)&p.first );
+  VERIFY( (void*)&p == (void*)&p.first.first );
+}
+
+struct empty { };
+
+void
+test02()
+{
+  std::pair<std::pair<empty, empty>, empty> p;
+#if __cplusplus >= 201103L
+  static_assert(sizeof(p) == (3 * sizeof(empty)), "PR libstdc++/87822");
+#endif
+  VERIFY( (void*)&p == (void*)&p.first );
+}
+
+void
+test03()
+{
+  typedef std::pair<int, int> int_pair;
+  typedef std::pair<int_pair, int_pair> int_pair_pair;
+  std::pair<int_pair_pair, int_pair_pair> p;
+#if __cplusplus >= 201103L
+  static_assert(sizeof(int_pair_pair) == (2 * sizeof(int_pair)), "nested");
+  static_assert(sizeof(p) == (2 * sizeof(int_pair_pair)), "nested again");
+#endif
+  VERIFY( (void*)&p == (void*)&p.first );
+  VERIFY( (void*)&p == (void*)&p.first.first );
+  VERIFY( (void*)&p == (void*)&p.first.first.first );
+}
+
+int main()
+{
+  test01();
+  test02();
+  test03();
+}
diff --git a/libstdc++-v3/testsuite/20_util/pair/ref_assign.cc b/libstdc++-v3/testsuite/20_util/pair/ref_assign.cc
new file mode 100644
index 00000000000..ea37fcfcf52
--- /dev/null
+++ b/libstdc++-v3/testsuite/20_util/pair/ref_assign.cc
@@ -0,0 +1,74 @@
+// Copyright (C) 2018 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do run { target c++11 } }
+
+#include <utility>
+#include <testsuite_hooks.h>
+
+void
+test01()
+{
+  typedef std::pair<int&, int> pair_type;
+  int i = 1;
+  int j = 2;
+  pair_type p(i, 3);
+  const pair_type q(j, 4);
+  p = q;
+  VERIFY( p.first == q.first );
+  VERIFY( p.second == q.second );
+  VERIFY( i == j );
+}
+
+void
+test02()
+{
+  typedef std::pair<int, int&> pair_type;
+  int i = 1;
+  int j = 2;
+  pair_type p(3, i);
+  const pair_type q(4, j);
+  p = q;
+  VERIFY( p.first == q.first );
+  VERIFY( p.second == q.second );
+  VERIFY( i == j );
+}
+
+void
+test03()
+{
+  typedef std::pair<int&, int&> pair_type;
+  int i = 1;
+  int j = 2;
+  int k = 3;
+  int l = 4;
+  pair_type p(i, j);
+  const pair_type q(k, l);
+  p = q;
+  VERIFY( p.first == q.first );
+  VERIFY( p.second == q.second );
+  VERIFY( i == k );
+  VERIFY( j == l );
+}
+
+int
+main()
+{
+  test01();
+  test02();
+  test03();
+}
diff --git a/libstdc++-v3/testsuite/20_util/unique_ptr/cons/incomplete.cc b/libstdc++-v3/testsuite/20_util/unique_ptr/cons/incomplete.cc
new file mode 100644
index 00000000000..1a8f28838a1
--- /dev/null
+++ b/libstdc++-v3/testsuite/20_util/unique_ptr/cons/incomplete.cc
@@ -0,0 +1,32 @@
+// Copyright (C) 2018 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do compile { target c++11 } }
+
+#include <memory>
+
+struct Incomplete;
+
+void f(void** p)
+{
+  ::new (p[0]) std::unique_ptr<Incomplete>();
+  ::new (p[1]) std::unique_ptr<Incomplete[]>();
+
+  // PR libstdc++/87704
+  ::new (p[2]) std::unique_ptr<Incomplete>(nullptr);
+  ::new (p[3]) std::unique_ptr<Incomplete[]>(nullptr);
+}
diff --git a/libstdc++-v3/testsuite/21_strings/basic_string/cons/char/86138.cc b/libstdc++-v3/testsuite/21_strings/basic_string/cons/char/86138.cc
new file mode 100644
index 00000000000..a85fd9c82c9
--- /dev/null
+++ b/libstdc++-v3/testsuite/21_strings/basic_string/cons/char/86138.cc
@@ -0,0 +1,30 @@
+// Copyright (C) 2018 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++17" }
+// { dg-do compile { target c++1z } }
+// { dg-final { scan-assembler-not "_ZNSs4_Rep20_S_empty_rep_storageE:" } }
+
+#undef _GLIBCXX_USE_CXX11_ABI
+#define _GLIBCXX_USE_CXX11_ABI 0
+#include <string>
+
+void
+test01(std::string* s)
+{
+  s->~basic_string();
+}
diff --git a/libstdc++-v3/testsuite/21_strings/basic_string/cons/wchar_t/86138.cc b/libstdc++-v3/testsuite/21_strings/basic_string/cons/wchar_t/86138.cc
new file mode 100644
index 00000000000..d77922976d0
--- /dev/null
+++ b/libstdc++-v3/testsuite/21_strings/basic_string/cons/wchar_t/86138.cc
@@ -0,0 +1,30 @@
+// Copyright (C) 2018 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++17" }
+// { dg-do compile { target c++1z } }
+// { dg-final { scan-assembler-not "_ZNSbIwSt11char_traitsIwESaIwEE4_Rep20_S_empty_rep_storageE:" } }
+
+#undef _GLIBCXX_USE_CXX11_ABI
+#define _GLIBCXX_USE_CXX11_ABI 0
+#include <string>
+
+void
+test01(std::wstring* s)
+{
+  s->~basic_string();
+}
diff --git a/libstdc++-v3/testsuite/21_strings/basic_string/dr2268.cc b/libstdc++-v3/testsuite/21_strings/basic_string/dr2268.cc
new file mode 100644
index 00000000000..3ad6860d81f
--- /dev/null
+++ b/libstdc++-v3/testsuite/21_strings/basic_string/dr2268.cc
@@ -0,0 +1,45 @@
+// Copyright (C) 2018 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do run { target c++11 } }
+
+#include <string>
+#include <testsuite_hooks.h>
+
+void
+test01()
+{
+  // PR libstdc++/84087
+
+  std::string s0 = "string";
+  std::string s;
+  s.append(s0, 2);
+  VERIFY( s == "ring" );
+  s.assign(s0, 3);
+  VERIFY( s == "ing" );
+  s.insert(2, s0, 4);
+  VERIFY( s == "inngg" );
+  s.replace(2, 3, s0, 2);
+  VERIFY( s == "inring" );
+  VERIFY( s.compare(2, 4, s0, 2) == 0 );
+}
+
+int
+main()
+{
+  test01();
+}
diff --git a/libstdc++-v3/testsuite/21_strings/basic_string/init-list.cc b/libstdc++-v3/testsuite/21_strings/basic_string/init-list.cc
index bb390d650a3..8df9d2f0640 100644
--- a/libstdc++-v3/testsuite/21_strings/basic_string/init-list.cc
+++ b/libstdc++-v3/testsuite/21_strings/basic_string/init-list.cc
@@ -17,6 +17,7 @@
 //
 
 // { dg-do run { target c++11 } }
+// { dg-require-effective-target cxx11-abi }
 
 #include <string>
 #include <testsuite_hooks.h>
diff --git a/libstdc++-v3/testsuite/21_strings/basic_string/modifiers/assign/char/87749.cc b/libstdc++-v3/testsuite/21_strings/basic_string/modifiers/assign/char/87749.cc
new file mode 100644
index 00000000000..ef5f1e708ac
--- /dev/null
+++ b/libstdc++-v3/testsuite/21_strings/basic_string/modifiers/assign/char/87749.cc
@@ -0,0 +1,78 @@
+// Copyright (C) 2018 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do run { target c++11 } }
+
+// PR libstdc++/87749
+
+#include <string>
+#include <testsuite_hooks.h>
+
+bool oom = false;
+
+template<typename T>
+struct alloc
+{
+  using value_type = T;
+
+#if !_GLIBCXX_USE_CXX11_ABI
+  using size_type = unsigned long;
+  using difference_type = long;
+  using reference = T&;
+  using const_reference = T&;
+  using pointer = T*;
+  using const_pointer = const T*;
+  template<typename U>
+    struct rebind { using other = alloc<U>; };
+#endif
+
+  int not_empty = 0; // this makes is_always_equal false
+
+  alloc() = default;
+  template<typename U>
+    alloc(const alloc<U>&) { }
+
+  T* allocate(unsigned long n)
+  {
+    if (oom)
+      throw std::bad_alloc();
+    return std::allocator<T>().allocate(n);
+  }
+
+  void deallocate(T* p, unsigned long n)
+  {
+    std::allocator<T>().deallocate(p, n);
+  }
+};
+
+template<typename T, typename U>
+bool operator==(const alloc<T>&, const alloc<U>&) { return true; }
+
+template<typename T, typename U>
+bool operator!=(const alloc<T>&, const alloc<U>&) { return false; }
+
+int main()
+{
+  using string = std::basic_string<char, std::char_traits<char>, alloc<char>>;
+
+  string s = "PR libstdc++/87749 a string that is longer than a short string";
+  const auto ptr = s.c_str();
+  oom = true;
+  string ss;
+  ss = std::move(s); // allocators are equal, should not allocate new storage
+  VERIFY( ss.c_str() == ptr );
+}
diff --git a/libstdc++-v3/testsuite/21_strings/basic_string/modifiers/assign/char/move_assign_optim.cc b/libstdc++-v3/testsuite/21_strings/basic_string/modifiers/assign/char/move_assign_optim.cc
new file mode 100644
index 00000000000..b56bc50e1c1
--- /dev/null
+++ b/libstdc++-v3/testsuite/21_strings/basic_string/modifiers/assign/char/move_assign_optim.cc
@@ -0,0 +1,35 @@
+// Copyright (C) 2018 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-O1" }
+// { dg-do compile { target c++11 } }
+// { dg-final { scan-assembler-not "__throw_length_error" } }
+// { dg-final { scan-assembler-not "__throw_bad_alloc" } }
+
+#include <bits/c++config.h>
+#undef _GLIBCXX_EXTERN_TEMPLATE
+#include <string>
+
+void
+test01(std::string& target, std::string&& source)
+{
+  // The move assignment operator should be simple enough that the compiler
+  // can see that it never results in a length_error or bad_alloc exception
+  // (which would be turned into std::terminate by the noexcept on the
+  // assignment operator).
+  target = std::move(source);
+}
diff --git a/libstdc++-v3/testsuite/21_strings/basic_string/modifiers/assign/wchar_t/87749.cc b/libstdc++-v3/testsuite/21_strings/basic_string/modifiers/assign/wchar_t/87749.cc
new file mode 100644
index 00000000000..d4062a9e637
--- /dev/null
+++ b/libstdc++-v3/testsuite/21_strings/basic_string/modifiers/assign/wchar_t/87749.cc
@@ -0,0 +1,79 @@
+// Copyright (C) 2018 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do run { target c++11 } }
+
+// PR libstdc++/87749
+
+#include <string>
+#include <testsuite_hooks.h>
+
+bool oom = false;
+
+template<typename T>
+struct alloc
+{
+  using value_type = T;
+
+#if !_GLIBCXX_USE_CXX11_ABI
+  using size_type = unsigned long;
+  using difference_type = long;
+  using reference = T&;
+  using const_reference = T&;
+  using pointer = T*;
+  using const_pointer = const T*;
+  template<typename U>
+    struct rebind { using other = alloc<U>; };
+#endif
+
+  int not_empty = 0; // this makes is_always_equal false
+
+  alloc() = default;
+  template<typename U>
+    alloc(const alloc<U>&) { }
+
+  T* allocate(unsigned long n)
+  {
+    if (oom)
+      throw std::bad_alloc();
+    return std::allocator<T>().allocate(n);
+  }
+
+  void deallocate(T* p, unsigned long n)
+  {
+    std::allocator<T>().deallocate(p, n);
+  }
+};
+
+template<typename T, typename U>
+bool operator==(const alloc<T>&, const alloc<U>&) { return true; }
+
+template<typename T, typename U>
+bool operator!=(const alloc<T>&, const alloc<U>&) { return false; }
+
+int main()
+{
+  using string
+    = std::basic_string<wchar_t, std::char_traits<wchar_t>, alloc<wchar_t>>;
+
+  string s = L"PR libstdc++/87749 a string that is longer than a short string";
+  const auto ptr = s.c_str();
+  oom = true;
+  string ss;
+  ss = std::move(s); // allocators are equal, should not allocate new storage
+  VERIFY( ss.c_str() == ptr );
+}
diff --git a/libstdc++-v3/testsuite/21_strings/basic_string/modifiers/assign/wchar_t/move_assign_optim.cc b/libstdc++-v3/testsuite/21_strings/basic_string/modifiers/assign/wchar_t/move_assign_optim.cc
new file mode 100644
index 00000000000..f54ad36a5d0
--- /dev/null
+++ b/libstdc++-v3/testsuite/21_strings/basic_string/modifiers/assign/wchar_t/move_assign_optim.cc
@@ -0,0 +1,35 @@
+// Copyright (C) 2018 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-O1" }
+// { dg-do compile { target c++11 } }
+// { dg-final { scan-assembler-not "__throw_length_error" } }
+// { dg-final { scan-assembler-not "__throw_bad_alloc" } }
+
+#include <bits/c++config.h>
+#undef _GLIBCXX_EXTERN_TEMPLATE
+#include <string>
+
+void
+test01(std::wstring& target, std::wstring&& source)
+{
+  // The move assignment operator should be simple enough that the compiler
+  // can see that it never results in a length_error or bad_alloc exception
+  // (which would be turned into std::terminate by the noexcept on the
+  // assignment operator).
+  target = std::move(source);
+}
diff --git a/libstdc++-v3/testsuite/21_strings/basic_string/operations/data/char/86169.cc b/libstdc++-v3/testsuite/21_strings/basic_string/operations/data/char/86169.cc
new file mode 100644
index 00000000000..a8b0ff4aa3f
--- /dev/null
+++ b/libstdc++-v3/testsuite/21_strings/basic_string/operations/data/char/86169.cc
@@ -0,0 +1,37 @@
+// Copyright (C) 2018 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++17" }
+// { dg-do run { target c++1z } }
+
+// PR libstdc++/86169
+
+#ifndef _GLIBCXX_USE_CXX11_ABI
+# define _GLIBCXX_USE_CXX11_ABI 0
+#endif
+
+#include <string>
+#include <testsuite_hooks.h>
+
+int main()
+{
+  const std::string s0{"hello world"};
+  std::string s1 {s0};
+  char* p = s1.data();
+  *p = ' ';
+  VERIFY(s0.compare("hello world") == 0);
+}
diff --git a/libstdc++-v3/testsuite/21_strings/basic_string_view/operators/char/89446.cc b/libstdc++-v3/testsuite/21_strings/basic_string_view/operators/char/89446.cc
new file mode 100644
index 00000000000..75a75614e12
--- /dev/null
+++ b/libstdc++-v3/testsuite/21_strings/basic_string_view/operators/char/89446.cc
@@ -0,0 +1,28 @@
+// Copyright (C) 2019 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++17 -fexceptions -fnon-call-exceptions -O1" }
+// { dg-do run { target { powerpc*-*-linux* i?86-*-linux* x86_64-*-linux* } } }
+// { dg-require-effective-target c++1z }
+
+#include <string_view>
+
+int main()
+{
+  std::string_view s1, s2;
+  return s1 != s2;
+}
diff --git a/libstdc++-v3/testsuite/22_locale/codecvt/codecvt_utf8/69703.cc b/libstdc++-v3/testsuite/22_locale/codecvt/codecvt_utf8/69703.cc
index 99b9dd1beff..c6c3257ba75 100644
--- a/libstdc++-v3/testsuite/22_locale/codecvt/codecvt_utf8/69703.cc
+++ b/libstdc++-v3/testsuite/22_locale/codecvt/codecvt_utf8/69703.cc
@@ -68,7 +68,6 @@ test03()
   VERIFY( in[2] == U'c' );
 }
 
-
 void
 test04()
 {
@@ -90,6 +89,6 @@ main()
 {
   test01();
   test02();
-  test01();
-  test02();
+  test03();
+  test04();
 }
diff --git a/libstdc++-v3/testsuite/22_locale/codecvt/codecvt_utf8/wchar_t/1.cc b/libstdc++-v3/testsuite/22_locale/codecvt/codecvt_utf8/wchar_t/1.cc
new file mode 100644
index 00000000000..c44f91f357e
--- /dev/null
+++ b/libstdc++-v3/testsuite/22_locale/codecvt/codecvt_utf8/wchar_t/1.cc
@@ -0,0 +1,52 @@
+// Copyright (C) 2018 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do run { target c++11 } }
+
+#include <string>
+#include <codecvt>
+#include <testsuite_hooks.h>
+
+void
+test01()
+{
+  const char out[] = u8"\u00A33.50";
+  wchar_t in[8] = {};
+  std::codecvt_utf8<wchar_t> cvt;
+  std::mbstate_t st;
+  const char* no;
+  wchar_t* ni;
+  auto res = cvt.in(st, out, out+6, no, in, in+8, ni);
+  VERIFY( res == std::codecvt_base::ok );
+  VERIFY( in[1] == L'3' );
+  VERIFY( in[2] == L'.' );
+  VERIFY( in[3] == L'5' );
+  VERIFY( in[4] == L'0' );
+
+  char out2[8] = {};
+  char* no2;
+  const wchar_t* ni2;
+  res = cvt.out(st, in, ni, ni2, out2, out2+8, no2);
+  VERIFY( res == std::codecvt_base::ok );
+  VERIFY( out2 == std::string(out) );
+}
+
+int
+main()
+{
+  test01();
+}
diff --git a/libstdc++-v3/testsuite/22_locale/numpunct/members/char/3.cc b/libstdc++-v3/testsuite/22_locale/numpunct/members/char/3.cc
index fd75463d9a8..a5dc98804db 100644
--- a/libstdc++-v3/testsuite/22_locale/numpunct/members/char/3.cc
+++ b/libstdc++-v3/testsuite/22_locale/numpunct/members/char/3.cc
@@ -1,4 +1,4 @@
-// { dg-require-namedlocale "it_IT.ISO8859-15" }
+// { dg-require-namedlocale "nl_NL.ISO8859-15" }
 
 // 2001-01-24 Benjamin Kosnik  <bkoz@redhat.com>
 
@@ -28,12 +28,14 @@ void test02()
 {
   using namespace std;
 
-  locale loc_it = locale(ISO_8859(15,it_IT));
+  // nl_NL chosen because it has no thousands separator (at this time).
+  locale loc_it = locale(ISO_8859(15,nl_NL));
 
   const numpunct<char>& nump_it = use_facet<numpunct<char> >(loc_it); 
 
   string g = nump_it.grouping();
 
+  // Ensure that grouping is empty for locales with empty thousands separator.
   VERIFY( g == "" );
 }
 
diff --git a/libstdc++-v3/testsuite/23_containers/forward_list/comparable.cc b/libstdc++-v3/testsuite/23_containers/forward_list/comparable.cc
index f81481aa9c5..dc2a76c85c4 100644
--- a/libstdc++-v3/testsuite/23_containers/forward_list/comparable.cc
+++ b/libstdc++-v3/testsuite/23_containers/forward_list/comparable.cc
@@ -17,15 +17,11 @@
 // with this library; see the file COPYING3.  If not see
 // <http://www.gnu.org/licenses/>.
 
-
-// NOTE: This makes use of the fact that we know how moveable
-// is implemented on list (via swap). If the implementation changed
-// this test may begin to fail.
-
 #include <forward_list>
 #include <testsuite_hooks.h>
 
-int main()
+void
+test01()
 {
   std::forward_list<double> a = {0.0, 1.0, 2.0, 3.0, 4.0};
   std::forward_list<double> b = {0.0, 1.0, 2.0, 3.0, 4.0, 5.0};
@@ -43,6 +39,40 @@ int main()
   VERIFY((b >  a) == true);
   VERIFY((b >= a) == true);
   VERIFY((b <= a) == false);
+}
+
+void
+test02()
+{
+  // The EqualityComparable requirements only require ==
+  struct X {
+    bool operator==(const X&) const { return true; }
+  };
+
+  std::forward_list<X> a(2);
+  const auto b = a;
+  VERIFY( a == b );
+}
+
+void
+test03()
+{
+  // The LessThanComparable requirements only require <
+  struct X {
+    bool operator<(const X&) const { return false; }
+  };
 
-  return 0;
+  std::forward_list<X> a(2);
+  const auto b = a;
+  VERIFY( !(a < b) );
+  VERIFY( !(a > b) );
+  VERIFY( a <= b );
+  VERIFY( a >= b );
+}
+
+int main()
+{
+  test01();
+  test02();
+  test03();
 }
diff --git a/libstdc++-v3/testsuite/23_containers/forward_list/operations/90105.cc b/libstdc++-v3/testsuite/23_containers/forward_list/operations/90105.cc
new file mode 100644
index 00000000000..3c1478e2e34
--- /dev/null
+++ b/libstdc++-v3/testsuite/23_containers/forward_list/operations/90105.cc
@@ -0,0 +1,60 @@
+// Copyright (C) 2019 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do run { target c++11 } }
+
+#include <forward_list>
+#include <testsuite_hooks.h>
+
+// PR libstdc++/90105 - std::forward_list::sort() is not "stable"
+
+struct X
+{
+  int key;
+  int val;
+};
+
+bool operator<(const X& l, const X& r)
+{ return l.key < r.key; }
+
+bool operator==(const X& l, const X& r)
+{ return l.key == r.key && l.val == r.val; }
+
+void
+test01()
+{
+  std::forward_list<X> l{ {1, 1}, {2, 2}, {1, 3}, {0, 4}, {2, 5}, {0, 6} };
+  l.sort();
+  std::forward_list<X> exp{ {0, 4}, {0, 6}, {1, 1}, {1, 3}, {2, 2}, {2, 5} };
+  VERIFY( l == exp );
+}
+
+void
+test02()
+{
+  std::forward_list<X> l{ {1, 1}, {1, 2}, {1, 3}, {1, 4}, {1, 5}, {1, 6} };
+  const std::forward_list<X> exp = l;
+  l.sort();
+  VERIFY( l == exp );
+}
+
+int
+main()
+{
+  test01();
+  test02();
+}
diff --git a/libstdc++-v3/testsuite/23_containers/map/modifiers/insert/78595.cc b/libstdc++-v3/testsuite/23_containers/map/modifiers/insert/78595.cc
new file mode 100644
index 00000000000..187d165b083
--- /dev/null
+++ b/libstdc++-v3/testsuite/23_containers/map/modifiers/insert/78595.cc
@@ -0,0 +1,115 @@
+// Copyright (C) 2018 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do run { target c++11 } }
+
+#include <map>
+#include <testsuite_hooks.h>
+
+void
+test01()
+{
+  struct X {
+    mutable int conversions = 0;
+
+    operator std::pair<const int, int>() const {
+      if (++conversions > 1)
+	throw 1;
+      return {};
+    }
+  };
+
+  std::map<int, int> m;
+  m.insert(X());
+  VERIFY( m.size() == 1 );
+  m.insert(m.begin(), X());
+  VERIFY( m.size() == 1 );
+
+}
+void
+test02()
+{
+  struct Y {
+    int conversions = 0;
+
+    operator std::pair<const int, int>() && {
+      if (++conversions > 1)
+	throw 1;
+      return {};
+    }
+  };
+
+  std::map<int, int> m;
+  m.insert(Y());
+  VERIFY( m.size() == 1 );
+  m.insert(m.begin(), Y());
+  VERIFY( m.size() == 1 );
+}
+
+struct Key {
+  int key;
+  bool operator<(const Key& r) const { return key < r.key; }
+};
+
+struct Z {
+  operator std::pair<const Key, int>() const { return { { z }, 0 }; }
+  int z;
+};
+
+template<typename T>
+struct Alloc
+{
+  Alloc() = default;
+
+  template<typename U>
+    Alloc(const Alloc<U>&) { }
+
+  using value_type = T;
+
+  T* allocate(std::size_t n) { return std::allocator<T>().allocate(n); }
+
+  void deallocate(T* p, std::size_t n) { std::allocator<T>().deallocate(p, n); }
+
+  template<typename U>
+    void construct(U* p, const Z& z) { ::new (p) U{ { z.z+1 }, 0}; }
+
+  template<typename U>
+    bool operator==(const Alloc<U>&) { return true; }
+
+  template<typename U>
+    bool operator!=(const Alloc<U>&) { return false; }
+};
+
+void
+test03()
+{
+  std::map<Key, int, std::less<Key>, Alloc<std::pair<const Key, int>>> m;
+  m.insert(Z{});
+  m.insert(Z{});
+  VERIFY( m.size() == 1 );
+  m.insert(Z{});
+  m.insert(Z{1});
+  VERIFY( m.size() == 2 );
+}
+
+int
+main()
+{
+  test01();
+  test02();
+  test03();
+}
diff --git a/libstdc++-v3/testsuite/23_containers/multimap/modifiers/insert/78595.cc b/libstdc++-v3/testsuite/23_containers/multimap/modifiers/insert/78595.cc
new file mode 100644
index 00000000000..2f357fcae95
--- /dev/null
+++ b/libstdc++-v3/testsuite/23_containers/multimap/modifiers/insert/78595.cc
@@ -0,0 +1,115 @@
+// Copyright (C) 2018 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do run { target c++11 } }
+
+#include <map>
+#include <testsuite_hooks.h>
+
+void
+test01()
+{
+  struct X {
+    mutable int conversions = 0;
+
+    operator std::pair<const int, int>() const {
+      if (++conversions > 1)
+	throw 1;
+      return {};
+    }
+  };
+
+  std::multimap<int, int> m;
+  m.insert(X());
+  VERIFY( m.size() == 1 );
+  m.insert(m.begin(), X());
+  VERIFY( m.size() == 2 );
+
+}
+void
+test02()
+{
+  struct Y {
+    int conversions = 0;
+
+    operator std::pair<const int, int>() && {
+      if (++conversions > 1)
+	throw 1;
+      return {};
+    }
+  };
+
+  std::multimap<int, int> m;
+  m.insert(Y());
+  VERIFY( m.size() == 1 );
+  m.insert(m.begin(), Y());
+  VERIFY( m.size() == 2 );
+}
+
+struct Key {
+  int key;
+  bool operator<(const Key& r) const { return key < r.key; }
+};
+
+struct Z {
+  operator std::pair<const Key, int>() const { return { { z }, 0 }; }
+  int z;
+};
+
+template<typename T>
+struct Alloc
+{
+  Alloc() = default;
+
+  template<typename U>
+    Alloc(const Alloc<U>&) { }
+
+  using value_type = T;
+
+  T* allocate(std::size_t n) { return std::allocator<T>().allocate(n); }
+
+  void deallocate(T* p, std::size_t n) { std::allocator<T>().deallocate(p, n); }
+
+  template<typename U>
+    void construct(U* p, const Z& z) { ::new (p) U{ { z.z+1 }, 0}; }
+
+  template<typename U>
+    bool operator==(const Alloc<U>&) { return true; }
+
+  template<typename U>
+    bool operator!=(const Alloc<U>&) { return false; }
+};
+
+void
+test03()
+{
+  std::multimap<Key, int, std::less<Key>, Alloc<std::pair<const Key, int>>> m;
+  m.insert(Z{});
+  m.insert(Z{});
+  VERIFY( m.size() == 2 );
+  m.insert(Z{});
+  m.insert(Z{1});
+  VERIFY( m.size() == 4 );
+}
+
+int
+main()
+{
+  test01();
+  test02();
+  test03();
+}
diff --git a/libstdc++-v3/testsuite/23_containers/set/modifiers/node_swap.cc b/libstdc++-v3/testsuite/23_containers/set/modifiers/node_swap.cc
new file mode 100644
index 00000000000..32c7d496428
--- /dev/null
+++ b/libstdc++-v3/testsuite/23_containers/set/modifiers/node_swap.cc
@@ -0,0 +1,48 @@
+// Copyright (C) 2018 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++17" }
+// { dg-do run { target c++1z } }
+
+#include <set>
+#include <testsuite_hooks.h>
+
+void
+test01()
+{
+  // PR libstdc++/82966
+  std::set<int>::node_type n1, n2;
+  n1.swap(n2);
+  VERIFY( n1.empty() );
+  VERIFY( n2.empty() );
+}
+
+void
+test02()
+{
+  std::set<int> s{1, 2};
+  std::set<int>::node_type n1 = s.extract(1), n2;
+  swap(n1, n2);
+  VERIFY( n1.empty() );
+  VERIFY( !n2.empty() );
+}
+
+int main()
+{
+  test01();
+  test02();
+}
diff --git a/libstdc++-v3/testsuite/23_containers/unordered_map/modifiers/78595.cc b/libstdc++-v3/testsuite/23_containers/unordered_map/modifiers/78595.cc
new file mode 100644
index 00000000000..47cd67b86d8
--- /dev/null
+++ b/libstdc++-v3/testsuite/23_containers/unordered_map/modifiers/78595.cc
@@ -0,0 +1,122 @@
+// Copyright (C) 2018 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do run { target c++11 } }
+
+#include <unordered_map>
+#include <testsuite_hooks.h>
+
+void
+test01()
+{
+  struct X {
+    mutable int conversions = 0;
+
+    operator std::pair<const int, int>() const {
+      if (++conversions > 1)
+	throw 1;
+      return {};
+    }
+  };
+
+  std::unordered_map<int, int> m;
+  m.insert(X());
+  VERIFY( m.size() == 1 );
+  m.insert(m.begin(), X());
+  VERIFY( m.size() == 1 );
+
+}
+void
+test02()
+{
+  struct Y {
+    int conversions = 0;
+
+    operator std::pair<const int, int>() && {
+      if (++conversions > 1)
+	throw 1;
+      return {};
+    }
+  };
+
+  std::unordered_map<int, int> m;
+  m.insert(Y());
+  VERIFY( m.size() == 1 );
+  m.insert(m.begin(), Y());
+  VERIFY( m.size() == 1 );
+}
+
+struct Key {
+  int key;
+  bool operator==(const Key& r) const { return key == r.key; }
+};
+
+namespace std {
+  template<> struct hash<Key> {
+    size_t operator()(const Key& k) const { return std::hash<int>()(k.key); }
+  };
+}
+
+struct Z {
+  operator std::pair<const Key, int>() const { return { { z }, 0 }; }
+  int z;
+};
+
+template<typename T>
+struct Alloc
+{
+  Alloc() = default;
+
+  template<typename U>
+    Alloc(const Alloc<U>&) { }
+
+  using value_type = T;
+
+  T* allocate(std::size_t n) { return std::allocator<T>().allocate(n); }
+
+  void deallocate(T* p, std::size_t n) { std::allocator<T>().deallocate(p, n); }
+
+  template<typename U>
+    void construct(U* p, const Z& z) { ::new (p) U{ { z.z+1 }, 0}; }
+
+  template<typename U>
+    bool operator==(const Alloc<U>&) { return true; }
+
+  template<typename U>
+    bool operator!=(const Alloc<U>&) { return false; }
+};
+
+void
+test03()
+{
+  std::unordered_map<Key, int, std::hash<Key>, std::equal_to<Key>,
+		     Alloc<std::pair<const Key, int>>> m;
+  m.insert(Z{});
+  m.insert(Z{});
+  VERIFY( m.size() == 1 );
+  m.insert(Z{});
+  m.insert(Z{1});
+  VERIFY( m.size() == 2 );
+}
+
+int
+main()
+{
+  test01();
+  test02();
+  test03();
+}
diff --git a/libstdc++-v3/testsuite/23_containers/unordered_multimap/modifiers/78595.cc b/libstdc++-v3/testsuite/23_containers/unordered_multimap/modifiers/78595.cc
new file mode 100644
index 00000000000..e47c20cad81
--- /dev/null
+++ b/libstdc++-v3/testsuite/23_containers/unordered_multimap/modifiers/78595.cc
@@ -0,0 +1,122 @@
+// Copyright (C) 2018 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do run { target c++11 } }
+
+#include <unordered_map>
+#include <testsuite_hooks.h>
+
+void
+test01()
+{
+  struct X {
+    mutable int conversions = 0;
+
+    operator std::pair<const int, int>() const {
+      if (++conversions > 1)
+	throw 1;
+      return {};
+    }
+  };
+
+  std::unordered_multimap<int, int> m;
+  m.insert(X());
+  VERIFY( m.size() == 1 );
+  m.insert(m.begin(), X());
+  VERIFY( m.size() == 2 );
+
+}
+void
+test02()
+{
+  struct Y {
+    int conversions = 0;
+
+    operator std::pair<const int, int>() && {
+      if (++conversions > 1)
+	throw 1;
+      return {};
+    }
+  };
+
+  std::unordered_multimap<int, int> m;
+  m.insert(Y());
+  VERIFY( m.size() == 1 );
+  m.insert(m.begin(), Y());
+  VERIFY( m.size() == 2 );
+}
+
+struct Key {
+  int key;
+  bool operator==(const Key& r) const { return key == r.key; }
+};
+
+namespace std {
+  template<> struct hash<Key> {
+    size_t operator()(const Key& k) const { return std::hash<int>()(k.key); }
+  };
+}
+
+struct Z {
+  operator std::pair<const Key, int>() const { return { { z }, 0 }; }
+  int z;
+};
+
+template<typename T>
+struct Alloc
+{
+  Alloc() = default;
+
+  template<typename U>
+    Alloc(const Alloc<U>&) { }
+
+  using value_type = T;
+
+  T* allocate(std::size_t n) { return std::allocator<T>().allocate(n); }
+
+  void deallocate(T* p, std::size_t n) { std::allocator<T>().deallocate(p, n); }
+
+  template<typename U>
+    void construct(U* p, const Z& z) { ::new (p) U{ { z.z+1 }, 0}; }
+
+  template<typename U>
+    bool operator==(const Alloc<U>&) { return true; }
+
+  template<typename U>
+    bool operator!=(const Alloc<U>&) { return false; }
+};
+
+void
+test03()
+{
+  std::unordered_multimap<Key, int, std::hash<Key>, std::equal_to<Key>,
+			  Alloc<std::pair<const Key, int>>> m;
+  m.insert(Z{});
+  m.insert(Z{});
+  VERIFY( m.size() == 2 );
+  m.insert(Z{});
+  m.insert(Z{1});
+  VERIFY( m.size() == 4 );
+}
+
+int
+main()
+{
+  test01();
+  test02();
+  test03();
+}
diff --git a/libstdc++-v3/testsuite/23_containers/unordered_set/allocator/move_assign.cc b/libstdc++-v3/testsuite/23_containers/unordered_set/allocator/move_assign.cc
index 01d4dd6c0a1..75006fadd5b 100644
--- a/libstdc++-v3/testsuite/23_containers/unordered_set/allocator/move_assign.cc
+++ b/libstdc++-v3/testsuite/23_containers/unordered_set/allocator/move_assign.cc
@@ -18,71 +18,133 @@
 // { dg-do run { target c++11 } }
 
 #include <unordered_set>
+
 #include <testsuite_hooks.h>
 #include <testsuite_allocator.h>
 #include <testsuite_counter_type.h>
 
 using __gnu_test::propagating_allocator;
 using __gnu_test::counter_type;
+using __gnu_test::tracker_allocator;
+using __gnu_test::tracker_allocator_counter;
 
 void test01()
 {
-  typedef propagating_allocator<counter_type, false> alloc_type;
-  typedef __gnu_test::counter_type_hasher hash;
-  typedef std::unordered_set<counter_type, hash,
-			     std::equal_to<counter_type>,
-			     alloc_type> test_type;
+  tracker_allocator_counter::reset();
+  {
+    typedef propagating_allocator<counter_type, false,
+				  tracker_allocator<counter_type>> alloc_type;
+    typedef __gnu_test::counter_type_hasher hash;
+    typedef std::unordered_set<counter_type, hash,
+			       std::equal_to<counter_type>,
+			       alloc_type> test_type;
+
+    test_type v1(alloc_type(1));
+    v1.emplace(0);
 
-  test_type v1(alloc_type(1));
-  v1.emplace(0);
+    test_type v2(alloc_type(2));
+    v2.emplace(1);
 
-  test_type v2(alloc_type(2));
-  v2.emplace(1);
+    counter_type::reset();
 
-  counter_type::reset();
+    v2 = std::move(v1);
 
-  v2 = std::move(v1);
+    VERIFY( 1 == v1.get_allocator().get_personality() );
+    VERIFY( 2 == v2.get_allocator().get_personality() );
 
-  VERIFY( 1 == v1.get_allocator().get_personality() );
-  VERIFY( 2 == v2.get_allocator().get_personality() );
+    VERIFY( counter_type::move_count == 1  );
+    VERIFY( counter_type::destructor_count == 2 );
+  }
 
-  VERIFY( counter_type::move_count == 1  );
-  VERIFY( counter_type::destructor_count == 2 );
+  // Check there's nothing left allocated or constructed.
+  VERIFY( tracker_allocator_counter::get_construct_count()
+	  == tracker_allocator_counter::get_destruct_count() );
+  VERIFY( tracker_allocator_counter::get_allocation_count()
+	  == tracker_allocator_counter::get_deallocation_count() );
 }
 
 void test02()
 {
-  typedef propagating_allocator<counter_type, true> alloc_type;
-  typedef __gnu_test::counter_type_hasher hash;
-  typedef std::unordered_set<counter_type, hash,
-			     std::equal_to<counter_type>,
-			     alloc_type> test_type;
+  tracker_allocator_counter::reset();
+  {
+    typedef propagating_allocator<counter_type, true,
+				  tracker_allocator<counter_type>> alloc_type;
+    typedef __gnu_test::counter_type_hasher hash;
+    typedef std::unordered_set<counter_type, hash,
+			       std::equal_to<counter_type>,
+			       alloc_type> test_type;
+
+    test_type v1(alloc_type(1));
+    v1.emplace(0);
 
-  test_type v1(alloc_type(1));
-  v1.emplace(0);
+    auto it = v1.begin();
 
-  auto it = v1.begin();
+    test_type v2(alloc_type(2));
+    v2.emplace(0);
 
-  test_type v2(alloc_type(2));
-  v2.emplace(0);
+    counter_type::reset();
 
-  counter_type::reset();
+    v2 = std::move(v1);
 
-  v2 = std::move(v1);
+    VERIFY(0 == v1.get_allocator().get_personality());
+    VERIFY(1 == v2.get_allocator().get_personality());
 
-  VERIFY(0 == v1.get_allocator().get_personality());
-  VERIFY(1 == v2.get_allocator().get_personality());
+    VERIFY( counter_type::move_count == 0 );
+    VERIFY( counter_type::copy_count == 0 );
+    VERIFY( counter_type::destructor_count == 1 );
 
-  VERIFY( counter_type::move_count == 0 );
-  VERIFY( counter_type::copy_count == 0 );
-  VERIFY( counter_type::destructor_count == 1 );
+    VERIFY( it == v2.begin() );
+  }
 
-  VERIFY( it == v2.begin() );
+  // Check there's nothing left allocated or constructed.
+  VERIFY( tracker_allocator_counter::get_construct_count()
+	  == tracker_allocator_counter::get_destruct_count() );
+  VERIFY( tracker_allocator_counter::get_allocation_count()
+	  == tracker_allocator_counter::get_deallocation_count() );
+}
+
+void test03()
+{
+  tracker_allocator_counter::reset();
+  {
+    typedef propagating_allocator<counter_type, false,
+				  tracker_allocator<counter_type>> alloc_type;
+    typedef __gnu_test::counter_type_hasher hash;
+    typedef std::unordered_set<counter_type, hash,
+			       std::equal_to<counter_type>,
+			       alloc_type> test_type;
+
+    test_type v1(alloc_type(1));
+    v1.emplace(0);
+
+    test_type v2(alloc_type(2));
+    int i = 0;
+    v2.emplace(i++);
+    for (; v2.bucket_count() == v1.bucket_count(); ++i)
+      v2.emplace(i);
+
+    counter_type::reset();
+
+    v2 = std::move(v1);
+
+    VERIFY( 1 == v1.get_allocator().get_personality() );
+    VERIFY( 2 == v2.get_allocator().get_personality() );
+
+    VERIFY( counter_type::move_count == 1  );
+    VERIFY( counter_type::destructor_count == i + 1 );
+  }
+
+  // Check there's nothing left allocated or constructed.
+  VERIFY( tracker_allocator_counter::get_construct_count()
+	  == tracker_allocator_counter::get_destruct_count() );
+  VERIFY( tracker_allocator_counter::get_allocation_count()
+	  == tracker_allocator_counter::get_deallocation_count() );
 }
 
 int main()
 {
   test01();
   test02();
+  test03();
   return 0;
 }
diff --git a/libstdc++-v3/testsuite/23_containers/vector/bool/80893.cc b/libstdc++-v3/testsuite/23_containers/vector/bool/80893.cc
new file mode 100644
index 00000000000..0b0016c9790
--- /dev/null
+++ b/libstdc++-v3/testsuite/23_containers/vector/bool/80893.cc
@@ -0,0 +1,76 @@
+// Copyright (C) 2017 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do run { target c++11 } }
+
+// libstdc++/80893
+
+#include <vector>
+#include <testsuite_allocator.h>
+
+struct DereferencedInvalidPointer { };
+
+// User-defined pointer type that throws if a null pointer is dereferenced.
+template<typename T>
+struct Pointer : __gnu_test::PointerBase<Pointer<T>, T>
+{
+  using __gnu_test::PointerBase<Pointer<T>, T>::PointerBase;
+
+  T& operator*() const
+  {
+    if (!this->value)
+      throw DereferencedInvalidPointer();
+    return *this->value;
+  }
+};
+
+// Minimal allocator using Pointer<T>
+template<typename T>
+struct Alloc
+{
+  typedef T value_type;
+  typedef Pointer<T> pointer;
+
+  Alloc() = default;
+  template<typename U>
+    Alloc(const Alloc<U>&) { }
+
+  pointer allocate(std::size_t n)
+  {
+    if (n)
+      return pointer(std::allocator<T>().allocate(n));
+    return nullptr;
+  }
+
+  void deallocate(pointer p, std::size_t n)
+  {
+    if (n)
+      std::allocator<T>().deallocate(p.value, n);
+  }
+};
+
+template<typename T>
+bool operator==(Alloc<T>, Alloc<T>) { return true; }
+
+template<typename T>
+bool operator!=(Alloc<T>, Alloc<T>) { return false; }
+
+int main()
+{
+  std::vector<bool, Alloc<bool>> v(0);
+  std::vector<bool, Alloc<bool>> w(v);
+}
diff --git a/libstdc++-v3/testsuite/23_containers/vector/capacity/resize/strong_guarantee.cc b/libstdc++-v3/testsuite/23_containers/vector/capacity/resize/strong_guarantee.cc
new file mode 100644
index 00000000000..b209d76867a
--- /dev/null
+++ b/libstdc++-v3/testsuite/23_containers/vector/capacity/resize/strong_guarantee.cc
@@ -0,0 +1,60 @@
+// Copyright (C) 2018 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+#include <vector>
+#include <testsuite_hooks.h>
+
+struct X
+{
+  X() : data(1)
+  {
+    if (fail)
+      throw 1;
+  }
+
+  static bool fail;
+
+  std::vector<int> data;
+};
+
+bool X::fail = false;
+
+void
+test01()
+{
+  std::vector<X> v(2);
+  X* const addr = &v[0];
+  bool caught = false;
+  try {
+    X::fail = true;
+    v.resize(v.capacity() + 1); // force reallocation
+  } catch (int) {
+    caught = true;
+  }
+  VERIFY( caught );
+  VERIFY( v.size() == 2 );
+  VERIFY( &v[0] == addr );
+  // PR libstdc++/83982
+  VERIFY( ! v[0].data.empty() );
+  VERIFY( ! v[1].data.empty() );
+}
+
+int
+main()
+{
+  test01();
+}
diff --git a/libstdc++-v3/testsuite/23_containers/vector/cons/86292.cc b/libstdc++-v3/testsuite/23_containers/vector/cons/86292.cc
new file mode 100644
index 00000000000..7103efb82ff
--- /dev/null
+++ b/libstdc++-v3/testsuite/23_containers/vector/cons/86292.cc
@@ -0,0 +1,64 @@
+// Copyright (C) 2018 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do run }
+
+#include <vector>
+#include <testsuite_hooks.h>
+#include <testsuite_iterators.h>
+
+struct X
+{
+  X() { ++count; }
+  X(const X&) { if (++copies >= max_copies) throw 1; ++count; }
+  ~X() { --count; }
+
+  static int count;
+  static int copies;
+  static int max_copies;
+};
+
+int X::count = 0;
+int X::copies = 0;
+int X::max_copies = 0;
+
+void
+test01()
+{
+  X x[3];
+  const int count = X::count;
+  X::max_copies = 2;
+  __gnu_test::test_container<const X, __gnu_test::input_iterator_wrapper>
+    x_input(x, x+3);
+  bool caught = false;
+  try
+  {
+    std::vector<X> v(x_input.begin(), x_input.end());
+  }
+  catch(int)
+  {
+    caught = true;
+  }
+  VERIFY( caught );
+  VERIFY( X::count == count );
+}
+
+int
+main()
+{
+  test01();
+}
diff --git a/libstdc++-v3/testsuite/24_iterators/reverse_iterator/dr2188.cc b/libstdc++-v3/testsuite/24_iterators/reverse_iterator/dr2188.cc
new file mode 100644
index 00000000000..047334ddf24
--- /dev/null
+++ b/libstdc++-v3/testsuite/24_iterators/reverse_iterator/dr2188.cc
@@ -0,0 +1,47 @@
+// Copyright (C) 2018 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do run { target c++11 } }
+
+// PR libstdc++/86734
+
+#include <iterator>
+#include <testsuite_hooks.h>
+
+void
+test01()
+{
+  // LWG DR 2188
+  // Reverse iterator does not fully support targets that overload operator&
+  struct X {
+    int val;
+    int* operator&() { return &val; }
+    const int* operator&() const { return &val; }
+  };
+
+  X x[2] = { {1}, {2} };
+  std::reverse_iterator<X*> rev(x+2);
+  VERIFY( rev->val == 2 );
+  ++rev;
+  VERIFY( rev->val == 1 );
+}
+
+int
+main()
+{
+  test01();
+}
diff --git a/libstdc++-v3/testsuite/26_numerics/random/chi_squared_distribution/83833.cc b/libstdc++-v3/testsuite/26_numerics/random/chi_squared_distribution/83833.cc
new file mode 100644
index 00000000000..821a1a40e2a
--- /dev/null
+++ b/libstdc++-v3/testsuite/26_numerics/random/chi_squared_distribution/83833.cc
@@ -0,0 +1,40 @@
+// Copyright (C) 2018 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do run { target c++11 } }
+// { dg-additional-options "-ffloat-store" { target { m68*-*-* || ia32 } } }
+
+#include <random>
+#include <testsuite_hooks.h>
+
+void
+test01()
+{
+  std::default_random_engine r1, r2;
+  using chi = std::chi_squared_distribution<double>;
+  chi::param_type p(5);
+  chi d1(p);
+  chi d2;
+  d2.param(p);
+  VERIFY( d1(r1) == d2(r2) ); // PR libstdc++/83833
+}
+
+int
+main()
+{
+  test01();
+}
diff --git a/libstdc++-v3/testsuite/26_numerics/valarray/87641.cc b/libstdc++-v3/testsuite/26_numerics/valarray/87641.cc
new file mode 100644
index 00000000000..eae5440e60b
--- /dev/null
+++ b/libstdc++-v3/testsuite/26_numerics/valarray/87641.cc
@@ -0,0 +1,75 @@
+// Copyright (C) 2018 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+#include <valarray>
+#include <testsuite_hooks.h>
+
+void
+test01()
+{
+  // PR libstdc++/87641
+  std::valarray<int> v1(3);
+  v1[0] = 1;
+  v1[1] = 2;
+  v1[2] = 3;
+  std::valarray< std::valarray<int> > v2(v1, 3);
+  std::valarray<int> v3 = v2.sum();
+  VERIFY( v3.size() == v1.size() );
+  VERIFY( v3[0] == 3 );
+  VERIFY( v3[1] == 6 );
+  VERIFY( v3[2] == 9 );
+}
+
+struct X
+{
+  X() : val(1) { }
+
+  X& operator+=(const X& x) { val += x.val; return *this; }
+  bool operator==(const X& x) { return val == x.val; }
+
+  int val;
+};
+
+void
+test02()
+{
+  std::valarray<X> v1(1);
+  VERIFY( v1.sum() == v1[0] );
+
+  std::valarray<X> v2(2);
+  VERIFY( v2.sum().val == 2 );
+}
+
+struct Y
+{
+  X& operator+=(const Y&) { throw 1; }
+};
+
+void
+test03()
+{
+  std::valarray<Y> v1(1);
+  (void) v1.sum(); // no addition performed for a single element
+}
+
+int
+main()
+{
+  test01();
+  test02();
+  test03();
+}
diff --git a/libstdc++-v3/testsuite/27_io/basic_ios/copyfmt/char/1.cc b/libstdc++-v3/testsuite/27_io/basic_ios/copyfmt/char/1.cc
index 840017e4e85..aa05679ddbe 100644
--- a/libstdc++-v3/testsuite/27_io/basic_ios/copyfmt/char/1.cc
+++ b/libstdc++-v3/testsuite/27_io/basic_ios/copyfmt/char/1.cc
@@ -46,13 +46,6 @@ void test02()
   }
 
   {
-    // The library throws the new definition of std::ios::failure
-#if _GLIBCXX_USE_CXX11_ABI
-    typedef std::ios_base::failure exception_type;
-#else
-    typedef std::exception exception_type;
-#endif
-
     std::ios ios_01(0);
     std::ios ios_02(0);
     ios_01.clear(std::ios_base::eofbit);
@@ -62,7 +55,7 @@ void test02()
       ios_01.copyfmt(ios_02);
       VERIFY( false );
     }
-    catch(exception_type&) {
+    catch(std::ios_base::failure&) {
       VERIFY( true );
     }
     catch(...) {
diff --git a/libstdc++-v3/testsuite/27_io/basic_ios/exceptions/char/1.cc b/libstdc++-v3/testsuite/27_io/basic_ios/exceptions/char/1.cc
index 152e783640a..89342d9ffe3 100644
--- a/libstdc++-v3/testsuite/27_io/basic_ios/exceptions/char/1.cc
+++ b/libstdc++-v3/testsuite/27_io/basic_ios/exceptions/char/1.cc
@@ -50,20 +50,13 @@ void test01()
   }
 
   {
-    // The library throws the new definition of std::ios::failure
-#if _GLIBCXX_USE_CXX11_ABI
-    typedef std::ios_base::failure exception_type;
-#else
-    typedef std::exception exception_type;
-#endif
-
     std::ios ios_01(0);
     ios_01.clear(std::ios_base::eofbit);
     try {
       ios_01.exceptions(std::ios_base::eofbit);
       VERIFY( false );
     }
-    catch(exception_type&) {
+    catch(std::ios_base::failure&) {
       iostate02 = ios_01.exceptions();
       VERIFY( static_cast<bool>(iostate02 & std::ios_base::eofbit) );
     }
diff --git a/libstdc++-v3/testsuite/27_io/basic_istream/extractors_arithmetic/char/exceptions_failbit.cc b/libstdc++-v3/testsuite/27_io/basic_istream/extractors_arithmetic/char/exceptions_failbit.cc
index 5fa3f1f34a0..b4dde2047f6 100644
--- a/libstdc++-v3/testsuite/27_io/basic_istream/extractors_arithmetic/char/exceptions_failbit.cc
+++ b/libstdc++-v3/testsuite/27_io/basic_istream/extractors_arithmetic/char/exceptions_failbit.cc
@@ -27,20 +27,13 @@ void test_failbit()
   istringstream stream("jaylib - champion sound");
   stream.exceptions(ios_base::failbit);
 
-  // The library throws the new definition of std::ios::failure
-#if _GLIBCXX_USE_CXX11_ABI
-    typedef std::ios_base::failure exception_type;
-#else
-    typedef std::exception exception_type;
-#endif
-
   try
     {
       T i;
       stream >> i;
       VERIFY( false );
     }
-  catch (const exception_type&)
+  catch (const std::ios_base::failure&)
     {
       // stream should set failbit and throw ios_base::failure.
       VERIFY( stream.fail() );
diff --git a/libstdc++-v3/testsuite/27_io/basic_istream/extractors_arithmetic/wchar_t/exceptions_failbit.cc b/libstdc++-v3/testsuite/27_io/basic_istream/extractors_arithmetic/wchar_t/exceptions_failbit.cc
index 4ff48f73712..41d2f1fc24a 100644
--- a/libstdc++-v3/testsuite/27_io/basic_istream/extractors_arithmetic/wchar_t/exceptions_failbit.cc
+++ b/libstdc++-v3/testsuite/27_io/basic_istream/extractors_arithmetic/wchar_t/exceptions_failbit.cc
@@ -27,20 +27,13 @@ void test_failbit()
   wistringstream stream(L"jaylib - champion sound");
   stream.exceptions(ios_base::failbit);
 
-  // The library throws the new definition of std::ios::failure
-#if _GLIBCXX_USE_CXX11_ABI
-    typedef std::ios_base::failure exception_type;
-#else
-    typedef std::exception exception_type;
-#endif
-
   try
     {
       T i;
       stream >> i;
       VERIFY( false );
     }
-  catch (const exception_type&)
+  catch (const std::ios_base::failure&)
     {
       // stream should set failbit and throw ios_base::failure.
       VERIFY( stream.fail() );
diff --git a/libstdc++-v3/testsuite/27_io/basic_istream/extractors_other/char/exceptions_null.cc b/libstdc++-v3/testsuite/27_io/basic_istream/extractors_other/char/exceptions_null.cc
index 088aaa42808..1d146ddd5dd 100644
--- a/libstdc++-v3/testsuite/27_io/basic_istream/extractors_other/char/exceptions_null.cc
+++ b/libstdc++-v3/testsuite/27_io/basic_istream/extractors_other/char/exceptions_null.cc
@@ -35,19 +35,12 @@ void test4()
   istringstream stream;
   stream.exceptions(ios_base::failbit);
 
-  // The library throws the new definition of std::ios::failure
-#if _GLIBCXX_USE_CXX11_ABI
-    typedef std::ios_base::failure exception_type;
-#else
-    typedef std::exception exception_type;
-#endif
-
   try
     {
       stream >> static_cast<streambuf*>(0);
       VERIFY(false);
     }
-  catch (exception_type&)
+  catch (std::ios_base::failure&)
     {
     }
 
diff --git a/libstdc++-v3/testsuite/27_io/basic_istream/extractors_other/wchar_t/exceptions_null.cc b/libstdc++-v3/testsuite/27_io/basic_istream/extractors_other/wchar_t/exceptions_null.cc
index fd6322b4cdb..d51bcd5e469 100644
--- a/libstdc++-v3/testsuite/27_io/basic_istream/extractors_other/wchar_t/exceptions_null.cc
+++ b/libstdc++-v3/testsuite/27_io/basic_istream/extractors_other/wchar_t/exceptions_null.cc
@@ -35,19 +35,12 @@ void test4()
   wistringstream stream;
   stream.exceptions(ios_base::failbit);
 
-  // The library throws the new definition of std::ios::failure
-#if _GLIBCXX_USE_CXX11_ABI
-    typedef std::ios_base::failure exception_type;
-#else
-    typedef std::exception exception_type;
-#endif
-
   try
     {
       stream >> static_cast<wstreambuf*>(0);
       VERIFY( false );
     }
-  catch (exception_type&)
+  catch (std::ios_base::failure&)
     {
     }
 
diff --git a/libstdc++-v3/testsuite/27_io/basic_istream/sentry/char/12297.cc b/libstdc++-v3/testsuite/27_io/basic_istream/sentry/char/12297.cc
index 0900a70d148..708f343dd37 100644
--- a/libstdc++-v3/testsuite/27_io/basic_istream/sentry/char/12297.cc
+++ b/libstdc++-v3/testsuite/27_io/basic_istream/sentry/char/12297.cc
@@ -26,19 +26,12 @@ int main()
   istringstream stream;
   stream.exceptions(ios_base::eofbit);
 
-  // The library throws the new definition of std::ios::failure
-#if _GLIBCXX_USE_CXX11_ABI
-    typedef std::ios_base::failure exception_type;
-#else
-    typedef std::exception exception_type;
-#endif
-
   try
     {
       istream::sentry sentry(stream, false);
       VERIFY( false );
     }
-  catch (exception_type&)
+  catch (std::ios_base::failure&)
     {
       VERIFY( stream.rdstate() == (ios_base::eofbit | ios_base::failbit) );
     }
diff --git a/libstdc++-v3/testsuite/27_io/basic_istream/sentry/wchar_t/12297.cc b/libstdc++-v3/testsuite/27_io/basic_istream/sentry/wchar_t/12297.cc
index e72fe1a03a0..6e572cc653d 100644
--- a/libstdc++-v3/testsuite/27_io/basic_istream/sentry/wchar_t/12297.cc
+++ b/libstdc++-v3/testsuite/27_io/basic_istream/sentry/wchar_t/12297.cc
@@ -26,19 +26,12 @@ int main()
   wistringstream stream;
   stream.exceptions(ios_base::eofbit);
 
-  // The library throws the new definition of std::ios::failure
-#if _GLIBCXX_USE_CXX11_ABI
-    typedef std::ios_base::failure exception_type;
-#else
-    typedef std::exception exception_type;
-#endif
-
   try
     {
       wistream::sentry sentry(stream, false);
       VERIFY( false );
     }
-  catch (exception_type&)
+  catch (std::ios_base::failure&)
     {
       VERIFY( stream.rdstate() == (ios_base::eofbit | ios_base::failbit) );
     }
diff --git a/libstdc++-v3/testsuite/27_io/basic_ostream/inserters_other/char/exceptions_null.cc b/libstdc++-v3/testsuite/27_io/basic_ostream/inserters_other/char/exceptions_null.cc
index 9a7bd06f21a..481f04e588c 100644
--- a/libstdc++-v3/testsuite/27_io/basic_ostream/inserters_other/char/exceptions_null.cc
+++ b/libstdc++-v3/testsuite/27_io/basic_ostream/inserters_other/char/exceptions_null.cc
@@ -37,19 +37,12 @@ void test3()
   ostringstream stream;
   stream.exceptions(ios_base::badbit);
 
-  // The library throws the new definition of std::ios::failure
-#if _GLIBCXX_USE_CXX11_ABI
-    typedef std::ios_base::failure exception_type;
-#else
-    typedef std::exception exception_type;
-#endif
-
   try
     {
       stream << static_cast<streambuf*>(0);
       VERIFY( false );
     }
-  catch (exception_type&)
+  catch (std::ios_base::failure&)
     {
     }
 
diff --git a/libstdc++-v3/testsuite/27_io/basic_ostream/inserters_other/wchar_t/exceptions_null.cc b/libstdc++-v3/testsuite/27_io/basic_ostream/inserters_other/wchar_t/exceptions_null.cc
index fcfb37d2dac..177cecb2edf 100644
--- a/libstdc++-v3/testsuite/27_io/basic_ostream/inserters_other/wchar_t/exceptions_null.cc
+++ b/libstdc++-v3/testsuite/27_io/basic_ostream/inserters_other/wchar_t/exceptions_null.cc
@@ -37,19 +37,12 @@ void test3()
   wostringstream stream;
   stream.exceptions(ios_base::badbit);
 
-  // The library throws the new definition of std::ios::failure
-#if _GLIBCXX_USE_CXX11_ABI
-    typedef std::ios_base::failure exception_type;
-#else
-    typedef std::exception exception_type;
-#endif
-
   try
     {
       stream << static_cast<wstreambuf*>(0);
       VERIFY( false );
     }
-  catch (exception_type&)
+  catch (std::ios_base::failure&)
     {
     }
 
diff --git a/libstdc++-v3/testsuite/27_io/ios_base/failure/dual_abi.cc b/libstdc++-v3/testsuite/27_io/ios_base/failure/dual_abi.cc
new file mode 100644
index 00000000000..9bd72a1baf9
--- /dev/null
+++ b/libstdc++-v3/testsuite/27_io/ios_base/failure/dual_abi.cc
@@ -0,0 +1,99 @@
+// Copyright (C) 2018 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-D_GLIBCXX_USE_CXX11_ABI=0" }
+// { dg-do run { target c++11 } }
+
+#include <fstream>
+#include <system_error>
+#include <testsuite_hooks.h>
+
+void
+test01()
+{
+  using std::ios;
+  bool caught_ios_failure = false;
+  bool rethrown = false;
+  bool caught_system_error = false;
+  try {
+    std::ifstream f;
+    f.exceptions(ios::failbit | ios::badbit | ios::eofbit);
+    try {
+      f.get();
+    }
+    catch (const ios::failure&) // catch as old ABI type
+    {
+      caught_ios_failure = true;
+#if _GLIBCXX_USE_DUAL_ABI || _GLIBCXX_USE_CXX11_ABI == 1
+      rethrown = true;
+      throw; // re-throw, to catch as new ABI type
+#endif
+    }
+  }
+  catch (const std::system_error& e)
+  {
+    caught_system_error = true;
+  }
+
+  VERIFY( caught_ios_failure );
+  if (rethrown)
+    VERIFY( caught_system_error );
+}
+
+void
+test02()
+{
+  using std::ios;
+  const std::exception* p = nullptr;
+  bool caught_ios_failure = false;
+  bool caught_exception = false;
+  try {
+    std::ifstream f;
+    f.exceptions(ios::failbit | ios::badbit | ios::eofbit);
+    try {
+      f.get();
+    }
+    catch (const std::exception& e1)
+    {
+      caught_exception = true;
+      p = &e1;
+      throw;
+    }
+  }
+  catch (const ios::failure& e2)
+  {
+    caught_ios_failure = true;
+#if _GLIBCXX_USE_DUAL_ABI
+    // If the Dual ABI is active the library throws the new type,
+    // so e1 was an object of that new type and so &e1 != &e2.
+    VERIFY( p != &e2 );
+#else
+    // Otherwise there's only one type of ios::failure, so &e1 == &e2.
+    VERIFY( p == &e2 );
+#endif
+  }
+
+  VERIFY( caught_exception );
+  VERIFY( caught_ios_failure );
+}
+
+int
+main()
+{
+  test01();
+  test02();
+}
diff --git a/libstdc++-v3/testsuite/27_io/ios_base/storage/2.cc b/libstdc++-v3/testsuite/27_io/ios_base/storage/2.cc
index 8fa306f61a2..2ec234a1bfb 100644
--- a/libstdc++-v3/testsuite/27_io/ios_base/storage/2.cc
+++ b/libstdc++-v3/testsuite/27_io/ios_base/storage/2.cc
@@ -50,18 +50,11 @@ void test02()
   ios.pword(1) = v;
   VERIFY( ios.pword(1) == v );
 
-  // The library throws the new definition of std::ios::failure
-#if _GLIBCXX_USE_CXX11_ABI
-    typedef std::ios_base::failure exception_type;
-#else
-    typedef std::exception exception_type;
-#endif
-
   try
     {
       v = ios.pword(max);
     }
-  catch(exception_type&)
+  catch(std::ios_base::failure&)
     {
       // Ok.
       VERIFY( ios.bad() );
@@ -80,7 +73,7 @@ void test02()
     {
       v = ios.pword(std::numeric_limits<int>::max());
     }
-  catch(exception_type&)
+  catch(std::ios_base::failure&)
     {
       // Ok.
       VERIFY( ios.bad() );
@@ -99,7 +92,7 @@ void test02()
     {
       l = ios.iword(max);
     }
-  catch(exception_type&)
+  catch(std::ios_base::failure&)
     {
       // Ok.
       VERIFY( ios.bad() );
@@ -118,7 +111,7 @@ void test02()
     {
       l = ios.iword(std::numeric_limits<int>::max());
     }
-  catch(exception_type&)
+  catch(std::ios_base::failure&)
     {
       // Ok.
       VERIFY( ios.bad() );
diff --git a/libstdc++-v3/testsuite/28_regex/basic_regex/85098.cc b/libstdc++-v3/testsuite/28_regex/basic_regex/85098.cc
new file mode 100644
index 00000000000..173b1901a7c
--- /dev/null
+++ b/libstdc++-v3/testsuite/28_regex/basic_regex/85098.cc
@@ -0,0 +1,45 @@
+// Copyright (C) 2018 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-O0" }
+// { dg-do link { target c++11 } }
+
+#include <regex>
+
+void f(const std::regex_constants::syntax_option_type&) { }
+
+void
+test01()
+{
+  f(std::regex::icase);
+  f(std::regex::nosubs);
+  f(std::regex::optimize);
+  f(std::regex::collate);
+  f(std::regex::ECMAScript);
+  f(std::regex::basic);
+  f(std::regex::extended);
+  f(std::regex::awk);
+  f(std::regex::grep);
+  f(std::regex::egrep);
+  // f(std::regex::multiline);
+}
+
+int
+main()
+{
+  test01();
+}
diff --git a/libstdc++-v3/testsuite/30_threads/async/84532.cc b/libstdc++-v3/testsuite/30_threads/async/84532.cc
new file mode 100644
index 00000000000..480ed733ca3
--- /dev/null
+++ b/libstdc++-v3/testsuite/30_threads/async/84532.cc
@@ -0,0 +1,38 @@
+// { dg-do compile { target c++11 } }
+// { dg-require-cstdint "" }
+// { dg-require-gthreads "" }
+
+// Copyright (C) 2018 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+#include <future>
+
+// PR libstdc++/84532
+
+struct F
+{
+  template<typename T, typename U>
+    void operator()(T, U, int&)
+    {
+      using std::is_same;
+      using std::reference_wrapper;
+      static_assert(is_same<T, reference_wrapper<int>>::value, "");
+      static_assert(is_same<U, reference_wrapper<const int>>::value, "");
+    }
+};
+int i = 0;
+auto fut = std::async(F{}, std::ref(i), std::cref(i), std::ref(i));
diff --git a/libstdc++-v3/testsuite/30_threads/condition_variable/members/68519.cc b/libstdc++-v3/testsuite/30_threads/condition_variable/members/68519.cc
new file mode 100644
index 00000000000..71c1d29e231
--- /dev/null
+++ b/libstdc++-v3/testsuite/30_threads/condition_variable/members/68519.cc
@@ -0,0 +1,51 @@
+// Copyright (C) 2017 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do run }
+// { dg-options "-pthread"  }
+// { dg-require-effective-target c++11 }
+// { dg-require-effective-target pthread }
+// { dg-require-cstdint "" }
+// { dg-require-gthreads "" }
+
+#include <condition_variable>
+#include <testsuite_hooks.h>
+
+// PR libstdc++/68519
+
+bool val = false;
+std::mutex mx;
+std::condition_variable cv;
+
+void
+test01()
+{
+  for (int i = 0; i < 3; ++i)
+  {
+    std::unique_lock<std::mutex> l(mx);
+    auto start = std::chrono::system_clock::now();
+    cv.wait_for(l, std::chrono::duration<float>(1), [] { return val; });
+    auto t = std::chrono::system_clock::now();
+    VERIFY( (t - start) >= std::chrono::seconds(1) );
+  }
+}
+
+int
+main()
+{
+  test01();
+}
diff --git a/libstdc++-v3/testsuite/30_threads/thread/84532.cc b/libstdc++-v3/testsuite/30_threads/thread/84532.cc
new file mode 100644
index 00000000000..f389b9b88e3
--- /dev/null
+++ b/libstdc++-v3/testsuite/30_threads/thread/84532.cc
@@ -0,0 +1,38 @@
+// { dg-do compile { target c++11 } }
+// { dg-require-cstdint "" }
+// { dg-require-gthreads "" }
+
+// Copyright (C) 2018 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+#include <thread>
+
+// PR libstdc++/84532
+
+struct F
+{
+  template<typename T, typename U>
+    void operator()(T, U, int&)
+    {
+      using std::is_same;
+      using std::reference_wrapper;
+      static_assert(is_same<T, reference_wrapper<int>>::value, "");
+      static_assert(is_same<U, reference_wrapper<const int>>::value, "");
+    }
+};
+int i = 0;
+std::thread t(F{}, std::ref(i), std::cref(i), std::ref(i));
diff --git a/libstdc++-v3/testsuite/experimental/any/misc/any_cast_neg.cc b/libstdc++-v3/testsuite/experimental/any/misc/any_cast_neg.cc
index 697b0f03e2b..81eda331fc8 100644
--- a/libstdc++-v3/testsuite/experimental/any/misc/any_cast_neg.cc
+++ b/libstdc++-v3/testsuite/experimental/any/misc/any_cast_neg.cc
@@ -25,5 +25,5 @@ void test01()
   using std::experimental::any_cast;
 
   const any y(1);
-  any_cast<int&>(y); // { dg-error "qualifiers" "" { target { *-*-* } } 359 }
+  any_cast<int&>(y); // { dg-error "qualifiers" "" { target { *-*-* } } 357 }
 }
diff --git a/libstdc++-v3/testsuite/experimental/array/neg.cc b/libstdc++-v3/testsuite/experimental/array/neg.cc
index 3963287f257..e531678122a 100644
--- a/libstdc++-v3/testsuite/experimental/array/neg.cc
+++ b/libstdc++-v3/testsuite/experimental/array/neg.cc
@@ -24,5 +24,5 @@ int main()
 {
   int dummy;
   auto bad = std::experimental::make_array(std::ref(dummy));
-  // { dg-error "explicit target type" "" { target *-*-* } 78 }
+  // { dg-error "explicit target type" "" { target *-*-* } 76 }
 }
diff --git a/libstdc++-v3/testsuite/experimental/filesystem/operations/space.cc b/libstdc++-v3/testsuite/experimental/filesystem/operations/space.cc
new file mode 100644
index 00000000000..aa6a6aeaa60
--- /dev/null
+++ b/libstdc++-v3/testsuite/experimental/filesystem/operations/space.cc
@@ -0,0 +1,57 @@
+// Copyright (C) 2017-2018 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-DUSE_FILESYSTEM_TS -lstdc++fs" }
+// { dg-do run { target c++11 } }
+// { dg-require-filesystem-ts "" }
+
+// 30.10.14.3 Permissions [fs.op.space]
+
+#include <experimental/filesystem>
+#include <testsuite_fs.h>
+#include <testsuite_hooks.h>
+
+namespace fs = std::experimental::filesystem;
+
+void
+test01()
+{
+  fs::space_info s = fs::space("/");
+  std::error_code ec = make_error_code(std::errc::invalid_argument);
+  s = fs::space("/", ec);
+  VERIFY( !ec );
+
+  s = fs::space(__gnu_test::nonexistent_path(), ec);
+  VERIFY( ec );
+  VERIFY( s.capacity ==  static_cast<uintmax_t>(-1) );
+  VERIFY( s.free ==  static_cast<uintmax_t>(-1) );
+  VERIFY( s.available ==  static_cast<uintmax_t>(-1) );
+}
+
+void
+test02()
+{
+  fs::space_info s = fs::space(".");
+  VERIFY( s.capacity >= s.free );
+}
+
+int
+main()
+{
+  test01();
+  test02();
+}
diff --git a/libstdc++-v3/testsuite/experimental/functional/87538.cc b/libstdc++-v3/testsuite/experimental/functional/87538.cc
new file mode 100644
index 00000000000..1ee9ecd55f3
--- /dev/null
+++ b/libstdc++-v3/testsuite/experimental/functional/87538.cc
@@ -0,0 +1,48 @@
+// Copyright (C) 2018 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do run { target c++14 } }
+
+#include <experimental/functional>
+#include <testsuite_hooks.h>
+
+struct N {
+  int operator()(int i) { if (i == 0) throw -1; return i; }
+};
+
+void
+test01()
+{
+  N n;
+  auto not_n = std::experimental::not_fn(n);
+  static_assert( !noexcept(not_n(1)), "can throw" );
+  VERIFY(not_n(1) == 0);
+  int exception = 0;
+  try {
+    not_n(0);
+  }
+  catch (int e) {
+    exception = e;
+  }
+  VERIFY(exception == -1);
+}
+
+int
+main()
+{
+  test01();
+}
diff --git a/libstdc++-v3/testsuite/experimental/memory_resource/70966.cc b/libstdc++-v3/testsuite/experimental/memory_resource/70966.cc
new file mode 100644
index 00000000000..c0173ffa7a9
--- /dev/null
+++ b/libstdc++-v3/testsuite/experimental/memory_resource/70966.cc
@@ -0,0 +1,56 @@
+// Copyright (C) 2018 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do run { target c++14 } }
+
+#include <experimental/memory_resource>
+
+namespace pmr = std::experimental::pmr;
+
+struct X
+{
+  pmr::memory_resource* res = nullptr;
+  void* ptr = nullptr;
+  static constexpr std::size_t n = 64;
+
+  constexpr X() { }
+
+  explicit
+  X(pmr::memory_resource* r) : res(r), ptr(r->allocate(n)) { }
+
+  ~X() { if (ptr) res->deallocate(ptr, n); }
+};
+
+void
+swap(X& lhs, X& rhs) {
+    std::swap(lhs.res, rhs.res);
+    std::swap(lhs.ptr, rhs.ptr);
+}
+
+void
+test01()
+{
+  static X x1;
+  X x2(pmr::new_delete_resource());
+  swap(x1, x2);
+  // Now x1 will deallocate the memory during destruction of static objects.
+}
+
+int main()
+{
+  test01();
+}
diff --git a/libstdc++-v3/testsuite/experimental/memory_resource/resource_adaptor.cc b/libstdc++-v3/testsuite/experimental/memory_resource/resource_adaptor.cc
index 8e639f22380..b85c5c8be45 100644
--- a/libstdc++-v3/testsuite/experimental/memory_resource/resource_adaptor.cc
+++ b/libstdc++-v3/testsuite/experimental/memory_resource/resource_adaptor.cc
@@ -1,4 +1,5 @@
 // { dg-do run { target c++14 } }
+// { dg-xfail-run-if "PR libstdc++/77691" { { i?86-*-solaris2.* x86_64-*-solaris2.* } && ilp32 } }
 
 // Copyright (C) 2016-2017 Free Software Foundation, Inc.
 //
diff --git a/libstdc++-v3/testsuite/experimental/polymorphic_allocator/pmr_typedefs_deque.cc b/libstdc++-v3/testsuite/experimental/polymorphic_allocator/pmr_typedefs_deque.cc
new file mode 100644
index 00000000000..2b475791bfa
--- /dev/null
+++ b/libstdc++-v3/testsuite/experimental/polymorphic_allocator/pmr_typedefs_deque.cc
@@ -0,0 +1,28 @@
+// Copyright (C) 2018 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do compile { target c++14 } }
+
+#include <experimental/deque>
+
+namespace xpmr = std::experimental::pmr;
+
+struct X { };
+
+static_assert(std::is_same<xpmr::deque<X>,
+    std::deque<X, xpmr::polymorphic_allocator<X>>>::value,
+    "pmr::deque");
diff --git a/libstdc++-v3/testsuite/experimental/polymorphic_allocator/pmr_typedefs_forward_list.cc b/libstdc++-v3/testsuite/experimental/polymorphic_allocator/pmr_typedefs_forward_list.cc
new file mode 100644
index 00000000000..ac2dd52dff6
--- /dev/null
+++ b/libstdc++-v3/testsuite/experimental/polymorphic_allocator/pmr_typedefs_forward_list.cc
@@ -0,0 +1,28 @@
+// Copyright (C) 2018 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do compile { target c++14 } }
+
+#include <experimental/forward_list>
+
+namespace xpmr = std::experimental::pmr;
+
+struct X { };
+
+static_assert(std::is_same<xpmr::forward_list<X>,
+    std::forward_list<X, xpmr::polymorphic_allocator<X>>>::value,
+    "pmr::forward_list");
diff --git a/libstdc++-v3/testsuite/experimental/polymorphic_allocator/pmr_typedefs_list.cc b/libstdc++-v3/testsuite/experimental/polymorphic_allocator/pmr_typedefs_list.cc
new file mode 100644
index 00000000000..aea5c8061bd
--- /dev/null
+++ b/libstdc++-v3/testsuite/experimental/polymorphic_allocator/pmr_typedefs_list.cc
@@ -0,0 +1,28 @@
+// Copyright (C) 2018 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do compile { target c++14 } }
+
+#include <experimental/list>
+
+namespace xpmr = std::experimental::pmr;
+
+struct X { };
+
+static_assert(std::is_same<xpmr::list<X>,
+    std::list<X, xpmr::polymorphic_allocator<X>>>::value,
+    "pmr::list");
diff --git a/libstdc++-v3/testsuite/experimental/polymorphic_allocator/pmr_typedefs_map.cc b/libstdc++-v3/testsuite/experimental/polymorphic_allocator/pmr_typedefs_map.cc
new file mode 100644
index 00000000000..2074022dc2b
--- /dev/null
+++ b/libstdc++-v3/testsuite/experimental/polymorphic_allocator/pmr_typedefs_map.cc
@@ -0,0 +1,35 @@
+// Copyright (C) 2018 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do compile { target c++14 } }
+
+#include <experimental/map>
+
+namespace xpmr = std::experimental::pmr;
+
+struct X { };
+struct Y { };
+struct Cmp { bool operator()(X, X) const { return false; } };
+
+static_assert(std::is_same<xpmr::map<X, Y>,
+    std::map<X, Y, std::less<X>,
+	     xpmr::polymorphic_allocator<std::pair<const X, Y>>>>::value,
+    "pmr::map");
+static_assert(std::is_same<xpmr::map<X, Y, Cmp>,
+    std::map<X, Y, Cmp,
+	     xpmr::polymorphic_allocator<std::pair<const X, Y>>>>::value,
+    "pmr::map");
diff --git a/libstdc++-v3/testsuite/experimental/polymorphic_allocator/pmr_typedefs_match.cc b/libstdc++-v3/testsuite/experimental/polymorphic_allocator/pmr_typedefs_match.cc
new file mode 100644
index 00000000000..8f5f8513403
--- /dev/null
+++ b/libstdc++-v3/testsuite/experimental/polymorphic_allocator/pmr_typedefs_match.cc
@@ -0,0 +1,50 @@
+// Copyright (C) 2018 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do compile { target c++14 } }
+// { dg-require-effective-target cxx11-abi }
+
+#include <experimental/regex>
+
+namespace xpmr = std::experimental::pmr;
+
+struct X;
+static_assert(std::is_same<xpmr::match_results<X*>,
+    std::match_results<X*,
+      xpmr::polymorphic_allocator<std::sub_match<X*>>>>::value,
+    "pmr::match_results");
+
+static_assert(std::is_same<xpmr::cmatch,
+    std::match_results<const char*,
+      xpmr::polymorphic_allocator<std::sub_match<const char*>>>>::value,
+    "pmr::cmatch");
+static_assert(std::is_same<xpmr::smatch,
+    std::match_results<xpmr::string::const_iterator,
+      xpmr::polymorphic_allocator<
+	std::sub_match<xpmr::string::const_iterator>>>>::value,
+    "pmr::smatch");
+#ifdef _GLIBCXX_USE_WCHAR_T
+static_assert(std::is_same<xpmr::wcmatch,
+    std::match_results<const wchar_t*,
+      xpmr::polymorphic_allocator<std::sub_match<const wchar_t*>>>>::value,
+    "pmr::wcmatch");
+static_assert(std::is_same<xpmr::wsmatch,
+    std::match_results<xpmr::wstring::const_iterator,
+      xpmr::polymorphic_allocator<
+	std::sub_match<xpmr::wstring::const_iterator>>>>::value,
+    "pmr::wsmatch");
+#endif
diff --git a/libstdc++-v3/testsuite/experimental/polymorphic_allocator/pmr_typedefs_multimap.cc b/libstdc++-v3/testsuite/experimental/polymorphic_allocator/pmr_typedefs_multimap.cc
new file mode 100644
index 00000000000..e6acaf41122
--- /dev/null
+++ b/libstdc++-v3/testsuite/experimental/polymorphic_allocator/pmr_typedefs_multimap.cc
@@ -0,0 +1,35 @@
+// Copyright (C) 2018 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do compile { target c++14 } }
+
+#include <experimental/map>
+
+namespace xpmr = std::experimental::pmr;
+
+struct X { };
+struct Y { };
+struct Cmp { bool operator()(X, X) const { return false; } };
+
+static_assert(std::is_same<xpmr::multimap<X, Y>,
+    std::multimap<X, Y, std::less<X>,
+		  xpmr::polymorphic_allocator<std::pair<const X, Y>>>>::value,
+    "pmr::multimap");
+static_assert(std::is_same<xpmr::multimap<X, Y, Cmp>,
+    std::multimap<X, Y, Cmp,
+		  xpmr::polymorphic_allocator<std::pair<const X, Y>>>>::value,
+    "pmr::multimap");
diff --git a/libstdc++-v3/testsuite/experimental/polymorphic_allocator/pmr_typedefs_multiset.cc b/libstdc++-v3/testsuite/experimental/polymorphic_allocator/pmr_typedefs_multiset.cc
new file mode 100644
index 00000000000..e98c556c489
--- /dev/null
+++ b/libstdc++-v3/testsuite/experimental/polymorphic_allocator/pmr_typedefs_multiset.cc
@@ -0,0 +1,32 @@
+// Copyright (C) 2018 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do compile { target c++14 } }
+
+#include <experimental/set>
+
+namespace xpmr = std::experimental::pmr;
+
+struct X { };
+struct Cmp { bool operator()(X, X) const { return false; } };
+
+static_assert(std::is_same<xpmr::multiset<X>,
+    std::multiset<X, std::less<X>, xpmr::polymorphic_allocator<X>>>::value,
+    "pmr::multiset");
+static_assert(std::is_same<xpmr::multiset<X, Cmp>,
+    std::multiset<X, Cmp, xpmr::polymorphic_allocator<X>>>::value,
+    "pmr::multiset");
diff --git a/libstdc++-v3/testsuite/experimental/polymorphic_allocator/pmr_typedefs_set.cc b/libstdc++-v3/testsuite/experimental/polymorphic_allocator/pmr_typedefs_set.cc
new file mode 100644
index 00000000000..182a11e9701
--- /dev/null
+++ b/libstdc++-v3/testsuite/experimental/polymorphic_allocator/pmr_typedefs_set.cc
@@ -0,0 +1,32 @@
+// Copyright (C) 2018 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do compile { target c++14 } }
+
+#include <experimental/set>
+
+namespace xpmr = std::experimental::pmr;
+
+struct X { };
+struct Cmp { bool operator()(X, X) const { return false; } };
+
+static_assert(std::is_same<xpmr::set<X>,
+    std::set<X, std::less<X>, xpmr::polymorphic_allocator<X>>>::value,
+    "pmr::set");
+static_assert(std::is_same<xpmr::set<X, Cmp>,
+    std::set<X, Cmp, xpmr::polymorphic_allocator<X>>>::value,
+    "pmr::set");
diff --git a/libstdc++-v3/testsuite/experimental/polymorphic_allocator/pmr_typedefs_string.cc b/libstdc++-v3/testsuite/experimental/polymorphic_allocator/pmr_typedefs_string.cc
new file mode 100644
index 00000000000..ed53ce1a89b
--- /dev/null
+++ b/libstdc++-v3/testsuite/experimental/polymorphic_allocator/pmr_typedefs_string.cc
@@ -0,0 +1,61 @@
+// Copyright (C) 2018 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do compile { target c++14 } }
+// { dg-require-effective-target cxx11-abi }
+
+#include <experimental/string>
+
+namespace xpmr = std::experimental::pmr;
+
+struct T : std::char_traits<char> { };
+
+static_assert(std::is_same<xpmr::basic_string<char>,
+    std::basic_string<char, std::char_traits<char>,
+		      xpmr::polymorphic_allocator<char>>>::value,
+    "pmr::basic_string");
+static_assert(std::is_same<xpmr::basic_string<char, T>,
+    std::basic_string<char, T, xpmr::polymorphic_allocator<char>>>::value,
+    "pmr::basic_string");
+
+static_assert(std::is_same<xpmr::string,
+    std::basic_string<char, std::char_traits<char>,
+		      xpmr::polymorphic_allocator<char>>>::value,
+    "pmr::string");
+static_assert(std::is_same<xpmr::u16string,
+    std::basic_string<char16_t, std::char_traits<char16_t>,
+		      xpmr::polymorphic_allocator<char16_t>>>::value,
+    "pmr::u16string");
+static_assert(std::is_same<xpmr::u32string,
+    std::basic_string<char32_t, std::char_traits<char32_t>,
+		      xpmr::polymorphic_allocator<char32_t>>>::value,
+    "pmr::u32string");
+
+#ifdef _GLIBCXX_USE_WCHAR_T
+static_assert(std::is_same<xpmr::basic_string<wchar_t>,
+    std::basic_string<wchar_t, std::char_traits<wchar_t>,
+		      xpmr::polymorphic_allocator<wchar_t>>>::value,
+    "pmr::basic_string<wchar_t>");
+static_assert(std::is_same<xpmr::basic_string<wchar_t, T>,
+    std::basic_string<wchar_t, T, xpmr::polymorphic_allocator<wchar_t>>>::value,
+    "pmr::basic_string<wchar_t>");
+
+static_assert(std::is_same<xpmr::wstring,
+    std::basic_string<wchar_t, std::char_traits<wchar_t>,
+		      xpmr::polymorphic_allocator<wchar_t>>>::value,
+    "pmr::wstring");
+#endif
diff --git a/libstdc++-v3/testsuite/experimental/polymorphic_allocator/pmr_typedefs_unordered_map.cc b/libstdc++-v3/testsuite/experimental/polymorphic_allocator/pmr_typedefs_unordered_map.cc
new file mode 100644
index 00000000000..15e00e7e720
--- /dev/null
+++ b/libstdc++-v3/testsuite/experimental/polymorphic_allocator/pmr_typedefs_unordered_map.cc
@@ -0,0 +1,40 @@
+// Copyright (C) 2018 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do compile { target c++14 } }
+
+#include <experimental/unordered_map>
+
+namespace xpmr = std::experimental::pmr;
+
+struct X { };
+struct Y { };
+struct Hash { std::size_t operator()(X) const { return 0; } };
+struct Eq { bool operator()(X, X) const { return true; } };
+
+static_assert(std::is_same<xpmr::unordered_map<X, Y>,
+    std::unordered_map<X, Y, std::hash<X>, std::equal_to<X>,
+      xpmr::polymorphic_allocator<std::pair<const X, Y>>>>::value,
+    "pmr::unordered_map");
+static_assert(std::is_same<xpmr::unordered_map<X, Y, Hash>,
+    std::unordered_map<X, Y, Hash, std::equal_to<X>,
+      xpmr::polymorphic_allocator<std::pair<const X, Y>>>>::value,
+    "pmr::unordered_map");
+static_assert(std::is_same<xpmr::unordered_map<X, Y, Hash, Eq>,
+    std::unordered_map<X, Y, Hash, Eq,
+      xpmr::polymorphic_allocator<std::pair<const X, Y>>>>::value,
+    "pmr::unordered_map");
diff --git a/libstdc++-v3/testsuite/experimental/polymorphic_allocator/pmr_typedefs_unordered_multimap.cc b/libstdc++-v3/testsuite/experimental/polymorphic_allocator/pmr_typedefs_unordered_multimap.cc
new file mode 100644
index 00000000000..67054ffb4c9
--- /dev/null
+++ b/libstdc++-v3/testsuite/experimental/polymorphic_allocator/pmr_typedefs_unordered_multimap.cc
@@ -0,0 +1,40 @@
+// Copyright (C) 2018 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do compile { target c++14 } }
+
+#include <experimental/unordered_map>
+
+namespace xpmr = std::experimental::pmr;
+
+struct X { };
+struct Y { };
+struct Hash { std::size_t operator()(X) const { return 0; } };
+struct Eq { bool operator()(X, X) const { return true; } };
+
+static_assert(std::is_same<xpmr::unordered_multimap<X, Y>,
+    std::unordered_multimap<X, Y, std::hash<X>, std::equal_to<X>,
+      xpmr::polymorphic_allocator<std::pair<const X, Y>>>>::value,
+    "pmr::unordered_multimap");
+static_assert(std::is_same<xpmr::unordered_multimap<X, Y, Hash>,
+    std::unordered_multimap<X, Y, Hash, std::equal_to<X>,
+      xpmr::polymorphic_allocator<std::pair<const X, Y>>>>::value,
+    "pmr::unordered_multimap");
+static_assert(std::is_same<xpmr::unordered_multimap<X, Y, Hash, Eq>,
+    std::unordered_multimap<X, Y, Hash, Eq,
+      xpmr::polymorphic_allocator<std::pair<const X, Y>>>>::value,
+    "pmr::unordered_multimap");
diff --git a/libstdc++-v3/testsuite/experimental/polymorphic_allocator/pmr_typedefs_unordered_multiset.cc b/libstdc++-v3/testsuite/experimental/polymorphic_allocator/pmr_typedefs_unordered_multiset.cc
new file mode 100644
index 00000000000..aaba4d3ec47
--- /dev/null
+++ b/libstdc++-v3/testsuite/experimental/polymorphic_allocator/pmr_typedefs_unordered_multiset.cc
@@ -0,0 +1,39 @@
+// Copyright (C) 2018 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do compile { target c++14 } }
+
+#include <experimental/unordered_set>
+
+namespace xpmr = std::experimental::pmr;
+
+struct X { };
+struct Hash { std::size_t operator()(X) const { return 0; } };
+struct Eq { bool operator()(X, X) const { return true; } };
+
+static_assert(std::is_same<xpmr::unordered_multiset<X>,
+    std::unordered_multiset<X, std::hash<X>, std::equal_to<X>,
+      xpmr::polymorphic_allocator<X>>>::value,
+    "pmr::unordered_multiset");
+static_assert(std::is_same<xpmr::unordered_multiset<X, Hash>,
+    std::unordered_multiset<X, Hash, std::equal_to<X>,
+      xpmr::polymorphic_allocator<X>>>::value,
+    "pmr::unordered_multiset");
+static_assert(std::is_same<xpmr::unordered_multiset<X, Hash, Eq>,
+    std::unordered_multiset<X, Hash, Eq,
+      xpmr::polymorphic_allocator<X>>>::value,
+    "pmr::unordered_multiset");
diff --git a/libstdc++-v3/testsuite/experimental/polymorphic_allocator/pmr_typedefs_unordered_set.cc b/libstdc++-v3/testsuite/experimental/polymorphic_allocator/pmr_typedefs_unordered_set.cc
new file mode 100644
index 00000000000..b90051ec074
--- /dev/null
+++ b/libstdc++-v3/testsuite/experimental/polymorphic_allocator/pmr_typedefs_unordered_set.cc
@@ -0,0 +1,39 @@
+// Copyright (C) 2018 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do compile { target c++14 } }
+
+#include <experimental/unordered_set>
+
+namespace xpmr = std::experimental::pmr;
+
+struct X { };
+struct Hash { std::size_t operator()(X) const { return 0; } };
+struct Eq { bool operator()(X, X) const { return true; } };
+
+static_assert(std::is_same<xpmr::unordered_set<X>,
+    std::unordered_set<X, std::hash<X>, std::equal_to<X>,
+      xpmr::polymorphic_allocator<X>>>::value,
+    "pmr::unordered_set");
+static_assert(std::is_same<xpmr::unordered_set<X, Hash>,
+    std::unordered_set<X, Hash, std::equal_to<X>,
+      xpmr::polymorphic_allocator<X>>>::value,
+    "pmr::unordered_set");
+static_assert(std::is_same<xpmr::unordered_set<X, Hash, Eq>,
+    std::unordered_set<X, Hash, Eq,
+      xpmr::polymorphic_allocator<X>>>::value,
+    "pmr::unordered_set");
diff --git a/libstdc++-v3/testsuite/experimental/polymorphic_allocator/pmr_typedefs_vector.cc b/libstdc++-v3/testsuite/experimental/polymorphic_allocator/pmr_typedefs_vector.cc
new file mode 100644
index 00000000000..f780aa5666b
--- /dev/null
+++ b/libstdc++-v3/testsuite/experimental/polymorphic_allocator/pmr_typedefs_vector.cc
@@ -0,0 +1,28 @@
+// Copyright (C) 2018 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do compile { target c++14 } }
+
+#include <experimental/vector>
+
+namespace xpmr = std::experimental::pmr;
+
+struct X { };
+
+static_assert(std::is_same<xpmr::vector<X>,
+    std::vector<X, xpmr::polymorphic_allocator<X>>>::value,
+    "pmr::vector");
diff --git a/libstdc++-v3/testsuite/experimental/propagate_const/assignment/move_neg.cc b/libstdc++-v3/testsuite/experimental/propagate_const/assignment/move_neg.cc
index 040e30b81a2..a0cc0e9f434 100644
--- a/libstdc++-v3/testsuite/experimental/propagate_const/assignment/move_neg.cc
+++ b/libstdc++-v3/testsuite/experimental/propagate_const/assignment/move_neg.cc
@@ -25,7 +25,7 @@
 using std::experimental::propagate_const;
 using std::unique_ptr;
 
-// { dg-error "no type" "" { target *-*-* } 162 }
+// { dg-error "no type" "" { target *-*-* } 160 }
 
 int main()
 {
diff --git a/libstdc++-v3/testsuite/experimental/propagate_const/cons/move_neg.cc b/libstdc++-v3/testsuite/experimental/propagate_const/cons/move_neg.cc
index 743658f5f9e..ac71a29cf56 100644
--- a/libstdc++-v3/testsuite/experimental/propagate_const/cons/move_neg.cc
+++ b/libstdc++-v3/testsuite/experimental/propagate_const/cons/move_neg.cc
@@ -25,10 +25,10 @@
 using std::experimental::propagate_const;
 using std::unique_ptr;
 
-// { dg-error "no type" "" { target *-*-* } 120 }
-// { dg-error "no type" "" { target *-*-* } 127 }
-// { dg-error "no type" "" { target *-*-* } 136 }
-// { dg-error "no type" "" { target *-*-* } 145 }
+// { dg-error "no type" "" { target *-*-* } 118 }
+// { dg-error "no type" "" { target *-*-* } 125 }
+// { dg-error "no type" "" { target *-*-* } 134 }
+// { dg-error "no type" "" { target *-*-* } 143 }
 
 int main()
 {
diff --git a/libstdc++-v3/testsuite/experimental/propagate_const/requirements2.cc b/libstdc++-v3/testsuite/experimental/propagate_const/requirements2.cc
index 6f8fef80aca..626805ecd46 100644
--- a/libstdc++-v3/testsuite/experimental/propagate_const/requirements2.cc
+++ b/libstdc++-v3/testsuite/experimental/propagate_const/requirements2.cc
@@ -21,9 +21,9 @@
 
 using std::experimental::propagate_const;
 
-// { dg-error "requires a class or a pointer to an object type" "" { target *-*-* } 107 }
-// { dg-error "not a pointer-to-object type" "" { target *-*-* } 68 }
-// { dg-error "forming pointer to reference type" "" { target *-*-* } 189 }
-// { dg-error "forming pointer to reference type" "" { target *-*-* } 215 }
+// { dg-error "requires a class or a pointer to an object type" "" { target *-*-* } 105 }
+// { dg-error "not a pointer-to-object type" "" { target *-*-* } 66 }
+// { dg-error "forming pointer to reference type" "" { target *-*-* } 187 }
+// { dg-error "forming pointer to reference type" "" { target *-*-* } 213 }
 
 propagate_const<void*> test1;
diff --git a/libstdc++-v3/testsuite/experimental/propagate_const/requirements3.cc b/libstdc++-v3/testsuite/experimental/propagate_const/requirements3.cc
index 0498b0bafa4..74ed5d35c4e 100644
--- a/libstdc++-v3/testsuite/experimental/propagate_const/requirements3.cc
+++ b/libstdc++-v3/testsuite/experimental/propagate_const/requirements3.cc
@@ -21,6 +21,6 @@
 
 using std::experimental::propagate_const;
 
-// { dg-error "requires a class or a pointer to an object type" "" { target *-*-* } 107 }
+// { dg-error "requires a class or a pointer to an object type" "" { target *-*-* } 105 }
 
 propagate_const<void (*)()> test1;
diff --git a/libstdc++-v3/testsuite/experimental/propagate_const/requirements4.cc b/libstdc++-v3/testsuite/experimental/propagate_const/requirements4.cc
index d662af82fee..4182c0862f3 100644
--- a/libstdc++-v3/testsuite/experimental/propagate_const/requirements4.cc
+++ b/libstdc++-v3/testsuite/experimental/propagate_const/requirements4.cc
@@ -21,8 +21,8 @@
 
 using std::experimental::propagate_const;
 
-// { dg-error "requires a class or a pointer to an object type" "" { target *-*-* } 107 }
-// { dg-error "invalid type" "" { target *-*-* } 68 }
-// { dg-error "uninitialized reference member" "" { target *-*-* } 114 }
+// { dg-error "requires a class or a pointer to an object type" "" { target *-*-* } 105 }
+// { dg-error "invalid type" "" { target *-*-* } 66 }
+// { dg-error "uninitialized reference member" "" { target *-*-* } 112 }
 
 propagate_const<int&> test1; // { dg-error "use of deleted function" }
diff --git a/libstdc++-v3/testsuite/experimental/propagate_const/requirements5.cc b/libstdc++-v3/testsuite/experimental/propagate_const/requirements5.cc
index adf0809858a..07a4c69c147 100644
--- a/libstdc++-v3/testsuite/experimental/propagate_const/requirements5.cc
+++ b/libstdc++-v3/testsuite/experimental/propagate_const/requirements5.cc
@@ -21,6 +21,6 @@
 
 using std::experimental::propagate_const;
 
-// { dg-error "requires a class or a pointer to an object type" "" { target *-*-* } 107 }
+// { dg-error "requires a class or a pointer to an object type" "" { target *-*-* } 105 }
 
 propagate_const<int[1]> test1;
diff --git a/libstdc++-v3/testsuite/ext/ext_pointer/1.cc b/libstdc++-v3/testsuite/ext/ext_pointer/1.cc
index 096a15fb671..56560a001b3 100644
--- a/libstdc++-v3/testsuite/ext/ext_pointer/1.cc
+++ b/libstdc++-v3/testsuite/ext/ext_pointer/1.cc
@@ -180,11 +180,25 @@ void test04() {
   VERIFY(bPtr3 == aPtr);
 }
 
+// Check that long long values can be used for pointer arithmetic.
+void test05()
+{
+  A a[2] = { 1, 2 };
+  A_pointer p = a;
+  A_pointer q = p + 0ull;
+  VERIFY( p == q );
+  q += 0ll;
+  VERIFY( p == q );
+  q += 1ll;
+  VERIFY( q->i == p[1ll].i );
+}
+
 int main()
 {
   test01();
   test02();
   test03();
   test04();
+  test05();
   return 0;
 }
diff --git a/libstdc++-v3/testsuite/lib/libstdc++.exp b/libstdc++-v3/testsuite/lib/libstdc++.exp
index b081d8a5b90..cd929d8cb4e 100644
--- a/libstdc++-v3/testsuite/lib/libstdc++.exp
+++ b/libstdc++-v3/testsuite/lib/libstdc++.exp
@@ -239,7 +239,7 @@ proc libstdc++_init { testfile } {
 
     # Default settings.
     set cxx [transform "g++"]
-    set cxxflags "-fmessage-length=0"
+    set cxxflags "-fmessage-length=0 -fno-show-column"
     set cxxpchflags ""
     set cxxvtvflags ""
     set cxxldflags ""
diff --git a/libstdc++-v3/testsuite/special_functions/06_comp_ellint_3/check_value.cc b/libstdc++-v3/testsuite/special_functions/06_comp_ellint_3/check_value.cc
index 1a3dbac3d2d..60f6addf008 100644
--- a/libstdc++-v3/testsuite/special_functions/06_comp_ellint_3/check_value.cc
+++ b/libstdc++-v3/testsuite/special_functions/06_comp_ellint_3/check_value.cc
@@ -1,7 +1,7 @@
 // { dg-do run { target c++11 } }
 // { dg-options "-D__STDCPP_WANT_MATH_SPEC_FUNCS__" }
 //
-// Copyright (C) 2016-2017 Free Software Foundation, Inc.
+// Copyright (C) 2016-2018 Free Software Foundation, Inc.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
 // software; you can redistribute it and/or modify it under the
@@ -37,387 +37,444 @@
 #endif
 #include <specfun_testcase.h>
 
-
 // Test data for k=-0.90000000000000002.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 2.6751587294384150e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 5
+// max(|f - f_Boost| / |f_Boost|): 1.2838262090802751e-16
+// mean(f - f_Boost): 4.4408920985006264e-17
+// variance(f - f_Boost): 2.4347558803117648e-34
+// stddev(f - f_Boost): 1.5603704304785339e-17
 const testcase_comp_ellint_3<double>
 data001[10] =
 {
   { 2.2805491384227703, -0.90000000000000002, 0.0000000000000000 },
-  { 2.1537868513875287, -0.90000000000000002, 0.10000000000000001 },
-  { 2.0443194576468890, -0.90000000000000002, 0.20000000000000001 },
-  { 1.9486280260314426, -0.90000000000000002, 0.29999999999999999 },
-  { 1.8641114227238349, -0.90000000000000002, 0.40000000000000002 },
-  { 1.7888013241937861, -0.90000000000000002, 0.50000000000000000 },
-  { 1.7211781128919523, -0.90000000000000002, 0.59999999999999998 },
-  { 1.6600480747670940, -0.90000000000000002, 0.69999999999999996 },
-  { 1.6044591960982202, -0.90000000000000002, 0.80000000000000004 },
-  { 1.5536420236310946, -0.90000000000000002, 0.90000000000000002 },
+  { 2.4295011187834885, -0.90000000000000002, 0.10000000000000001 },
+  { 2.6076835743348412, -0.90000000000000002, 0.20000000000000001 },
+  { 2.8256506968858512, -0.90000000000000002, 0.30000000000000004 },
+  { 3.1000689868578619, -0.90000000000000002, 0.40000000000000002 },
+  { 3.4591069002104677, -0.90000000000000002, 0.50000000000000000 },
+  { 3.9549939883570229, -0.90000000000000002, 0.60000000000000009 },
+  { 4.6985482312992435, -0.90000000000000002, 0.70000000000000007 },
+  { 5.9820740813645710, -0.90000000000000002, 0.80000000000000004 },
+  { 8.9942562031858699, -0.90000000000000002, 0.90000000000000002 },
 };
 const double toler001 = 2.5000000000000020e-13;
 
 // Test data for k=-0.80000000000000004.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 1.5960830388244336e-16
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 4.1949393471095187e-16
+// mean(f - f_Boost): 9.5479180117763459e-16
+// variance(f - f_Boost): 5.4782007307014711e-34
+// stddev(f - f_Boost): 2.3405556457178006e-17
 const testcase_comp_ellint_3<double>
 data002[10] =
 {
-  { 1.9953027776647296, -0.80000000000000004, 0.0000000000000000 },
-  { 1.8910755418379521, -0.80000000000000004, 0.10000000000000001 },
-  { 1.8007226661734588, -0.80000000000000004, 0.20000000000000001 },
-  { 1.7214611048717301, -0.80000000000000004, 0.29999999999999999 },
-  { 1.6512267838651289, -0.80000000000000004, 0.40000000000000002 },
-  { 1.5884528947755532, -0.80000000000000004, 0.50000000000000000 },
-  { 1.5319262547427865, -0.80000000000000004, 0.59999999999999998 },
-  { 1.4806912324625332, -0.80000000000000004, 0.69999999999999996 },
-  { 1.4339837018309471, -0.80000000000000004, 0.80000000000000004 },
-  { 1.3911845406776222, -0.80000000000000004, 0.90000000000000002 },
+  { 1.9953027776647294, -0.80000000000000004, 0.0000000000000000 },
+  { 2.1172616484005085, -0.80000000000000004, 0.10000000000000001 },
+  { 2.2624789434186798, -0.80000000000000004, 0.20000000000000001 },
+  { 2.4392042002725698, -0.80000000000000004, 0.30000000000000004 },
+  { 2.6604037035529728, -0.80000000000000004, 0.40000000000000002 },
+  { 2.9478781158239751, -0.80000000000000004, 0.50000000000000000 },
+  { 3.3418121892288055, -0.80000000000000004, 0.60000000000000009 },
+  { 3.9268876980046397, -0.80000000000000004, 0.70000000000000007 },
+  { 4.9246422058196071, -0.80000000000000004, 0.80000000000000004 },
+  { 7.2263259298637132, -0.80000000000000004, 0.90000000000000002 },
 };
 const double toler002 = 2.5000000000000020e-13;
 
 // Test data for k=-0.69999999999999996.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.3074070916136724e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 3
+// max(|f - f_Boost| / |f_Boost|): 1.9832236886714888e-16
+// mean(f - f_Boost): -1.5543122344752191e-16
+// variance(f - f_Boost): 2.9825759533819119e-33
+// stddev(f - f_Boost): 5.4612965066748680e-17
 const testcase_comp_ellint_3<double>
 data003[10] =
 {
-  { 1.8456939983747236, -0.69999999999999996, 0.0000000000000000 },
-  { 1.7528050171757608, -0.69999999999999996, 0.10000000000000001 },
-  { 1.6721098780092145, -0.69999999999999996, 0.20000000000000001 },
-  { 1.6011813647733213, -0.69999999999999996, 0.29999999999999999 },
-  { 1.5382162002954762, -0.69999999999999996, 0.40000000000000002 },
-  { 1.4818433192178544, -0.69999999999999996, 0.50000000000000000 },
-  { 1.4309994736080540, -0.69999999999999996, 0.59999999999999998 },
-  { 1.3848459188329196, -0.69999999999999996, 0.69999999999999996 },
-  { 1.3427110650397531, -0.69999999999999996, 0.80000000000000004 },
-  { 1.3040500499695913, -0.69999999999999996, 0.90000000000000002 },
+  { 1.8456939983747234, -0.69999999999999996, 0.0000000000000000 },
+  { 1.9541347343119564, -0.69999999999999996, 0.10000000000000001 },
+  { 2.0829290325820202, -0.69999999999999996, 0.20000000000000001 },
+  { 2.2392290510988535, -0.69999999999999996, 0.30000000000000004 },
+  { 2.4342502915307880, -0.69999999999999996, 0.40000000000000002 },
+  { 2.6868019968236996, -0.69999999999999996, 0.50000000000000000 },
+  { 3.0314573496746742, -0.69999999999999996, 0.60000000000000009 },
+  { 3.5408408771788564, -0.69999999999999996, 0.70000000000000007 },
+  { 4.4042405729076961, -0.69999999999999996, 0.80000000000000004 },
+  { 6.3796094177887754, -0.69999999999999996, 0.90000000000000002 },
 };
 const double toler003 = 2.5000000000000020e-13;
 
 // Test data for k=-0.59999999999999998.
-// max(|f - f_GSL|): 6.6613381477509392e-16
-// max(|f - f_GSL| / |f_GSL|): 4.1891472451898755e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 2
+// max(|f - f_Boost| / |f_Boost|): 2.2547200163366559e-16
+// mean(f - f_Boost): -1.9984014443252818e-16
+// variance(f - f_Boost): 4.9303806576313241e-33
+// stddev(f - f_Boost): 7.0216669371534022e-17
 const testcase_comp_ellint_3<double>
 data004[10] =
 {
   { 1.7507538029157526, -0.59999999999999998, 0.0000000000000000 },
-  { 1.6648615773343014, -0.59999999999999998, 0.10000000000000001 },
-  { 1.5901418016279374, -0.59999999999999998, 0.20000000000000001 },
-  { 1.5243814243493585, -0.59999999999999998, 0.29999999999999999 },
-  { 1.4659345278069984, -0.59999999999999998, 0.40000000000000002 },
-  { 1.4135484285693078, -0.59999999999999998, 0.50000000000000000 },
-  { 1.3662507535812816, -0.59999999999999998, 0.59999999999999998 },
-  { 1.3232737468822813, -0.59999999999999998, 0.69999999999999996 },
-  { 1.2840021261752192, -0.59999999999999998, 0.80000000000000004 },
-  { 1.2479362973851875, -0.59999999999999998, 0.90000000000000002 },
+  { 1.8508766487100685, -0.59999999999999998, 0.10000000000000001 },
+  { 1.9695980282802217, -0.59999999999999998, 0.20000000000000001 },
+  { 2.1134154405060599, -0.59999999999999998, 0.30000000000000004 },
+  { 2.2925036420985130, -0.59999999999999998, 0.40000000000000002 },
+  { 2.5239007084492711, -0.59999999999999998, 0.50000000000000000 },
+  { 2.8388723099514972, -0.59999999999999998, 0.60000000000000009 },
+  { 3.3029735898397159, -0.59999999999999998, 0.70000000000000007 },
+  { 4.0867036409261832, -0.59999999999999998, 0.80000000000000004 },
+  { 5.8709993116265604, -0.59999999999999998, 0.90000000000000002 },
 };
 const double toler004 = 2.5000000000000020e-13;
 
 // Test data for k=-0.50000000000000000.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 1.7857620325589816e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 3
+// max(|f - f_Boost| / |f_Boost|): 2.1900131385114407e-16
+// mean(f - f_Boost): 2.4424906541753446e-16
+// variance(f - f_Boost): 7.3651365379430888e-33
+// stddev(f - f_Boost): 8.5820373676319358e-17
 const testcase_comp_ellint_3<double>
 data005[10] =
 {
-  { 1.6857503548125963, -0.50000000000000000, 0.0000000000000000 },
-  { 1.6045524936084892, -0.50000000000000000, 0.10000000000000001 },
-  { 1.5338490483665983, -0.50000000000000000, 0.20000000000000001 },
-  { 1.4715681939859637, -0.50000000000000000, 0.29999999999999999 },
-  { 1.4161679518465340, -0.50000000000000000, 0.40000000000000002 },
-  { 1.3664739530045971, -0.50000000000000000, 0.50000000000000000 },
-  { 1.3215740290190876, -0.50000000000000000, 0.59999999999999998 },
-  { 1.2807475181182502, -0.50000000000000000, 0.69999999999999996 },
-  { 1.2434165408189539, -0.50000000000000000, 0.80000000000000004 },
-  { 1.2091116095504744, -0.50000000000000000, 0.90000000000000002 },
+  { 1.6857503548125961, -0.50000000000000000, 0.0000000000000000 },
+  { 1.7803034946545482, -0.50000000000000000, 0.10000000000000001 },
+  { 1.8922947612264021, -0.50000000000000000, 0.20000000000000001 },
+  { 2.0277924458111314, -0.50000000000000000, 0.30000000000000004 },
+  { 2.1962905366178065, -0.50000000000000000, 0.40000000000000002 },
+  { 2.4136715042011945, -0.50000000000000000, 0.50000000000000000 },
+  { 2.7090491861753558, -0.50000000000000000, 0.60000000000000009 },
+  { 3.1433945297859229, -0.50000000000000000, 0.70000000000000007 },
+  { 3.8750701888108070, -0.50000000000000000, 0.80000000000000004 },
+  { 5.5355132096026463, -0.50000000000000000, 0.90000000000000002 },
 };
 const double toler005 = 2.5000000000000020e-13;
 
-// Test data for k=-0.40000000000000002.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 6.1925080711125793e-16
+// Test data for k=-0.39999999999999991.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.1718164615986397e-16
+// mean(f - f_Boost): 6.2172489379008762e-16
+// variance(f - f_Boost): 1.6458949750907531e-31
+// stddev(f - f_Boost): 4.0569631192441877e-16
 const testcase_comp_ellint_3<double>
 data006[10] =
 {
-  { 1.6399998658645112, -0.40000000000000002, 0.0000000000000000 },
-  { 1.5620566886683604, -0.40000000000000002, 0.10000000000000001 },
-  { 1.4941414344266770, -0.40000000000000002, 0.20000000000000001 },
-  { 1.4342789859950078, -0.40000000000000002, 0.29999999999999999 },
-  { 1.3809986210732901, -0.40000000000000002, 0.40000000000000002 },
-  { 1.3331797176377398, -0.40000000000000002, 0.50000000000000000 },
-  { 1.2899514672527024, -0.40000000000000002, 0.59999999999999998 },
-  { 1.2506255923253344, -0.40000000000000002, 0.69999999999999996 },
-  { 1.2146499565727209, -0.40000000000000002, 0.80000000000000004 },
-  { 1.1815758115929846, -0.40000000000000002, 0.90000000000000002 },
+  { 1.6399998658645112, -0.39999999999999991, 0.0000000000000000 },
+  { 1.7306968836847190, -0.39999999999999991, 0.10000000000000001 },
+  { 1.8380358826317627, -0.39999999999999991, 0.20000000000000001 },
+  { 1.9677924132520139, -0.39999999999999991, 0.30000000000000004 },
+  { 2.1289968719280026, -0.39999999999999991, 0.40000000000000002 },
+  { 2.3367461373176512, -0.39999999999999991, 0.50000000000000000 },
+  { 2.6186940209850191, -0.39999999999999991, 0.60000000000000009 },
+  { 3.0327078743873246, -0.39999999999999991, 0.70000000000000007 },
+  { 3.7289548002199902, -0.39999999999999991, 0.80000000000000004 },
+  { 5.3055535102872513, -0.39999999999999991, 0.90000000000000002 },
 };
 const double toler006 = 2.5000000000000020e-13;
 
-// Test data for k=-0.30000000000000004.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.8209844149902043e-16
+// Test data for k=-0.29999999999999993.
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 3.9274792319434433e-16
+// mean(f - f_Boost): 6.2172489379008762e-16
+// variance(f - f_Boost): 8.7651211691223537e-33
+// stddev(f - f_Boost): 9.3622225828712025e-17
 const testcase_comp_ellint_3<double>
 data007[10] =
 {
-  { 1.6080486199305128, -0.30000000000000004, 0.0000000000000000 },
-  { 1.5323534693557528, -0.30000000000000004, 0.10000000000000001 },
-  { 1.4663658145259877, -0.30000000000000004, 0.20000000000000001 },
-  { 1.4081767433479091, -0.30000000000000004, 0.29999999999999999 },
-  { 1.3563643538969763, -0.30000000000000004, 0.40000000000000002 },
-  { 1.3098448759814962, -0.30000000000000004, 0.50000000000000000 },
-  { 1.2677758800420669, -0.30000000000000004, 0.59999999999999998 },
-  { 1.2294913236274982, -0.30000000000000004, 0.69999999999999996 },
-  { 1.1944567571590048, -0.30000000000000004, 0.80000000000000004 },
-  { 1.1622376896064914, -0.30000000000000004, 0.90000000000000002 },
+  { 1.6080486199305128, -0.29999999999999993, 0.0000000000000000 },
+  { 1.6960848815118226, -0.29999999999999993, 0.10000000000000001 },
+  { 1.8002173372290500, -0.29999999999999993, 0.20000000000000001 },
+  { 1.9260216862473254, -0.29999999999999993, 0.30000000000000004 },
+  { 2.0822121773175533, -0.29999999999999993, 0.40000000000000002 },
+  { 2.2833505881933971, -0.29999999999999993, 0.50000000000000000 },
+  { 2.5560975528589065, -0.29999999999999993, 0.60000000000000009 },
+  { 2.9562123549913877, -0.29999999999999993, 0.70000000000000007 },
+  { 3.6283050484567170, -0.29999999999999993, 0.80000000000000004 },
+  { 5.1479514944016795, -0.29999999999999993, 0.90000000000000002 },
 };
 const double toler007 = 2.5000000000000020e-13;
 
 // Test data for k=-0.19999999999999996.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.8637687241174905e-16
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 1.9753938705764407e-16
+// mean(f - f_Boost): 3.1086244689504381e-16
+// variance(f - f_Boost): 4.1147374377268827e-32
+// stddev(f - f_Boost): 2.0284815596220939e-16
 const testcase_comp_ellint_3<double>
 data008[10] =
 {
-  { 1.5868678474541660, -0.19999999999999996, 0.0000000000000000 },
-  { 1.5126513474261087, -0.19999999999999996, 0.10000000000000001 },
-  { 1.4479323932249564, -0.19999999999999996, 0.20000000000000001 },
-  { 1.3908453514752477, -0.19999999999999996, 0.29999999999999999 },
-  { 1.3400002519661005, -0.19999999999999996, 0.40000000000000002 },
-  { 1.2943374404397372, -0.19999999999999996, 0.50000000000000000 },
-  { 1.2530330675914556, -0.19999999999999996, 0.59999999999999998 },
-  { 1.2154356555075863, -0.19999999999999996, 0.69999999999999996 },
-  { 1.1810223448909909, -0.19999999999999996, 0.80000000000000004 },
-  { 1.1493679916141861, -0.19999999999999996, 0.90000000000000002 },
+  { 1.5868678474541662, -0.19999999999999996, 0.0000000000000000 },
+  { 1.6731552050562593, -0.19999999999999996, 0.10000000000000001 },
+  { 1.7751816279738935, -0.19999999999999996, 0.20000000000000001 },
+  { 1.8983924169967101, -0.19999999999999996, 0.30000000000000004 },
+  { 2.0512956926676806, -0.19999999999999996, 0.40000000000000002 },
+  { 2.2481046259421302, -0.19999999999999996, 0.50000000000000000 },
+  { 2.5148333891629315, -0.19999999999999996, 0.60000000000000009 },
+  { 2.9058704854500967, -0.19999999999999996, 0.70000000000000007 },
+  { 3.5622166386422633, -0.19999999999999996, 0.80000000000000004 },
+  { 5.0448269356200370, -0.19999999999999996, 0.90000000000000002 },
 };
 const double toler008 = 2.5000000000000020e-13;
 
 // Test data for k=-0.099999999999999978.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.8887517676790089e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 5
+// max(|f - f_Boost| / |f_Boost|): 1.9932308021417639e-16
+// mean(f - f_Boost): 0.0000000000000000
+// variance(f - f_Boost): 6.8368087769470551e-64
+// stddev(f - f_Boost): 2.6147291976315738e-32
 const testcase_comp_ellint_3<double>
 data009[10] =
 {
-  { 1.5747455615173562, -0.099999999999999978, 0.0000000000000000 },
-  { 1.5013711111199950, -0.099999999999999978, 0.10000000000000001 },
-  { 1.4373749386463430, -0.099999999999999978, 0.20000000000000001 },
-  { 1.3809159606704959, -0.099999999999999978, 0.29999999999999999 },
-  { 1.3306223265207477, -0.099999999999999978, 0.40000000000000002 },
-  { 1.2854480708580160, -0.099999999999999978, 0.50000000000000000 },
-  { 1.2445798942989255, -0.099999999999999978, 0.59999999999999998 },
-  { 1.2073745911083185, -0.099999999999999978, 0.69999999999999996 },
-  { 1.1733158866987732, -0.099999999999999978, 0.80000000000000004 },
-  { 1.1419839485283374, -0.099999999999999978, 0.90000000000000002 },
+  { 1.5747455615173560, -0.099999999999999978, 0.0000000000000000 },
+  { 1.6600374067558428, -0.099999999999999978, 0.10000000000000001 },
+  { 1.7608656115083421, -0.099999999999999978, 0.20000000000000001 },
+  { 1.8826015946315438, -0.099999999999999978, 0.30000000000000004 },
+  { 2.0336367403076760, -0.099999999999999978, 0.40000000000000002 },
+  { 2.2279868912966849, -0.099999999999999978, 0.50000000000000000 },
+  { 2.4913004919173827, -0.099999999999999978, 0.60000000000000009 },
+  { 2.8771910188009744, -0.099999999999999978, 0.70000000000000007 },
+  { 3.5246199613295617, -0.099999999999999978, 0.80000000000000004 },
+  { 4.9862890417305508, -0.099999999999999978, 0.90000000000000002 },
 };
 const double toler009 = 2.5000000000000020e-13;
 
 // Test data for k=0.0000000000000000.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 1.6725702444488137e-16
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 2.1899085000907084e-16
+// mean(f - f_Boost): -2.2204460492503131e-16
+// variance(f - f_Boost): 5.4782007307014711e-32
+// stddev(f - f_Boost): 2.3405556457178008e-16
 const testcase_comp_ellint_3<double>
 data010[10] =
 {
   { 1.5707963267948966, 0.0000000000000000, 0.0000000000000000 },
-  { 1.4976955329233277, 0.0000000000000000, 0.10000000000000001 },
-  { 1.4339343023863691, 0.0000000000000000, 0.20000000000000001 },
-  { 1.3776795151134889, 0.0000000000000000, 0.29999999999999999 },
-  { 1.3275651989026320, 0.0000000000000000, 0.40000000000000002 },
-  { 1.2825498301618641, 0.0000000000000000, 0.50000000000000000 },
-  { 1.2418235332245127, 0.0000000000000000, 0.59999999999999998 },
-  { 1.2047457872617382, 0.0000000000000000, 0.69999999999999996 },
-  { 1.1708024551734544, 0.0000000000000000, 0.80000000000000004 },
-  { 1.1395754288497419, 0.0000000000000000, 0.90000000000000002 },
+  { 1.6557647109660170, 0.0000000000000000, 0.10000000000000001 },
+  { 1.7562036827601817, 0.0000000000000000, 0.20000000000000001 },
+  { 1.8774607092226381, 0.0000000000000000, 0.30000000000000004 },
+  { 2.0278893379868062, 0.0000000000000000, 0.40000000000000002 },
+  { 2.2214414690791831, 0.0000000000000000, 0.50000000000000000 },
+  { 2.4836470664490258, 0.0000000000000000, 0.60000000000000009 },
+  { 2.8678686047727386, 0.0000000000000000, 0.70000000000000007 },
+  { 3.5124073655203634, 0.0000000000000000, 0.80000000000000004 },
+  { 4.9672941328980516, 0.0000000000000000, 0.90000000000000002 },
 };
 const double toler010 = 2.5000000000000020e-13;
 
 // Test data for k=0.10000000000000009.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.8887517676790089e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 5
+// max(|f - f_Boost| / |f_Boost|): 1.9932308021417639e-16
+// mean(f - f_Boost): -2.2204460492503132e-17
+// variance(f - f_Boost): 6.0868897007794120e-35
+// stddev(f - f_Boost): 7.8018521523926693e-18
 const testcase_comp_ellint_3<double>
 data011[10] =
 {
-  { 1.5747455615173562, 0.10000000000000009, 0.0000000000000000 },
-  { 1.5013711111199950, 0.10000000000000009, 0.10000000000000001 },
-  { 1.4373749386463430, 0.10000000000000009, 0.20000000000000001 },
-  { 1.3809159606704959, 0.10000000000000009, 0.29999999999999999 },
-  { 1.3306223265207477, 0.10000000000000009, 0.40000000000000002 },
-  { 1.2854480708580160, 0.10000000000000009, 0.50000000000000000 },
-  { 1.2445798942989255, 0.10000000000000009, 0.59999999999999998 },
-  { 1.2073745911083185, 0.10000000000000009, 0.69999999999999996 },
-  { 1.1733158866987732, 0.10000000000000009, 0.80000000000000004 },
-  { 1.1419839485283374, 0.10000000000000009, 0.90000000000000002 },
+  { 1.5747455615173560, 0.10000000000000009, 0.0000000000000000 },
+  { 1.6600374067558428, 0.10000000000000009, 0.10000000000000001 },
+  { 1.7608656115083421, 0.10000000000000009, 0.20000000000000001 },
+  { 1.8826015946315440, 0.10000000000000009, 0.30000000000000004 },
+  { 2.0336367403076760, 0.10000000000000009, 0.40000000000000002 },
+  { 2.2279868912966849, 0.10000000000000009, 0.50000000000000000 },
+  { 2.4913004919173827, 0.10000000000000009, 0.60000000000000009 },
+  { 2.8771910188009744, 0.10000000000000009, 0.70000000000000007 },
+  { 3.5246199613295617, 0.10000000000000009, 0.80000000000000004 },
+  { 4.9862890417305508, 0.10000000000000009, 0.90000000000000002 },
 };
 const double toler011 = 2.5000000000000020e-13;
 
-// Test data for k=0.19999999999999996.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.8637687241174905e-16
+// Test data for k=0.20000000000000018.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 1.9753938705764407e-16
+// mean(f - f_Boost): 3.1086244689504381e-16
+// variance(f - f_Boost): 4.1147374377268827e-32
+// stddev(f - f_Boost): 2.0284815596220939e-16
 const testcase_comp_ellint_3<double>
 data012[10] =
 {
-  { 1.5868678474541660, 0.19999999999999996, 0.0000000000000000 },
-  { 1.5126513474261087, 0.19999999999999996, 0.10000000000000001 },
-  { 1.4479323932249564, 0.19999999999999996, 0.20000000000000001 },
-  { 1.3908453514752477, 0.19999999999999996, 0.29999999999999999 },
-  { 1.3400002519661005, 0.19999999999999996, 0.40000000000000002 },
-  { 1.2943374404397372, 0.19999999999999996, 0.50000000000000000 },
-  { 1.2530330675914556, 0.19999999999999996, 0.59999999999999998 },
-  { 1.2154356555075863, 0.19999999999999996, 0.69999999999999996 },
-  { 1.1810223448909909, 0.19999999999999996, 0.80000000000000004 },
-  { 1.1493679916141861, 0.19999999999999996, 0.90000000000000002 },
+  { 1.5868678474541662, 0.20000000000000018, 0.0000000000000000 },
+  { 1.6731552050562593, 0.20000000000000018, 0.10000000000000001 },
+  { 1.7751816279738935, 0.20000000000000018, 0.20000000000000001 },
+  { 1.8983924169967101, 0.20000000000000018, 0.30000000000000004 },
+  { 2.0512956926676806, 0.20000000000000018, 0.40000000000000002 },
+  { 2.2481046259421302, 0.20000000000000018, 0.50000000000000000 },
+  { 2.5148333891629315, 0.20000000000000018, 0.60000000000000009 },
+  { 2.9058704854500967, 0.20000000000000018, 0.70000000000000007 },
+  { 3.5622166386422633, 0.20000000000000018, 0.80000000000000004 },
+  { 5.0448269356200370, 0.20000000000000018, 0.90000000000000002 },
 };
 const double toler012 = 2.5000000000000020e-13;
 
 // Test data for k=0.30000000000000004.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.8209844149902043e-16
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 3.4585997630846713e-16
+// mean(f - f_Boost): 5.1070259132757197e-16
+// variance(f - f_Boost): 1.7591111235252501e-32
+// stddev(f - f_Boost): 1.3263148659067538e-16
 const testcase_comp_ellint_3<double>
 data013[10] =
 {
   { 1.6080486199305128, 0.30000000000000004, 0.0000000000000000 },
-  { 1.5323534693557528, 0.30000000000000004, 0.10000000000000001 },
-  { 1.4663658145259877, 0.30000000000000004, 0.20000000000000001 },
-  { 1.4081767433479091, 0.30000000000000004, 0.29999999999999999 },
-  { 1.3563643538969763, 0.30000000000000004, 0.40000000000000002 },
-  { 1.3098448759814962, 0.30000000000000004, 0.50000000000000000 },
-  { 1.2677758800420669, 0.30000000000000004, 0.59999999999999998 },
-  { 1.2294913236274982, 0.30000000000000004, 0.69999999999999996 },
-  { 1.1944567571590048, 0.30000000000000004, 0.80000000000000004 },
-  { 1.1622376896064914, 0.30000000000000004, 0.90000000000000002 },
+  { 1.6960848815118228, 0.30000000000000004, 0.10000000000000001 },
+  { 1.8002173372290500, 0.30000000000000004, 0.20000000000000001 },
+  { 1.9260216862473254, 0.30000000000000004, 0.30000000000000004 },
+  { 2.0822121773175533, 0.30000000000000004, 0.40000000000000002 },
+  { 2.2833505881933975, 0.30000000000000004, 0.50000000000000000 },
+  { 2.5560975528589065, 0.30000000000000004, 0.60000000000000009 },
+  { 2.9562123549913877, 0.30000000000000004, 0.70000000000000007 },
+  { 3.6283050484567174, 0.30000000000000004, 0.80000000000000004 },
+  { 5.1479514944016795, 0.30000000000000004, 0.90000000000000002 },
 };
 const double toler013 = 2.5000000000000020e-13;
 
-// Test data for k=0.39999999999999991.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 6.1925080711125793e-16
+// Test data for k=0.40000000000000013.
+// max(|f - f_Boost|): 2.6645352591003757e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 6.7696531428672557e-16
+// mean(f - f_Boost): 1.1990408665951691e-15
+// variance(f - f_Boost): 2.6514491536595121e-31
+// stddev(f - f_Boost): 5.1492224205791612e-16
 const testcase_comp_ellint_3<double>
 data014[10] =
 {
-  { 1.6399998658645112, 0.39999999999999991, 0.0000000000000000 },
-  { 1.5620566886683604, 0.39999999999999991, 0.10000000000000001 },
-  { 1.4941414344266770, 0.39999999999999991, 0.20000000000000001 },
-  { 1.4342789859950078, 0.39999999999999991, 0.29999999999999999 },
-  { 1.3809986210732901, 0.39999999999999991, 0.40000000000000002 },
-  { 1.3331797176377398, 0.39999999999999991, 0.50000000000000000 },
-  { 1.2899514672527024, 0.39999999999999991, 0.59999999999999998 },
-  { 1.2506255923253344, 0.39999999999999991, 0.69999999999999996 },
-  { 1.2146499565727209, 0.39999999999999991, 0.80000000000000004 },
-  { 1.1815758115929846, 0.39999999999999991, 0.90000000000000002 },
+  { 1.6399998658645112, 0.40000000000000013, 0.0000000000000000 },
+  { 1.7306968836847190, 0.40000000000000013, 0.10000000000000001 },
+  { 1.8380358826317629, 0.40000000000000013, 0.20000000000000001 },
+  { 1.9677924132520141, 0.40000000000000013, 0.30000000000000004 },
+  { 2.1289968719280030, 0.40000000000000013, 0.40000000000000002 },
+  { 2.3367461373176512, 0.40000000000000013, 0.50000000000000000 },
+  { 2.6186940209850196, 0.40000000000000013, 0.60000000000000009 },
+  { 3.0327078743873246, 0.40000000000000013, 0.70000000000000007 },
+  { 3.7289548002199906, 0.40000000000000013, 0.80000000000000004 },
+  { 5.3055535102872522, 0.40000000000000013, 0.90000000000000002 },
 };
 const double toler014 = 2.5000000000000020e-13;
 
 // Test data for k=0.50000000000000000.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 1.7857620325589816e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 3
+// max(|f - f_Boost| / |f_Boost|): 2.1900131385114407e-16
+// mean(f - f_Boost): 2.4424906541753446e-16
+// variance(f - f_Boost): 7.3651365379430888e-33
+// stddev(f - f_Boost): 8.5820373676319358e-17
 const testcase_comp_ellint_3<double>
 data015[10] =
 {
-  { 1.6857503548125963, 0.50000000000000000, 0.0000000000000000 },
-  { 1.6045524936084892, 0.50000000000000000, 0.10000000000000001 },
-  { 1.5338490483665983, 0.50000000000000000, 0.20000000000000001 },
-  { 1.4715681939859637, 0.50000000000000000, 0.29999999999999999 },
-  { 1.4161679518465340, 0.50000000000000000, 0.40000000000000002 },
-  { 1.3664739530045971, 0.50000000000000000, 0.50000000000000000 },
-  { 1.3215740290190876, 0.50000000000000000, 0.59999999999999998 },
-  { 1.2807475181182502, 0.50000000000000000, 0.69999999999999996 },
-  { 1.2434165408189539, 0.50000000000000000, 0.80000000000000004 },
-  { 1.2091116095504744, 0.50000000000000000, 0.90000000000000002 },
+  { 1.6857503548125961, 0.50000000000000000, 0.0000000000000000 },
+  { 1.7803034946545482, 0.50000000000000000, 0.10000000000000001 },
+  { 1.8922947612264021, 0.50000000000000000, 0.20000000000000001 },
+  { 2.0277924458111314, 0.50000000000000000, 0.30000000000000004 },
+  { 2.1962905366178065, 0.50000000000000000, 0.40000000000000002 },
+  { 2.4136715042011945, 0.50000000000000000, 0.50000000000000000 },
+  { 2.7090491861753558, 0.50000000000000000, 0.60000000000000009 },
+  { 3.1433945297859229, 0.50000000000000000, 0.70000000000000007 },
+  { 3.8750701888108070, 0.50000000000000000, 0.80000000000000004 },
+  { 5.5355132096026463, 0.50000000000000000, 0.90000000000000002 },
 };
 const double toler015 = 2.5000000000000020e-13;
 
 // Test data for k=0.60000000000000009.
-// max(|f - f_GSL|): 6.6613381477509392e-16
-// max(|f - f_GSL| / |f_GSL|): 4.7124937590522226e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 2
+// max(|f - f_Boost| / |f_Boost|): 2.2547200163366559e-16
+// mean(f - f_Boost): -2.2204460492503131e-16
+// variance(f - f_Boost): 6.0868897007794117e-33
+// stddev(f - f_Boost): 7.8018521523926690e-17
 const testcase_comp_ellint_3<double>
 data016[10] =
 {
   { 1.7507538029157526, 0.60000000000000009, 0.0000000000000000 },
-  { 1.6648615773343014, 0.60000000000000009, 0.10000000000000001 },
-  { 1.5901418016279374, 0.60000000000000009, 0.20000000000000001 },
-  { 1.5243814243493585, 0.60000000000000009, 0.29999999999999999 },
-  { 1.4659345278069984, 0.60000000000000009, 0.40000000000000002 },
-  { 1.4135484285693078, 0.60000000000000009, 0.50000000000000000 },
-  { 1.3662507535812816, 0.60000000000000009, 0.59999999999999998 },
-  { 1.3232737468822813, 0.60000000000000009, 0.69999999999999996 },
-  { 1.2840021261752192, 0.60000000000000009, 0.80000000000000004 },
-  { 1.2479362973851873, 0.60000000000000009, 0.90000000000000002 },
+  { 1.8508766487100687, 0.60000000000000009, 0.10000000000000001 },
+  { 1.9695980282802217, 0.60000000000000009, 0.20000000000000001 },
+  { 2.1134154405060599, 0.60000000000000009, 0.30000000000000004 },
+  { 2.2925036420985130, 0.60000000000000009, 0.40000000000000002 },
+  { 2.5239007084492711, 0.60000000000000009, 0.50000000000000000 },
+  { 2.8388723099514976, 0.60000000000000009, 0.60000000000000009 },
+  { 3.3029735898397159, 0.60000000000000009, 0.70000000000000007 },
+  { 4.0867036409261832, 0.60000000000000009, 0.80000000000000004 },
+  { 5.8709993116265613, 0.60000000000000009, 0.90000000000000002 },
 };
 const double toler016 = 2.5000000000000020e-13;
 
-// Test data for k=0.69999999999999996.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.3074070916136724e-16
+// Test data for k=0.70000000000000018.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 2.9298727220933567e-16
+// mean(f - f_Boost): 4.8849813083506892e-16
+// variance(f - f_Boost): 2.0476296953421943e-31
+// stddev(f - f_Boost): 4.5250742483877478e-16
 const testcase_comp_ellint_3<double>
 data017[10] =
 {
-  { 1.8456939983747236, 0.69999999999999996, 0.0000000000000000 },
-  { 1.7528050171757608, 0.69999999999999996, 0.10000000000000001 },
-  { 1.6721098780092145, 0.69999999999999996, 0.20000000000000001 },
-  { 1.6011813647733213, 0.69999999999999996, 0.29999999999999999 },
-  { 1.5382162002954762, 0.69999999999999996, 0.40000000000000002 },
-  { 1.4818433192178544, 0.69999999999999996, 0.50000000000000000 },
-  { 1.4309994736080540, 0.69999999999999996, 0.59999999999999998 },
-  { 1.3848459188329196, 0.69999999999999996, 0.69999999999999996 },
-  { 1.3427110650397531, 0.69999999999999996, 0.80000000000000004 },
-  { 1.3040500499695913, 0.69999999999999996, 0.90000000000000002 },
+  { 1.8456939983747238, 0.70000000000000018, 0.0000000000000000 },
+  { 1.9541347343119566, 0.70000000000000018, 0.10000000000000001 },
+  { 2.0829290325820207, 0.70000000000000018, 0.20000000000000001 },
+  { 2.2392290510988540, 0.70000000000000018, 0.30000000000000004 },
+  { 2.4342502915307880, 0.70000000000000018, 0.40000000000000002 },
+  { 2.6868019968237000, 0.70000000000000018, 0.50000000000000000 },
+  { 3.0314573496746746, 0.70000000000000018, 0.60000000000000009 },
+  { 3.5408408771788569, 0.70000000000000018, 0.70000000000000007 },
+  { 4.4042405729076970, 0.70000000000000018, 0.80000000000000004 },
+  { 6.3796094177887763, 0.70000000000000018, 0.90000000000000002 },
 };
 const double toler017 = 2.5000000000000020e-13;
 
 // Test data for k=0.80000000000000004.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 1.5960830388244336e-16
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 4.1949393471095187e-16
+// mean(f - f_Boost): 9.5479180117763459e-16
+// variance(f - f_Boost): 5.4782007307014711e-34
+// stddev(f - f_Boost): 2.3405556457178006e-17
 const testcase_comp_ellint_3<double>
 data018[10] =
 {
-  { 1.9953027776647296, 0.80000000000000004, 0.0000000000000000 },
-  { 1.8910755418379521, 0.80000000000000004, 0.10000000000000001 },
-  { 1.8007226661734588, 0.80000000000000004, 0.20000000000000001 },
-  { 1.7214611048717301, 0.80000000000000004, 0.29999999999999999 },
-  { 1.6512267838651289, 0.80000000000000004, 0.40000000000000002 },
-  { 1.5884528947755532, 0.80000000000000004, 0.50000000000000000 },
-  { 1.5319262547427865, 0.80000000000000004, 0.59999999999999998 },
-  { 1.4806912324625332, 0.80000000000000004, 0.69999999999999996 },
-  { 1.4339837018309471, 0.80000000000000004, 0.80000000000000004 },
-  { 1.3911845406776222, 0.80000000000000004, 0.90000000000000002 },
+  { 1.9953027776647294, 0.80000000000000004, 0.0000000000000000 },
+  { 2.1172616484005085, 0.80000000000000004, 0.10000000000000001 },
+  { 2.2624789434186798, 0.80000000000000004, 0.20000000000000001 },
+  { 2.4392042002725698, 0.80000000000000004, 0.30000000000000004 },
+  { 2.6604037035529728, 0.80000000000000004, 0.40000000000000002 },
+  { 2.9478781158239751, 0.80000000000000004, 0.50000000000000000 },
+  { 3.3418121892288055, 0.80000000000000004, 0.60000000000000009 },
+  { 3.9268876980046397, 0.80000000000000004, 0.70000000000000007 },
+  { 4.9246422058196071, 0.80000000000000004, 0.80000000000000004 },
+  { 7.2263259298637132, 0.80000000000000004, 0.90000000000000002 },
 };
 const double toler018 = 2.5000000000000020e-13;
 
-// Test data for k=0.89999999999999991.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 2.6751587294384150e-16
+// Test data for k=0.90000000000000013.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 3
+// max(|f - f_Boost| / |f_Boost|): 1.5716352001310461e-16
+// mean(f - f_Boost): 4.4408920985006264e-17
+// variance(f - f_Boost): 2.4347558803117648e-34
+// stddev(f - f_Boost): 1.5603704304785339e-17
 const testcase_comp_ellint_3<double>
 data019[10] =
 {
-  { 2.2805491384227703, 0.89999999999999991, 0.0000000000000000 },
-  { 2.1537868513875287, 0.89999999999999991, 0.10000000000000001 },
-  { 2.0443194576468895, 0.89999999999999991, 0.20000000000000001 },
-  { 1.9486280260314426, 0.89999999999999991, 0.29999999999999999 },
-  { 1.8641114227238351, 0.89999999999999991, 0.40000000000000002 },
-  { 1.7888013241937863, 0.89999999999999991, 0.50000000000000000 },
-  { 1.7211781128919525, 0.89999999999999991, 0.59999999999999998 },
-  { 1.6600480747670940, 0.89999999999999991, 0.69999999999999996 },
-  { 1.6044591960982202, 0.89999999999999991, 0.80000000000000004 },
-  { 1.5536420236310948, 0.89999999999999991, 0.90000000000000002 },
+  { 2.2805491384227707, 0.90000000000000013, 0.0000000000000000 },
+  { 2.4295011187834890, 0.90000000000000013, 0.10000000000000001 },
+  { 2.6076835743348421, 0.90000000000000013, 0.20000000000000001 },
+  { 2.8256506968858521, 0.90000000000000013, 0.30000000000000004 },
+  { 3.1000689868578628, 0.90000000000000013, 0.40000000000000002 },
+  { 3.4591069002104686, 0.90000000000000013, 0.50000000000000000 },
+  { 3.9549939883570242, 0.90000000000000013, 0.60000000000000009 },
+  { 4.6985482312992453, 0.90000000000000013, 0.70000000000000007 },
+  { 5.9820740813645727, 0.90000000000000013, 0.80000000000000004 },
+  { 8.9942562031858735, 0.90000000000000013, 0.90000000000000002 },
 };
 const double toler019 = 2.5000000000000020e-13;
 
-template<typename Tp, unsigned int Num>
+template<typename Ret, unsigned int Num>
   void
-  test(const testcase_comp_ellint_3<Tp> (&data)[Num], Tp toler)
+  test(const testcase_comp_ellint_3<Ret> (&data)[Num], Ret toler)
   {
-    const Tp eps = std::numeric_limits<Tp>::epsilon();
-    Tp max_abs_diff = -Tp(1);
-    Tp max_abs_frac = -Tp(1);
+    bool test __attribute__((unused)) = true;
+    const Ret eps = std::numeric_limits<Ret>::epsilon();
+    Ret max_abs_diff = -Ret(1);
+    Ret max_abs_frac = -Ret(1);
     unsigned int num_datum = Num;
     for (unsigned int i = 0; i < num_datum; ++i)
       {
-	const Tp f = std::comp_ellint_3(data[i].k, data[i].nu);
-	const Tp f0 = data[i].f0;
-	const Tp diff = f - f0;
+	const Ret f = std::comp_ellint_3(data[i].k, data[i].nu);
+	const Ret f0 = data[i].f0;
+	const Ret diff = f - f0;
 	if (std::abs(diff) > max_abs_diff)
 	  max_abs_diff = std::abs(diff);
-	if (std::abs(f0) > Tp(10) * eps
-	 && std::abs(f) > Tp(10) * eps)
+	if (std::abs(f0) > Ret(10) * eps
+	 && std::abs(f) > Ret(10) * eps)
 	  {
-	    const Tp frac = diff / f0;
+	    const Ret frac = diff / f0;
 	    if (std::abs(frac) > max_abs_frac)
 	      max_abs_frac = std::abs(frac);
 	  }
diff --git a/libstdc++-v3/testsuite/special_functions/06_comp_ellint_3/pr66689.cc b/libstdc++-v3/testsuite/special_functions/06_comp_ellint_3/pr66689.cc
new file mode 100644
index 00000000000..c500f20dfd7
--- /dev/null
+++ b/libstdc++-v3/testsuite/special_functions/06_comp_ellint_3/pr66689.cc
@@ -0,0 +1,24 @@
+// { dg-do run { target c++11 } }
+// { dg-require-c-std "" }
+// { dg-options "-D__STDCPP_WANT_MATH_SPEC_FUNCS__" }
+// { dg-add-options ieee }
+
+#include <cmath>
+#include <testsuite_hooks.h>
+
+void
+test01()
+{
+  double Pi1 = std::comp_ellint_3(0.75, 0.0);
+  VERIFY(std::abs(Pi1 - 1.91099) < 0.00001);
+
+  double Pi2 = std::comp_ellint_3(0.75, 0.5);
+  VERIFY(std::abs(Pi2 - 2.80011) < 0.00001);
+}
+
+int
+main()
+{
+  test01();
+  return 0;
+}
diff --git a/libstdc++-v3/testsuite/special_functions/13_ellint_3/check_value.cc b/libstdc++-v3/testsuite/special_functions/13_ellint_3/check_value.cc
index 8a7202fdb2c..7a948e0f56c 100644
--- a/libstdc++-v3/testsuite/special_functions/13_ellint_3/check_value.cc
+++ b/libstdc++-v3/testsuite/special_functions/13_ellint_3/check_value.cc
@@ -1,7 +1,7 @@
 // { dg-do run { target c++11 } }
 // { dg-options "-D__STDCPP_WANT_MATH_SPEC_FUNCS__" }
 //
-// Copyright (C) 2016-2017 Free Software Foundation, Inc.
+// Copyright (C) 2016-2018 Free Software Foundation, Inc.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
 // software; you can redistribute it and/or modify it under the
@@ -37,30 +37,32 @@
 #endif
 #include <specfun_testcase.h>
 
-
 // Test data for k=-0.90000000000000002, nu=0.0000000000000000.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 2.9686139313362077e-16
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 5.7842011620951154e-16
+// mean(f - f_Boost): 5.8286708792820721e-17
+// variance(f - f_Boost): 4.1942474344433133e-34
+// stddev(f - f_Boost): 2.0479861900030756e-17
 const testcase_ellint_3<double>
 data001[10] =
 {
   { 0.0000000000000000, -0.90000000000000002, 0.0000000000000000, 
 	  0.0000000000000000 },
-  { 0.17525427376115024, -0.90000000000000002, 0.0000000000000000, 
+  { 0.17525427376115027, -0.90000000000000002, 0.0000000000000000, 
 	  0.17453292519943295 },
   { 0.35492464591297446, -0.90000000000000002, 0.0000000000000000, 
 	  0.34906585039886590 },
-  { 0.54388221416157112, -0.90000000000000002, 0.0000000000000000, 
+  { 0.54388221416157123, -0.90000000000000002, 0.0000000000000000, 
 	  0.52359877559829882 },
-  { 0.74797400423532490, -0.90000000000000002, 0.0000000000000000, 
+  { 0.74797400423532512, -0.90000000000000002, 0.0000000000000000, 
 	  0.69813170079773179 },
-  { 0.97463898451966458, -0.90000000000000002, 0.0000000000000000, 
+  { 0.97463898451966446, -0.90000000000000002, 0.0000000000000000, 
 	  0.87266462599716477 },
-  { 1.2334463254523440, -0.90000000000000002, 0.0000000000000000, 
+  { 1.2334463254523438, -0.90000000000000002, 0.0000000000000000, 
 	  1.0471975511965976 },
   { 1.5355247765594913, -0.90000000000000002, 0.0000000000000000, 
 	  1.2217304763960306 },
-  { 1.8882928567775121, -0.90000000000000002, 0.0000000000000000, 
+  { 1.8882928567775126, -0.90000000000000002, 0.0000000000000000, 
 	  1.3962634015954636 },
   { 2.2805491384227703, -0.90000000000000002, 0.0000000000000000, 
 	  1.5707963267948966 },
@@ -68,269 +70,299 @@ data001[10] =
 const double toler001 = 2.5000000000000020e-13;
 
 // Test data for k=-0.90000000000000002, nu=0.10000000000000001.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.0141810743801079e-16
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 4.1500594295134815e-16
+// mean(f - f_Boost): 1.0269562977782698e-16
+// variance(f - f_Boost): 1.4388836606733082e-32
+// stddev(f - f_Boost): 1.1995347684303728e-16
 const testcase_ellint_3<double>
 data002[10] =
 {
   { 0.0000000000000000, -0.90000000000000002, 0.10000000000000001, 
 	  0.0000000000000000 },
-  { 0.17507714233254656, -0.90000000000000002, 0.10000000000000001, 
+  { 0.17543204932716244, -0.90000000000000002, 0.10000000000000001, 
 	  0.17453292519943295 },
-  { 0.35350932904326521, -0.90000000000000002, 0.10000000000000001, 
+  { 0.35636022898551184, -0.90000000000000002, 0.10000000000000001, 
 	  0.34906585039886590 },
-  { 0.53911129989870976, -0.90000000000000002, 0.10000000000000001, 
+  { 0.54880278898382584, -0.90000000000000002, 0.10000000000000001, 
 	  0.52359877559829882 },
-  { 0.73666644254508395, -0.90000000000000002, 0.10000000000000001, 
+  { 0.75988834774529268, -0.90000000000000002, 0.10000000000000001, 
 	  0.69813170079773179 },
-  { 0.95250736612100195, -0.90000000000000002, 0.10000000000000001, 
+  { 0.99853303003568117, -0.90000000000000002, 0.10000000000000001, 
 	  0.87266462599716477 },
-  { 1.1950199550905594, -0.90000000000000002, 0.10000000000000001, 
+  { 1.2759958823999022, -0.90000000000000002, 0.10000000000000001, 
 	  1.0471975511965976 },
-  { 1.4741687286340850, -0.90000000000000002, 0.10000000000000001, 
+  { 1.6051187364639401, -0.90000000000000002, 0.10000000000000001, 
 	  1.2217304763960306 },
-  { 1.7968678183506057, -0.90000000000000002, 0.10000000000000001, 
+  { 1.9941406879519472, -0.90000000000000002, 0.10000000000000001, 
 	  1.3962634015954636 },
-  { 2.1537868513875287, -0.90000000000000002, 0.10000000000000001, 
+  { 2.4295011187834881, -0.90000000000000002, 0.10000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler002 = 2.5000000000000020e-13;
 
 // Test data for k=-0.90000000000000002, nu=0.20000000000000001.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 3.0588292817405780e-16
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 5.2711357908578066e-16
+// mean(f - f_Boost): 8.0491169285323847e-17
+// variance(f - f_Boost): 7.9985534974304465e-34
+// stddev(f - f_Boost): 2.8281714052423424e-17
 const testcase_ellint_3<double>
 data003[10] =
 {
   { 0.0000000000000000, -0.90000000000000002, 0.20000000000000001, 
 	  0.0000000000000000 },
-  { 0.17490065089140927, -0.90000000000000002, 0.20000000000000001, 
+  { 0.17561047321968409, -0.90000000000000002, 0.20000000000000001, 
 	  0.17453292519943295 },
-  { 0.35211377590661436, -0.90000000000000002, 0.20000000000000001, 
+  { 0.35781659944356109, -0.90000000000000002, 0.20000000000000001, 
 	  0.34906585039886590 },
-  { 0.53448220334204100, -0.90000000000000002, 0.20000000000000001, 
+  { 0.55388150905215283, -0.90000000000000002, 0.20000000000000001, 
 	  0.52359877559829882 },
-  { 0.72591368943179579, -0.90000000000000002, 0.20000000000000001, 
+  { 0.77246874123251441, -0.90000000000000002, 0.20000000000000001, 
 	  0.69813170079773179 },
-  { 0.93192539780038763, -0.90000000000000002, 0.20000000000000001, 
+  { 1.0244466254771925, -0.90000000000000002, 0.20000000000000001, 
 	  0.87266462599716477 },
-  { 1.1600809679692683, -0.90000000000000002, 0.20000000000000001, 
+  { 1.3234824077640801, -0.90000000000000002, 0.20000000000000001, 
 	  1.0471975511965976 },
-  { 1.4195407225882510, -0.90000000000000002, 0.20000000000000001, 
+  { 1.6849848968804237, -0.90000000000000002, 0.20000000000000001, 
 	  1.2217304763960306 },
-  { 1.7168966476424525, -0.90000000000000002, 0.20000000000000001, 
+  { 2.1185749045502273, -0.90000000000000002, 0.20000000000000001, 
 	  1.3962634015954636 },
-  { 2.0443194576468890, -0.90000000000000002, 0.20000000000000001, 
+  { 2.6076835743348412, -0.90000000000000002, 0.20000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler003 = 2.5000000000000020e-13;
 
-// Test data for k=-0.90000000000000002, nu=0.29999999999999999.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.2403611223075570e-16
+// Test data for k=-0.90000000000000002, nu=0.30000000000000004.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 4.9955372494296814e-16
+// mean(f - f_Boost): 5.8286708792820721e-17
+// variance(f - f_Boost): 4.1942474344433133e-34
+// stddev(f - f_Boost): 2.0479861900030756e-17
 const testcase_ellint_3<double>
 data004[10] =
 {
-  { 0.0000000000000000, -0.90000000000000002, 0.29999999999999999, 
+  { 0.0000000000000000, -0.90000000000000002, 0.30000000000000004, 
 	  0.0000000000000000 },
-  { 0.17472479532647531, -0.90000000000000002, 0.29999999999999999, 
+  { 0.17578954966746221, -0.90000000000000002, 0.30000000000000004, 
 	  0.17453292519943295 },
-  { 0.35073750187374114, -0.90000000000000002, 0.29999999999999999, 
+  { 0.35929429810867447, -0.90000000000000002, 0.30000000000000004, 
 	  0.34906585039886590 },
-  { 0.52998766129466957, -0.90000000000000002, 0.29999999999999999, 
+  { 0.55912757154240811, -0.90000000000000002, 0.30000000000000004, 
 	  0.52359877559829882 },
-  { 0.71566993548699553, -0.90000000000000002, 0.29999999999999999, 
+  { 0.78578314722025389, -0.90000000000000002, 0.30000000000000004, 
 	  0.69813170079773179 },
-  { 0.91271517762560195, -0.90000000000000002, 0.29999999999999999, 
+  { 1.0526941001131365, -0.90000000000000002, 0.30000000000000004, 
 	  0.87266462599716477 },
-  { 1.1281241199843370, -0.90000000000000002, 0.29999999999999999, 
+  { 1.3769682234538601, -0.90000000000000002, 0.30000000000000004, 
 	  1.0471975511965976 },
-  { 1.3704929576917451, -0.90000000000000002, 0.29999999999999999, 
+  { 1.7779437432911238, -0.90000000000000002, 0.30000000000000004, 
 	  1.2217304763960306 },
-  { 1.6461981511487713, -0.90000000000000002, 0.29999999999999999, 
+  { 2.2676509341813631, -0.90000000000000002, 0.30000000000000004, 
 	  1.3962634015954636 },
-  { 1.9486280260314426, -0.90000000000000002, 0.29999999999999999, 
+  { 2.8256506968858512, -0.90000000000000002, 0.30000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler004 = 2.5000000000000020e-13;
 
 // Test data for k=-0.90000000000000002, nu=0.40000000000000002.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.3487482375512111e-16
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 4.7042235432234642e-16
+// mean(f - f_Boost): 2.0261570199409106e-16
+// variance(f - f_Boost): 5.8024227149195491e-32
+// stddev(f - f_Boost): 2.4088218520512364e-16
 const testcase_ellint_3<double>
 data005[10] =
 {
   { 0.0000000000000000, -0.90000000000000002, 0.40000000000000002, 
 	  0.0000000000000000 },
-  { 0.17454957156468837, -0.90000000000000002, 0.40000000000000002, 
+  { 0.17596928293938452, -0.90000000000000002, 0.40000000000000002, 
 	  0.17453292519943295 },
-  { 0.34938003933330430, -0.90000000000000002, 0.40000000000000002, 
+  { 0.36079388642472821, -0.90000000000000002, 0.40000000000000002, 
 	  0.34906585039886590 },
-  { 0.52562093533067433, -0.90000000000000002, 0.40000000000000002, 
+  { 0.56455096667115612, -0.90000000000000002, 0.40000000000000002, 
 	  0.52359877559829882 },
-  { 0.70589461324915670, -0.90000000000000002, 0.40000000000000002, 
+  { 0.79990996997869435, -0.90000000000000002, 0.40000000000000002, 
 	  0.69813170079773179 },
-  { 0.89472658511942849, -0.90000000000000002, 0.40000000000000002, 
+  { 1.0836647913872215, -0.90000000000000002, 0.40000000000000002, 
 	  0.87266462599716477 },
-  { 1.0987419542323440, -0.90000000000000002, 0.40000000000000002, 
+  { 1.4378726836091849, -0.90000000000000002, 0.40000000000000002, 
 	  1.0471975511965976 },
-  { 1.3261349565496303, -0.90000000000000002, 0.40000000000000002, 
+  { 1.8880446720682853, -0.90000000000000002, 0.40000000000000002, 
 	  1.2217304763960306 },
-  { 1.5831293909853765, -0.90000000000000002, 0.40000000000000002, 
+  { 2.4505848932025227, -0.90000000000000002, 0.40000000000000002, 
 	  1.3962634015954636 },
-  { 1.8641114227238349, -0.90000000000000002, 0.40000000000000002, 
+  { 3.1000689868578615, -0.90000000000000002, 0.40000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler005 = 2.5000000000000020e-13;
 
 // Test data for k=-0.90000000000000002, nu=0.50000000000000000.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.4538944656036724e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 6
+// max(|f - f_Boost| / |f_Boost|): 3.8944086593755267e-16
+// mean(f - f_Boost): 6.9388939039072284e-17
+// variance(f - f_Boost): 1.7333369499485123e-32
+// stddev(f - f_Boost): 1.3165625507162629e-16
 const testcase_ellint_3<double>
 data006[10] =
 {
   { 0.0000000000000000, -0.90000000000000002, 0.50000000000000000, 
 	  0.0000000000000000 },
-  { 0.17437497557073334, -0.90000000000000002, 0.50000000000000000, 
+  { 0.17614967734498183, -0.90000000000000002, 0.50000000000000000, 
 	  0.17453292519943295 },
-  { 0.34804093691586013, -0.90000000000000002, 0.50000000000000000, 
+  { 0.36231594750319435, -0.90000000000000002, 0.50000000000000000, 
 	  0.34906585039886590 },
-  { 0.52137576320372891, -0.90000000000000002, 0.50000000000000000, 
+  { 0.57016256984349567, -0.90000000000000002, 0.50000000000000000, 
 	  0.52359877559829882 },
-  { 0.69655163996912262, -0.90000000000000002, 0.50000000000000000, 
+  { 0.81494025918293422, -0.90000000000000002, 0.50000000000000000, 
 	  0.69813170079773179 },
-  { 0.87783188683054236, -0.90000000000000002, 0.50000000000000000, 
+  { 1.1178482279283477, -0.90000000000000002, 0.50000000000000000, 
 	  0.87266462599716477 },
-  { 1.0716015959755185, -0.90000000000000002, 0.50000000000000000, 
+  { 1.5081455873012106, -0.90000000000000002, 0.50000000000000000, 
 	  1.0471975511965976 },
-  { 1.2857636916026749, -0.90000000000000002, 0.50000000000000000, 
+  { 2.0213599730863998, -0.90000000000000002, 0.50000000000000000, 
 	  1.2217304763960306 },
-  { 1.5264263913252363, -0.90000000000000002, 0.50000000000000000, 
+  { 2.6822467012926827, -0.90000000000000002, 0.50000000000000000, 
 	  1.3962634015954636 },
-  { 1.7888013241937861, -0.90000000000000002, 0.50000000000000000, 
+  { 3.4591069002104677, -0.90000000000000002, 0.50000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler006 = 2.5000000000000020e-13;
 
-// Test data for k=-0.90000000000000002, nu=0.59999999999999998.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.5560830683344639e-16
+// Test data for k=-0.90000000000000002, nu=0.60000000000000009.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 4.0602096790645418e-16
+// mean(f - f_Boost): 1.0269562977782698e-16
+// variance(f - f_Boost): 1.4388836606733082e-32
+// stddev(f - f_Boost): 1.1995347684303728e-16
 const testcase_ellint_3<double>
 data007[10] =
 {
-  { 0.0000000000000000, -0.90000000000000002, 0.59999999999999998, 
+  { 0.0000000000000000, -0.90000000000000002, 0.60000000000000009, 
 	  0.0000000000000000 },
-  { 0.17420100334657812, -0.90000000000000002, 0.59999999999999998, 
+  { 0.17633073723493825, -0.90000000000000002, 0.60000000000000009, 
 	  0.17453292519943295 },
-  { 0.34671975876122157, -0.90000000000000002, 0.59999999999999998, 
+  { 0.36386108723492810, -0.90000000000000002, 0.60000000000000009, 
 	  0.34906585039886590 },
-  { 0.51724631570707946, -0.90000000000000002, 0.59999999999999998, 
+  { 0.57597424744716241, -0.90000000000000002, 0.60000000000000009, 
 	  0.52359877559829882 },
-  { 0.68760879113743023, -0.90000000000000002, 0.59999999999999998, 
+  { 0.83098051948501150, -0.90000000000000002, 0.60000000000000009, 
 	  0.69813170079773179 },
-  { 0.86192157779698364, -0.90000000000000002, 0.59999999999999998, 
+  { 1.1558706545698916, -0.90000000000000002, 0.60000000000000009, 
 	  0.87266462599716477 },
-  { 1.0464279696166354, -0.90000000000000002, 0.59999999999999998, 
+  { 1.5905576379415669, -0.90000000000000002, 0.60000000000000009, 
 	  1.0471975511965976 },
-  { 1.2488156247094007, -0.90000000000000002, 0.59999999999999998, 
+  { 2.1875186010215080, -0.90000000000000002, 0.60000000000000009, 
 	  1.2217304763960306 },
-  { 1.4750988777188472, -0.90000000000000002, 0.59999999999999998, 
+  { 2.9885767771316849, -0.90000000000000002, 0.60000000000000009, 
 	  1.3962634015954636 },
-  { 1.7211781128919523, -0.90000000000000002, 0.59999999999999998, 
+  { 3.9549939883570224, -0.90000000000000002, 0.60000000000000009, 
 	  1.5707963267948966 },
 };
 const double toler007 = 2.5000000000000020e-13;
 
-// Test data for k=-0.90000000000000002, nu=0.69999999999999996.
-// max(|f - f_GSL|): 6.6613381477509392e-16
-// max(|f - f_GSL| / |f_GSL|): 5.4833366769839281e-16
+// Test data for k=-0.90000000000000002, nu=0.70000000000000007.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 5.1938610791060186e-16
+// mean(f - f_Boost): 3.0253577421035517e-16
+// variance(f - f_Boost): 4.2342877557562532e-32
+// stddev(f - f_Boost): 2.0577385051935665e-16
 const testcase_ellint_3<double>
 data008[10] =
 {
-  { 0.0000000000000000, -0.90000000000000002, 0.69999999999999996, 
+  { 0.0000000000000000, -0.90000000000000002, 0.70000000000000007, 
 	  0.0000000000000000 },
-  { 0.17402765093102207, -0.90000000000000002, 0.69999999999999996, 
+  { 0.17651246700160939, -0.90000000000000002, 0.70000000000000007, 
 	  0.17453292519943295 },
-  { 0.34541608382635131, -0.90000000000000002, 0.69999999999999996, 
+  { 0.36542993547358982, -0.90000000000000002, 0.70000000000000007, 
 	  0.34906585039886590 },
-  { 0.51322715827061682, -0.90000000000000002, 0.69999999999999996, 
+  { 0.58199897877674867, -0.90000000000000002, 0.70000000000000007, 
 	  0.52359877559829882 },
-  { 0.67903717872440272, -0.90000000000000002, 0.69999999999999996, 
+  { 0.84815633587352857, -0.90000000000000002, 0.70000000000000007, 
 	  0.69813170079773179 },
-  { 0.84690113601682671, -0.90000000000000002, 0.69999999999999996, 
+  { 1.1985495623872375, -0.90000000000000002, 0.70000000000000007, 
 	  0.87266462599716477 },
-  { 1.0229914311548418, -0.90000000000000002, 0.69999999999999996, 
+  { 1.6892158134027688, -0.90000000000000002, 0.70000000000000007, 
 	  1.0471975511965976 },
-  { 1.2148329639709381, -0.90000000000000002, 0.69999999999999996, 
+  { 2.4029722191094236, -0.90000000000000002, 0.70000000000000007, 
 	  1.2217304763960306 },
-  { 1.4283586501307803, -0.90000000000000002, 0.69999999999999996, 
+  { 3.4201084941340052, -0.90000000000000002, 0.70000000000000007, 
 	  1.3962634015954636 },
-  { 1.6600480747670940, -0.90000000000000002, 0.69999999999999996, 
+  { 4.6985482312992435, -0.90000000000000002, 0.70000000000000007, 
 	  1.5707963267948966 },
 };
 const double toler008 = 2.5000000000000020e-13;
 
 // Test data for k=-0.90000000000000002, nu=0.80000000000000004.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.7525301941362493e-16
+// max(|f - f_Boost|): 2.6645352591003757e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 6.5091520146032660e-16
+// mean(f - f_Boost): 2.8310687127941490e-16
+// variance(f - f_Boost): 9.8950000698295322e-33
+// stddev(f - f_Boost): 9.9473614943006532e-17
 const testcase_ellint_3<double>
 data009[10] =
 {
   { 0.0000000000000000, -0.90000000000000002, 0.80000000000000004, 
 	  0.0000000000000000 },
-  { 0.17385491439925146, -0.90000000000000002, 0.80000000000000004, 
+  { 0.17669487107954862, -0.90000000000000002, 0.80000000000000004, 
 	  0.17453292519943295 },
-  { 0.34412950523113928, -0.90000000000000002, 0.80000000000000004, 
+  { 0.36702314729628421, -0.90000000000000002, 0.80000000000000004, 
 	  0.34906585039886590 },
-  { 0.50931321668729590, -0.90000000000000002, 0.80000000000000004, 
+  { 0.58825099711365492, -0.90000000000000002, 0.80000000000000004, 
 	  0.52359877559829882 },
-  { 0.67081081392296327, -0.90000000000000002, 0.80000000000000004, 
+  { 0.86661711422209031, -0.90000000000000002, 0.80000000000000004, 
 	  0.69813170079773179 },
-  { 0.83268846097293259, -0.90000000000000002, 0.80000000000000004, 
+  { 1.2469779109884802, -0.90000000000000002, 0.80000000000000004, 
 	  0.87266462599716477 },
-  { 1.0010985015814027, -0.90000000000000002, 0.80000000000000004, 
+  { 1.8105469760531578, -0.90000000000000002, 0.80000000000000004, 
 	  1.0471975511965976 },
-  { 1.1834394045489680, -0.90000000000000002, 0.80000000000000004, 
+  { 2.6989505165893752, -0.90000000000000002, 0.80000000000000004, 
 	  1.2217304763960306 },
-  { 1.3855695891683186, -0.90000000000000002, 0.80000000000000004, 
+  { 4.0935213267757424, -0.90000000000000002, 0.80000000000000004, 
 	  1.3962634015954636 },
-  { 1.6044591960982202, -0.90000000000000002, 0.80000000000000004, 
+  { 5.9820740813645710, -0.90000000000000002, 0.80000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler009 = 2.5000000000000020e-13;
 
 // Test data for k=-0.90000000000000002, nu=0.90000000000000002.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.8471853989694167e-16
+// max(|f - f_Boost|): 4.4408920985006262e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 8.2628580104449673e-16
+// mean(f - f_Boost): 8.5764728652293339e-16
+// variance(f - f_Boost): 8.9671393318321280e-31
+// stddev(f - f_Boost): 9.4694980499666013e-16
 const testcase_ellint_3<double>
 data010[10] =
 {
   { 0.0000000000000000, -0.90000000000000002, 0.90000000000000002, 
 	  0.0000000000000000 },
-  { 0.17368278986240135, -0.90000000000000002, 0.90000000000000002, 
+  { 0.17687795394604169, -0.90000000000000002, 0.90000000000000002, 
 	  0.17453292519943295 },
-  { 0.34285962963961397, -0.90000000000000002, 0.90000000000000002, 
+  { 0.36864140434751286, -0.90000000000000002, 0.90000000000000002, 
 	  0.34906585039886590 },
-  { 0.50549974644993312, -0.90000000000000002, 0.90000000000000002, 
+  { 0.59474595366817051, -0.90000000000000002, 0.90000000000000002, 
 	  0.52359877559829882 },
-  { 0.66290623857720876, -0.90000000000000002, 0.90000000000000002, 
+  { 0.88654237226056665, -0.90000000000000002, 0.90000000000000002, 
 	  0.69813170079773179 },
-  { 0.81921183128847175, -0.90000000000000002, 0.90000000000000002, 
+  { 1.3026595810616726, -0.90000000000000002, 0.90000000000000002, 
 	  0.87266462599716477 },
-  { 0.98058481956066390, -0.90000000000000002, 0.90000000000000002, 
+  { 1.9653635459278078, -0.90000000000000002, 0.90000000000000002, 
 	  1.0471975511965976 },
-  { 1.1543223520473569, -0.90000000000000002, 0.90000000000000002, 
+  { 3.1451407527189463, -0.90000000000000002, 0.90000000000000002, 
 	  1.2217304763960306 },
-  { 1.3462119782292938, -0.90000000000000002, 0.90000000000000002, 
+  { 5.3745230680316114, -0.90000000000000002, 0.90000000000000002, 
 	  1.3962634015954636 },
-  { 1.5536420236310946, -0.90000000000000002, 0.90000000000000002, 
+  { 8.9942562031858682, -0.90000000000000002, 0.90000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler010 = 2.5000000000000020e-13;
 
 // Test data for k=-0.80000000000000004, nu=0.0000000000000000.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.1175183168766718e-16
+// max(|f - f_Boost|): 1.5543122344752192e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 7.7898565163847540e-16
+// mean(f - f_Boost): 2.3869795029440865e-16
+// variance(f - f_Boost): 2.1368406725192426e-31
+// stddev(f - f_Boost): 4.6225974002926564e-16
 const testcase_ellint_3<double>
 data011[10] =
 {
@@ -338,289 +370,319 @@ data011[10] =
 	  0.0000000000000000 },
   { 0.17510154241338899, -0.80000000000000004, 0.0000000000000000, 
 	  0.17453292519943295 },
-  { 0.35365068839779390, -0.80000000000000004, 0.0000000000000000, 
+  { 0.35365068839779396, -0.80000000000000004, 0.0000000000000000, 
 	  0.34906585039886590 },
   { 0.53926804409084550, -0.80000000000000004, 0.0000000000000000, 
 	  0.52359877559829882 },
-  { 0.73587926028070361, -0.80000000000000004, 0.0000000000000000, 
+  { 0.73587926028070372, -0.80000000000000004, 0.0000000000000000, 
 	  0.69813170079773179 },
   { 0.94770942970071170, -0.80000000000000004, 0.0000000000000000, 
 	  0.87266462599716477 },
   { 1.1789022995388236, -0.80000000000000004, 0.0000000000000000, 
 	  1.0471975511965976 },
-  { 1.4323027881876009, -0.80000000000000004, 0.0000000000000000, 
+  { 1.4323027881876012, -0.80000000000000004, 0.0000000000000000, 
 	  1.2217304763960306 },
-  { 1.7069629739121674, -0.80000000000000004, 0.0000000000000000, 
+  { 1.7069629739121677, -0.80000000000000004, 0.0000000000000000, 
 	  1.3962634015954636 },
-  { 1.9953027776647296, -0.80000000000000004, 0.0000000000000000, 
+  { 1.9953027776647294, -0.80000000000000004, 0.0000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler011 = 2.5000000000000020e-13;
 
 // Test data for k=-0.80000000000000004, nu=0.10000000000000001.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.1537164503193145e-16
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 8.3898786942190374e-16
+// mean(f - f_Boost): 2.3869795029440865e-16
+// variance(f - f_Boost): 2.9190059990693968e-31
+// stddev(f - f_Boost): 5.4027826155319237e-16
 const testcase_ellint_3<double>
 data012[10] =
 {
   { 0.0000000000000000, -0.80000000000000004, 0.10000000000000001, 
 	  0.0000000000000000 },
-  { 0.17492468824017163, -0.80000000000000004, 0.10000000000000001, 
+  { 0.17527903952342144, -0.80000000000000004, 0.10000000000000001, 
 	  0.17453292519943295 },
-  { 0.35224443521476911, -0.80000000000000004, 0.10000000000000001, 
+  { 0.35507705313548549, -0.80000000000000004, 0.10000000000000001, 
 	  0.34906585039886590 },
-  { 0.53456851853226950, -0.80000000000000004, 0.10000000000000001, 
+  { 0.54411455987643553, -0.80000000000000004, 0.10000000000000001, 
 	  0.52359877559829882 },
-  { 0.72488875602364922, -0.80000000000000004, 0.10000000000000001, 
+  { 0.74745625666804383, -0.80000000000000004, 0.10000000000000001, 
 	  0.69813170079773179 },
-  { 0.92661354274638952, -0.80000000000000004, 0.10000000000000001, 
+  { 0.97046953684238557, -0.80000000000000004, 0.10000000000000001, 
 	  0.87266462599716477 },
-  { 1.1432651144499075, -0.80000000000000004, 0.10000000000000001, 
+  { 1.2183080025184605, -0.80000000000000004, 0.10000000000000001, 
 	  1.0471975511965976 },
-  { 1.3774479927211429, -0.80000000000000004, 0.10000000000000001, 
+  { 1.4943711151994405, -0.80000000000000004, 0.10000000000000001, 
 	  1.2217304763960306 },
-  { 1.6287092337196041, -0.80000000000000004, 0.10000000000000001, 
+  { 1.7972401309544201, -0.80000000000000004, 0.10000000000000001, 
 	  1.3962634015954636 },
-  { 1.8910755418379521, -0.80000000000000004, 0.10000000000000001, 
+  { 2.1172616484005085, -0.80000000000000004, 0.10000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler012 = 2.5000000000000020e-13;
 
 // Test data for k=-0.80000000000000004, nu=0.20000000000000001.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.1894552974436829e-16
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 7.8513740186068518e-16
+// mean(f - f_Boost): 2.8310687127941490e-16
+// variance(f - f_Boost): 2.7528339102381189e-31
+// stddev(f - f_Boost): 5.2467455724840699e-16
 const testcase_ellint_3<double>
 data013[10] =
 {
   { 0.0000000000000000, -0.80000000000000004, 0.20000000000000001, 
 	  0.0000000000000000 },
-  { 0.17474847286224940, -0.80000000000000004, 0.20000000000000001, 
+  { 0.17545718375086419, -0.80000000000000004, 0.20000000000000001, 
 	  0.17453292519943295 },
-  { 0.35085779529084682, -0.80000000000000004, 0.20000000000000001, 
+  { 0.35652404627248163, -0.80000000000000004, 0.20000000000000001, 
 	  0.34906585039886590 },
-  { 0.53000829263059146, -0.80000000000000004, 0.20000000000000001, 
+  { 0.54911638512920913, -0.80000000000000004, 0.20000000000000001, 
 	  0.52359877559829882 },
-  { 0.71443466027453384, -0.80000000000000004, 0.20000000000000001, 
+  { 0.75967684282131176, -0.80000000000000004, 0.20000000000000001, 
 	  0.69813170079773179 },
-  { 0.90698196872715420, -0.80000000000000004, 0.20000000000000001, 
+  { 0.99513526893543769, -0.80000000000000004, 0.20000000000000001, 
 	  0.87266462599716477 },
-  { 1.1108198200558579, -0.80000000000000004, 0.20000000000000001, 
+  { 1.2622192109995993, -0.80000000000000004, 0.20000000000000001, 
 	  1.0471975511965976 },
-  { 1.3284988909963957, -0.80000000000000004, 0.20000000000000001, 
+  { 1.5654106676347741, -0.80000000000000004, 0.20000000000000001, 
 	  1.2217304763960306 },
-  { 1.5600369318140328, -0.80000000000000004, 0.20000000000000001, 
+  { 1.9029531718534984, -0.80000000000000004, 0.20000000000000001, 
 	  1.3962634015954636 },
-  { 1.8007226661734588, -0.80000000000000004, 0.20000000000000001, 
+  { 2.2624789434186798, -0.80000000000000004, 0.20000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler013 = 2.5000000000000020e-13;
 
-// Test data for k=-0.80000000000000004, nu=0.29999999999999999.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.2247517409029886e-16
+// Test data for k=-0.80000000000000004, nu=0.30000000000000004.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 7.2825261583337354e-16
+// mean(f - f_Boost): 2.6367796834847468e-16
+// variance(f - f_Boost): 2.8249350208968825e-31
+// stddev(f - f_Boost): 5.3150117788175054e-16
 const testcase_ellint_3<double>
 data014[10] =
 {
-  { 0.0000000000000000, -0.80000000000000004, 0.29999999999999999, 
+  { 0.0000000000000000, -0.80000000000000004, 0.30000000000000004, 
 	  0.0000000000000000 },
-  { 0.17457289217669889, -0.80000000000000004, 0.29999999999999999, 
+  { 0.17563597931587369, -0.80000000000000004, 0.30000000000000004, 
 	  0.17453292519943295 },
-  { 0.34949028801501258, -0.80000000000000004, 0.29999999999999999, 
+  { 0.35799220412005128, -0.80000000000000004, 0.30000000000000004, 
 	  0.34906585039886590 },
-  { 0.52558024362769307, -0.80000000000000004, 0.29999999999999999, 
+  { 0.55428253691111318, -0.80000000000000004, 0.30000000000000004, 
 	  0.52359877559829882 },
-  { 0.70447281740094891, -0.80000000000000004, 0.29999999999999999, 
+  { 0.77260647376977365, -0.80000000000000004, 0.30000000000000004, 
 	  0.69813170079773179 },
-  { 0.88864745641528986, -0.80000000000000004, 0.29999999999999999, 
+  { 1.0220015271210958, -0.80000000000000004, 0.30000000000000004, 
 	  0.87266462599716477 },
-  { 1.0811075819341462, -0.80000000000000004, 0.29999999999999999, 
+  { 1.3115965312302671, -0.80000000000000004, 0.30000000000000004, 
 	  1.0471975511965976 },
-  { 1.2844589654082377, -0.80000000000000004, 0.29999999999999999, 
+  { 1.6478518468813512, -0.80000000000000004, 0.30000000000000004, 
 	  1.2217304763960306 },
-  { 1.4991461361277847, -0.80000000000000004, 0.29999999999999999, 
+  { 2.0290458414203481, -0.80000000000000004, 0.30000000000000004, 
 	  1.3962634015954636 },
-  { 1.7214611048717301, -0.80000000000000004, 0.29999999999999999, 
+  { 2.4392042002725693, -0.80000000000000004, 0.30000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler014 = 2.5000000000000020e-13;
 
 // Test data for k=-0.80000000000000004, nu=0.40000000000000002.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.2596216594752862e-16
+// max(|f - f_Boost|): 2.2204460492503131e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 8.3462748389836647e-16
+// mean(f - f_Boost): 3.3861802251067273e-16
+// variance(f - f_Boost): 4.3719465706454422e-31
+// stddev(f - f_Boost): 6.6120696991527871e-16
 const testcase_ellint_3<double>
 data015[10] =
 {
   { 0.0000000000000000, -0.80000000000000004, 0.40000000000000002, 
 	  0.0000000000000000 },
-  { 0.17439794211872175, -0.80000000000000004, 0.40000000000000002, 
+  { 0.17581543047866136, -0.80000000000000004, 0.40000000000000002, 
 	  0.17453292519943295 },
-  { 0.34814144964568972, -0.80000000000000004, 0.40000000000000002, 
+  { 0.35948208343061633, -0.80000000000000004, 0.40000000000000002, 
 	  0.34906585039886590 },
-  { 0.52127776285273064, -0.80000000000000004, 0.40000000000000002, 
+  { 0.55962280893702021, -0.80000000000000004, 0.40000000000000002, 
 	  0.52359877559829882 },
-  { 0.69496411438966588, -0.80000000000000004, 0.40000000000000002, 
+  { 0.78632063889234116, -0.80000000000000004, 0.40000000000000002, 
 	  0.69813170079773179 },
-  { 0.87146878427509589, -0.80000000000000004, 0.40000000000000002, 
+  { 1.0514333069550323, -0.80000000000000004, 0.40000000000000002, 
 	  0.87266462599716477 },
-  { 1.0537579024937762, -0.80000000000000004, 0.40000000000000002, 
+  { 1.3677213138838757, -0.80000000000000004, 0.40000000000000002, 
 	  1.0471975511965976 },
-  { 1.2445534387922637, -0.80000000000000004, 0.40000000000000002, 
+  { 1.7451736773665165, -0.80000000000000004, 0.40000000000000002, 
 	  1.2217304763960306 },
-  { 1.4446769766361993, -0.80000000000000004, 0.40000000000000002, 
+  { 2.1830100424586831, -0.80000000000000004, 0.40000000000000002, 
 	  1.3962634015954636 },
-  { 1.6512267838651289, -0.80000000000000004, 0.40000000000000002, 
+  { 2.6604037035529724, -0.80000000000000004, 0.40000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler015 = 2.5000000000000020e-13;
 
 // Test data for k=-0.80000000000000004, nu=0.50000000000000000.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.2940800093915668e-16
+// max(|f - f_Boost|): 2.6645352591003757e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 9.0388243828581744e-16
+// mean(f - f_Boost): 3.8580250105724191e-16
+// variance(f - f_Boost): 6.4106456575047741e-31
+// stddev(f - f_Boost): 8.0066507713929764e-16
 const testcase_ellint_3<double>
 data016[10] =
 {
   { 0.0000000000000000, -0.80000000000000004, 0.50000000000000000, 
 	  0.0000000000000000 },
-  { 0.17422361866118044, -0.80000000000000004, 0.50000000000000000, 
+  { 0.17599554153999472, -0.80000000000000004, 0.50000000000000000, 
 	  0.17453292519943295 },
-  { 0.34681083254170475, -0.80000000000000004, 0.50000000000000000, 
+  { 0.36099426243351540, -0.80000000000000004, 0.50000000000000000, 
 	  0.34906585039886590 },
-  { 0.51709470815494440, -0.80000000000000004, 0.50000000000000000, 
+  { 0.56514786174780673, -0.80000000000000004, 0.50000000000000000, 
 	  0.52359877559829882 },
-  { 0.68587375344080237, -0.80000000000000004, 0.50000000000000000, 
+  { 0.80090697622371010, -0.80000000000000004, 0.50000000000000000, 
 	  0.69813170079773179 },
-  { 0.85532571852810624, -0.80000000000000004, 0.50000000000000000, 
+  { 1.0838891627679339, -0.80000000000000004, 0.50000000000000000, 
 	  0.87266462599716477 },
-  { 1.0284677391874903, -0.80000000000000004, 0.50000000000000000, 
+  { 1.4323506654466280, -0.80000000000000004, 0.50000000000000000, 
 	  1.0471975511965976 },
-  { 1.2081693942686225, -0.80000000000000004, 0.50000000000000000, 
+  { 1.8625761085390575, -0.80000000000000004, 0.50000000000000000, 
 	  1.2217304763960306 },
-  { 1.3955803006426311, -0.80000000000000004, 0.50000000000000000, 
+  { 2.3768757305654766, -0.80000000000000004, 0.50000000000000000, 
 	  1.3962634015954636 },
-  { 1.5884528947755532, -0.80000000000000004, 0.50000000000000000, 
+  { 2.9478781158239746, -0.80000000000000004, 0.50000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler016 = 2.5000000000000020e-13;
 
-// Test data for k=-0.80000000000000004, nu=0.59999999999999998.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.3281408974056389e-16
+// Test data for k=-0.80000000000000004, nu=0.60000000000000009.
+// max(|f - f_Boost|): 3.5527136788005009e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 1.0631099169042069e-15
+// mean(f - f_Boost): 4.8294701571194306e-16
+// variance(f - f_Boost): 1.1633910328160319e-30
+// stddev(f - f_Boost): 1.0786060600682865e-15
 const testcase_ellint_3<double>
 data017[10] =
 {
-  { 0.0000000000000000, -0.80000000000000004, 0.59999999999999998, 
+  { 0.0000000000000000, -0.80000000000000004, 0.60000000000000009, 
 	  0.0000000000000000 },
-  { 0.17404991781414089, -0.80000000000000004, 0.59999999999999998, 
+  { 0.17617631684170665, -0.80000000000000004, 0.60000000000000009, 
 	  0.17453292519943295 },
-  { 0.34549800443625167, -0.80000000000000004, 0.59999999999999998, 
+  { 0.36252934193666231, -0.80000000000000004, 0.60000000000000009, 
 	  0.34906585039886590 },
-  { 0.51302536167001545, -0.80000000000000004, 0.59999999999999998, 
+  { 0.57086932622945163, -0.80000000000000004, 0.60000000000000009, 
 	  0.52359877559829882 },
-  { 0.67717065003912236, -0.80000000000000004, 0.59999999999999998, 
+  { 0.81646796740150973, -0.80000000000000004, 0.60000000000000009, 
 	  0.69813170079773179 },
-  { 0.84011512421134416, -0.80000000000000004, 0.59999999999999998, 
+  { 1.1199552158519064, -0.80000000000000004, 0.60000000000000009, 
 	  0.87266462599716477 },
-  { 1.0049863847088740, -0.80000000000000004, 0.59999999999999998, 
+  { 1.5079766673336394, -0.80000000000000004, 0.60000000000000009, 
 	  1.0471975511965976 },
-  { 1.1748145941898920, -0.80000000000000004, 0.59999999999999998, 
+  { 2.0082747447038165, -0.80000000000000004, 0.60000000000000009, 
 	  1.2217304763960306 },
-  { 1.3510319699755071, -0.80000000000000004, 0.59999999999999998, 
+  { 2.6315146066775523, -0.80000000000000004, 0.60000000000000009, 
 	  1.3962634015954636 },
-  { 1.5319262547427865, -0.80000000000000004, 0.59999999999999998, 
+  { 3.3418121892288051, -0.80000000000000004, 0.60000000000000009, 
 	  1.5707963267948966 },
 };
 const double toler017 = 2.5000000000000020e-13;
 
-// Test data for k=-0.80000000000000004, nu=0.69999999999999996.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 4.3618176466061808e-16
+// Test data for k=-0.80000000000000004, nu=0.70000000000000007.
+// max(|f - f_Boost|): 2.2204460492503131e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 5.6544679145741375e-16
+// mean(f - f_Boost): 3.2751579226442120e-16
+// variance(f - f_Boost): 4.4236851331020672e-31
+// stddev(f - f_Boost): 6.6510789599147505e-16
 const testcase_ellint_3<double>
 data018[10] =
 {
-  { 0.0000000000000000, -0.80000000000000004, 0.69999999999999996, 
+  { 0.0000000000000000, -0.80000000000000004, 0.70000000000000007, 
 	  0.0000000000000000 },
-  { 0.17387683562442199, -0.80000000000000004, 0.69999999999999996, 
+  { 0.17635776076721221, -0.80000000000000004, 0.70000000000000007, 
 	  0.17453292519943295 },
-  { 0.34420254775101611, -0.80000000000000004, 0.69999999999999996, 
+  { 0.36408794649916976, -0.80000000000000004, 0.70000000000000007, 
 	  0.34906585039886590 },
-  { 0.50906439222143673, -0.80000000000000004, 0.69999999999999996, 
+  { 0.57679992290624138, -0.80000000000000004, 0.70000000000000007, 
 	  0.52359877559829882 },
-  { 0.66882693152688422, -0.80000000000000004, 0.69999999999999996, 
+  { 0.83312441418142813, -0.80000000000000004, 0.70000000000000007, 
 	  0.69813170079773179 },
-  { 0.82574792844091316, -0.80000000000000004, 0.69999999999999996, 
+  { 1.1603958891464856, -0.80000000000000004, 0.70000000000000007, 
 	  0.87266462599716477 },
-  { 0.98310431309490931, -0.80000000000000004, 0.69999999999999996, 
+  { 1.5982855143796213, -0.80000000000000004, 0.70000000000000007, 
 	  1.0471975511965976 },
-  { 1.1440884535113258, -0.80000000000000004, 0.69999999999999996, 
+  { 2.1962484408371821, -0.80000000000000004, 0.70000000000000007, 
 	  1.2217304763960306 },
-  { 1.3103743938952537, -0.80000000000000004, 0.69999999999999996, 
+  { 2.9873281786111869, -0.80000000000000004, 0.70000000000000007, 
 	  1.3962634015954636 },
-  { 1.4806912324625332, -0.80000000000000004, 0.69999999999999996, 
+  { 3.9268876980046397, -0.80000000000000004, 0.70000000000000007, 
 	  1.5707963267948966 },
 };
 const double toler018 = 2.5000000000000020e-13;
 
 // Test data for k=-0.80000000000000004, nu=0.80000000000000004.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.3951228558314112e-16
+// max(|f - f_Boost|): 4.4408920985006262e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 9.0176949165011079e-16
+// mean(f - f_Boost): 7.0499162063697436e-16
+// variance(f - f_Boost): 1.7230805408026989e-30
+// stddev(f - f_Boost): 1.3126616246400665e-15
 const testcase_ellint_3<double>
 data019[10] =
 {
   { 0.0000000000000000, -0.80000000000000004, 0.80000000000000004, 
 	  0.0000000000000000 },
-  { 0.17370436817515203, -0.80000000000000004, 0.80000000000000004, 
+  { 0.17653987774203392, -0.80000000000000004, 0.80000000000000004, 
 	  0.17453292519943295 },
-  { 0.34292405894783395, -0.80000000000000004, 0.80000000000000004, 
+  { 0.36567072568046877, -0.80000000000000004, 0.80000000000000004, 
 	  0.34906585039886590 },
-  { 0.50520682176250076, -0.80000000000000004, 0.80000000000000004, 
+  { 0.58295359996558616, -0.80000000000000004, 0.80000000000000004, 
 	  0.52359877559829882 },
-  { 0.66081751679736178, -0.80000000000000004, 0.80000000000000004, 
+  { 0.85101998309176108, -0.80000000000000004, 0.80000000000000004, 
 	  0.69813170079773179 },
-  { 0.81214672249355102, -0.80000000000000004, 0.80000000000000004, 
+  { 1.2062322059736537, -0.80000000000000004, 0.80000000000000004, 
 	  0.87266462599716477 },
-  { 0.96264481387685552, -0.80000000000000004, 0.80000000000000004, 
+  { 1.7090321420917429, -0.80000000000000004, 0.80000000000000004, 
 	  1.0471975511965976 },
-  { 1.1156611352656258, -0.80000000000000004, 0.80000000000000004, 
+  { 2.4529058049405066, -0.80000000000000004, 0.80000000000000004, 
 	  1.2217304763960306 },
-  { 1.2730756225143889, -0.80000000000000004, 0.80000000000000004, 
+  { 3.5368893360106948, -0.80000000000000004, 0.80000000000000004, 
 	  1.3962634015954636 },
-  { 1.4339837018309471, -0.80000000000000004, 0.80000000000000004, 
+  { 4.9246422058196062, -0.80000000000000004, 0.80000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler019 = 2.5000000000000020e-13;
 
 // Test data for k=-0.80000000000000004, nu=0.90000000000000002.
-// max(|f - f_GSL|): 3.3306690738754696e-16
-// max(|f - f_GSL| / |f_GSL|): 4.4280684534289690e-16
+// max(|f - f_Boost|): 4.4408920985006262e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 7.7782721357365268e-16
+// mean(f - f_Boost): 8.9928064994637676e-16
+// variance(f - f_Boost): 1.5485199571025344e-30
+// stddev(f - f_Boost): 1.2443954183066307e-15
 const testcase_ellint_3<double>
 data020[10] =
 {
   { 0.0000000000000000, -0.80000000000000004, 0.90000000000000002, 
 	  0.0000000000000000 },
-  { 0.17353251158533151, -0.80000000000000004, 0.90000000000000002, 
+  { 0.17672267223433513, -0.80000000000000004, 0.90000000000000002, 
 	  0.17453292519943295 },
-  { 0.34166214791545768, -0.80000000000000004, 0.90000000000000002, 
+  { 0.36727835537196063, -0.80000000000000004, 0.90000000000000002, 
 	  0.34906585039886590 },
-  { 0.50144799535130569, -0.80000000000000004, 0.90000000000000002, 
+  { 0.58934569363716649, -0.80000000000000004, 0.90000000000000002, 
 	  0.52359877559829882 },
-  { 0.65311976193814425, -0.80000000000000004, 0.90000000000000002, 
+  { 0.87032723471138851, -0.80000000000000004, 0.90000000000000002, 
 	  0.69813170079773179 },
-  { 0.79924384892320866, -0.80000000000000004, 0.90000000000000002, 
+  { 1.2588676111323349, -0.80000000000000004, 0.90000000000000002, 
 	  0.87266462599716477 },
-  { 0.94345762353365603, -0.80000000000000004, 0.90000000000000002, 
+  { 1.8498731900660019, -0.80000000000000004, 0.90000000000000002, 
 	  1.0471975511965976 },
-  { 1.0892582069219161, -0.80000000000000004, 0.90000000000000002, 
+  { 2.8368381299300420, -0.80000000000000004, 0.90000000000000002, 
 	  1.2217304763960306 },
-  { 1.2387000876610268, -0.80000000000000004, 0.90000000000000002, 
+  { 4.5674844191654058, -0.80000000000000004, 0.90000000000000002, 
 	  1.3962634015954636 },
-  { 1.3911845406776222, -0.80000000000000004, 0.90000000000000002, 
+  { 7.2263259298637115, -0.80000000000000004, 0.90000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler020 = 2.5000000000000020e-13;
 
 // Test data for k=-0.69999999999999996, nu=0.0000000000000000.
-// max(|f - f_GSL|): 3.3306690738754696e-16
-// max(|f - f_GSL| / |f_GSL|): 3.5930208052157665e-16
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 5.5425633303580569e-16
+// mean(f - f_Boost): 7.7715611723760953e-17
+// variance(f - f_Boost): 7.4564398834547797e-34
+// stddev(f - f_Boost): 2.7306482533374340e-17
 const testcase_ellint_3<double>
 data021[10] =
 {
@@ -628,289 +690,319 @@ data021[10] =
 	  0.0000000000000000 },
   { 0.17496737466916723, -0.69999999999999996, 0.0000000000000000, 
 	  0.17453292519943295 },
-  { 0.35254687535677925, -0.69999999999999996, 0.0000000000000000, 
+  { 0.35254687535677931, -0.69999999999999996, 0.0000000000000000, 
 	  0.34906585039886590 },
-  { 0.53536740275997119, -0.69999999999999996, 0.0000000000000000, 
+  { 0.53536740275997130, -0.69999999999999996, 0.0000000000000000, 
 	  0.52359877559829882 },
   { 0.72603797651684454, -0.69999999999999996, 0.0000000000000000, 
 	  0.69813170079773179 },
-  { 0.92698296348313458, -0.69999999999999996, 0.0000000000000000, 
+  { 0.92698296348313447, -0.69999999999999996, 0.0000000000000000, 
 	  0.87266462599716477 },
   { 1.1400447527693316, -0.69999999999999996, 0.0000000000000000, 
 	  1.0471975511965976 },
-  { 1.3657668117194073, -0.69999999999999996, 0.0000000000000000, 
+  { 1.3657668117194071, -0.69999999999999996, 0.0000000000000000, 
 	  1.2217304763960306 },
-  { 1.6024686895959159, -0.69999999999999996, 0.0000000000000000, 
+  { 1.6024686895959162, -0.69999999999999996, 0.0000000000000000, 
 	  1.3962634015954636 },
-  { 1.8456939983747236, -0.69999999999999996, 0.0000000000000000, 
+  { 1.8456939983747234, -0.69999999999999996, 0.0000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler021 = 2.5000000000000020e-13;
 
 // Test data for k=-0.69999999999999996, nu=0.10000000000000001.
-// max(|f - f_GSL|): 3.3306690738754696e-16
-// max(|f - f_GSL| / |f_GSL|): 3.6735282577377367e-16
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 5.2736371663370261e-16
+// mean(f - f_Boost): 8.8817841970012528e-17
+// variance(f - f_Boost): 9.7390235212470591e-34
+// stddev(f - f_Boost): 3.1207408609570677e-17
 const testcase_ellint_3<double>
 data022[10] =
 {
   { 0.0000000000000000, -0.69999999999999996, 0.10000000000000001, 
 	  0.0000000000000000 },
-  { 0.17479076384884684, -0.69999999999999996, 0.10000000000000001, 
+  { 0.17514462737300920, -0.69999999999999996, 0.10000000000000001, 
 	  0.17453292519943295 },
-  { 0.35114844900396364, -0.69999999999999996, 0.10000000000000001, 
+  { 0.35396527997470451, -0.69999999999999996, 0.10000000000000001, 
 	  0.34906585039886590 },
-  { 0.53072776947527001, -0.69999999999999996, 0.10000000000000001, 
+  { 0.54015179589433981, -0.69999999999999996, 0.10000000000000001, 
 	  0.52359877559829882 },
-  { 0.71530198262386235, -0.69999999999999996, 0.10000000000000001, 
+  { 0.73734430854477728, -0.69999999999999996, 0.10000000000000001, 
 	  0.69813170079773179 },
-  { 0.90666760677828306, -0.69999999999999996, 0.10000000000000001, 
+  { 0.94888950796697047, -0.69999999999999996, 0.10000000000000001, 
 	  0.87266462599716477 },
-  { 1.1063366517438080, -0.69999999999999996, 0.10000000000000001, 
+  { 1.1772807959736322, -0.69999999999999996, 0.10000000000000001, 
 	  1.0471975511965976 },
-  { 1.3149477243092149, -0.69999999999999996, 0.10000000000000001, 
+  { 1.4231796401075831, -0.69999999999999996, 0.10000000000000001, 
 	  1.2217304763960306 },
-  { 1.5314886725038925, -0.69999999999999996, 0.10000000000000001, 
+  { 1.6841856799887469, -0.69999999999999996, 0.10000000000000001, 
 	  1.3962634015954636 },
-  { 1.7528050171757608, -0.69999999999999996, 0.10000000000000001, 
+  { 1.9541347343119562, -0.69999999999999996, 0.10000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler022 = 2.5000000000000020e-13;
 
 // Test data for k=-0.69999999999999996, nu=0.20000000000000001.
-// max(|f - f_GSL|): 3.3306690738754696e-16
-// max(|f - f_GSL| / |f_GSL|): 3.7517969287516802e-16
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 4.9907249355047774e-16
+// mean(f - f_Boost): 3.3306690738754695e-17
+// variance(f - f_Boost): 1.3695501826753678e-34
+// stddev(f - f_Boost): 1.1702778228589003e-17
 const testcase_ellint_3<double>
 data023[10] =
 {
   { 0.0000000000000000, -0.69999999999999996, 0.20000000000000001, 
 	  0.0000000000000000 },
-  { 0.17461479077791475, -0.69999999999999996, 0.20000000000000001, 
+  { 0.17532252613350796, -0.69999999999999996, 0.20000000000000001, 
 	  0.17453292519943295 },
-  { 0.34976950621407538, -0.69999999999999996, 0.20000000000000001, 
+  { 0.35540417596807522, -0.69999999999999996, 0.20000000000000001, 
 	  0.34906585039886590 },
-  { 0.52622533231350177, -0.69999999999999996, 0.20000000000000001, 
+  { 0.54508913033361928, -0.69999999999999996, 0.20000000000000001, 
 	  0.52359877559829882 },
-  { 0.70508774017895215, -0.69999999999999996, 0.20000000000000001, 
+  { 0.74927635777718415, -0.69999999999999996, 0.20000000000000001, 
 	  0.69813170079773179 },
-  { 0.88775302531730294, -0.69999999999999996, 0.20000000000000001, 
+  { 0.97261706337936338, -0.69999999999999996, 0.20000000000000001, 
 	  0.87266462599716477 },
-  { 1.0756195476149006, -0.69999999999999996, 0.20000000000000001, 
+  { 1.2187303976209327, -0.69999999999999996, 0.20000000000000001, 
 	  1.0471975511965976 },
-  { 1.2695349716654374, -0.69999999999999996, 0.20000000000000001, 
+  { 1.4887796709222487, -0.69999999999999996, 0.20000000000000001, 
 	  1.2217304763960306 },
-  { 1.4690814617070540, -0.69999999999999996, 0.20000000000000001, 
+  { 1.7796581281839212, -0.69999999999999996, 0.20000000000000001, 
 	  1.3962634015954636 },
-  { 1.6721098780092145, -0.69999999999999996, 0.20000000000000001, 
+  { 2.0829290325820202, -0.69999999999999996, 0.20000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler023 = 2.5000000000000020e-13;
 
-// Test data for k=-0.69999999999999996, nu=0.29999999999999999.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.8280039841080712e-16
+// Test data for k=-0.69999999999999996, nu=0.30000000000000004.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 4.6912897610535316e-16
+// mean(f - f_Boost): 1.6653345369377347e-17
+// variance(f - f_Boost): 2.6207864467918357e-32
+// stddev(f - f_Boost): 1.6188843216214787e-16
 const testcase_ellint_3<double>
 data024[10] =
 {
-  { 0.0000000000000000, -0.69999999999999996, 0.29999999999999999, 
+  { 0.0000000000000000, -0.69999999999999996, 0.30000000000000004, 
 	  0.0000000000000000 },
-  { 0.17443945136076175, -0.69999999999999996, 0.29999999999999999, 
+  { 0.17550107516328570, -0.69999999999999996, 0.30000000000000004, 
 	  0.17453292519943295 },
-  { 0.34840956983535287, -0.69999999999999996, 0.29999999999999999, 
+  { 0.35686409576571959, -0.69999999999999996, 0.30000000000000004, 
 	  0.34906585039886590 },
-  { 0.52185308551329168, -0.69999999999999996, 0.29999999999999999, 
+  { 0.55018827316513352, -0.69999999999999996, 0.30000000000000004, 
 	  0.52359877559829882 },
-  { 0.69535240431168255, -0.69999999999999996, 0.29999999999999999, 
+  { 0.76189759494390275, -0.69999999999999996, 0.30000000000000004, 
 	  0.69813170079773179 },
-  { 0.87007983473964923, -0.69999999999999996, 0.29999999999999999, 
+  { 0.99844623430885615, -0.69999999999999996, 0.30000000000000004, 
 	  0.87266462599716477 },
-  { 1.0474657975577066, -0.69999999999999996, 0.29999999999999999, 
+  { 1.2652862989039833, -0.69999999999999996, 0.30000000000000004, 
 	  1.0471975511965976 },
-  { 1.2286225419931891, -0.69999999999999996, 0.29999999999999999, 
+  { 1.5647666808691361, -0.69999999999999996, 0.30000000000000004, 
 	  1.2217304763960306 },
-  { 1.4136490671013271, -0.69999999999999996, 0.29999999999999999, 
+  { 1.8932499694938163, -0.69999999999999996, 0.30000000000000004, 
 	  1.3962634015954636 },
-  { 1.6011813647733213, -0.69999999999999996, 0.29999999999999999, 
+  { 2.2392290510988535, -0.69999999999999996, 0.30000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler024 = 2.5000000000000020e-13;
 
 // Test data for k=-0.69999999999999996, nu=0.40000000000000002.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.3472957053482092e-16
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 6.5578567644745380e-16
+// mean(f - f_Boost): 1.4710455076283324e-16
+// variance(f - f_Boost): 2.6715739327327140e-33
+// stddev(f - f_Boost): 5.1687270509601433e-17
 const testcase_ellint_3<double>
 data025[10] =
 {
   { 0.0000000000000000, -0.69999999999999996, 0.40000000000000002, 
 	  0.0000000000000000 },
-  { 0.17426474153983229, -0.69999999999999996, 0.40000000000000002, 
+  { 0.17568027871494424, -0.69999999999999996, 0.40000000000000002, 
 	  0.17453292519943295 },
-  { 0.34706817945773732, -0.69999999999999996, 0.40000000000000002, 
+  { 0.35834559208180261, -0.69999999999999996, 0.40000000000000002, 
 	  0.34906585039886590 },
-  { 0.51760452851738148, -0.69999999999999996, 0.40000000000000002, 
+  { 0.55545885451190613, -0.69999999999999996, 0.40000000000000002, 
 	  0.52359877559829882 },
-  { 0.68605801534722755, -0.69999999999999996, 0.40000000000000002, 
+  { 0.77528120402568101, -0.69999999999999996, 0.40000000000000002, 
 	  0.69813170079773179 },
-  { 0.85351339387296532, -0.69999999999999996, 0.40000000000000002, 
+  { 1.0267241287600319, -0.69999999999999996, 0.40000000000000002, 
 	  0.87266462599716477 },
-  { 1.0215297967969539, -0.69999999999999996, 0.40000000000000002, 
+  { 1.3181380338980246, -0.69999999999999996, 0.40000000000000002, 
 	  1.0471975511965976 },
-  { 1.1915051074460530, -0.69999999999999996, 0.40000000000000002, 
+  { 1.6542840785132085, -0.69999999999999996, 0.40000000000000002, 
 	  1.2217304763960306 },
-  { 1.3639821911744707, -0.69999999999999996, 0.40000000000000002, 
+  { 2.0315595131131818, -0.69999999999999996, 0.40000000000000002, 
 	  1.3962634015954636 },
-  { 1.5382162002954762, -0.69999999999999996, 0.40000000000000002, 
+  { 2.4342502915307875, -0.69999999999999996, 0.40000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler025 = 2.5000000000000020e-13;
 
 // Test data for k=-0.69999999999999996, nu=0.50000000000000000.
-// max(|f - f_GSL|): 3.3306690738754696e-16
-// max(|f - f_GSL| / |f_GSL|): 3.9748346743390620e-16
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 6.0416041815443256e-16
+// mean(f - f_Boost): 1.9151347174783951e-16
+// variance(f - f_Boost): 7.8758646268991113e-33
+// stddev(f - f_Boost): 8.8746068233466605e-17
 const testcase_ellint_3<double>
 data026[10] =
 {
   { 0.0000000000000000, -0.69999999999999996, 0.50000000000000000, 
 	  0.0000000000000000 },
-  { 0.17409065729516096, -0.69999999999999996, 0.50000000000000000, 
+  { 0.17586014108156545, -0.69999999999999996, 0.50000000000000000, 
 	  0.17453292519943295 },
-  { 0.34574489064986091, -0.69999999999999996, 0.50000000000000000, 
+  { 0.35984923894341653, -0.69999999999999996, 0.50000000000000000, 
 	  0.34906585039886590 },
-  { 0.51347361925579782, -0.69999999999999996, 0.50000000000000000, 
+  { 0.56091135606739995, -0.69999999999999996, 0.50000000000000000, 
 	  0.52359877559829882 },
-  { 0.67717079489579279, -0.69999999999999996, 0.50000000000000000, 
+  { 0.78951212635197054, -0.69999999999999996, 0.50000000000000000, 
 	  0.69813170079773179 },
-  { 0.83793902055292280, -0.69999999999999996, 0.50000000000000000, 
+  { 1.0578865732938729, -0.69999999999999996, 0.50000000000000000, 
 	  0.87266462599716477 },
-  { 0.99752863545289705, -0.69999999999999996, 0.50000000000000000, 
+  { 1.3789149005151722, -0.69999999999999996, 0.50000000000000000, 
 	  1.0471975511965976 },
-  { 1.1576240080401501, -0.69999999999999996, 0.50000000000000000, 
+  { 1.7620212286086225, -0.69999999999999996, 0.50000000000000000, 
 	  1.2217304763960306 },
-  { 1.3191464023923762, -0.69999999999999996, 0.50000000000000000, 
+  { 2.2051554347435585, -0.69999999999999996, 0.50000000000000000, 
 	  1.3962634015954636 },
-  { 1.4818433192178544, -0.69999999999999996, 0.50000000000000000, 
+  { 2.6868019968236991, -0.69999999999999996, 0.50000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler026 = 2.5000000000000020e-13;
 
-// Test data for k=-0.69999999999999996, nu=0.59999999999999998.
-// max(|f - f_GSL|): 3.3306690738754696e-16
-// max(|f - f_GSL| / |f_GSL|): 4.0457157538295173e-16
+// Test data for k=-0.69999999999999996, nu=0.60000000000000009.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 3.6515644573247170e-16
+// mean(f - f_Boost): 9.9920072216264091e-17
+// variance(f - f_Boost): 1.2325951644078310e-33
+// stddev(f - f_Boost): 3.5108334685767011e-17
 const testcase_ellint_3<double>
 data027[10] =
 {
-  { 0.0000000000000000, -0.69999999999999996, 0.59999999999999998, 
+  { 0.0000000000000000, -0.69999999999999996, 0.60000000000000009, 
 	  0.0000000000000000 },
-  { 0.17391719464391614, -0.69999999999999996, 0.59999999999999998, 
+  { 0.17604066659721918, -0.69999999999999996, 0.60000000000000009, 
 	  0.17453292519943295 },
-  { 0.34443927423869031, -0.69999999999999996, 0.59999999999999998, 
+  { 0.36137563278353424, -0.69999999999999996, 0.60000000000000009, 
 	  0.34906585039886590 },
-  { 0.50945473266486063, -0.69999999999999996, 0.59999999999999998, 
+  { 0.56655721272747606, -0.69999999999999996, 0.60000000000000009, 
 	  0.52359877559829882 },
-  { 0.66866056326513812, -0.69999999999999996, 0.59999999999999998, 
+  { 0.80468966552978305, -0.69999999999999996, 0.60000000000000009, 
 	  0.69813170079773179 },
-  { 0.82325830002337352, -0.69999999999999996, 0.59999999999999998, 
+  { 1.0924902943683852, -0.69999999999999996, 0.60000000000000009, 
 	  0.87266462599716477 },
-  { 0.97522808245669368, -0.69999999999999996, 0.59999999999999998, 
+  { 1.4499247992499797, -0.69999999999999996, 0.60000000000000009, 
 	  1.0471975511965976 },
-  { 1.1265300613705285, -0.69999999999999996, 0.59999999999999998, 
+  { 1.8953714382113815, -0.69999999999999996, 0.60000000000000009, 
 	  1.2217304763960306 },
-  { 1.2784066076152001, -0.69999999999999996, 0.59999999999999998, 
+  { 2.4323229949248670, -0.69999999999999996, 0.60000000000000009, 
 	  1.3962634015954636 },
-  { 1.4309994736080540, -0.69999999999999996, 0.59999999999999998, 
+  { 3.0314573496746742, -0.69999999999999996, 0.60000000000000009, 
 	  1.5707963267948966 },
 };
 const double toler027 = 2.5000000000000020e-13;
 
-// Test data for k=-0.69999999999999996, nu=0.69999999999999996.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 5.4867405596732161e-16
+// Test data for k=-0.69999999999999996, nu=0.70000000000000007.
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 4.8475278552871384e-16
+// mean(f - f_Boost): 9.9920072216264091e-17
+// variance(f - f_Boost): 1.2325951644078310e-33
+// stddev(f - f_Boost): 3.5108334685767011e-17
 const testcase_ellint_3<double>
 data028[10] =
 {
-  { 0.0000000000000000, -0.69999999999999996, 0.69999999999999996, 
+  { 0.0000000000000000, -0.69999999999999996, 0.70000000000000007, 
 	  0.0000000000000000 },
-  { 0.17374434963995031, -0.69999999999999996, 0.69999999999999996, 
+  { 0.17622185963747933, -0.69999999999999996, 0.70000000000000007, 
 	  0.17453292519943295 },
-  { 0.34315091562900674, -0.69999999999999996, 0.69999999999999996, 
+  { 0.36292539360435261, -0.69999999999999996, 0.70000000000000007, 
 	  0.34906585039886590 },
-  { 0.50554262375653347, -0.69999999999999996, 0.69999999999999996, 
+  { 0.57240892970150015, -0.69999999999999996, 0.70000000000000007, 
 	  0.52359877559829882 },
-  { 0.66050025406305801, -0.69999999999999996, 0.69999999999999996, 
+  { 0.82093084713182629, -0.69999999999999996, 0.70000000000000007, 
 	  0.69813170079773179 },
-  { 0.80938620118847404, -0.69999999999999996, 0.69999999999999996, 
+  { 1.1312609022179871, -0.69999999999999996, 0.70000000000000007, 
 	  0.87266462599716477 },
-  { 0.95443223855852144, -0.69999999999999996, 0.69999999999999996, 
+  { 1.5345768067715795, -0.69999999999999996, 0.70000000000000007, 
 	  1.0471975511965976 },
-  { 1.0978573207128304, -0.69999999999999996, 0.69999999999999996, 
+  { 2.0668847445934420, -0.69999999999999996, 0.70000000000000007, 
 	  1.2217304763960306 },
-  { 1.2411754575007123, -0.69999999999999996, 0.69999999999999996, 
+  { 2.7483444537551240, -0.69999999999999996, 0.70000000000000007, 
 	  1.3962634015954636 },
-  { 1.3848459188329196, -0.69999999999999996, 0.69999999999999996, 
+  { 3.5408408771788560, -0.69999999999999996, 0.70000000000000007, 
 	  1.5707963267948966 },
 };
 const double toler028 = 2.5000000000000020e-13;
 
 // Test data for k=-0.69999999999999996, nu=0.80000000000000004.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.1829502028913879e-16
+// max(|f - f_Boost|): 2.2204460492503131e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 6.8664526853112274e-16
+// mean(f - f_Boost): 1.6930901125533636e-16
+// variance(f - f_Boost): 3.5389557150937801e-33
+// stddev(f - f_Boost): 5.9489122661994095e-17
 const testcase_ellint_3<double>
 data029[10] =
 {
   { 0.0000000000000000, -0.69999999999999996, 0.80000000000000004, 
 	  0.0000000000000000 },
-  { 0.17357211837335740, -0.69999999999999996, 0.80000000000000004, 
+  { 0.17640372461994805, -0.69999999999999996, 0.80000000000000004, 
 	  0.17453292519943295 },
-  { 0.34187941416012108, -0.69999999999999996, 0.80000000000000004, 
+  { 0.36449916621651091, -0.69999999999999996, 0.80000000000000004, 
 	  0.34906585039886590 },
-  { 0.50173239465478259, -0.69999999999999996, 0.80000000000000004, 
+  { 0.57848021800372573, -0.69999999999999996, 0.80000000000000004, 
 	  0.52359877559829882 },
-  { 0.65266550725988315, -0.69999999999999996, 0.80000000000000004, 
+  { 0.83837480968392586, -0.69999999999999996, 0.80000000000000004, 
 	  0.69813170079773179 },
-  { 0.79624879865249298, -0.69999999999999996, 0.80000000000000004, 
+  { 1.1751669030061143, -0.69999999999999996, 0.80000000000000004, 
 	  0.87266462599716477 },
-  { 0.93497577043296920, -0.69999999999999996, 0.80000000000000004, 
+  { 1.6381851899173601, -0.69999999999999996, 0.80000000000000004, 
 	  1.0471975511965976 },
-  { 1.0713041566930750, -0.69999999999999996, 0.80000000000000004, 
+  { 2.3002065924302197, -0.69999999999999996, 0.80000000000000004, 
 	  1.2217304763960306 },
-  { 1.2069772023255654, -0.69999999999999996, 0.80000000000000004, 
+  { 3.2337600665337862, -0.69999999999999996, 0.80000000000000004, 
 	  1.3962634015954636 },
-  { 1.3427110650397531, -0.69999999999999996, 0.80000000000000004, 
+  { 4.4042405729076961, -0.69999999999999996, 0.80000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler029 = 2.5000000000000020e-13;
 
 // Test data for k=-0.69999999999999996, nu=0.90000000000000002.
-// max(|f - f_GSL|): 3.3306690738754696e-16
-// max(|f - f_GSL| / |f_GSL|): 4.2494869624129105e-16
+// max(|f - f_Boost|): 3.5527136788005009e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 8.5869439826269878e-16
+// mean(f - f_Boost): 6.7723604502134545e-16
+// variance(f - f_Boost): 4.8757508225668289e-31
+// stddev(f - f_Boost): 6.9826576763914390e-16
 const testcase_ellint_3<double>
 data030[10] =
 {
   { 0.0000000000000000, -0.69999999999999996, 0.90000000000000002, 
 	  0.0000000000000000 },
-  { 0.17340049697003637, -0.69999999999999996, 0.90000000000000002, 
+  { 0.17658626600478800, -0.69999999999999996, 0.90000000000000002, 
 	  0.17453292519943295 },
-  { 0.34062438249741556, -0.69999999999999996, 0.90000000000000002, 
+  { 0.36609762156017206, -0.69999999999999996, 0.90000000000000002, 
 	  0.34906585039886590 },
-  { 0.49801946510076867, -0.69999999999999996, 0.90000000000000002, 
+  { 0.58478615187842409, -0.69999999999999996, 0.90000000000000002, 
 	  0.52359877559829882 },
-  { 0.64513432604750476, -0.69999999999999996, 0.90000000000000002, 
+  { 0.85718862878291846, -0.69999999999999996, 0.90000000000000002, 
 	  0.69813170079773179 },
-  { 0.78378145487573758, -0.69999999999999996, 0.90000000000000002, 
+  { 1.2255385617397643, -0.69999999999999996, 0.90000000000000002, 
 	  0.87266462599716477 },
-  { 0.91671799500854623, -0.69999999999999996, 0.90000000000000002, 
+  { 1.7696521899992939, -0.69999999999999996, 0.90000000000000002, 
 	  1.0471975511965976 },
-  { 1.0466193579463123, -0.69999999999999996, 0.90000000000000002, 
+  { 2.6476314987883502, -0.69999999999999996, 0.90000000000000002, 
 	  1.2217304763960306 },
-  { 1.1754218079199146, -0.69999999999999996, 0.90000000000000002, 
+  { 4.1373434902898083, -0.69999999999999996, 0.90000000000000002, 
 	  1.3962634015954636 },
-  { 1.3040500499695913, -0.69999999999999996, 0.90000000000000002, 
+  { 6.3796094177887746, -0.69999999999999996, 0.90000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler030 = 2.5000000000000020e-13;
 
 // Test data for k=-0.59999999999999998, nu=0.0000000000000000.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 2.8964816695821429e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.3664899092028927e-16
+// mean(f - f_Boost): 5.2735593669694933e-17
+// variance(f - f_Boost): 3.4333862218458872e-34
+// stddev(f - f_Boost): 1.8529398861932589e-17
 const testcase_ellint_3<double>
 data031[10] =
 {
@@ -918,289 +1010,319 @@ data031[10] =
 	  0.0000000000000000 },
   { 0.17485154362988359, -0.59999999999999998, 0.0000000000000000, 
 	  0.17453292519943295 },
-  { 0.35160509865544326, -0.59999999999999998, 0.0000000000000000, 
+  { 0.35160509865544320, -0.59999999999999998, 0.0000000000000000, 
 	  0.34906585039886590 },
   { 0.53210652578446138, -0.59999999999999998, 0.0000000000000000, 
 	  0.52359877559829882 },
   { 0.71805304664485659, -0.59999999999999998, 0.0000000000000000, 
 	  0.69813170079773179 },
-  { 0.91082759030195970, -0.59999999999999998, 0.0000000000000000, 
+  { 0.91082759030195981, -0.59999999999999998, 0.0000000000000000, 
 	  0.87266462599716477 },
   { 1.1112333229323361, -0.59999999999999998, 0.0000000000000000, 
 	  1.0471975511965976 },
   { 1.3191461190365270, -0.59999999999999998, 0.0000000000000000, 
 	  1.2217304763960306 },
-  { 1.5332022105084773, -0.59999999999999998, 0.0000000000000000, 
+  { 1.5332022105084779, -0.59999999999999998, 0.0000000000000000, 
 	  1.3962634015954636 },
-  { 1.7507538029157526, -0.59999999999999998, 0.0000000000000000, 
+  { 1.7507538029157523, -0.59999999999999998, 0.0000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler031 = 2.5000000000000020e-13;
 
 // Test data for k=-0.59999999999999998, nu=0.10000000000000001.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 2.6674242225057385e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.2335247010355137e-16
+// mean(f - f_Boost): 8.6042284408449634e-17
+// variance(f - f_Boost): 2.2835347143080263e-33
+// stddev(f - f_Boost): 4.7786344433405099e-17
 const testcase_ellint_3<double>
 data032[10] =
 {
   { 0.0000000000000000, -0.59999999999999998, 0.10000000000000001, 
 	  0.0000000000000000 },
-  { 0.17467514275022011, -0.59999999999999998, 0.10000000000000001, 
+  { 0.17502858548476194, -0.59999999999999998, 0.10000000000000001, 
 	  0.17453292519943295 },
-  { 0.35021333086258255, -0.59999999999999998, 0.10000000000000001, 
+  { 0.35301673150537388, -0.59999999999999998, 0.10000000000000001, 
 	  0.34906585039886590 },
-  { 0.52751664092962691, -0.59999999999999998, 0.10000000000000001, 
+  { 0.53683932476326812, -0.59999999999999998, 0.10000000000000001, 
 	  0.52359877559829882 },
-  { 0.70752126971957874, -0.59999999999999998, 0.10000000000000001, 
+  { 0.72914228589586771, -0.59999999999999998, 0.10000000000000001, 
 	  0.69813170079773179 },
-  { 0.89111058756112871, -0.59999999999999998, 0.10000000000000001, 
+  { 0.93208036718354692, -0.59999999999999998, 0.10000000000000001, 
 	  0.87266462599716477 },
-  { 1.0789241202877768, -0.59999999999999998, 0.10000000000000001, 
+  { 1.1468984688863377, -0.59999999999999998, 0.10000000000000001, 
 	  1.0471975511965976 },
-  { 1.2710800210399946, -0.59999999999999998, 0.10000000000000001, 
+  { 1.3733904977062528, -0.59999999999999998, 0.10000000000000001, 
 	  1.2217304763960306 },
-  { 1.4669060574440276, -0.59999999999999998, 0.10000000000000001, 
+  { 1.6094225663372157, -0.59999999999999998, 0.10000000000000001, 
 	  1.3962634015954636 },
-  { 1.6648615773343014, -0.59999999999999998, 0.10000000000000001, 
+  { 1.8508766487100685, -0.59999999999999998, 0.10000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler032 = 2.5000000000000020e-13;
 
 // Test data for k=-0.59999999999999998, nu=0.20000000000000001.
-// max(|f - f_GSL|): 6.6613381477509392e-16
-// max(|f - f_GSL| / |f_GSL|): 4.1891472451898755e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.0940560416437693e-16
+// mean(f - f_Boost): 4.1633363423443370e-17
+// variance(f - f_Boost): 8.5834655546147173e-33
+// stddev(f - f_Boost): 9.2646994309662939e-17
 const testcase_ellint_3<double>
 data033[10] =
 {
   { 0.0000000000000000, -0.59999999999999998, 0.20000000000000001, 
 	  0.0000000000000000 },
-  { 0.17449937871800650, -0.59999999999999998, 0.20000000000000001, 
+  { 0.17520627248155893, -0.59999999999999998, 0.20000000000000001, 
 	  0.17453292519943295 },
-  { 0.34884093647346553, -0.59999999999999998, 0.20000000000000001, 
+  { 0.35444873935437748, -0.59999999999999998, 0.20000000000000001, 
 	  0.34906585039886590 },
-  { 0.52306221119844087, -0.59999999999999998, 0.20000000000000001, 
+  { 0.54172310557682524, -0.59999999999999998, 0.20000000000000001, 
 	  0.52359877559829882 },
-  { 0.69749955678982223, -0.59999999999999998, 0.20000000000000001, 
+  { 0.74084300280734672, -0.59999999999999998, 0.20000000000000001, 
 	  0.69813170079773179 },
-  { 0.87274610682416853, -0.59999999999999998, 0.20000000000000001, 
+  { 0.95509001527006121, -0.59999999999999998, 0.20000000000000001, 
 	  0.87266462599716477 },
-  { 1.0494620540750792, -0.59999999999999998, 0.20000000000000001, 
+  { 1.1865688084431796, -0.59999999999999998, 0.20000000000000001, 
 	  1.0471975511965976 },
-  { 1.2280847305507339, -0.59999999999999998, 0.20000000000000001, 
+  { 1.4352978868932598, -0.59999999999999998, 0.20000000000000001, 
 	  1.2217304763960306 },
-  { 1.4085436279696886, -0.59999999999999998, 0.20000000000000001, 
+  { 1.6983400371331816, -0.59999999999999998, 0.20000000000000001, 
 	  1.3962634015954636 },
-  { 1.5901418016279374, -0.59999999999999998, 0.20000000000000001, 
+  { 1.9695980282802215, -0.59999999999999998, 0.20000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler033 = 2.5000000000000020e-13;
 
-// Test data for k=-0.59999999999999998, nu=0.29999999999999999.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 2.9132420715478757e-16
+// Test data for k=-0.59999999999999998, nu=0.30000000000000004.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 2.9470074709717020e-16
+// mean(f - f_Boost): 7.4940054162198071e-17
+// variance(f - f_Boost): 1.6823592487044846e-32
+// stddev(f - f_Boost): 1.2970579203352812e-16
 const testcase_ellint_3<double>
 data034[10] =
 {
-  { 0.0000000000000000, -0.59999999999999998, 0.29999999999999999, 
+  { 0.0000000000000000, -0.59999999999999998, 0.30000000000000004, 
 	  0.0000000000000000 },
-  { 0.17432424744393932, -0.59999999999999998, 0.29999999999999999, 
+  { 0.17538460882640122, -0.59999999999999998, 0.30000000000000004, 
 	  0.17453292519943295 },
-  { 0.34748744127146447, -0.59999999999999998, 0.29999999999999999, 
+  { 0.35590165133735557, -0.59999999999999998, 0.30000000000000004, 
 	  0.34906585039886590 },
-  { 0.51873632743924825, -0.59999999999999998, 0.29999999999999999, 
+  { 0.54676661152254535, -0.59999999999999998, 0.30000000000000004, 
 	  0.52359877559829882 },
-  { 0.68794610396313116, -0.59999999999999998, 0.29999999999999999, 
+  { 0.75321709418305305, -0.59999999999999998, 0.30000000000000004, 
 	  0.69813170079773179 },
-  { 0.85558070175468726, -0.59999999999999998, 0.29999999999999999, 
+  { 0.98012637808992920, -0.59999999999999998, 0.30000000000000004, 
 	  0.87266462599716477 },
-  { 1.0224416343605653, -0.59999999999999998, 0.29999999999999999, 
+  { 1.2310891277158875, -0.59999999999999998, 0.30000000000000004, 
 	  1.0471975511965976 },
-  { 1.1893144457936788, -0.59999999999999998, 0.29999999999999999, 
+  { 1.5069157924585623, -0.59999999999999998, 0.30000000000000004, 
 	  1.2217304763960306 },
-  { 1.3566435377982575, -0.59999999999999998, 0.29999999999999999, 
+  { 1.8039583598337940, -0.59999999999999998, 0.30000000000000004, 
 	  1.3962634015954636 },
-  { 1.5243814243493585, -0.59999999999999998, 0.29999999999999999, 
+  { 2.1134154405060599, -0.59999999999999998, 0.30000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler034 = 2.5000000000000020e-13;
 
 // Test data for k=-0.59999999999999998, nu=0.40000000000000002.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.3897581541285558e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 2.7909659715991921e-16
+// mean(f - f_Boost): -2.7755575615628915e-18
+// variance(f - f_Boost): 2.4044165394594425e-32
+// stddev(f - f_Boost): 1.5506181152880429e-16
 const testcase_ellint_3<double>
 data035[10] =
 {
   { 0.0000000000000000, -0.59999999999999998, 0.40000000000000002, 
 	  0.0000000000000000 },
-  { 0.17414974487670717, -0.59999999999999998, 0.40000000000000002, 
+  { 0.17556359876533037, -0.59999999999999998, 0.40000000000000002, 
 	  0.17453292519943295 },
-  { 0.34615238767335027, -0.59999999999999998, 0.40000000000000002, 
+  { 0.35737601674244679, -0.59999999999999998, 0.40000000000000002, 
 	  0.34906585039886590 },
-  { 0.51453257838108557, -0.59999999999999998, 0.40000000000000002, 
+  { 0.55197933771320218, -0.59999999999999998, 0.40000000000000002, 
 	  0.52359877559829882 },
-  { 0.67882386787534399, -0.59999999999999998, 0.40000000000000002, 
+  { 0.76633591620002894, -0.59999999999999998, 0.40000000000000002, 
 	  0.69813170079773179 },
-  { 0.83948470233173578, -0.59999999999999998, 0.40000000000000002, 
+  { 1.0075231136019616, -0.59999999999999998, 0.40000000000000002, 
 	  0.87266462599716477 },
-  { 0.99753496200073977, -0.59999999999999998, 0.40000000000000002, 
+  { 1.2815842073813450, -0.59999999999999998, 0.40000000000000002, 
 	  1.0471975511965976 },
-  { 1.1541101404388487, -0.59999999999999998, 0.40000000000000002, 
+  { 1.5911666941449827, -0.59999999999999998, 0.40000000000000002, 
 	  1.2217304763960306 },
-  { 1.3100911323398814, -0.59999999999999998, 0.40000000000000002, 
+  { 1.9323227566025762, -0.59999999999999998, 0.40000000000000002, 
 	  1.3962634015954636 },
-  { 1.4659345278069984, -0.59999999999999998, 0.40000000000000002, 
+  { 2.2925036420985130, -0.59999999999999998, 0.40000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler035 = 2.5000000000000020e-13;
 
 // Test data for k=-0.59999999999999998, nu=0.50000000000000000.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.5022138270566200e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 2.6240126899196213e-16
+// mean(f - f_Boost): 9.1593399531575410e-17
+// variance(f - f_Boost): 1.0357223256482469e-33
+// stddev(f - f_Boost): 3.2182640128619758e-17
 const testcase_ellint_3<double>
 data036[10] =
 {
   { 0.0000000000000000, -0.59999999999999998, 0.50000000000000000, 
 	  0.0000000000000000 },
-  { 0.17397586700252807, -0.59999999999999998, 0.50000000000000000, 
+  { 0.17574324658480217, -0.59999999999999998, 0.50000000000000000, 
 	  0.17453292519943295 },
-  { 0.34483533397138516, -0.59999999999999998, 0.50000000000000000, 
+  { 0.35887240603169313, -0.59999999999999998, 0.50000000000000000, 
 	  0.34906585039886590 },
-  { 0.51044500461706477, -0.59999999999999998, 0.50000000000000000, 
+  { 0.55737161826345261, -0.59999999999999998, 0.50000000000000000, 
 	  0.52359877559829882 },
-  { 0.67009988034712664, -0.59999999999999998, 0.50000000000000000, 
+  { 0.78028227313077458, -0.59999999999999998, 0.50000000000000000, 
 	  0.69813170079773179 },
-  { 0.82434762375735193, -0.59999999999999998, 0.50000000000000000, 
+  { 1.0376989776486290, -0.59999999999999998, 0.50000000000000000, 
 	  0.87266462599716477 },
-  { 0.97447346702798998, -0.59999999999999998, 0.50000000000000000, 
+  { 1.3395933991042925, -0.59999999999999998, 0.50000000000000000, 
 	  1.0471975511965976 },
-  { 1.1219494000522143, -0.59999999999999998, 0.50000000000000000, 
+  { 1.6924049626591782, -0.59999999999999998, 0.50000000000000000, 
 	  1.2217304763960306 },
-  { 1.2680242605954484, -0.59999999999999998, 0.50000000000000000, 
+  { 2.0931011856518920, -0.59999999999999998, 0.50000000000000000, 
 	  1.3962634015954636 },
-  { 1.4135484285693078, -0.59999999999999998, 0.50000000000000000, 
+  { 2.5239007084492706, -0.59999999999999998, 0.50000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler036 = 2.5000000000000020e-13;
 
-// Test data for k=-0.59999999999999998, nu=0.59999999999999998.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.2504224329684343e-16
+// Test data for k=-0.59999999999999998, nu=0.60000000000000009.
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.6651378277398083e-16
+// mean(f - f_Boost): 1.1934897514720432e-16
+// variance(f - f_Boost): 1.7585404776158019e-33
+// stddev(f - f_Boost): 4.1934955319110598e-17
 const testcase_ellint_3<double>
 data037[10] =
 {
-  { 0.0000000000000000, -0.59999999999999998, 0.59999999999999998, 
+  { 0.0000000000000000, -0.59999999999999998, 0.60000000000000009, 
 	  0.0000000000000000 },
-  { 0.17380260984469353, -0.59999999999999998, 0.59999999999999998, 
+  { 0.17592355661219386, -0.59999999999999998, 0.60000000000000009, 
 	  0.17453292519943295 },
-  { 0.34353585361777839, -0.59999999999999998, 0.59999999999999998, 
+  { 0.36039141192661606, -0.59999999999999998, 0.60000000000000009, 
 	  0.34906585039886590 },
-  { 0.50646805774321380, -0.59999999999999998, 0.59999999999999998, 
+  { 0.56295472636903854, -0.59999999999999998, 0.60000000000000009, 
 	  0.52359877559829882 },
-  { 0.66174468108625506, -0.59999999999999998, 0.59999999999999998, 
+  { 0.79515295130165986, -0.59999999999999998, 0.60000000000000009, 
 	  0.69813170079773179 },
-  { 0.81007462280278408, -0.59999999999999998, 0.59999999999999998, 
+  { 1.0711886441942242, -0.59999999999999998, 0.60000000000000009, 
 	  0.87266462599716477 },
-  { 0.95303466945718729, -0.59999999999999998, 0.59999999999999998, 
+  { 1.4072952835139891, -0.59999999999999998, 0.60000000000000009, 
 	  1.0471975511965976 },
-  { 1.0924118588677505, -0.59999999999999998, 0.59999999999999998, 
+  { 1.8174863977376825, -0.59999999999999998, 0.60000000000000009, 
 	  1.2217304763960306 },
-  { 1.2297640574847937, -0.59999999999999998, 0.59999999999999998, 
+  { 2.3029921578542232, -0.59999999999999998, 0.60000000000000009, 
 	  1.3962634015954636 },
-  { 1.3662507535812816, -0.59999999999999998, 0.59999999999999998, 
+  { 2.8388723099514972, -0.59999999999999998, 0.60000000000000009, 
 	  1.5707963267948966 },
 };
 const double toler037 = 2.5000000000000020e-13;
 
-// Test data for k=-0.59999999999999998, nu=0.69999999999999996.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.3559889697529752e-16
+// Test data for k=-0.59999999999999998, nu=0.70000000000000007.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 2.2451074234797436e-16
+// mean(f - f_Boost): 5.2735593669694933e-17
+// variance(f - f_Boost): 3.4333862218458872e-34
+// stddev(f - f_Boost): 1.8529398861932589e-17
 const testcase_ellint_3<double>
 data038[10] =
 {
-  { 0.0000000000000000, -0.59999999999999998, 0.69999999999999996, 
+  { 0.0000000000000000, -0.59999999999999998, 0.70000000000000007, 
 	  0.0000000000000000 },
-  { 0.17362996946312007, -0.59999999999999998, 0.69999999999999996, 
+  { 0.17610453321631936, -0.59999999999999998, 0.70000000000000007, 
 	  0.17453292519943295 },
-  { 0.34225353454870588, -0.59999999999999998, 0.69999999999999996, 
+  { 0.36193365056369764, -0.59999999999999998, 0.70000000000000007, 
 	  0.34906585039886590 },
-  { 0.50259656397799524, -0.59999999999999998, 0.69999999999999996, 
+  { 0.56874098962268527, -0.59999999999999998, 0.70000000000000007, 
 	  0.52359877559829882 },
-  { 0.65373184496628933, -0.59999999999999998, 0.69999999999999996, 
+  { 0.81106198671477181, -0.59999999999999998, 0.70000000000000007, 
 	  0.69813170079773179 },
-  { 0.79658372884056439, -0.59999999999999998, 0.69999999999999996, 
+  { 1.1086886419010082, -0.59999999999999998, 0.70000000000000007, 
 	  0.87266462599716477 },
-  { 0.93303240100245421, -0.59999999999999998, 0.69999999999999996, 
+  { 1.4879048567239257, -0.59999999999999998, 0.70000000000000007, 
 	  1.0471975511965976 },
-  { 1.0651547944716557, -0.59999999999999998, 0.69999999999999996, 
+  { 1.9780310073615923, -0.59999999999999998, 0.70000000000000007, 
 	  1.2217304763960306 },
-  { 1.1947676204853441, -0.59999999999999998, 0.69999999999999996, 
+  { 2.5941545586772712, -0.59999999999999998, 0.70000000000000007, 
 	  1.3962634015954636 },
-  { 1.3232737468822813, -0.59999999999999998, 0.69999999999999996, 
+  { 3.3029735898397155, -0.59999999999999998, 0.70000000000000007, 
 	  1.5707963267948966 },
 };
 const double toler038 = 2.5000000000000020e-13;
 
 // Test data for k=-0.59999999999999998, nu=0.80000000000000004.
-// max(|f - f_GSL|): 6.6613381477509392e-16
-// max(|f - f_GSL| / |f_GSL|): 5.1879494682720725e-16
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 4.3826960061025914e-16
+// mean(f - f_Boost): 2.7478019859472625e-16
+// variance(f - f_Boost): 4.6451528105588637e-32
+// stddev(f - f_Boost): 2.1552616570984749e-16
 const testcase_ellint_3<double>
 data039[10] =
 {
   { 0.0000000000000000, -0.59999999999999998, 0.80000000000000004, 
 	  0.0000000000000000 },
-  { 0.17345794195390685, -0.59999999999999998, 0.80000000000000004, 
+  { 0.17628618080795252, -0.59999999999999998, 0.80000000000000004, 
 	  0.17453292519943295 },
-  { 0.34098797854531027, -0.59999999999999998, 0.80000000000000004, 
+  { 0.36349976272521012, -0.59999999999999998, 0.80000000000000004, 
 	  0.34906585039886590 },
-  { 0.49882569168826213, -0.59999999999999998, 0.80000000000000004, 
+  { 0.57474392342151914, -0.59999999999999998, 0.80000000000000004, 
 	  0.52359877559829882 },
-  { 0.64603758566475511, -0.59999999999999998, 0.80000000000000004, 
+  { 0.82814493499158159, -0.59999999999999998, 0.80000000000000004, 
 	  0.69813170079773179 },
-  { 0.78380365594769730, -0.59999999999999998, 0.80000000000000004, 
+  { 1.1511281795998280, -0.59999999999999998, 0.80000000000000004, 
 	  0.87266462599716477 },
-  { 0.91430946255611190, -0.59999999999999998, 0.80000000000000004, 
+  { 1.5864286332503075, -0.59999999999999998, 0.80000000000000004, 
 	  1.0471975511965976 },
-  { 1.0398955217270607, -0.59999999999999998, 0.80000000000000004, 
+  { 2.1958944866494527, -0.59999999999999998, 0.80000000000000004, 
 	  1.2217304763960306 },
-  { 1.1625948314277679, -0.59999999999999998, 0.80000000000000004, 
+  { 3.0398358172574604, -0.59999999999999998, 0.80000000000000004, 
 	  1.3962634015954636 },
-  { 1.2840021261752192, -0.59999999999999998, 0.80000000000000004, 
+  { 4.0867036409261832, -0.59999999999999998, 0.80000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler039 = 2.5000000000000020e-13;
 
 // Test data for k=-0.59999999999999998, nu=0.90000000000000002.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 3.4768329326726447e-16
+// max(|f - f_Boost|): 2.2204460492503131e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 5.7440178400898422e-16
+// mean(f - f_Boost): 5.0792703376600914e-16
+// variance(f - f_Boost): 1.9863137923719990e-31
+// stddev(f - f_Boost): 4.4568080420543122e-16
 const testcase_ellint_3<double>
 data040[10] =
 {
   { 0.0000000000000000, -0.59999999999999998, 0.90000000000000002, 
 	  0.0000000000000000 },
-  { 0.17328652344890030, -0.59999999999999998, 0.90000000000000002, 
+  { 0.17646850384035848, -0.59999999999999998, 0.90000000000000002, 
 	  0.17453292519943295 },
-  { 0.33973880062929018, -0.59999999999999998, 0.90000000000000002, 
+  { 0.36509041515134105, -0.59999999999999998, 0.90000000000000002, 
 	  0.34906585039886590 },
-  { 0.49515092233122743, -0.59999999999999998, 0.90000000000000002, 
+  { 0.58097838596260631, -0.59999999999999998, 0.90000000000000002, 
 	  0.52359877559829882 },
-  { 0.63864042139737043, -0.59999999999999998, 0.90000000000000002, 
+  { 0.84656453396163722, -0.59999999999999998, 0.90000000000000002, 
 	  0.69813170079773179 },
-  { 0.77167205646538850, -0.59999999999999998, 0.90000000000000002, 
+  { 1.1997828426963724, -0.59999999999999998, 0.90000000000000002, 
 	  0.87266462599716477 },
-  { 0.89673202848034383, -0.59999999999999998, 0.90000000000000002, 
+  { 1.7112436789225605, -0.59999999999999998, 0.90000000000000002, 
 	  1.0471975511965976 },
-  { 1.0163984492661304, -0.59999999999999998, 0.90000000000000002, 
+  { 2.5193168553672312, -0.59999999999999998, 0.90000000000000002, 
 	  1.2217304763960306 },
-  { 1.1328845785162431, -0.59999999999999998, 0.90000000000000002, 
+  { 3.8656670488606686, -0.59999999999999998, 0.90000000000000002, 
 	  1.3962634015954636 },
-  { 1.2479362973851875, -0.59999999999999998, 0.90000000000000002, 
+  { 5.8709993116265595, -0.59999999999999998, 0.90000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler040 = 2.5000000000000020e-13;
 
 // Test data for k=-0.50000000000000000, nu=0.0000000000000000.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 3.1201497220602069e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.4551389361831220e-16
+// mean(f - f_Boost): -1.3877787807814457e-17
+// variance(f - f_Boost): 2.5893058141206173e-32
+// stddev(f - f_Boost): 1.6091320064309879e-16
 const testcase_ellint_3<double>
 data041[10] =
 {
@@ -1208,1469 +1330,1619 @@ data041[10] =
 	  0.0000000000000000 },
   { 0.17475385514035785, -0.50000000000000000, 0.0000000000000000, 
 	  0.17453292519943295 },
-  { 0.35081868470101585, -0.50000000000000000, 0.0000000000000000, 
+  { 0.35081868470101579, -0.50000000000000000, 0.0000000000000000, 
 	  0.34906585039886590 },
   { 0.52942862705190574, -0.50000000000000000, 0.0000000000000000, 
 	  0.52359877559829882 },
-  { 0.71164727562630314, -0.50000000000000000, 0.0000000000000000, 
+  { 0.71164727562630326, -0.50000000000000000, 0.0000000000000000, 
 	  0.69813170079773179 },
   { 0.89824523594227768, -0.50000000000000000, 0.0000000000000000, 
 	  0.87266462599716477 },
-  { 1.0895506700518851, -0.50000000000000000, 0.0000000000000000, 
+  { 1.0895506700518853, -0.50000000000000000, 0.0000000000000000, 
 	  1.0471975511965976 },
-  { 1.2853005857432931, -0.50000000000000000, 0.0000000000000000, 
+  { 1.2853005857432933, -0.50000000000000000, 0.0000000000000000, 
 	  1.2217304763960306 },
-  { 1.4845545520549484, -0.50000000000000000, 0.0000000000000000, 
+  { 1.4845545520549488, -0.50000000000000000, 0.0000000000000000, 
 	  1.3962634015954636 },
-  { 1.6857503548125963, -0.50000000000000000, 0.0000000000000000, 
+  { 1.6857503548125961, -0.50000000000000000, 0.0000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler041 = 2.5000000000000020e-13;
 
 // Test data for k=-0.50000000000000000, nu=0.10000000000000001.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 3.1662857256911530e-16
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.7416868347177582e-16
+// mean(f - f_Boost): 2.7755575615628915e-18
+// variance(f - f_Boost): 5.4326441655972001e-32
+// stddev(f - f_Boost): 2.3308033305273100e-16
 const testcase_ellint_3<double>
 data042[10] =
 {
   { 0.0000000000000000, -0.50000000000000000, 0.10000000000000001, 
 	  0.0000000000000000 },
-  { 0.17457763120814676, -0.50000000000000000, 0.10000000000000001, 
+  { 0.17493071928248824, -0.50000000000000000, 0.10000000000000001, 
 	  0.17453292519943295 },
-  { 0.34943246340849154, -0.50000000000000000, 0.10000000000000001, 
+  { 0.35222467688034798, -0.50000000000000000, 0.10000000000000001, 
 	  0.34906585039886590 },
-  { 0.52487937869610790, -0.50000000000000000, 0.10000000000000001, 
+  { 0.53411928652008112, -0.50000000000000000, 0.10000000000000001, 
 	  0.52359877559829882 },
-  { 0.70127785096388384, -0.50000000000000000, 0.10000000000000001, 
+  { 0.72256398117177589, -0.50000000000000000, 0.10000000000000001, 
 	  0.69813170079773179 },
-  { 0.87898815988624479, -0.50000000000000000, 0.10000000000000001, 
+  { 0.91899583232771009, -0.50000000000000000, 0.10000000000000001, 
 	  0.87266462599716477 },
-  { 1.0582764576094172, -0.50000000000000000, 0.10000000000000001, 
+  { 1.1240549163055360, -0.50000000000000000, 0.10000000000000001, 
 	  1.0471975511965976 },
-  { 1.2391936844060205, -0.50000000000000000, 0.10000000000000001, 
+  { 1.3372938086286021, -0.50000000000000000, 0.10000000000000001, 
 	  1.2217304763960306 },
-  { 1.4214793542995841, -0.50000000000000000, 0.10000000000000001, 
+  { 1.5570024469132429, -0.50000000000000000, 0.10000000000000001, 
 	  1.3962634015954636 },
-  { 1.6045524936084892, -0.50000000000000000, 0.10000000000000001, 
+  { 1.7803034946545480, -0.50000000000000000, 0.10000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler042 = 2.5000000000000020e-13;
 
 // Test data for k=-0.50000000000000000, nu=0.20000000000000001.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 3.2114786773102175e-16
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.1198767993730867e-16
+// mean(f - f_Boost): 2.7755575615628914e-17
+// variance(f - f_Boost): 5.0311947683004831e-32
+// stddev(f - f_Boost): 2.2430324938128922e-16
 const testcase_ellint_3<double>
 data043[10] =
 {
   { 0.0000000000000000, -0.50000000000000000, 0.20000000000000001, 
 	  0.0000000000000000 },
-  { 0.17440204336345433, -0.50000000000000000, 0.20000000000000001, 
+  { 0.17510822779582402, -0.50000000000000000, 0.20000000000000001, 
 	  0.17453292519943295 },
-  { 0.34806552388338824, -0.50000000000000000, 0.20000000000000001, 
+  { 0.35365094725531487, -0.50000000000000000, 0.20000000000000001, 
 	  0.34906585039886590 },
-  { 0.52046416757129810, -0.50000000000000000, 0.20000000000000001, 
+  { 0.53895933237328697, -0.50000000000000000, 0.20000000000000001, 
 	  0.52359877559829882 },
-  { 0.69140924550993865, -0.50000000000000000, 0.20000000000000001, 
+  { 0.73408090840070794, -0.50000000000000000, 0.20000000000000001, 
 	  0.69813170079773179 },
-  { 0.86104678636125520, -0.50000000000000000, 0.20000000000000001, 
+  { 0.94145442818535396, -0.50000000000000000, 0.20000000000000001, 
 	  0.87266462599716477 },
-  { 1.0297439459053981, -0.50000000000000000, 0.20000000000000001, 
+  { 1.1624120186296487, -0.50000000000000000, 0.20000000000000001, 
 	  1.0471975511965976 },
-  { 1.1979214112912033, -0.50000000000000000, 0.20000000000000001, 
+  { 1.3965823372867114, -0.50000000000000000, 0.20000000000000001, 
 	  1.2217304763960306 },
-  { 1.3659033858648930, -0.50000000000000000, 0.20000000000000001, 
+  { 1.6414308440430099, -0.50000000000000000, 0.20000000000000001, 
 	  1.3962634015954636 },
-  { 1.5338490483665983, -0.50000000000000000, 0.20000000000000001, 
+  { 1.8922947612264018, -0.50000000000000000, 0.20000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler043 = 2.5000000000000020e-13;
 
-// Test data for k=-0.50000000000000000, nu=0.29999999999999999.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 3.2557837230041312e-16
+// Test data for k=-0.50000000000000000, nu=0.30000000000000004.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.3800262770228813e-16
+// mean(f - f_Boost): 5.8286708792820721e-17
+// variance(f - f_Boost): 8.5027191584278157e-32
+// stddev(f - f_Boost): 2.9159422419567599e-16
 const testcase_ellint_3<double>
 data044[10] =
 {
-  { 0.0000000000000000, -0.50000000000000000, 0.29999999999999999, 
+  { 0.0000000000000000, -0.50000000000000000, 0.30000000000000004, 
 	  0.0000000000000000 },
-  { 0.17422708752228896, -0.50000000000000000, 0.29999999999999999, 
+  { 0.17528638488102041, -0.50000000000000000, 0.30000000000000004, 
 	  0.17453292519943295 },
-  { 0.34671739434855858, -0.50000000000000000, 0.29999999999999999, 
+  { 0.35509802222332720, -0.50000000000000000, 0.30000000000000004, 
 	  0.34906585039886590 },
-  { 0.51617616305641878, -0.50000000000000000, 0.29999999999999999, 
+  { 0.54395740731866193, -0.50000000000000000, 0.30000000000000004, 
 	  0.52359877559829882 },
-  { 0.68200047612545167, -0.50000000000000000, 0.29999999999999999, 
+  { 0.74625871438752667, -0.50000000000000000, 0.30000000000000004, 
 	  0.69813170079773179 },
-  { 0.84427217869498372, -0.50000000000000000, 0.29999999999999999, 
+  { 0.96588271186092023, -0.50000000000000000, 0.30000000000000004, 
 	  0.87266462599716477 },
-  { 1.0035637821389782, -0.50000000000000000, 0.29999999999999999, 
+  { 1.2054319584357329, -0.50000000000000000, 0.30000000000000004, 
 	  1.0471975511965976 },
-  { 1.1606800483933111, -0.50000000000000000, 0.29999999999999999, 
+  { 1.4651077994832871, -0.50000000000000000, 0.30000000000000004, 
 	  1.2217304763960306 },
-  { 1.3164407134643459, -0.50000000000000000, 0.29999999999999999, 
+  { 1.7416018368052644, -0.50000000000000000, 0.30000000000000004, 
 	  1.3962634015954636 },
-  { 1.4715681939859637, -0.50000000000000000, 0.29999999999999999, 
+  { 2.0277924458111314, -0.50000000000000000, 0.30000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler044 = 2.5000000000000020e-13;
 
 // Test data for k=-0.50000000000000000, nu=0.40000000000000002.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 3.2992508582900068e-16
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.0439932918341581e-16
+// mean(f - f_Boost): 3.0531133177191807e-17
+// variance(f - f_Boost): 9.0809736800018602e-32
+// stddev(f - f_Boost): 3.0134653938616686e-16
 const testcase_ellint_3<double>
 data045[10] =
 {
   { 0.0000000000000000, -0.50000000000000000, 0.40000000000000002, 
 	  0.0000000000000000 },
-  { 0.17405275963859917, -0.50000000000000000, 0.40000000000000002, 
+  { 0.17546519477859268, -0.50000000000000000, 0.40000000000000002, 
 	  0.17453292519943295 },
-  { 0.34538761957029329, -0.50000000000000000, 0.40000000000000002, 
+  { 0.35656644822531680, -0.50000000000000000, 0.40000000000000002, 
 	  0.34906585039886590 },
-  { 0.51200902646603907, -0.50000000000000000, 0.40000000000000002, 
+  { 0.54912289677411319, -0.50000000000000000, 0.40000000000000002, 
 	  0.52359877559829882 },
-  { 0.67301522212868792, -0.50000000000000000, 0.40000000000000002, 
+  { 0.75916731611690047, -0.50000000000000000, 0.40000000000000002, 
 	  0.69813170079773179 },
-  { 0.82853844466313320, -0.50000000000000000, 0.40000000000000002, 
+  { 0.99260415631328214, -0.50000000000000000, 0.40000000000000002, 
 	  0.87266462599716477 },
-  { 0.97942097862681488, -0.50000000000000000, 0.40000000000000002, 
+  { 1.2541925856918670, -0.50000000000000000, 0.40000000000000002, 
 	  1.0471975511965976 },
-  { 1.1268429801220614, -0.50000000000000000, 0.40000000000000002, 
+  { 1.5456393705347609, -0.50000000000000000, 0.40000000000000002, 
 	  1.2217304763960306 },
-  { 1.2720406704533922, -0.50000000000000000, 0.40000000000000002, 
+  { 1.8631904972952076, -0.50000000000000000, 0.40000000000000002, 
 	  1.3962634015954636 },
-  { 1.4161679518465340, -0.50000000000000000, 0.40000000000000002, 
+  { 2.1962905366178065, -0.50000000000000000, 0.40000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler045 = 2.5000000000000020e-13;
 
 // Test data for k=-0.50000000000000000, nu=0.50000000000000000.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 3.3419255755184137e-16
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.6797816859260978e-16
+// mean(f - f_Boost): 9.4368957093138303e-17
+// variance(f - f_Boost): 7.7794254682023874e-32
+// stddev(f - f_Boost): 2.7891621444803792e-16
 const testcase_ellint_3<double>
 data046[10] =
 {
   { 0.0000000000000000, -0.50000000000000000, 0.50000000000000000, 
 	  0.0000000000000000 },
-  { 0.17387905570381157, -0.50000000000000000, 0.50000000000000000, 
+  { 0.17564466176941509, -0.50000000000000000, 0.50000000000000000, 
 	  0.17453292519943295 },
-  { 0.34407576010465207, -0.50000000000000000, 0.50000000000000000, 
+  { 0.35805679276065394, -0.50000000000000000, 0.50000000000000000, 
 	  0.34906585039886590 },
-  { 0.50795686560160824, -0.50000000000000000, 0.50000000000000000, 
+  { 0.55446601496200032, -0.50000000000000000, 0.50000000000000000, 
 	  0.52359877559829882 },
-  { 0.66442115453330164, -0.50000000000000000, 0.50000000000000000, 
+  { 0.77288783578259013, -0.50000000000000000, 0.50000000000000000, 
 	  0.69813170079773179 },
-  { 0.81373829119355345, -0.50000000000000000, 0.50000000000000000, 
+  { 1.0220246013918972, -0.50000000000000000, 0.50000000000000000, 
 	  0.87266462599716477 },
-  { 0.95705743313235825, -0.50000000000000000, 0.50000000000000000, 
+  { 1.3101681612463965, -0.50000000000000000, 0.50000000000000000, 
 	  1.0471975511965976 },
-  { 1.0959131991362554, -0.50000000000000000, 0.50000000000000000, 
+  { 1.6422994881851025, -0.50000000000000000, 0.50000000000000000, 
 	  1.2217304763960306 },
-  { 1.2318900529754597, -0.50000000000000000, 0.50000000000000000, 
+  { 2.0152636030998816, -0.50000000000000000, 0.50000000000000000, 
 	  1.3962634015954636 },
-  { 1.3664739530045971, -0.50000000000000000, 0.50000000000000000, 
+  { 2.4136715042011945, -0.50000000000000000, 0.50000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler046 = 2.5000000000000020e-13;
 
-// Test data for k=-0.50000000000000000, nu=0.59999999999999998.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 3.3838494104749599e-16
+// Test data for k=-0.50000000000000000, nu=0.60000000000000009.
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.9178421578645735e-16
+// mean(f - f_Boost): 1.3322676295501878e-16
+// variance(f - f_Boost): 1.7749370367472766e-31
+// stddev(f - f_Boost): 4.2130001622920411e-16
 const testcase_ellint_3<double>
 data047[10] =
 {
-  { 0.0000000000000000, -0.50000000000000000, 0.59999999999999998, 
+  { 0.0000000000000000, -0.50000000000000000, 0.60000000000000009, 
 	  0.0000000000000000 },
-  { 0.17370597174637581, -0.50000000000000000, 0.59999999999999998, 
+  { 0.17582479017522740, -0.50000000000000000, 0.60000000000000009, 
 	  0.17453292519943295 },
-  { 0.34278139158591414, -0.50000000000000000, 0.59999999999999998, 
+  { 0.35956964546660036, -0.50000000000000000, 0.60000000000000009, 
 	  0.34906585039886590 },
-  { 0.50401419439302708, -0.50000000000000000, 0.59999999999999998, 
+  { 0.55999790372984193, -0.50000000000000000, 0.60000000000000009, 
 	  0.52359877559829882 },
-  { 0.65618938076167210, -0.50000000000000000, 0.59999999999999998, 
+  { 0.78751507911209895, -0.50000000000000000, 0.60000000000000009, 
 	  0.69813170079773179 },
-  { 0.79977959248855424, -0.50000000000000000, 0.59999999999999998, 
+  { 1.0546620505035220, -0.50000000000000000, 0.60000000000000009, 
 	  0.87266462599716477 },
-  { 0.93625925190753545, -0.50000000000000000, 0.59999999999999998, 
+  { 1.3754438357425935, -0.50000000000000000, 0.60000000000000009, 
 	  1.0471975511965976 },
-  { 1.0674905658379708, -0.50000000000000000, 0.59999999999999998, 
+  { 1.7615727400820127, -0.50000000000000000, 0.60000000000000009, 
 	  1.2217304763960306 },
-  { 1.1953481298023050, -0.50000000000000000, 0.59999999999999998, 
+  { 2.2134638067565242, -0.50000000000000000, 0.60000000000000009, 
 	  1.3962634015954636 },
-  { 1.3215740290190876, -0.50000000000000000, 0.59999999999999998, 
+  { 2.7090491861753558, -0.50000000000000000, 0.60000000000000009, 
 	  1.5707963267948966 },
 };
 const double toler047 = 2.5000000000000020e-13;
 
-// Test data for k=-0.50000000000000000, nu=0.69999999999999996.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 3.4250604066951477e-16
+// Test data for k=-0.50000000000000000, nu=0.70000000000000007.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.0745105182189226e-16
+// mean(f - f_Boost): 4.1633363423443370e-17
+// variance(f - f_Boost): 1.9996383743576116e-32
+// stddev(f - f_Boost): 1.4140857026211713e-16
 const testcase_ellint_3<double>
 data048[10] =
 {
-  { 0.0000000000000000, -0.50000000000000000, 0.69999999999999996, 
+  { 0.0000000000000000, -0.50000000000000000, 0.70000000000000007, 
 	  0.0000000000000000 },
-  { 0.17353350383131641, -0.50000000000000000, 0.69999999999999996, 
+  { 0.17600558435914915, -0.50000000000000000, 0.70000000000000007, 
 	  0.17453292519943295 },
-  { 0.34150410405436771, -0.50000000000000000, 0.69999999999999996, 
+  { 0.36110561926726259, -0.50000000000000000, 0.70000000000000007, 
 	  0.34906585039886590 },
-  { 0.50017589696443487, -0.50000000000000000, 0.69999999999999996, 
+  { 0.56573074641137111, -0.50000000000000000, 0.70000000000000007, 
 	  0.52359877559829882 },
-  { 0.64829398188419951, -0.50000000000000000, 0.69999999999999996, 
+  { 0.80316073084237205, -0.50000000000000000, 0.70000000000000007, 
 	  0.69813170079773179 },
-  { 0.78658270782402073, -0.50000000000000000, 0.69999999999999996, 
+  { 1.0911910688131461, -0.50000000000000000, 0.70000000000000007, 
 	  0.87266462599716477 },
-  { 0.91684738336675053, -0.50000000000000000, 0.69999999999999996, 
+  { 1.4530946406380640, -0.50000000000000000, 0.70000000000000007, 
 	  1.0471975511965976 },
-  { 1.0412486789555935, -0.50000000000000000, 0.69999999999999996, 
+  { 1.9144386536785372, -0.50000000000000000, 0.70000000000000007, 
 	  1.2217304763960306 },
-  { 1.1619021847612001, -0.50000000000000000, 0.69999999999999996, 
+  { 2.4878788958234970, -0.50000000000000000, 0.70000000000000007, 
 	  1.3962634015954636 },
-  { 1.2807475181182502, -0.50000000000000000, 0.69999999999999996, 
+  { 3.1433945297859225, -0.50000000000000000, 0.70000000000000007, 
 	  1.5707963267948966 },
 };
 const double toler048 = 2.5000000000000020e-13;
 
 // Test data for k=-0.50000000000000000, nu=0.80000000000000004.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.5715240651179632e-16
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.4380477375534667e-16
+// mean(f - f_Boost): 2.3037127760972000e-16
+// variance(f - f_Boost): 1.4989821857033475e-31
+// stddev(f - f_Boost): 3.8716691306248618e-16
 const testcase_ellint_3<double>
 data049[10] =
 {
   { 0.0000000000000000, -0.50000000000000000, 0.80000000000000004, 
 	  0.0000000000000000 },
-  { 0.17336164805979126, -0.50000000000000000, 0.80000000000000004, 
+  { 0.17618704872620228, -0.50000000000000000, 0.80000000000000004, 
 	  0.17453292519943295 },
-  { 0.34024350132086773, -0.50000000000000000, 0.80000000000000004, 
+  { 0.36266535159745827, -0.50000000000000000, 0.80000000000000004, 
 	  0.34906585039886590 },
-  { 0.49643719555734073, -0.50000000000000000, 0.80000000000000004, 
+  { 0.57167789954529158, -0.50000000000000000, 0.80000000000000004, 
 	  0.52359877559829882 },
-  { 0.64071162456976150, -0.50000000000000000, 0.80000000000000004, 
+  { 0.81995752984315018, -0.50000000000000000, 0.80000000000000004, 
 	  0.69813170079773179 },
-  { 0.77407836177211908, -0.50000000000000000, 0.80000000000000004, 
+  { 1.1325112162158122, -0.50000000000000000, 0.80000000000000004, 
 	  0.87266462599716477 },
-  { 0.89867058251905652, -0.50000000000000000, 0.80000000000000004, 
+  { 1.5479055930718042, -0.50000000000000000, 0.80000000000000004, 
 	  1.0471975511965976 },
-  { 1.0169181822134910, -0.50000000000000000, 0.80000000000000004, 
+  { 2.1215243941010486, -0.50000000000000000, 0.80000000000000004, 
 	  1.2217304763960306 },
-  { 1.1311363312779448, -0.50000000000000000, 0.80000000000000004, 
+  { 2.9069405767650132, -0.50000000000000000, 0.80000000000000004, 
 	  1.3962634015954636 },
-  { 1.2434165408189539, -0.50000000000000000, 0.80000000000000004, 
+  { 3.8750701888108066, -0.50000000000000000, 0.80000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler049 = 2.5000000000000020e-13;
 
 // Test data for k=-0.50000000000000000, nu=0.90000000000000002.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.4664649039489274e-16
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.6192315188521289e-16
+// mean(f - f_Boost): 3.5249581031848718e-16
+// variance(f - f_Boost): 2.5029385557256515e-31
+// stddev(f - f_Boost): 5.0029376927217987e-16
 const testcase_ellint_3<double>
 data050[10] =
 {
   { 0.0000000000000000, -0.50000000000000000, 0.90000000000000002, 
 	  0.0000000000000000 },
-  { 0.17319040056865681, -0.50000000000000000, 0.90000000000000002, 
+  { 0.17636918772384180, -0.50000000000000000, 0.90000000000000002, 
 	  0.17453292519943295 },
-  { 0.33899920036578557, -0.50000000000000000, 0.90000000000000002, 
+  { 0.36424950570740700, -0.50000000000000000, 0.90000000000000002, 
 	  0.34906585039886590 },
-  { 0.49279362182695174, -0.50000000000000000, 0.90000000000000002, 
+  { 0.57785404590231426, -0.50000000000000000, 0.90000000000000002, 
 	  0.52359877559829882 },
-  { 0.63342123379746151, -0.50000000000000000, 0.90000000000000002, 
+  { 0.83806480521716531, -0.50000000000000000, 0.90000000000000002, 
 	  0.69813170079773179 },
-  { 0.76220595179550321, -0.50000000000000000, 0.90000000000000002, 
+  { 1.1798568683069752, -0.50000000000000000, 0.90000000000000002, 
 	  0.87266462599716477 },
-  { 0.88160004743532294, -0.50000000000000000, 0.90000000000000002, 
+  { 1.6678766243739607, -0.50000000000000000, 0.90000000000000002, 
 	  1.0471975511965976 },
-  { 0.99427448642310123, -0.50000000000000000, 0.90000000000000002, 
+  { 2.4282976450693483, -0.50000000000000000, 0.90000000000000002, 
 	  1.2217304763960306 },
-  { 1.1027091512470095, -0.50000000000000000, 0.90000000000000002, 
+  { 3.6810787666126656, -0.50000000000000000, 0.90000000000000002, 
 	  1.3962634015954636 },
-  { 1.2091116095504744, -0.50000000000000000, 0.90000000000000002, 
+  { 5.5355132096026454, -0.50000000000000000, 0.90000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler050 = 2.5000000000000020e-13;
 
-// Test data for k=-0.40000000000000002, nu=0.0000000000000000.
-// max(|f - f_GSL|): 6.6613381477509392e-16
-// max(|f - f_GSL| / |f_GSL|): 4.0617918857203532e-16
+// Test data for k=-0.39999999999999991, nu=0.0000000000000000.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.1423314994346225e-16
+// mean(f - f_Boost): 1.9428902930940238e-17
+// variance(f - f_Boost): 2.2263750157116445e-32
+// stddev(f - f_Boost): 1.4921042241450980e-16
 const testcase_ellint_3<double>
 data051[10] =
 {
-  { 0.0000000000000000, -0.40000000000000002, 0.0000000000000000, 
+  { 0.0000000000000000, -0.39999999999999991, 0.0000000000000000, 
 	  0.0000000000000000 },
-  { 0.17467414669441528, -0.40000000000000002, 0.0000000000000000, 
+  { 0.17467414669441528, -0.39999999999999991, 0.0000000000000000, 
 	  0.17453292519943295 },
-  { 0.35018222772483443, -0.40000000000000002, 0.0000000000000000, 
+  { 0.35018222772483443, -0.39999999999999991, 0.0000000000000000, 
 	  0.34906585039886590 },
-  { 0.52729015917508737, -0.40000000000000002, 0.0000000000000000, 
+  { 0.52729015917508748, -0.39999999999999991, 0.0000000000000000, 
 	  0.52359877559829882 },
-  { 0.70662374407341244, -0.40000000000000002, 0.0000000000000000, 
+  { 0.70662374407341244, -0.39999999999999991, 0.0000000000000000, 
 	  0.69813170079773179 },
-  { 0.88859210497602170, -0.40000000000000002, 0.0000000000000000, 
+  { 0.88859210497602159, -0.39999999999999991, 0.0000000000000000, 
 	  0.87266462599716477 },
-  { 1.0733136290471379, -0.40000000000000002, 0.0000000000000000, 
+  { 1.0733136290471381, -0.39999999999999991, 0.0000000000000000, 
 	  1.0471975511965976 },
-  { 1.2605612170157061, -0.40000000000000002, 0.0000000000000000, 
+  { 1.2605612170157066, -0.39999999999999991, 0.0000000000000000, 
 	  1.2217304763960306 },
-  { 1.4497513956433439, -0.40000000000000002, 0.0000000000000000, 
+  { 1.4497513956433439, -0.39999999999999991, 0.0000000000000000, 
 	  1.3962634015954636 },
-  { 1.6399998658645112, -0.40000000000000002, 0.0000000000000000, 
+  { 1.6399998658645112, -0.39999999999999991, 0.0000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler051 = 2.5000000000000020e-13;
 
-// Test data for k=-0.40000000000000002, nu=0.10000000000000001.
-// max(|f - f_GSL|): 6.6613381477509392e-16
-// max(|f - f_GSL| / |f_GSL|): 4.2644663257577874e-16
+// Test data for k=-0.39999999999999991, nu=0.10000000000000001.
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.8489340395463703e-16
+// mean(f - f_Boost): 6.3837823915946496e-17
+// variance(f - f_Boost): 4.4785242050000272e-32
+// stddev(f - f_Boost): 2.1162523963365114e-16
 const testcase_ellint_3<double>
 data052[10] =
 {
-  { 0.0000000000000000, -0.40000000000000002, 0.10000000000000001, 
+  { 0.0000000000000000, -0.39999999999999991, 0.10000000000000001, 
 	  0.0000000000000000 },
-  { 0.17449806706684670, -0.40000000000000002, 0.10000000000000001, 
+  { 0.17485086590796767, -0.39999999999999991, 0.10000000000000001, 
 	  0.17453292519943295 },
-  { 0.34880048623856075, -0.40000000000000002, 0.10000000000000001, 
+  { 0.35158366412506992, -0.39999999999999991, 0.10000000000000001, 
 	  0.34906585039886590 },
-  { 0.52277322065757392, -0.40000000000000002, 0.10000000000000001, 
+  { 0.53194731675711726, -0.39999999999999991, 0.10000000000000001, 
 	  0.52359877559829882 },
-  { 0.69638072056918365, -0.40000000000000002, 0.10000000000000001, 
+  { 0.71740615528010931, -0.39999999999999991, 0.10000000000000001, 
 	  0.69813170079773179 },
-  { 0.86968426619831540, -0.40000000000000002, 0.10000000000000001, 
+  { 0.90896157773487030, -0.39999999999999991, 0.10000000000000001, 
 	  0.87266462599716477 },
-  { 1.0428044206578095, -0.40000000000000002, 0.10000000000000001, 
+  { 1.1069605483834348, -0.39999999999999991, 0.10000000000000001, 
 	  1.0471975511965976 },
-  { 1.2158651158274378, -0.40000000000000002, 0.10000000000000001, 
+  { 1.3109353428823001, -0.39999999999999991, 0.10000000000000001, 
 	  1.2217304763960306 },
-  { 1.3889447129893324, -0.40000000000000002, 0.10000000000000001, 
+  { 1.5195460789903448, -0.39999999999999991, 0.10000000000000001, 
 	  1.3962634015954636 },
-  { 1.5620566886683604, -0.40000000000000002, 0.10000000000000001, 
+  { 1.7306968836847187, -0.39999999999999991, 0.10000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler052 = 2.5000000000000020e-13;
 
-// Test data for k=-0.40000000000000002, nu=0.20000000000000001.
-// max(|f - f_GSL|): 6.6613381477509392e-16
-// max(|f - f_GSL| / |f_GSL|): 4.4583049464169287e-16
+// Test data for k=-0.39999999999999991, nu=0.20000000000000001.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.0467985583872730e-16
+// mean(f - f_Boost): 8.6042284408449634e-17
+// variance(f - f_Boost): 1.5826864298542218e-32
+// stddev(f - f_Boost): 1.2580486595733180e-16
 const testcase_ellint_3<double>
 data053[10] =
 {
-  { 0.0000000000000000, -0.40000000000000002, 0.20000000000000001, 
+  { 0.0000000000000000, -0.39999999999999991, 0.20000000000000001, 
 	  0.0000000000000000 },
-  { 0.17432262290723397, -0.40000000000000002, 0.20000000000000001, 
+  { 0.17502822886437389, -0.39999999999999991, 0.20000000000000001, 
 	  0.17453292519943295 },
-  { 0.34743795258968596, -0.40000000000000002, 0.20000000000000001, 
+  { 0.35300530062530805, -0.39999999999999991, 0.20000000000000001, 
 	  0.34906585039886590 },
-  { 0.51838919472805101, -0.40000000000000002, 0.20000000000000001, 
+  { 0.53675259548210896, -0.39999999999999991, 0.20000000000000001, 
 	  0.52359877559829882 },
-  { 0.68663134739057907, -0.40000000000000002, 0.20000000000000001, 
+  { 0.72878006428676934, -0.39999999999999991, 0.20000000000000001, 
 	  0.69813170079773179 },
-  { 0.85206432981833979, -0.40000000000000002, 0.20000000000000001, 
+  { 0.93100219010583563, -0.39999999999999991, 0.20000000000000001, 
 	  0.87266462599716477 },
-  { 1.0149595349004430, -0.40000000000000002, 0.20000000000000001, 
+  { 1.1443487271187609, -0.39999999999999991, 0.20000000000000001, 
 	  1.0471975511965976 },
-  { 1.1758349405464676, -0.40000000000000002, 0.20000000000000001, 
+  { 1.3683427764108813, -0.39999999999999991, 0.20000000000000001, 
 	  1.2217304763960306 },
-  { 1.3353337673882637, -0.40000000000000002, 0.20000000000000001, 
+  { 1.6008221459300933, -0.39999999999999991, 0.20000000000000001, 
 	  1.3962634015954636 },
-  { 1.4941414344266770, -0.40000000000000002, 0.20000000000000001, 
+  { 1.8380358826317627, -0.39999999999999991, 0.20000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler053 = 2.5000000000000020e-13;
 
-// Test data for k=-0.40000000000000002, nu=0.29999999999999999.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 6.1925080711125793e-16
+// Test data for k=-0.39999999999999991, nu=0.30000000000000004.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 2.9973414591826100e-16
+// mean(f - f_Boost): 8.6042284408449634e-17
+// variance(f - f_Boost): 1.5826864298542218e-32
+// stddev(f - f_Boost): 1.2580486595733180e-16
 const testcase_ellint_3<double>
 data054[10] =
 {
-  { 0.0000000000000000, -0.40000000000000002, 0.29999999999999999, 
+  { 0.0000000000000000, -0.39999999999999991, 0.30000000000000004, 
 	  0.0000000000000000 },
-  { 0.17414781013591540, -0.40000000000000002, 0.29999999999999999, 
+  { 0.17520623975982899, -0.39999999999999991, 0.30000000000000004, 
 	  0.17453292519943295 },
-  { 0.34609415696777285, -0.40000000000000002, 0.29999999999999999, 
+  { 0.35444766141612105, -0.39999999999999991, 0.30000000000000004, 
 	  0.34906585039886590 },
-  { 0.51413131295862535, -0.40000000000000002, 0.29999999999999999, 
+  { 0.54171455841536009, -0.39999999999999991, 0.30000000000000004, 
 	  0.52359877559829882 },
-  { 0.67733527622935630, -0.40000000000000002, 0.29999999999999999, 
+  { 0.74080517001084012, -0.39999999999999991, 0.30000000000000004, 
 	  0.69813170079773179 },
-  { 0.83558675182733266, -0.40000000000000002, 0.29999999999999999, 
+  { 0.95496950509296563, -0.39999999999999991, 0.30000000000000004, 
 	  0.87266462599716477 },
-  { 0.98940140808865906, -0.40000000000000002, 0.29999999999999999, 
+  { 1.1862627879844718, -0.39999999999999991, 0.30000000000000004, 
 	  1.0471975511965976 },
-  { 1.1396968797728058, -0.40000000000000002, 0.29999999999999999, 
+  { 1.4346501803799458, -0.39999999999999991, 0.30000000000000004, 
 	  1.2217304763960306 },
-  { 1.2875920037865090, -0.40000000000000002, 0.29999999999999999, 
+  { 1.6971744798077697, -0.39999999999999991, 0.30000000000000004, 
 	  1.3962634015954636 },
-  { 1.4342789859950078, -0.40000000000000002, 0.29999999999999999, 
+  { 1.9677924132520139, -0.39999999999999991, 0.30000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler054 = 2.5000000000000020e-13;
 
-// Test data for k=-0.40000000000000002, nu=0.40000000000000002.
-// max(|f - f_GSL|): 6.6613381477509392e-16
-// max(|f - f_GSL| / |f_GSL|): 4.8235661108581362e-16
+// Test data for k=-0.39999999999999991, nu=0.40000000000000002.
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 6.2577246923979600e-16
+// mean(f - f_Boost): 1.8596235662471373e-16
+// variance(f - f_Boost): 1.6222417021441306e-31
+// stddev(f - f_Boost): 4.0277061736727151e-16
 const testcase_ellint_3<double>
 data055[10] =
 {
-  { 0.0000000000000000, -0.40000000000000002, 0.40000000000000002, 
+  { 0.0000000000000000, -0.39999999999999991, 0.40000000000000002, 
 	  0.0000000000000000 },
-  { 0.17397362471112707, -0.40000000000000002, 0.40000000000000002, 
+  { 0.17538490283034375, -0.39999999999999991, 0.40000000000000002, 
 	  0.17453292519943295 },
-  { 0.34476864603333196, -0.40000000000000002, 0.40000000000000002, 
+  { 0.35591129064319948, -0.39999999999999991, 0.40000000000000002, 
 	  0.34906585039886590 },
-  { 0.50999329415379346, -0.40000000000000002, 0.40000000000000002, 
+  { 0.54684250413264535, -0.39999999999999991, 0.40000000000000002, 
 	  0.52359877559829882 },
-  { 0.66845674551396006, -0.40000000000000002, 0.40000000000000002, 
+  { 0.75355027742668290, -0.39999999999999991, 0.40000000000000002, 
 	  0.69813170079773179 },
-  { 0.82012848346231748, -0.40000000000000002, 0.40000000000000002, 
+  { 0.98117935026780634, -0.39999999999999991, 0.40000000000000002, 
 	  0.87266462599716477 },
-  { 0.96582449258349057, -0.40000000000000002, 0.40000000000000002, 
+  { 1.2337464222030734, -0.39999999999999991, 0.40000000000000002, 
 	  1.0471975511965976 },
-  { 1.1068473749476286, -0.40000000000000002, 0.40000000000000002, 
+  { 1.5125183419289221, -0.39999999999999991, 0.40000000000000002, 
 	  1.2217304763960306 },
-  { 1.2447132729159989, -0.40000000000000002, 0.40000000000000002, 
+  { 1.8140224451130311, -0.39999999999999991, 0.40000000000000002, 
 	  1.3962634015954636 },
-  { 1.3809986210732901, -0.40000000000000002, 0.40000000000000002, 
+  { 2.1289968719280026, -0.39999999999999991, 0.40000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler055 = 2.5000000000000020e-13;
 
-// Test data for k=-0.40000000000000002, nu=0.50000000000000000.
-// max(|f - f_GSL|): 6.6613381477509392e-16
-// max(|f - f_GSL| / |f_GSL|): 4.9965792755639576e-16
+// Test data for k=-0.39999999999999991, nu=0.50000000000000000.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.8009196014748294e-16
+// mean(f - f_Boost): 1.6375789613221060e-16
+// variance(f - f_Boost): 6.4788283329186610e-32
+// stddev(f - f_Boost): 2.5453542647181080e-16
 const testcase_ellint_3<double>
 data056[10] =
 {
-  { 0.0000000000000000, -0.40000000000000002, 0.50000000000000000, 
+  { 0.0000000000000000, -0.39999999999999991, 0.50000000000000000, 
 	  0.0000000000000000 },
-  { 0.17380006262854136, -0.40000000000000002, 0.50000000000000000, 
+  { 0.17556422235224273, -0.39999999999999991, 0.50000000000000000, 
 	  0.17453292519943295 },
-  { 0.34346098216756610, -0.40000000000000002, 0.50000000000000000, 
+  { 0.35739675341763921, -0.39999999999999991, 0.50000000000000000, 
 	  0.34906585039886590 },
-  { 0.50596929935059420, -0.40000000000000002, 0.50000000000000000, 
+  { 0.55214655195037188, -0.39999999999999991, 0.50000000000000000, 
 	  0.52359877559829882 },
-  { 0.65996392089131251, -0.40000000000000002, 0.50000000000000000, 
+  { 0.76709520942047438, -0.39999999999999991, 0.50000000000000000, 
 	  0.69813170079773179 },
-  { 0.80558463511364786, -0.40000000000000002, 0.50000000000000000, 
+  { 1.0100278761577499, -0.39999999999999991, 0.50000000000000000, 
 	  0.87266462599716477 },
-  { 0.94397834522857704, -0.40000000000000002, 0.50000000000000000, 
+  { 1.2882265661384342, -0.39999999999999991, 0.50000000000000000, 
 	  1.0471975511965976 },
-  { 1.0768075114108115, -0.40000000000000002, 0.50000000000000000, 
+  { 1.6059059780051874, -0.39999999999999991, 0.50000000000000000, 
 	  1.2217304763960306 },
-  { 1.2059184624251333, -0.40000000000000002, 0.50000000000000000, 
+  { 1.9600182740224081, -0.39999999999999991, 0.50000000000000000, 
 	  1.3962634015954636 },
-  { 1.3331797176377398, -0.40000000000000002, 0.50000000000000000, 
+  { 2.3367461373176508, -0.39999999999999991, 0.50000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler056 = 2.5000000000000020e-13;
 
-// Test data for k=-0.40000000000000002, nu=0.59999999999999998.
-// max(|f - f_GSL|): 6.6613381477509392e-16
-// max(|f - f_GSL| / |f_GSL|): 5.1640223038298069e-16
+// Test data for k=-0.39999999999999991, nu=0.60000000000000009.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 2.8411408870840790e-16
+// mean(f - f_Boost): 9.7144514654701197e-17
+// variance(f - f_Boost): 1.4860570558543486e-32
+// stddev(f - f_Boost): 1.2190393988113545e-16
 const testcase_ellint_3<double>
 data057[10] =
 {
-  { 0.0000000000000000, -0.40000000000000002, 0.59999999999999998, 
+  { 0.0000000000000000, -0.39999999999999991, 0.60000000000000009, 
 	  0.0000000000000000 },
-  { 0.17362711992081245, -0.40000000000000002, 0.59999999999999998, 
+  { 0.17574420264267029, -0.39999999999999991, 0.60000000000000009, 
 	  0.17453292519943295 },
-  { 0.34217074276403953, -0.40000000000000002, 0.59999999999999998, 
+  { 0.35890463689046265, -0.39999999999999991, 0.60000000000000009, 
 	  0.34906585039886590 },
-  { 0.50205389185761606, -0.40000000000000002, 0.59999999999999998, 
+  { 0.55763773975194486, -0.39999999999999991, 0.60000000000000009, 
 	  0.52359877559829882 },
-  { 0.65182834920372734, -0.40000000000000002, 0.59999999999999998, 
+  { 0.78153324227761267, -0.39999999999999991, 0.60000000000000009, 
 	  0.69813170079773179 },
-  { 0.79186512820565136, -0.40000000000000002, 0.59999999999999998, 
+  { 1.0420205885765887, -0.39999999999999991, 0.60000000000000009, 
 	  0.87266462599716477 },
-  { 0.92365535916287134, -0.40000000000000002, 0.59999999999999998, 
+  { 1.3517205230381770, -0.39999999999999991, 0.60000000000000009, 
 	  1.0471975511965976 },
-  { 1.0491915663957907, -0.40000000000000002, 0.59999999999999998, 
+  { 1.7210360970313896, -0.39999999999999991, 0.60000000000000009, 
 	  1.2217304763960306 },
-  { 1.1705934291745106, -0.40000000000000002, 0.59999999999999998, 
+  { 2.1500780510169242, -0.39999999999999991, 0.60000000000000009, 
 	  1.3962634015954636 },
-  { 1.2899514672527024, -0.40000000000000002, 0.59999999999999998, 
+  { 2.6186940209850191, -0.39999999999999991, 0.60000000000000009, 
 	  1.5707963267948966 },
 };
 const double toler057 = 2.5000000000000020e-13;
 
-// Test data for k=-0.40000000000000002, nu=0.69999999999999996.
-// max(|f - f_GSL|): 6.6613381477509392e-16
-// max(|f - f_GSL| / |f_GSL|): 5.3264047918332349e-16
+// Test data for k=-0.39999999999999991, nu=0.70000000000000007.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.1553900340611668e-16
+// mean(f - f_Boost): 1.1657341758564144e-16
+// variance(f - f_Boost): 1.3242789405258207e-32
+// stddev(f - f_Boost): 1.1507731924779187e-16
 const testcase_ellint_3<double>
 data058[10] =
 {
-  { 0.0000000000000000, -0.40000000000000002, 0.69999999999999996, 
+  { 0.0000000000000000, -0.39999999999999991, 0.70000000000000007, 
 	  0.0000000000000000 },
-  { 0.17345479265712868, -0.40000000000000002, 0.69999999999999996, 
+  { 0.17592484806010436, -0.39999999999999991, 0.70000000000000007, 
 	  0.17453292519943295 },
-  { 0.34089751955950354, -0.40000000000000002, 0.69999999999999996, 
+  { 0.36043555139631439, -0.39999999999999991, 0.70000000000000007, 
 	  0.34906585039886590 },
-  { 0.49824200167361332, -0.40000000000000002, 0.69999999999999996, 
+  { 0.56332813669944881, -0.39999999999999991, 0.70000000000000007, 
 	  0.52359877559829882 },
-  { 0.64402450341199402, -0.40000000000000002, 0.69999999999999996, 
+  { 0.79697424562157548, -0.39999999999999991, 0.70000000000000007, 
 	  0.69813170079773179 },
-  { 0.77889207804122873, -0.40000000000000002, 0.69999999999999996, 
+  { 1.0778155987523672, -0.39999999999999991, 0.70000000000000007, 
 	  0.87266462599716477 },
-  { 0.90468169720957992, -0.40000000000000002, 0.69999999999999996, 
+  { 1.4272018169896268, -0.39999999999999991, 0.70000000000000007, 
 	  1.0471975511965976 },
-  { 1.0236847823692916, -0.40000000000000002, 0.69999999999999996, 
+  { 1.8684377907453380, -0.39999999999999991, 0.70000000000000007, 
 	  1.2217304763960306 },
-  { 1.1382465247425166, -0.40000000000000002, 0.69999999999999996, 
+  { 2.4128677409207469, -0.39999999999999991, 0.70000000000000007, 
 	  1.3962634015954636 },
-  { 1.2506255923253344, -0.40000000000000002, 0.69999999999999996, 
+  { 3.0327078743873241, -0.39999999999999991, 0.70000000000000007, 
 	  1.5707963267948966 },
 };
 const double toler058 = 2.5000000000000020e-13;
 
-// Test data for k=-0.40000000000000002, nu=0.80000000000000004.
-// max(|f - f_GSL|): 6.6613381477509392e-16
-// max(|f - f_GSL| / |f_GSL|): 6.6611561645571024e-16
+// Test data for k=-0.39999999999999991, nu=0.80000000000000004.
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.5727642219519274e-16
+// mean(f - f_Boost): 2.1926904736346843e-16
+// variance(f - f_Boost): 1.5293405480859847e-31
+// stddev(f - f_Boost): 3.9106783913868252e-16
 const testcase_ellint_3<double>
 data059[10] =
 {
-  { 0.0000000000000000, -0.40000000000000002, 0.80000000000000004, 
+  { 0.0000000000000000, -0.39999999999999991, 0.80000000000000004, 
 	  0.0000000000000000 },
-  { 0.17328307694277154, -0.40000000000000002, 0.80000000000000004, 
+  { 0.17610616300487833, -0.39999999999999991, 0.80000000000000004, 
 	  0.17453292519943295 },
-  { 0.33964091800132007, -0.40000000000000002, 0.80000000000000004, 
+  { 0.36199013167171978, -0.39999999999999991, 0.80000000000000004, 
 	  0.34906585039886590 },
-  { 0.49452889372467440, -0.40000000000000002, 0.80000000000000004, 
+  { 0.56923097361842423, -0.39999999999999991, 0.80000000000000004, 
 	  0.52359877559829882 },
-  { 0.63652940095937316, -0.40000000000000002, 0.80000000000000004, 
+  { 0.81354878456624347, -0.39999999999999991, 0.80000000000000004, 
 	  0.69813170079773179 },
-  { 0.76659772511159097, -0.40000000000000002, 0.80000000000000004, 
+  { 1.1182902719261825, -0.39999999999999991, 0.80000000000000004, 
 	  0.87266462599716477 },
-  { 0.88691047977338111, -0.40000000000000002, 0.80000000000000004, 
+  { 1.5192950589409022, -0.39999999999999991, 0.80000000000000004, 
 	  1.0471975511965976 },
-  { 1.0000273200611638, -0.40000000000000002, 0.80000000000000004, 
+  { 2.0678761710223981, -0.39999999999999991, 0.80000000000000004, 
 	  1.2217304763960306 },
-  { 1.1084787902188009, -0.40000000000000002, 0.80000000000000004, 
+  { 2.8135222249879783, -0.39999999999999991, 0.80000000000000004, 
 	  1.3962634015954636 },
-  { 1.2146499565727209, -0.40000000000000002, 0.80000000000000004, 
+  { 3.7289548002199902, -0.39999999999999991, 0.80000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler059 = 2.5000000000000020e-13;
 
-// Test data for k=-0.40000000000000002, nu=0.90000000000000002.
-// max(|f - f_GSL|): 6.6613381477509392e-16
-// max(|f - f_GSL| / |f_GSL|): 5.6376730823308004e-16
+// Test data for k=-0.39999999999999991, nu=0.90000000000000002.
+// max(|f - f_Boost|): 2.6645352591003757e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 5.0221626338023938e-16
+// mean(f - f_Boost): 4.1910919179599658e-16
+// variance(f - f_Boost): 6.2246150910247033e-31
+// stddev(f - f_Boost): 7.8896229891070860e-16
 const testcase_ellint_3<double>
 data060[10] =
 {
-  { 0.0000000000000000, -0.40000000000000002, 0.90000000000000002, 
+  { 0.0000000000000000, -0.39999999999999991, 0.90000000000000002, 
 	  0.0000000000000000 },
-  { 0.17311196891868127, -0.40000000000000002, 0.90000000000000002, 
+  { 0.17628815191971123, -0.39999999999999991, 0.90000000000000002, 
 	  0.17453292519943295 },
-  { 0.33840055664911906, -0.40000000000000002, 0.90000000000000002, 
+  { 0.36356903815378772, -0.39999999999999991, 0.90000000000000002, 
 	  0.34906585039886590 },
-  { 0.49091013944075329, -0.40000000000000002, 0.90000000000000002, 
+  { 0.57536079447000310, -0.39999999999999991, 0.90000000000000002, 
 	  0.52359877559829882 },
-  { 0.62932228186809580, -0.40000000000000002, 0.90000000000000002, 
+  { 0.83141355850172571, -0.39999999999999991, 0.90000000000000002, 
 	  0.69813170079773179 },
-  { 0.75492278323019801, -0.40000000000000002, 0.90000000000000002, 
+  { 1.1646481598721361, -0.39999999999999991, 0.90000000000000002, 
 	  0.87266462599716477 },
-  { 0.87021659043854294, -0.40000000000000002, 0.90000000000000002, 
+  { 1.6357275034001995, -0.39999999999999991, 0.90000000000000002, 
 	  1.0471975511965976 },
-  { 0.97800245228239246, -0.40000000000000002, 0.90000000000000002, 
+  { 2.3628787566572398, -0.39999999999999991, 0.90000000000000002, 
 	  1.2217304763960306 },
-  { 1.0809625773173697, -0.40000000000000002, 0.90000000000000002, 
+  { 3.5521010369134958, -0.39999999999999991, 0.90000000000000002, 
 	  1.3962634015954636 },
-  { 1.1815758115929846, -0.40000000000000002, 0.90000000000000002, 
+  { 5.3055535102872513, -0.39999999999999991, 0.90000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler060 = 2.5000000000000020e-13;
 
-// Test data for k=-0.30000000000000004, nu=0.0000000000000000.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 6.3361874537309281e-16
+// Test data for k=-0.29999999999999993, nu=0.0000000000000000.
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.2241249691539529e-16
+// mean(f - f_Boost): 4.9960036108132046e-17
+// variance(f - f_Boost): 4.6872855002064458e-32
+// stddev(f - f_Boost): 2.1650139722889657e-16
 const testcase_ellint_3<double>
 data061[10] =
 {
-  { 0.0000000000000000, -0.30000000000000004, 0.0000000000000000, 
+  { 0.0000000000000000, -0.29999999999999993, 0.0000000000000000, 
 	  0.0000000000000000 },
-  { 0.17461228653000099, -0.30000000000000004, 0.0000000000000000, 
+  { 0.17461228653000099, -0.29999999999999993, 0.0000000000000000, 
 	  0.17453292519943295 },
-  { 0.34969146102798415, -0.30000000000000004, 0.0000000000000000, 
+  { 0.34969146102798421, -0.29999999999999993, 0.0000000000000000, 
 	  0.34906585039886590 },
-  { 0.52565822873726320, -0.30000000000000004, 0.0000000000000000, 
+  { 0.52565822873726309, -0.29999999999999993, 0.0000000000000000, 
 	  0.52359877559829882 },
-  { 0.70284226512408532, -0.30000000000000004, 0.0000000000000000, 
+  { 0.70284226512408543, -0.29999999999999993, 0.0000000000000000, 
 	  0.69813170079773179 },
-  { 0.88144139195111182, -0.30000000000000004, 0.0000000000000000, 
+  { 0.88144139195111171, -0.29999999999999993, 0.0000000000000000, 
 	  0.87266462599716477 },
-  { 1.0614897067260520, -0.30000000000000004, 0.0000000000000000, 
+  { 1.0614897067260520, -0.29999999999999993, 0.0000000000000000, 
 	  1.0471975511965976 },
-  { 1.2428416824174218, -0.30000000000000004, 0.0000000000000000, 
+  { 1.2428416824174220, -0.29999999999999993, 0.0000000000000000, 
 	  1.2217304763960306 },
-  { 1.4251795877015927, -0.30000000000000004, 0.0000000000000000, 
+  { 1.4251795877015929, -0.29999999999999993, 0.0000000000000000, 
 	  1.3962634015954636 },
-  { 1.6080486199305128, -0.30000000000000004, 0.0000000000000000, 
+  { 1.6080486199305126, -0.29999999999999993, 0.0000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler061 = 2.5000000000000020e-13;
 
-// Test data for k=-0.30000000000000004, nu=0.10000000000000001.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 6.3908043711907203e-16
+// Test data for k=-0.29999999999999993, nu=0.10000000000000001.
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.1872304407982844e-16
+// mean(f - f_Boost): 9.4368957093138303e-17
+// variance(f - f_Boost): 4.0359883022230488e-32
+// stddev(f - f_Boost): 2.0089769292411121e-16
 const testcase_ellint_3<double>
 data062[10] =
 {
-  { 0.0000000000000000, -0.30000000000000004, 0.10000000000000001, 
+  { 0.0000000000000000, -0.29999999999999993, 0.10000000000000001, 
 	  0.0000000000000000 },
-  { 0.17443631884814376, -0.30000000000000004, 0.10000000000000001, 
+  { 0.17478889331392972, -0.29999999999999993, 0.10000000000000001, 
 	  0.17453292519943295 },
-  { 0.34831316835124926, -0.30000000000000004, 0.10000000000000001, 
+  { 0.35108939018329183, -0.29999999999999993, 0.10000000000000001, 
 	  0.34906585039886590 },
-  { 0.52116586276523857, -0.30000000000000004, 0.10000000000000001, 
+  { 0.53028990896115835, -0.29999999999999993, 0.10000000000000001, 
 	  0.52359877559829882 },
-  { 0.69269385837910036, -0.30000000000000004, 0.10000000000000001, 
+  { 0.71352417052371409, -0.29999999999999993, 0.10000000000000001, 
 	  0.69813170079773179 },
-  { 0.86279023163070856, -0.30000000000000004, 0.10000000000000001, 
+  { 0.90153086032405894, -0.29999999999999993, 0.10000000000000001, 
 	  0.87266462599716477 },
-  { 1.0315321461438263, -0.30000000000000004, 0.10000000000000001, 
+  { 1.0945187977283313, -0.29999999999999993, 0.10000000000000001, 
 	  1.0471975511965976 },
-  { 1.1991449111869024, -0.30000000000000004, 0.10000000000000001, 
+  { 1.2920699268385680, -0.29999999999999993, 0.10000000000000001, 
 	  1.2217304763960306 },
-  { 1.3659561780923213, -0.30000000000000004, 0.10000000000000001, 
+  { 1.4931243665896394, -0.29999999999999993, 0.10000000000000001, 
 	  1.3962634015954636 },
-  { 1.5323534693557528, -0.30000000000000004, 0.10000000000000001, 
+  { 1.6960848815118226, -0.29999999999999993, 0.10000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler062 = 2.5000000000000020e-13;
 
-// Test data for k=-0.30000000000000004, nu=0.20000000000000001.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 6.4447238179454079e-16
+// Test data for k=-0.29999999999999993, nu=0.20000000000000001.
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 6.2247497610332889e-16
+// mean(f - f_Boost): 1.1102230246251565e-16
+// variance(f - f_Boost): 3.8043060629871325e-32
+// stddev(f - f_Boost): 1.9504630380981672e-16
 const testcase_ellint_3<double>
 data063[10] =
 {
-  { 0.0000000000000000, -0.30000000000000004, 0.20000000000000001, 
+  { 0.0000000000000000, -0.29999999999999993, 0.20000000000000001, 
 	  0.0000000000000000 },
-  { 0.17426098615372088, -0.30000000000000004, 0.20000000000000001, 
+  { 0.17496614335337535, -0.29999999999999993, 0.20000000000000001, 
 	  0.17453292519943295 },
-  { 0.34695402664689923, -0.30000000000000004, 0.20000000000000001, 
+  { 0.35250745937139372, -0.29999999999999993, 0.20000000000000001, 
 	  0.34906585039886590 },
-  { 0.51680555567038933, -0.30000000000000004, 0.20000000000000001, 
+  { 0.53506875002836884, -0.29999999999999993, 0.20000000000000001, 
 	  0.52359877559829882 },
-  { 0.68303375225260210, -0.30000000000000004, 0.20000000000000001, 
+  { 0.72479106622248191, -0.29999999999999993, 0.20000000000000001, 
 	  0.69813170079773179 },
-  { 0.84540662891295026, -0.30000000000000004, 0.20000000000000001, 
+  { 0.92326451535891607, -0.29999999999999993, 0.20000000000000001, 
 	  0.87266462599716477 },
-  { 1.0041834051646927, -0.30000000000000004, 0.20000000000000001, 
+  { 1.1312092060698349, -0.29999999999999993, 0.20000000000000001, 
 	  1.0471975511965976 },
-  { 1.1599952702345711, -0.30000000000000004, 0.20000000000000001, 
+  { 1.3481473154592321, -0.29999999999999993, 0.20000000000000001, 
 	  1.2217304763960306 },
-  { 1.3137179520499165, -0.30000000000000004, 0.20000000000000001, 
+  { 1.5722049569662748, -0.29999999999999993, 0.20000000000000001, 
 	  1.3962634015954636 },
-  { 1.4663658145259877, -0.30000000000000004, 0.20000000000000001, 
+  { 1.8002173372290498, -0.29999999999999993, 0.20000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler063 = 2.5000000000000020e-13;
 
-// Test data for k=-0.30000000000000004, nu=0.29999999999999999.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 6.4979715256503266e-16
+// Test data for k=-0.29999999999999993, nu=0.30000000000000004.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 6.1678685180047551e-16
+// mean(f - f_Boost): 1.0547118733938987e-16
+// variance(f - f_Boost): 7.5633408838247182e-32
+// stddev(f - f_Boost): 2.7501528837184157e-16
 const testcase_ellint_3<double>
 data064[10] =
 {
-  { 0.0000000000000000, -0.30000000000000004, 0.29999999999999999, 
+  { 0.0000000000000000, -0.29999999999999993, 0.30000000000000004, 
 	  0.0000000000000000 },
-  { 0.17408628437042842, -0.30000000000000004, 0.29999999999999999, 
+  { 0.17514404084107435, -0.29999999999999993, 0.30000000000000004, 
 	  0.17453292519943295 },
-  { 0.34561356761638401, -0.30000000000000004, 0.29999999999999999, 
+  { 0.35394619108645647, -0.29999999999999993, 0.30000000000000004, 
 	  0.34906585039886590 },
-  { 0.51257058617875850, -0.30000000000000004, 0.29999999999999999, 
+  { 0.54000325463372689, -0.29999999999999993, 0.30000000000000004, 
 	  0.52359877559829882 },
-  { 0.67382207124602878, -0.30000000000000004, 0.29999999999999999, 
+  { 0.73670193794067651, -0.29999999999999993, 0.30000000000000004, 
 	  0.69813170079773179 },
-  { 0.82914751587825131, -0.30000000000000004, 0.29999999999999999, 
+  { 0.94689345491722177, -0.29999999999999993, 0.30000000000000004, 
 	  0.87266462599716477 },
-  { 0.97907434814374938, -0.30000000000000004, 0.29999999999999999, 
+  { 1.1723274608389140, -0.29999999999999993, 0.30000000000000004, 
 	  1.0471975511965976 },
-  { 1.1246399297351584, -0.30000000000000004, 0.29999999999999999, 
+  { 1.4128880552936287, -0.29999999999999993, 0.30000000000000004, 
 	  1.2217304763960306 },
-  { 1.2671793970398149, -0.30000000000000004, 0.29999999999999999, 
+  { 1.6659010047449661, -0.29999999999999993, 0.30000000000000004, 
 	  1.3962634015954636 },
-  { 1.4081767433479091, -0.30000000000000004, 0.29999999999999999, 
+  { 1.9260216862473254, -0.29999999999999993, 0.30000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler064 = 2.5000000000000020e-13;
 
-// Test data for k=-0.30000000000000004, nu=0.40000000000000002.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 6.5505716921759864e-16
+// Test data for k=-0.29999999999999993, nu=0.40000000000000002.
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 6.3983279132797385e-16
+// mean(f - f_Boost): 1.1657341758564144e-16
+// variance(f - f_Boost): 1.8245832308692586e-31
+// stddev(f - f_Boost): 4.2715140534349863e-16
 const testcase_ellint_3<double>
 data065[10] =
 {
-  { 0.0000000000000000, -0.30000000000000004, 0.40000000000000002, 
+  { 0.0000000000000000, -0.29999999999999993, 0.40000000000000002, 
 	  0.0000000000000000 },
-  { 0.17391220945982727, -0.30000000000000004, 0.40000000000000002, 
+  { 0.17532259000954434, -0.29999999999999993, 0.40000000000000002, 
 	  0.17453292519943295 },
-  { 0.34429133937639689, -0.30000000000000004, 0.40000000000000002, 
+  { 0.35540612770983693, -0.29999999999999993, 0.40000000000000002, 
 	  0.34906585039886590 },
-  { 0.50845471668581632, -0.30000000000000004, 0.40000000000000002, 
+  { 0.54510265552938919, -0.29999999999999993, 0.40000000000000002, 
 	  0.52359877559829882 },
-  { 0.66502347027873854, -0.30000000000000004, 0.40000000000000002, 
+  { 0.74932476310965057, -0.29999999999999993, 0.40000000000000002, 
 	  0.69813170079773179 },
-  { 0.81389191978012254, -0.30000000000000004, 0.40000000000000002, 
+  { 0.97272793583093109, -0.29999999999999993, 0.40000000000000002, 
 	  0.87266462599716477 },
-  { 0.95590618002140570, -0.30000000000000004, 0.40000000000000002, 
+  { 1.2188928987074241, -0.29999999999999993, 0.40000000000000002, 
 	  1.0471975511965976 },
-  { 1.0924915195213121, -0.30000000000000004, 0.40000000000000002, 
+  { 1.4888771674085941, -0.29999999999999993, 0.40000000000000002, 
 	  1.2217304763960306 },
-  { 1.2253651604038061, -0.30000000000000004, 0.40000000000000002, 
+  { 1.7794558498219191, -0.29999999999999993, 0.40000000000000002, 
 	  1.3962634015954636 },
-  { 1.3563643538969763, -0.30000000000000004, 0.40000000000000002, 
+  { 2.0822121773175528, -0.29999999999999993, 0.40000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler065 = 2.5000000000000020e-13;
 
-// Test data for k=-0.30000000000000004, nu=0.50000000000000000.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 6.7807908859023716e-16
+// Test data for k=-0.29999999999999993, nu=0.50000000000000000.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 6.0516138451673425e-16
+// mean(f - f_Boost): 4.7184478546569152e-17
+// variance(f - f_Boost): 1.9448563670505968e-32
+// stddev(f - f_Boost): 1.3945810722401896e-16
 const testcase_ellint_3<double>
 data066[10] =
 {
-  { 0.0000000000000000, -0.30000000000000004, 0.50000000000000000, 
+  { 0.0000000000000000, -0.29999999999999993, 0.50000000000000000, 
 	  0.0000000000000000 },
-  { 0.17373875742088232, -0.30000000000000004, 0.50000000000000000, 
+  { 0.17550179513158179, -0.29999999999999993, 0.50000000000000000, 
 	  0.17453292519943295 },
-  { 0.34298690571124157, -0.30000000000000004, 0.50000000000000000, 
+  { 0.35688783251681200, -0.29999999999999993, 0.50000000000000000, 
 	  0.34906585039886590 },
-  { 0.50445214859646936, -0.30000000000000004, 0.50000000000000000, 
+  { 0.55037700010142798, -0.29999999999999993, 0.50000000000000000, 
 	  0.52359877559829882 },
-  { 0.65660648352418516, -0.30000000000000004, 0.50000000000000000, 
+  { 0.76273839789895992, -0.29999999999999993, 0.50000000000000000, 
 	  0.69813170079773179 },
-  { 0.79953670639287289, -0.30000000000000004, 0.50000000000000000, 
+  { 1.0011570518830419, -0.29999999999999993, 0.50000000000000000, 
 	  0.87266462599716477 },
-  { 0.93443393926588536, -0.30000000000000004, 0.50000000000000000, 
+  { 1.2722987414055109, -0.29999999999999993, 0.50000000000000000, 
 	  1.0471975511965976 },
-  { 1.0630838369016911, -0.30000000000000004, 0.50000000000000000, 
+  { 1.5799590511080066, -0.29999999999999993, 0.50000000000000000, 
 	  1.2217304763960306 },
-  { 1.1875197325653029, -0.30000000000000004, 0.50000000000000000, 
+  { 1.9212367220124293, -0.29999999999999993, 0.50000000000000000, 
 	  1.3962634015954636 },
-  { 1.3098448759814962, -0.30000000000000004, 0.50000000000000000, 
+  { 2.2833505881933971, -0.29999999999999993, 0.50000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler066 = 2.5000000000000020e-13;
 
-// Test data for k=-0.30000000000000004, nu=0.59999999999999998.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 7.0057999499931649e-16
+// Test data for k=-0.29999999999999993, nu=0.60000000000000009.
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 5.2121157428443725e-16
+// mean(f - f_Boost): 1.9428902930940239e-16
+// variance(f - f_Boost): 1.5987596229703424e-31
+// stddev(f - f_Boost): 3.9984492281012430e-16
 const testcase_ellint_3<double>
 data067[10] =
 {
-  { 0.0000000000000000, -0.30000000000000004, 0.59999999999999998, 
+  { 0.0000000000000000, -0.29999999999999993, 0.60000000000000009, 
 	  0.0000000000000000 },
-  { 0.17356592428950823, -0.30000000000000004, 0.59999999999999998, 
+  { 0.17568166052076745, -0.29999999999999993, 0.60000000000000009, 
 	  0.17453292519943295 },
-  { 0.34169984536697379, -0.30000000000000004, 0.59999999999999998, 
+  { 0.35839189074731181, -0.29999999999999993, 0.60000000000000009, 
 	  0.34906585039886590 },
-  { 0.50055748266498457, -0.30000000000000004, 0.59999999999999998, 
+  { 0.55583724744367558, -0.29999999999999993, 0.60000000000000009, 
 	  0.52359877559829882 },
-  { 0.64854298527106768, -0.30000000000000004, 0.59999999999999998, 
+  { 0.77703498090888223, -0.29999999999999993, 0.60000000000000009, 
 	  0.69813170079773179 },
-  { 0.78599329284207431, -0.30000000000000004, 0.59999999999999998, 
+  { 1.0326772113675962, -0.29999999999999993, 0.60000000000000009, 
 	  0.87266462599716477 },
-  { 0.91445452089128199, -0.30000000000000004, 0.59999999999999998, 
+  { 1.3345139983717369, -0.29999999999999993, 0.60000000000000009, 
 	  1.0471975511965976 },
-  { 1.0360412952290587, -0.30000000000000004, 0.59999999999999998, 
+  { 1.6921742922838403, -0.29999999999999993, 0.60000000000000009, 
 	  1.2217304763960306 },
-  { 1.1530473919778641, -0.30000000000000004, 0.59999999999999998, 
+  { 2.1056608968472186, -0.29999999999999993, 0.60000000000000009, 
 	  1.3962634015954636 },
-  { 1.2677758800420669, -0.30000000000000004, 0.59999999999999998, 
+  { 2.5560975528589061, -0.29999999999999993, 0.60000000000000009, 
 	  1.5707963267948966 },
 };
 const double toler067 = 2.5000000000000020e-13;
 
-// Test data for k=-0.30000000000000004, nu=0.69999999999999996.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 7.2239502844122443e-16
+// Test data for k=-0.29999999999999993, nu=0.70000000000000007.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 6.0088945789059381e-16
+// mean(f - f_Boost): 1.6653345369377348e-16
+// variance(f - f_Boost): 3.1994213989721786e-31
+// stddev(f - f_Boost): 5.6563428104846852e-16
 const testcase_ellint_3<double>
 data068[10] =
 {
-  { 0.0000000000000000, -0.30000000000000004, 0.69999999999999996, 
+  { 0.0000000000000000, -0.29999999999999993, 0.70000000000000007, 
 	  0.0000000000000000 },
-  { 0.17339370613812224, -0.30000000000000004, 0.69999999999999996, 
+  { 0.17586219053197988, -0.29999999999999993, 0.70000000000000007, 
 	  0.17453292519943295 },
-  { 0.34042975138455933, -0.30000000000000004, 0.69999999999999996, 
+  { 0.35991891074557669, -0.29999999999999993, 0.70000000000000007, 
 	  0.34906585039886590 },
-  { 0.49676568368075985, -0.30000000000000004, 0.69999999999999996, 
+  { 0.56149538019961731, -0.29999999999999993, 0.70000000000000007, 
 	  0.52359877559829882 },
-  { 0.64080774055753720, -0.30000000000000004, 0.69999999999999996, 
+  { 0.79232303189667685, -0.29999999999999993, 0.70000000000000007, 
 	  0.69813170079773179 },
-  { 0.77318507779667278, -0.30000000000000004, 0.69999999999999996, 
+  { 1.0679345542878826, -0.29999999999999993, 0.70000000000000007, 
 	  0.87266462599716477 },
-  { 0.89579782346548609, -0.30000000000000004, 0.69999999999999996, 
+  { 1.4084400085913955, -0.29999999999999993, 0.70000000000000007, 
 	  1.0471975511965976 },
-  { 1.0110573286052202, -0.30000000000000004, 0.69999999999999996, 
+  { 1.8357382859296454, -0.29999999999999993, 0.70000000000000007, 
 	  1.2217304763960306 },
-  { 1.1214710972949635, -0.30000000000000004, 0.69999999999999996, 
+  { 2.3604197996171519, -0.29999999999999993, 0.70000000000000007, 
 	  1.3962634015954636 },
-  { 1.2294913236274982, -0.30000000000000004, 0.69999999999999996, 
+  { 2.9562123549913872, -0.29999999999999993, 0.70000000000000007, 
 	  1.5707963267948966 },
 };
 const double toler068 = 2.5000000000000020e-13;
 
-// Test data for k=-0.30000000000000004, nu=0.80000000000000004.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 7.4358357000101250e-16
+// Test data for k=-0.29999999999999993, nu=0.80000000000000004.
+// max(|f - f_Boost|): 2.2204460492503131e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 6.1197887707781618e-16
+// mean(f - f_Boost): 3.4416913763379854e-16
+// variance(f - f_Boost): 4.3461914185990199e-31
+// stddev(f - f_Boost): 6.5925650687718054e-16
 const testcase_ellint_3<double>
 data069[10] =
 {
-  { 0.0000000000000000, -0.30000000000000004, 0.80000000000000004, 
+  { 0.0000000000000000, -0.29999999999999993, 0.80000000000000004, 
 	  0.0000000000000000 },
-  { 0.17322209907520358, -0.30000000000000004, 0.80000000000000004, 
+  { 0.17604338956191670, -0.29999999999999993, 0.80000000000000004, 
 	  0.17453292519943295 },
-  { 0.33917623046949996, -0.30000000000000004, 0.80000000000000004, 
+  { 0.36146952517410791, -0.29999999999999993, 0.80000000000000004, 
 	  0.34906585039886590 },
-  { 0.49307204894329176, -0.30000000000000004, 0.80000000000000004, 
+  { 0.56736453393774644, -0.29999999999999993, 0.80000000000000004, 
 	  0.52359877559829882 },
-  { 0.63337802830291734, -0.30000000000000004, 0.80000000000000004, 
+  { 0.80873149979001091, -0.29999999999999993, 0.80000000000000004, 
 	  0.69813170079773179 },
-  { 0.76104540997689407, -0.30000000000000004, 0.80000000000000004, 
+  { 1.1077903069860620, -0.29999999999999993, 0.80000000000000004, 
 	  0.87266462599716477 },
-  { 0.87832009635450714, -0.30000000000000004, 0.80000000000000004, 
+  { 1.4985874311132998, -0.29999999999999993, 0.80000000000000004, 
 	  1.0471975511965976 },
-  { 0.98787879723171790, -0.30000000000000004, 0.80000000000000004, 
+  { 2.0298167266724954, -0.29999999999999993, 0.80000000000000004, 
 	  1.2217304763960306 },
-  { 1.0924036340069339, -0.30000000000000004, 0.80000000000000004, 
+  { 2.7483929054985432, -0.29999999999999993, 0.80000000000000004, 
 	  1.3962634015954636 },
-  { 1.1944567571590048, -0.30000000000000004, 0.80000000000000004, 
+  { 3.6283050484567170, -0.29999999999999993, 0.80000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler069 = 2.5000000000000020e-13;
 
-// Test data for k=-0.30000000000000004, nu=0.90000000000000002.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 7.6419688299804087e-16
+// Test data for k=-0.29999999999999993, nu=0.90000000000000002.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 5.1301806687926828e-16
+// mean(f - f_Boost): 4.1633363423443370e-16
+// variance(f - f_Boost): 2.2835347143080263e-31
+// stddev(f - f_Boost): 4.7786344433405093e-16
 const testcase_ellint_3<double>
 data070[10] =
 {
-  { 0.0000000000000000, -0.30000000000000004, 0.90000000000000002, 
+  { 0.0000000000000000, -0.29999999999999993, 0.90000000000000002, 
 	  0.0000000000000000 },
-  { 0.17305109924485945, -0.30000000000000004, 0.90000000000000002, 
+  { 0.17622526204962433, -0.29999999999999993, 0.90000000000000002, 
 	  0.17453292519943295 },
-  { 0.33793890239556984, -0.30000000000000004, 0.90000000000000002, 
+  { 0.36304439230777141, -0.29999999999999993, 0.90000000000000002, 
 	  0.34906585039886590 },
-  { 0.48947218005089738, -0.30000000000000004, 0.90000000000000002, 
+  { 0.57345914744719195, -0.29999999999999993, 0.90000000000000002, 
 	  0.52359877559829882 },
-  { 0.62623332340775151, -0.30000000000000004, 0.90000000000000002, 
+  { 0.82641512928845162, -0.29999999999999993, 0.90000000000000002, 
 	  0.69813170079773179 },
-  { 0.74951596581511148, -0.30000000000000004, 0.90000000000000002, 
+  { 1.1534256210757743, -0.29999999999999993, 0.90000000000000002, 
 	  0.87266462599716477 },
-  { 0.86189886597755994, -0.30000000000000004, 0.90000000000000002, 
+  { 1.6124900353411677, -0.29999999999999993, 0.90000000000000002, 
 	  1.0471975511965976 },
-  { 0.96629451153092005, -0.30000000000000004, 0.90000000000000002, 
+  { 2.3165905514845089, -0.29999999999999993, 0.90000000000000002, 
 	  1.2217304763960306 },
-  { 1.0655269133492682, -0.30000000000000004, 0.90000000000000002, 
+  { 3.4625619526539824, -0.29999999999999993, 0.90000000000000002, 
 	  1.3962634015954636 },
-  { 1.1622376896064914, -0.30000000000000004, 0.90000000000000002, 
+  { 5.1479514944016787, -0.29999999999999993, 0.90000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler070 = 2.5000000000000020e-13;
 
 // Test data for k=-0.19999999999999996, nu=0.0000000000000000.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.2156475739151676e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 6
+// max(|f - f_Boost| / |f_Boost|): 4.2156475739151676e-16
+// mean(f - f_Boost): -5.2735593669694933e-17
+// variance(f - f_Boost): 3.0473442641042680e-32
+// stddev(f - f_Boost): 1.7456644190978597e-16
 const testcase_ellint_3<double>
 data071[10] =
 {
   { 0.0000000000000000, -0.19999999999999996, 0.0000000000000000, 
 	  0.0000000000000000 },
-  { 0.17456817290292809, -0.19999999999999996, 0.0000000000000000, 
+  { 0.17456817290292806, -0.19999999999999996, 0.0000000000000000, 
 	  0.17453292519943295 },
-  { 0.34934315932086801, -0.19999999999999996, 0.0000000000000000, 
+  { 0.34934315932086796, -0.19999999999999996, 0.0000000000000000, 
 	  0.34906585039886590 },
   { 0.52450880529443988, -0.19999999999999996, 0.0000000000000000, 
 	  0.52359877559829882 },
-  { 0.70020491009844876, -0.19999999999999996, 0.0000000000000000, 
+  { 0.70020491009844887, -0.19999999999999996, 0.0000000000000000, 
 	  0.69813170079773179 },
-  { 0.87651006649967955, -0.19999999999999996, 0.0000000000000000, 
+  { 0.87651006649967977, -0.19999999999999996, 0.0000000000000000, 
 	  0.87266462599716477 },
   { 1.0534305870298994, -0.19999999999999996, 0.0000000000000000, 
 	  1.0471975511965976 },
-  { 1.2308975521670784, -0.19999999999999996, 0.0000000000000000, 
+  { 1.2308975521670789, -0.19999999999999996, 0.0000000000000000, 
 	  1.2217304763960306 },
   { 1.4087733584990738, -0.19999999999999996, 0.0000000000000000, 
 	  1.3962634015954636 },
-  { 1.5868678474541660, -0.19999999999999996, 0.0000000000000000, 
+  { 1.5868678474541662, -0.19999999999999996, 0.0000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler071 = 2.5000000000000020e-13;
 
 // Test data for k=-0.19999999999999996, nu=0.10000000000000001.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.3374593253183472e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 6
+// max(|f - f_Boost| / |f_Boost|): 4.0890622182605400e-16
+// mean(f - f_Boost): -3.8857805861880476e-17
+// variance(f - f_Boost): 2.8794792590749608e-32
+// stddev(f - f_Boost): 1.6969028431454054e-16
 const testcase_ellint_3<double>
 data072[10] =
 {
   { 0.0000000000000000, -0.19999999999999996, 0.10000000000000001, 
 	  0.0000000000000000 },
-  { 0.17439228502691748, -0.19999999999999996, 0.10000000000000001, 
+  { 0.17474469953608965, -0.19999999999999996, 0.10000000000000001, 
 	  0.17453292519943295 },
-  { 0.34796731137565740, -0.19999999999999996, 0.10000000000000001, 
+  { 0.35073860234984255, -0.19999999999999996, 0.10000000000000001, 
 	  0.34906585039886590 },
-  { 0.52003370294544848, -0.19999999999999996, 0.10000000000000001, 
+  { 0.52912258712951521, -0.19999999999999996, 0.10000000000000001, 
 	  0.52359877559829882 },
-  { 0.69012222258631462, -0.19999999999999996, 0.10000000000000001, 
+  { 0.71081701558898069, -0.19999999999999996, 0.10000000000000001, 
 	  0.69813170079773179 },
-  { 0.85803491465566772, -0.19999999999999996, 0.10000000000000001, 
+  { 0.89640758521169384, -0.19999999999999996, 0.10000000000000001, 
 	  0.87266462599716477 },
-  { 1.0238463961099364, -0.19999999999999996, 0.10000000000000001, 
+  { 1.0860417038089853, -0.19999999999999996, 0.10000000000000001, 
 	  1.0471975511965976 },
-  { 1.1878691059202153, -0.19999999999999996, 0.10000000000000001, 
+  { 1.2793599255528623, -0.19999999999999996, 0.10000000000000001, 
 	  1.2217304763960306 },
-  { 1.3505985031831940, -0.19999999999999996, 0.10000000000000001, 
+  { 1.4754938544089076, -0.19999999999999996, 0.10000000000000001, 
 	  1.3962634015954636 },
-  { 1.5126513474261087, -0.19999999999999996, 0.10000000000000001, 
+  { 1.6731552050562593, -0.19999999999999996, 0.10000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler072 = 2.5000000000000020e-13;
 
 // Test data for k=-0.19999999999999996, nu=0.20000000000000001.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.4549984059502760e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 6
+// max(|f - f_Boost| / |f_Boost|): 3.9570963716579749e-16
+// mean(f - f_Boost): -5.8286708792820721e-17
+// variance(f - f_Boost): 3.1158217732380362e-32
+// stddev(f - f_Boost): 1.7651690494788412e-16
 const testcase_ellint_3<double>
 data073[10] =
 {
   { 0.0000000000000000, -0.19999999999999996, 0.20000000000000001, 
 	  0.0000000000000000 },
-  { 0.17421703179583747, -0.19999999999999996, 0.20000000000000001, 
+  { 0.17492186907740698, -0.19999999999999996, 0.20000000000000001, 
 	  0.17453292519943295 },
-  { 0.34661057411998791, -0.19999999999999996, 0.20000000000000001, 
+  { 0.35215414286134267, -0.19999999999999996, 0.20000000000000001, 
 	  0.34906585039886590 },
-  { 0.51569006052647393, -0.19999999999999996, 0.20000000000000001, 
+  { 0.53388285615182440, -0.19999999999999996, 0.20000000000000001, 
 	  0.52359877559829882 },
-  { 0.68052412821107244, -0.19999999999999996, 0.20000000000000001, 
+  { 0.72200960282688265, -0.19999999999999996, 0.20000000000000001, 
 	  0.69813170079773179 },
-  { 0.84081341263313825, -0.19999999999999996, 0.20000000000000001, 
+  { 0.91793087614428526, -0.19999999999999996, 0.20000000000000001, 
 	  0.87266462599716477 },
-  { 0.99683359988842890, -0.19999999999999996, 0.20000000000000001, 
+  { 1.1222602841587976, -0.19999999999999996, 0.20000000000000001, 
 	  1.0471975511965976 },
-  { 1.1493086715118852, -0.19999999999999996, 0.20000000000000001, 
+  { 1.3345489407496247, -0.19999999999999996, 0.20000000000000001, 
 	  1.2217304763960306 },
-  { 1.2992699693957541, -0.19999999999999996, 0.20000000000000001, 
+  { 1.5531225705475502, -0.19999999999999996, 0.20000000000000001, 
 	  1.3962634015954636 },
-  { 1.4479323932249564, -0.19999999999999996, 0.20000000000000001, 
+  { 1.7751816279738935, -0.19999999999999996, 0.20000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler073 = 2.5000000000000020e-13;
 
-// Test data for k=-0.19999999999999996, nu=0.29999999999999999.
-// max(|f - f_GSL|): 6.6613381477509392e-16
-// max(|f - f_GSL| / |f_GSL|): 5.3140668101543467e-16
+// Test data for k=-0.19999999999999996, nu=0.30000000000000004.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.6785817924053817e-16
+// mean(f - f_Boost): -1.1102230246251566e-17
+// variance(f - f_Boost): 9.9840208317034302e-32
+// stddev(f - f_Boost): 3.1597501217190311e-16
 const testcase_ellint_3<double>
 data074[10] =
 {
-  { 0.0000000000000000, -0.19999999999999996, 0.29999999999999999, 
+  { 0.0000000000000000, -0.19999999999999996, 0.30000000000000004, 
 	  0.0000000000000000 },
-  { 0.17404240913577704, -0.19999999999999996, 0.29999999999999999, 
+  { 0.17509968571715159, -0.19999999999999996, 0.30000000000000004, 
 	  0.17453292519943295 },
-  { 0.34527248032587193, -0.19999999999999996, 0.29999999999999999, 
+  { 0.35359030214835629, -0.19999999999999996, 0.30000000000000004, 
 	  0.34906585039886590 },
-  { 0.51147118981668416, -0.19999999999999996, 0.29999999999999999, 
+  { 0.53879807274537084, -0.19999999999999996, 0.30000000000000004, 
 	  0.52359877559829882 },
-  { 0.67137107867777601, -0.19999999999999996, 0.29999999999999999, 
+  { 0.73384116418059731, -0.19999999999999996, 0.30000000000000004, 
 	  0.69813170079773179 },
-  { 0.82470418188668893, -0.19999999999999996, 0.29999999999999999, 
+  { 0.94132799329524031, -0.19999999999999996, 0.30000000000000004, 
 	  0.87266462599716477 },
-  { 0.97202873223594299, -0.19999999999999996, 0.29999999999999999, 
+  { 1.1628407021801439, -0.19999999999999996, 0.30000000000000004, 
 	  1.0471975511965976 },
-  { 1.1144773569375266, -0.19999999999999996, 0.29999999999999999, 
+  { 1.3982440216739438, -0.19999999999999996, 0.30000000000000004, 
 	  1.2217304763960306 },
-  { 1.2535292433701000, -0.19999999999999996, 0.29999999999999999, 
+  { 1.6450634983653640, -0.19999999999999996, 0.30000000000000004, 
 	  1.3962634015954636 },
-  { 1.3908453514752477, -0.19999999999999996, 0.29999999999999999, 
+  { 1.8983924169967099, -0.19999999999999996, 0.30000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler074 = 2.5000000000000020e-13;
 
 // Test data for k=-0.19999999999999996, nu=0.40000000000000002.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.6788709752760483e-16
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.3298410018355870e-16
+// mean(f - f_Boost): 1.3877787807814457e-17
+// variance(f - f_Boost): 9.4370567274974557e-32
+// stddev(f - f_Boost): 3.0719792850046133e-16
 const testcase_ellint_3<double>
 data075[10] =
 {
   { 0.0000000000000000, -0.19999999999999996, 0.40000000000000002, 
 	  0.0000000000000000 },
-  { 0.17386841301066674, -0.19999999999999996, 0.40000000000000002, 
+  { 0.17527815368535152, -0.19999999999999996, 0.40000000000000002, 
 	  0.17453292519943295 },
-  { 0.34395257914113253, -0.19999999999999996, 0.40000000000000002, 
+  { 0.35504762134297801, -0.19999999999999996, 0.40000000000000002, 
 	  0.34906585039886590 },
-  { 0.50737088376869466, -0.19999999999999996, 0.40000000000000002, 
+  { 0.54387742353211344, -0.19999999999999996, 0.40000000000000002, 
 	  0.52359877559829882 },
-  { 0.66262801717277631, -0.19999999999999996, 0.40000000000000002, 
+  { 0.74637910471804259, -0.19999999999999996, 0.40000000000000002, 
 	  0.69813170079773179 },
-  { 0.80958766645079094, -0.19999999999999996, 0.40000000000000002, 
+  { 0.96690539714174639, -0.19999999999999996, 0.40000000000000002, 
 	  0.87266462599716477 },
-  { 0.94913754236162040, -0.19999999999999996, 0.40000000000000002, 
+  { 1.2087859420184757, -0.19999999999999996, 0.40000000000000002, 
 	  1.0471975511965976 },
-  { 1.0827985514222997, -0.19999999999999996, 0.40000000000000002, 
+  { 1.4729799844168852, -0.19999999999999996, 0.40000000000000002, 
 	  1.2217304763960306 },
-  { 1.2124212429050478, -0.19999999999999996, 0.40000000000000002, 
+  { 1.7564445064596661, -0.19999999999999996, 0.40000000000000002, 
 	  1.3962634015954636 },
-  { 1.3400002519661005, -0.19999999999999996, 0.40000000000000002, 
+  { 2.0512956926676802, -0.19999999999999996, 0.40000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler075 = 2.5000000000000020e-13;
 
 // Test data for k=-0.19999999999999996, nu=0.50000000000000000.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.7788201301356829e-16
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.3841806057292116e-16
+// mean(f - f_Boost): 8.0491169285323847e-17
+// variance(f - f_Boost): 8.0538110429953348e-32
+// stddev(f - f_Boost): 2.8379237204328335e-16
 const testcase_ellint_3<double>
 data076[10] =
 {
   { 0.0000000000000000, -0.19999999999999996, 0.50000000000000000, 
 	  0.0000000000000000 },
-  { 0.17369503942181799, -0.19999999999999996, 0.50000000000000000, 
+  { 0.17545727725228877, -0.19999999999999996, 0.50000000000000000, 
 	  0.17453292519943295 },
-  { 0.34265043534362660, -0.19999999999999996, 0.50000000000000000, 
+  { 0.35652666242062175, -0.19999999999999996, 0.50000000000000000, 
 	  0.34906585039886590 },
-  { 0.50338337208655415, -0.19999999999999996, 0.50000000000000000, 
+  { 0.54913090549102406, -0.19999999999999996, 0.50000000000000000, 
 	  0.52359877559829882 },
-  { 0.65426373297163609, -0.19999999999999996, 0.50000000000000000, 
+  { 0.75970161209211551, -0.19999999999999996, 0.50000000000000000, 
 	  0.69813170079773179 },
-  { 0.79536193036145808, -0.19999999999999996, 0.50000000000000000, 
+  { 0.99504737401590326, -0.19999999999999996, 0.50000000000000000, 
 	  0.87266462599716477 },
-  { 0.92791875910061605, -0.19999999999999996, 0.50000000000000000, 
+  { 1.2614666007124373, -0.19999999999999996, 0.50000000000000000, 
 	  1.0471975511965976 },
-  { 1.0538145052725829, -0.19999999999999996, 0.50000000000000000, 
+  { 1.5625255355205496, -0.19999999999999996, 0.50000000000000000, 
 	  1.2217304763960306 },
-  { 1.1752060022875899, -0.19999999999999996, 0.50000000000000000, 
+  { 1.8954460255613343, -0.19999999999999996, 0.50000000000000000, 
 	  1.3962634015954636 },
-  { 1.2943374404397372, -0.19999999999999996, 0.50000000000000000, 
+  { 2.2481046259421302, -0.19999999999999996, 0.50000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler076 = 2.5000000000000020e-13;
 
-// Test data for k=-0.19999999999999996, nu=0.59999999999999998.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.8899223779598256e-16
+// Test data for k=-0.19999999999999996, nu=0.60000000000000009.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.5317584994994743e-16
+// mean(f - f_Boost): -1.3877787807814457e-17
+// variance(f - f_Boost): 1.0045745697575397e-31
+// stddev(f - f_Boost): 3.1695024369095219e-16
 const testcase_ellint_3<double>
 data077[10] =
 {
-  { 0.0000000000000000, -0.19999999999999996, 0.59999999999999998, 
+  { 0.0000000000000000, -0.19999999999999996, 0.60000000000000009, 
 	  0.0000000000000000 },
-  { 0.17352228440746925, -0.19999999999999996, 0.59999999999999998, 
+  { 0.17563706072900442, -0.19999999999999996, 0.60000000000000009, 
 	  0.17453292519943295 },
-  { 0.34136562863713626, -0.19999999999999996, 0.59999999999999998, 
+  { 0.35802800926807238, -0.19999999999999996, 0.60000000000000009, 
 	  0.34906585039886590 },
-  { 0.49950328177638481, -0.19999999999999996, 0.59999999999999998, 
+  { 0.55456942250515051, -0.19999999999999996, 0.60000000000000009, 
 	  0.52359877559829882 },
-  { 0.64625032705690799, -0.19999999999999996, 0.59999999999999998, 
+  { 0.77390003828438203, -0.19999999999999996, 0.60000000000000009, 
 	  0.69813170079773179 },
-  { 0.78193941198403083, -0.19999999999999996, 0.59999999999999998, 
+  { 1.0262441366366397, -0.19999999999999996, 0.60000000000000009, 
 	  0.87266462599716477 },
-  { 0.90817230934317128, -0.19999999999999996, 0.59999999999999998, 
+  { 1.3228192988439669, -0.19999999999999996, 0.60000000000000009, 
 	  1.0471975511965976 },
-  { 1.0271563751276462, -0.19999999999999996, 0.59999999999999998, 
+  { 1.6728005754680795, -0.19999999999999996, 0.60000000000000009, 
 	  1.2217304763960306 },
-  { 1.1412999379040518, -0.19999999999999996, 0.59999999999999998, 
+  { 2.0761587107468511, -0.19999999999999996, 0.60000000000000009, 
 	  1.3962634015954636 },
-  { 1.2530330675914556, -0.19999999999999996, 0.59999999999999998, 
+  { 2.5148333891629315, -0.19999999999999996, 0.60000000000000009, 
 	  1.5707963267948966 },
 };
 const double toler077 = 2.5000000000000020e-13;
 
-// Test data for k=-0.19999999999999996, nu=0.69999999999999996.
-// max(|f - f_GSL|): 6.6613381477509392e-16
-// max(|f - f_GSL| / |f_GSL|): 5.9999318361775115e-16
+// Test data for k=-0.19999999999999996, nu=0.70000000000000007.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.1818454249546518e-16
+// mean(f - f_Boost): 3.6082248300317589e-17
+// variance(f - f_Boost): 8.9638010532618564e-32
+// stddev(f - f_Boost): 2.9939607634806868e-16
 const testcase_ellint_3<double>
 data078[10] =
 {
-  { 0.0000000000000000, -0.19999999999999996, 0.69999999999999996, 
+  { 0.0000000000000000, -0.19999999999999996, 0.70000000000000007, 
 	  0.0000000000000000 },
-  { 0.17335014404233895, -0.19999999999999996, 0.69999999999999996, 
+  { 0.17581750846781172, -0.19999999999999996, 0.70000000000000007, 
 	  0.17453292519943295 },
-  { 0.34009775298617811, -0.19999999999999996, 0.69999999999999996, 
+  { 0.35955226882028513, -0.19999999999999996, 0.70000000000000007, 
 	  0.34906585039886590 },
-  { 0.49572560201923810, -0.19999999999999996, 0.69999999999999996, 
+  { 0.56020489659466499, -0.19999999999999996, 0.70000000000000007, 
 	  0.52359877559829882 },
-  { 0.63856276669886503, -0.19999999999999996, 0.69999999999999996, 
+  { 0.78908196988531487, -0.19999999999999996, 0.70000000000000007, 
 	  0.69813170079773179 },
-  { 0.76924438644867565, -0.19999999999999996, 0.69999999999999996, 
+  { 1.0611336754143517, -0.19999999999999996, 0.70000000000000007, 
 	  0.87266462599716477 },
-  { 0.88973060843856466, -0.19999999999999996, 0.69999999999999996, 
+  { 1.3956969951058884, -0.19999999999999996, 0.70000000000000007, 
 	  1.0471975511965976 },
-  { 1.0025230471636377, -0.19999999999999996, 0.69999999999999996, 
+  { 1.8138131612209609, -0.19999999999999996, 0.70000000000000007, 
 	  1.2217304763960306 },
-  { 1.1102356376093103, -0.19999999999999996, 0.69999999999999996, 
+  { 2.3256365528879561, -0.19999999999999996, 0.70000000000000007, 
 	  1.3962634015954636 },
-  { 1.2154356555075863, -0.19999999999999996, 0.69999999999999996, 
+  { 2.9058704854500963, -0.19999999999999996, 0.70000000000000007, 
 	  1.5707963267948966 },
 };
 const double toler078 = 2.5000000000000020e-13;
 
 // Test data for k=-0.19999999999999996, nu=0.80000000000000004.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 5.0901276230707249e-16
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.9866614515542431e-16
+// mean(f - f_Boost): 1.8318679906315082e-16
+// variance(f - f_Boost): 3.1335688610218711e-31
+// stddev(f - f_Boost): 5.5978289193417400e-16
 const testcase_ellint_3<double>
 data079[10] =
 {
   { 0.0000000000000000, -0.19999999999999996, 0.80000000000000004, 
 	  0.0000000000000000 },
-  { 0.17317861443718538, -0.19999999999999996, 0.80000000000000004, 
+  { 0.17599862486281712, -0.19999999999999996, 0.80000000000000004, 
 	  0.17453292519943295 },
-  { 0.33884641598718701, -0.19999999999999996, 0.80000000000000004, 
+  { 0.36110007227128776, -0.19999999999999996, 0.80000000000000004, 
 	  0.34906585039886590 },
-  { 0.49204565281259494, -0.19999999999999996, 0.80000000000000004, 
+  { 0.56605039658567224, -0.19999999999999996, 0.80000000000000004, 
 	  0.52359877559829882 },
-  { 0.63117851188220320, -0.19999999999999996, 0.80000000000000004, 
+  { 0.80537523874517691, -0.19999999999999996, 0.80000000000000004, 
 	  0.69813170079773179 },
-  { 0.75721095949544170, -0.19999999999999996, 0.80000000000000004, 
+  { 1.1005662342414086, -0.19999999999999996, 0.80000000000000004, 
 	  0.87266462599716477 },
-  { 0.87245201443919118, -0.19999999999999996, 0.80000000000000004, 
+  { 1.4845340298105778, -0.19999999999999996, 0.80000000000000004, 
 	  1.0471975511965976 },
-  { 0.97966584238831089, -0.19999999999999996, 0.80000000000000004, 
+  { 2.0043332244969392, -0.19999999999999996, 0.80000000000000004, 
 	  1.2217304763960306 },
-  { 1.0816336325174360, -0.19999999999999996, 0.80000000000000004, 
+  { 2.7052856676744761, -0.19999999999999996, 0.80000000000000004, 
 	  1.3962634015954636 },
-  { 1.1810223448909909, -0.19999999999999996, 0.80000000000000004, 
+  { 3.5622166386422629, -0.19999999999999996, 0.80000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler079 = 2.5000000000000020e-13;
 
 // Test data for k=-0.19999999999999996, nu=0.90000000000000002.
-// max(|f - f_GSL|): 6.6613381477509392e-16
-// max(|f - f_GSL| / |f_GSL|): 6.4833128442756722e-16
+// max(|f - f_Boost|): 2.6645352591003757e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 5.2817178727913890e-16
+// mean(f - f_Boost): 3.4694469519536142e-16
+// variance(f - f_Boost): 6.6311432369155086e-31
+// stddev(f - f_Boost): 8.1431831840598485e-16
 const testcase_ellint_3<double>
 data080[10] =
 {
   { 0.0000000000000000, -0.19999999999999996, 0.90000000000000002, 
 	  0.0000000000000000 },
-  { 0.17300769173837277, -0.19999999999999996, 0.90000000000000002, 
+  { 0.17618041435044951, -0.19999999999999996, 0.90000000000000002, 
 	  0.17453292519943295 },
-  { 0.33761123827372508, -0.19999999999999996, 0.90000000000000002, 
+  { 0.36267207636502929, -0.19999999999999996, 0.90000000000000002, 
 	  0.34906585039886590 },
-  { 0.48845905690769426, -0.19999999999999996, 0.90000000000000002, 
+  { 0.57212028758237743, -0.19999999999999996, 0.90000000000000002, 
 	  0.52359877559829882 },
-  { 0.62407720017324952, -0.19999999999999996, 0.90000000000000002, 
+  { 0.82293323876704483, -0.19999999999999996, 0.90000000000000002, 
 	  0.69813170079773179 },
-  { 0.74578146525124289, -0.19999999999999996, 0.90000000000000002, 
+  { 1.1457077279880385, -0.19999999999999996, 0.90000000000000002, 
 	  0.87266462599716477 },
-  { 0.85621583540073076, -0.19999999999999996, 0.90000000000000002, 
+  { 1.5967346899325681, -0.19999999999999996, 0.90000000000000002, 
 	  1.0471975511965976 },
-  { 0.95837725988001199, -0.19999999999999996, 0.90000000000000002, 
+  { 2.2856537353421724, -0.19999999999999996, 0.90000000000000002, 
 	  1.2217304763960306 },
-  { 1.0551821412633928, -0.19999999999999996, 0.90000000000000002, 
+  { 3.4034714304613902, -0.19999999999999996, 0.90000000000000002, 
 	  1.3962634015954636 },
-  { 1.1493679916141861, -0.19999999999999996, 0.90000000000000002, 
+  { 5.0448269356200361, -0.19999999999999996, 0.90000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler080 = 2.5000000000000020e-13;
 
 // Test data for k=-0.099999999999999978, nu=0.0000000000000000.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.1735566504509650e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 3.1735566504509645e-16
+// mean(f - f_Boost): -3.6082248300317589e-17
+// variance(f - f_Boost): 8.2258607846939269e-33
+// stddev(f - f_Boost): 9.0696531271564778e-17
 const testcase_ellint_3<double>
 data081[10] =
 {
   { 0.0000000000000000, -0.099999999999999978, 0.0000000000000000, 
 	  0.0000000000000000 },
-  { 0.17454173353063659, -0.099999999999999978, 0.0000000000000000, 
+  { 0.17454173353063662, -0.099999999999999978, 0.0000000000000000, 
 	  0.17453292519943295 },
-  { 0.34913506721468091, -0.099999999999999978, 0.0000000000000000, 
+  { 0.34913506721468096, -0.099999999999999978, 0.0000000000000000, 
 	  0.34906585039886590 },
-  { 0.52382550016538942, -0.099999999999999978, 0.0000000000000000, 
+  { 0.52382550016538953, -0.099999999999999978, 0.0000000000000000, 
 	  0.52359877559829882 },
   { 0.69864700854177020, -0.099999999999999978, 0.0000000000000000, 
 	  0.69813170079773179 },
-  { 0.87361792586964870, -0.099999999999999978, 0.0000000000000000, 
+  { 0.87361792586964859, -0.099999999999999978, 0.0000000000000000, 
 	  0.87266462599716477 },
-  { 1.0487386319621683, -0.099999999999999978, 0.0000000000000000, 
+  { 1.0487386319621685, -0.099999999999999978, 0.0000000000000000, 
 	  1.0471975511965976 },
-  { 1.2239913752078757, -0.099999999999999978, 0.0000000000000000, 
+  { 1.2239913752078759, -0.099999999999999978, 0.0000000000000000, 
 	  1.2217304763960306 },
-  { 1.3993423113684049, -0.099999999999999978, 0.0000000000000000, 
+  { 1.3993423113684051, -0.099999999999999978, 0.0000000000000000, 
 	  1.3962634015954636 },
-  { 1.5747455615173562, -0.099999999999999978, 0.0000000000000000, 
+  { 1.5747455615173558, -0.099999999999999978, 0.0000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler081 = 2.5000000000000020e-13;
 
 // Test data for k=-0.099999999999999978, nu=0.10000000000000001.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.3097339877269682e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 3.0305747373482148e-16
+// mean(f - f_Boost): -3.0531133177191807e-17
+// variance(f - f_Boost): 1.1508025840536076e-34
+// stddev(f - f_Boost): 1.0727546709539920e-17
 const testcase_ellint_3<double>
 data082[10] =
 {
   { 0.0000000000000000, -0.099999999999999978, 0.10000000000000001, 
 	  0.0000000000000000 },
-  { 0.17436589347616613, -0.099999999999999978, 0.10000000000000001, 
+  { 0.17471821213559732, -0.099999999999999978, 0.10000000000000001, 
 	  0.17453292519943295 },
-  { 0.34776067871237359, -0.099999999999999978, 0.10000000000000001, 
+  { 0.35052902610011138, -0.099999999999999978, 0.10000000000000001, 
 	  0.34906585039886590 },
-  { 0.51936064354727796, -0.099999999999999978, 0.10000000000000001, 
+  { 0.52842865990255727, -0.099999999999999978, 0.10000000000000001, 
 	  0.52359877559829882 },
-  { 0.68860303749364349, -0.099999999999999978, 0.10000000000000001, 
+  { 0.70921799731166713, -0.099999999999999978, 0.10000000000000001, 
 	  0.69813170079773179 },
-  { 0.85524561882332051, -0.099999999999999978, 0.10000000000000001, 
+  { 0.89340330535868662, -0.099999999999999978, 0.10000000000000001, 
 	  0.87266462599716477 },
-  { 1.0193708301908335, -0.099999999999999978, 0.10000000000000001, 
+  { 1.0811075784236857, -0.099999999999999978, 0.10000000000000001, 
 	  1.0471975511965976 },
-  { 1.1813474067123044, -0.099999999999999978, 0.10000000000000001, 
+  { 1.2720133232666426, -0.099999999999999978, 0.10000000000000001, 
 	  1.2217304763960306 },
-  { 1.3417670770424983, -0.099999999999999978, 0.10000000000000001, 
+  { 1.4653630031861395, -0.099999999999999978, 0.10000000000000001, 
 	  1.3962634015954636 },
-  { 1.5013711111199950, -0.099999999999999978, 0.10000000000000001, 
+  { 1.6600374067558428, -0.099999999999999978, 0.10000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler082 = 2.5000000000000020e-13;
 
 // Test data for k=-0.099999999999999978, nu=0.20000000000000001.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.4399947764827574e-16
+// max(|f - f_Boost|): 2.2204460492503131e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 1.6736714959992433e-16
+// mean(f - f_Boost): 5.5511151231257830e-18
+// variance(f - f_Boost): 3.8043060629871325e-36
+// stddev(f - f_Boost): 1.9504630380981673e-18
 const testcase_ellint_3<double>
 data083[10] =
 {
   { 0.0000000000000000, -0.099999999999999978, 0.20000000000000001, 
 	  0.0000000000000000 },
-  { 0.17419068786141340, -0.099999999999999978, 0.20000000000000001, 
+  { 0.17489533344059083, -0.099999999999999978, 0.20000000000000001, 
 	  0.17453292519943295 },
-  { 0.34640537686230133, -0.099999999999999978, 0.20000000000000001, 
+  { 0.35194305707815038, -0.099999999999999978, 0.20000000000000001, 
 	  0.34906585039886590 },
-  { 0.51502689171753946, -0.099999999999999978, 0.20000000000000001, 
+  { 0.53317790741512527, -0.099999999999999978, 0.20000000000000001, 
 	  0.52359877559829882 },
-  { 0.67904147863672715, -0.099999999999999978, 0.20000000000000001, 
+  { 0.72036681615081222, -0.099999999999999978, 0.20000000000000001, 
 	  0.69813170079773179 },
-  { 0.83811885126105179, -0.099999999999999978, 0.20000000000000001, 
+  { 0.91480372268244303, -0.099999999999999978, 0.20000000000000001, 
 	  0.87266462599716477 },
-  { 0.99255278555742787, -0.099999999999999978, 0.20000000000000001, 
+  { 1.1170528708071514, -0.099999999999999978, 0.20000000000000001, 
 	  1.0471975511965976 },
-  { 1.1431260546194930, -0.099999999999999978, 0.20000000000000001, 
+  { 1.3266916802718358, -0.099999999999999978, 0.20000000000000001, 
 	  1.2217304763960306 },
-  { 1.2909589656532101, -0.099999999999999978, 0.20000000000000001, 
+  { 1.5421622241831547, -0.099999999999999978, 0.20000000000000001, 
 	  1.3962634015954636 },
-  { 1.4373749386463430, -0.099999999999999978, 0.20000000000000001, 
+  { 1.7608656115083421, -0.099999999999999978, 0.20000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler083 = 2.5000000000000020e-13;
 
-// Test data for k=-0.099999999999999978, nu=0.29999999999999999.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.5650492137236872e-16
+// Test data for k=-0.099999999999999978, nu=0.30000000000000004.
+// max(|f - f_Boost|): 2.2204460492503131e-16 at index 6
+// max(|f - f_Boost| / |f_Boost|): 1.9186071760326645e-16
+// mean(f - f_Boost): -1.6653345369377347e-17
+// variance(f - f_Boost): 3.4238754566884194e-35
+// stddev(f - f_Boost): 5.8513891142945016e-18
 const testcase_ellint_3<double>
 data084[10] =
 {
-  { 0.0000000000000000, -0.099999999999999978, 0.29999999999999999, 
+  { 0.0000000000000000, -0.099999999999999978, 0.30000000000000004, 
 	  0.0000000000000000 },
-  { 0.17401611261390104, -0.099999999999999978, 0.29999999999999999, 
+  { 0.17507310163441189, -0.099999999999999978, 0.30000000000000004, 
 	  0.17453292519943295 },
-  { 0.34506869507511773, -0.099999999999999978, 0.29999999999999999, 
+  { 0.35337768072524217, -0.099999999999999978, 0.30000000000000004, 
 	  0.34906585039886590 },
-  { 0.51081757604259859, -0.099999999999999978, 0.29999999999999999, 
+  { 0.53808167801629170, -0.099999999999999978, 0.30000000000000004, 
 	  0.52359877559829882 },
-  { 0.66992297597712303, -0.099999999999999978, 0.29999999999999999, 
+  { 0.73215166755955019, -0.099999999999999978, 0.30000000000000004, 
 	  0.69813170079773179 },
-  { 0.82209722856174228, -0.099999999999999978, 0.29999999999999999, 
+  { 0.93806546000201219, -0.099999999999999978, 0.30000000000000004, 
 	  0.87266462599716477 },
-  { 0.96792430487669590, -0.099999999999999978, 0.29999999999999999, 
+  { 1.1573218723395986, -0.099999999999999978, 0.30000000000000004, 
 	  1.0471975511965976 },
-  { 1.1085964108954092, -0.099999999999999978, 0.29999999999999999, 
+  { 1.3897859679542097, -0.099999999999999978, 0.30000000000000004, 
 	  1.2217304763960306 },
-  { 1.2456748370836999, -0.099999999999999978, 0.29999999999999999, 
+  { 1.6331009404328622, -0.099999999999999978, 0.30000000000000004, 
 	  1.3962634015954636 },
-  { 1.3809159606704959, -0.099999999999999978, 0.29999999999999999, 
+  { 1.8826015946315438, -0.099999999999999978, 0.30000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler084 = 2.5000000000000020e-13;
 
 // Test data for k=-0.099999999999999978, nu=0.40000000000000002.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.6854758534459740e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.0338059536914377e-16
+// mean(f - f_Boost): 2.7755575615628914e-17
+// variance(f - f_Boost): 9.5107651574678308e-35
+// stddev(f - f_Boost): 9.7523151904908362e-18
 const testcase_ellint_3<double>
 data085[10] =
 {
   { 0.0000000000000000, -0.099999999999999978, 0.40000000000000002, 
 	  0.0000000000000000 },
-  { 0.17384216369897931, -0.099999999999999978, 0.40000000000000002, 
+  { 0.17525152094559704, -0.099999999999999978, 0.40000000000000002, 
 	  0.17453292519943295 },
-  { 0.34375018311376787, -0.099999999999999978, 0.40000000000000002, 
+  { 0.35483343742825979, -0.099999999999999978, 0.40000000000000002, 
 	  0.34906585039886590 },
-  { 0.50672650758380455, -0.099999999999999978, 0.40000000000000002, 
+  { 0.54314913099505446, -0.099999999999999978, 0.40000000000000002, 
 	  0.52359877559829882 },
-  { 0.66121264213337616, -0.099999999999999978, 0.40000000000000002, 
+  { 0.74463962034766862, -0.099999999999999978, 0.40000000000000002, 
 	  0.69813170079773179 },
-  { 0.80706202005774441, -0.099999999999999978, 0.40000000000000002, 
+  { 0.96349276837570441, -0.099999999999999978, 0.40000000000000002, 
 	  0.87266462599716477 },
-  { 0.94519376138245870, -0.099999999999999978, 0.40000000000000002, 
+  { 1.2029081382746343, -0.099999999999999978, 0.40000000000000002, 
 	  1.0471975511965976 },
-  { 1.0771880300759584, -0.099999999999999978, 0.40000000000000002, 
+  { 1.4638022887050806, -0.099999999999999978, 0.40000000000000002, 
 	  1.2217304763960306 },
-  { 1.2049711557188272, -0.099999999999999978, 0.40000000000000002, 
+  { 1.7432413830105224, -0.099999999999999978, 0.40000000000000002, 
 	  1.3962634015954636 },
-  { 1.3306223265207477, -0.099999999999999978, 0.40000000000000002, 
+  { 2.0336367403076760, -0.099999999999999978, 0.40000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler085 = 2.5000000000000020e-13;
 
 // Test data for k=-0.099999999999999978, nu=0.50000000000000000.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.8017534281650347e-16
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.9864616042835278e-16
+// mean(f - f_Boost): 1.0547118733938987e-16
+// variance(f - f_Boost): 7.5633408838247182e-32
+// stddev(f - f_Boost): 2.7501528837184157e-16
 const testcase_ellint_3<double>
 data086[10] =
 {
   { 0.0000000000000000, -0.099999999999999978, 0.50000000000000000, 
 	  0.0000000000000000 },
-  { 0.17366883711936548, -0.099999999999999978, 0.50000000000000000, 
+  { 0.17543059564292182, -0.099999999999999978, 0.50000000000000000, 
 	  0.17453292519943295 },
-  { 0.34244940634881882, -0.099999999999999978, 0.50000000000000000, 
+  { 0.35631088838721664, -0.099999999999999978, 0.50000000000000000, 
 	  0.34906585039886590 },
-  { 0.50274793281634367, -0.099999999999999978, 0.50000000000000000, 
+  { 0.54839023346436444, -0.099999999999999978, 0.50000000000000000, 
 	  0.52359877559829882 },
-  { 0.65287941633275082, -0.099999999999999978, 0.50000000000000000, 
+  { 0.75790846946088830, -0.099999999999999978, 0.50000000000000000, 
 	  0.69813170079773179 },
-  { 0.79291198790315398, -0.099999999999999978, 0.50000000000000000, 
+  { 0.99146713686720678, -0.099999999999999978, 0.50000000000000000, 
 	  0.87266462599716477 },
-  { 0.92412201537880323, -0.099999999999999978, 0.50000000000000000, 
+  { 1.2551692247937198, -0.099999999999999978, 0.50000000000000000, 
 	  1.0471975511965976 },
-  { 1.0484480076799372, -0.099999999999999978, 0.50000000000000000, 
+  { 1.5524660788146873, -0.099999999999999978, 0.50000000000000000, 
 	  1.2217304763960306 },
-  { 1.1681168130475206, -0.099999999999999978, 0.50000000000000000, 
+  { 1.8806578570830670, -0.099999999999999978, 0.50000000000000000, 
 	  1.3962634015954636 },
-  { 1.2854480708580160, -0.099999999999999978, 0.50000000000000000, 
+  { 2.2279868912966849, -0.099999999999999978, 0.50000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler086 = 2.5000000000000020e-13;
 
-// Test data for k=-0.099999999999999978, nu=0.59999999999999998.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.9142834151672032e-16
+// Test data for k=-0.099999999999999978, nu=0.60000000000000009.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 2.6726146516228014e-16
+// mean(f - f_Boost): -3.6082248300317589e-17
+// variance(f - f_Boost): 1.6073193116120635e-34
+// stddev(f - f_Boost): 1.2678009747638087e-17
 const testcase_ellint_3<double>
 data087[10] =
 {
-  { 0.0000000000000000, -0.099999999999999978, 0.59999999999999998, 
+  { 0.0000000000000000, -0.099999999999999978, 0.60000000000000009, 
 	  0.0000000000000000 },
-  { 0.17349612891469013, -0.099999999999999978, 0.59999999999999998, 
+  { 0.17561033003590576, -0.099999999999999978, 0.60000000000000009, 
 	  0.17453292519943295 },
-  { 0.34116594505539444, -0.099999999999999978, 0.59999999999999998, 
+  { 0.35781061668171932, -0.099999999999999978, 0.60000000000000009, 
 	  0.34906585039886590 },
-  { 0.49887649430466674, -0.099999999999999978, 0.59999999999999998, 
+  { 0.55381585659629196, -0.099999999999999978, 0.60000000000000009, 
 	  0.52359877559829882 },
-  { 0.64489553282165146, -0.099999999999999978, 0.59999999999999998, 
+  { 0.77204910484575640, -0.099999999999999978, 0.60000000000000009, 
 	  0.69813170079773179 },
-  { 0.77956016553782437, -0.099999999999999978, 0.59999999999999998, 
+  { 1.0224751740393108, -0.099999999999999978, 0.60000000000000009, 
 	  0.87266462599716477 },
-  { 0.90451074530096287, -0.099999999999999978, 0.59999999999999998, 
+  { 1.3160230906351114, -0.099999999999999978, 0.60000000000000009, 
 	  1.0471975511965976 },
-  { 1.0220113666961632, -0.099999999999999978, 0.59999999999999998, 
+  { 1.6616282844233206, -0.099999999999999978, 0.60000000000000009, 
 	  1.2217304763960306 },
-  { 1.1345351441065563, -0.099999999999999978, 0.59999999999999998, 
+  { 2.0592555664850392, -0.099999999999999978, 0.60000000000000009, 
 	  1.3962634015954636 },
-  { 1.2445798942989255, -0.099999999999999978, 0.59999999999999998, 
+  { 2.4913004919173822, -0.099999999999999978, 0.60000000000000009, 
 	  1.5707963267948966 },
 };
 const double toler087 = 2.5000000000000020e-13;
 
-// Test data for k=-0.099999999999999978, nu=0.69999999999999996.
-// max(|f - f_GSL|): 6.6613381477509392e-16
-// max(|f - f_GSL| / |f_GSL|): 5.5172091551439012e-16
+// Test data for k=-0.099999999999999978, nu=0.70000000000000007.
+// max(|f - f_Boost|): 2.2204460492503131e-16 at index 5
+// max(|f - f_Boost| / |f_Boost|): 2.1004074871280821e-16
+// mean(f - f_Boost): 3.3306690738754695e-17
+// variance(f - f_Boost): 1.3695501826753678e-34
+// stddev(f - f_Boost): 1.1702778228589003e-17
 const testcase_ellint_3<double>
 data088[10] =
 {
-  { 0.0000000000000000, -0.099999999999999978, 0.69999999999999996, 
+  { 0.0000000000000000, -0.099999999999999978, 0.70000000000000007, 
 	  0.0000000000000000 },
-  { 0.17332403516105047, -0.099999999999999978, 0.69999999999999996, 
+  { 0.17579072847532518, -0.099999999999999978, 0.70000000000000007, 
 	  0.17453292519943295 },
-  { 0.33989939374896883, -0.099999999999999978, 0.69999999999999996, 
+  { 0.35933322840606297, -0.099999999999999978, 0.70000000000000007, 
 	  0.34906585039886590 },
-  { 0.49510719568614070, -0.099999999999999978, 0.69999999999999996, 
+  { 0.55943788649460324, -0.099999999999999978, 0.70000000000000007, 
 	  0.52359877559829882 },
-  { 0.63723607776354974, -0.099999999999999978, 0.69999999999999996, 
+  { 0.78716856504031707, -0.099999999999999978, 0.70000000000000007, 
 	  0.69813170079773179 },
-  { 0.76693133887935327, -0.099999999999999978, 0.69999999999999996, 
+  { 1.0571501305617423, -0.099999999999999978, 0.70000000000000007, 
 	  0.87266462599716477 },
-  { 0.88619382078823805, -0.099999999999999978, 0.69999999999999996, 
+  { 1.3882948301743525, -0.099999999999999978, 0.70000000000000007, 
 	  1.0471975511965976 },
-  { 0.99758012018676490, -0.099999999999999978, 0.69999999999999996, 
+  { 1.8011785680114223, -0.099999999999999978, 0.70000000000000007, 
 	  1.2217304763960306 },
-  { 1.1037642270814410, -0.099999999999999978, 0.69999999999999996, 
+  { 2.3057268183616464, -0.099999999999999978, 0.70000000000000007, 
 	  1.3962634015954636 },
-  { 1.2073745911083185, -0.099999999999999978, 0.69999999999999996, 
+  { 2.8771910188009739, -0.099999999999999978, 0.70000000000000007, 
 	  1.5707963267948966 },
 };
 const double toler088 = 2.5000000000000020e-13;
 
 // Test data for k=-0.099999999999999978, nu=0.80000000000000004.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.1294144515772258e-16
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 3.3133043868392355e-16
+// mean(f - f_Boost): 1.8041124150158794e-16
+// variance(f - f_Boost): 6.1843750436434569e-32
+// stddev(f - f_Boost): 2.4868403735751633e-16
 const testcase_ellint_3<double>
 data089[10] =
 {
   { 0.0000000000000000, -0.099999999999999978, 0.80000000000000004, 
 	  0.0000000000000000 },
-  { 0.17315255197057014, -0.099999999999999978, 0.80000000000000004, 
+  { 0.17597179535373417, -0.099999999999999978, 0.80000000000000004, 
 	  0.17453292519943295 },
-  { 0.33864936055747991, -0.099999999999999978, 0.80000000000000004, 
+  { 0.36087935387831499, -0.099999999999999978, 0.80000000000000004, 
 	  0.34906585039886590 },
-  { 0.49143537041117613, -0.099999999999999978, 0.80000000000000004, 
+  { 0.56526935244526444, -0.099999999999999978, 0.80000000000000004, 
 	  0.52359877559829882 },
-  { 0.62987861760047492, -0.099999999999999978, 0.80000000000000004, 
+  { 0.80339402590612397, -0.099999999999999978, 0.80000000000000004, 
 	  0.69813170079773179 },
-  { 0.75496005490917517, -0.099999999999999978, 0.80000000000000004, 
+  { 1.0963358646374459, -0.099999999999999978, 0.80000000000000004, 
 	  0.87266462599716477 },
-  { 0.86903081862701881, -0.099999999999999978, 0.80000000000000004, 
+  { 1.4763748483246868, -0.099999999999999978, 0.80000000000000004, 
 	  1.0471975511965976 },
-  { 0.97490814820725591, -0.099999999999999978, 0.80000000000000004, 
+  { 1.9896610222794102, -0.099999999999999978, 0.80000000000000004, 
 	  1.2217304763960306 },
-  { 1.0754290107171083, -0.099999999999999978, 0.80000000000000004, 
+  { 2.6806423920122024, -0.099999999999999978, 0.80000000000000004, 
 	  1.3962634015954636 },
-  { 1.1733158866987732, -0.099999999999999978, 0.80000000000000004, 
+  { 3.5246199613295612, -0.099999999999999978, 0.80000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler089 = 2.5000000000000020e-13;
 
 // Test data for k=-0.099999999999999978, nu=0.90000000000000002.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.2325599449457852e-16
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.5624826890976725e-16
+// mean(f - f_Boost): 2.3314683517128288e-16
+// variance(f - f_Boost): 2.9401198977189756e-31
+// stddev(f - f_Boost): 5.4222872459129045e-16
 const testcase_ellint_3<double>
 data090[10] =
 {
   { 0.0000000000000000, -0.099999999999999978, 0.90000000000000002, 
 	  0.0000000000000000 },
-  { 0.17298167549096563, -0.099999999999999978, 0.90000000000000002, 
+  { 0.17615353510599349, -0.099999999999999978, 0.90000000000000002, 
 	  0.17453292519943295 },
-  { 0.33741546662741589, -0.099999999999999978, 0.90000000000000002, 
+  { 0.36244964892922371, -0.099999999999999978, 0.90000000000000002, 
 	  0.34906585039886590 },
-  { 0.48785665376856868, -0.099999999999999978, 0.90000000000000002, 
+  { 0.57132457590110530, -0.099999999999999978, 0.90000000000000002, 
 	  0.52359877559829882 },
-  { 0.62280288554518959, -0.099999999999999978, 0.90000000000000002, 
+  { 0.82087808820385000, -0.099999999999999978, 0.90000000000000002, 
 	  0.69813170079773179 },
-  { 0.74358903115455188, -0.099999999999999978, 0.90000000000000002, 
+  { 1.1411894342144451, -0.099999999999999978, 0.90000000000000002, 
 	  0.87266462599716477 },
-  { 0.85290207679298335, -0.099999999999999978, 0.90000000000000002, 
+  { 1.5875929286844597, -0.099999999999999978, 0.90000000000000002, 
 	  1.0471975511965976 },
-  { 0.95379006645397379, -0.099999999999999978, 0.90000000000000002, 
+  { 2.2678622986596659, -0.099999999999999978, 0.90000000000000002, 
 	  1.2217304763960306 },
-  { 1.0492213119872327, -0.099999999999999978, 0.90000000000000002, 
+  { 3.3697528941897903, -0.099999999999999978, 0.90000000000000002, 
 	  1.3962634015954636 },
-  { 1.1419839485283374, -0.099999999999999978, 0.90000000000000002, 
+  { 4.9862890417305499, -0.099999999999999978, 0.90000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler090 = 2.5000000000000020e-13;
 
 // Test data for k=0.0000000000000000, nu=0.0000000000000000.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 2.1203697876423452e-16
+// max(|f - f_Boost|): 2.2204460492503131e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 2.1203697876423447e-16
+// mean(f - f_Boost): -1.9428902930940238e-17
+// variance(f - f_Boost): 4.6602749271592373e-35
+// stddev(f - f_Boost): 6.8266206333435850e-18
 const testcase_ellint_3<double>
 data091[10] =
 {
   { 0.0000000000000000, 0.0000000000000000, 0.0000000000000000, 
 	  0.0000000000000000 },
-  { 0.17453292519943292, 0.0000000000000000, 0.0000000000000000, 
+  { 0.17453292519943295, 0.0000000000000000, 0.0000000000000000, 
 	  0.17453292519943295 },
-  { 0.34906585039886584, 0.0000000000000000, 0.0000000000000000, 
+  { 0.34906585039886590, 0.0000000000000000, 0.0000000000000000, 
 	  0.34906585039886590 },
-  { 0.52359877559829870, 0.0000000000000000, 0.0000000000000000, 
+  { 0.52359877559829882, 0.0000000000000000, 0.0000000000000000, 
 	  0.52359877559829882 },
-  { 0.69813170079773168, 0.0000000000000000, 0.0000000000000000, 
+  { 0.69813170079773179, 0.0000000000000000, 0.0000000000000000, 
 	  0.69813170079773179 },
   { 0.87266462599716477, 0.0000000000000000, 0.0000000000000000, 
 	  0.87266462599716477 },
-  { 1.0471975511965974, 0.0000000000000000, 0.0000000000000000, 
+  { 1.0471975511965976, 0.0000000000000000, 0.0000000000000000, 
 	  1.0471975511965976 },
-  { 1.2217304763960304, 0.0000000000000000, 0.0000000000000000, 
+  { 1.2217304763960306, 0.0000000000000000, 0.0000000000000000, 
 	  1.2217304763960306 },
-  { 1.3962634015954631, 0.0000000000000000, 0.0000000000000000, 
+  { 1.3962634015954636, 0.0000000000000000, 0.0000000000000000, 
 	  1.3962634015954636 },
   { 1.5707963267948966, 0.0000000000000000, 0.0000000000000000, 
 	  1.5707963267948966 },
@@ -2678,849 +2950,939 @@ data091[10] =
 const double toler091 = 2.5000000000000020e-13;
 
 // Test data for k=0.0000000000000000, nu=0.10000000000000001.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 2.1813975824747021e-16
+// max(|f - f_Boost|): 2.2204460492503131e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 2.1019052604815601e-16
+// mean(f - f_Boost): 2.7755575615628915e-18
+// variance(f - f_Boost): 9.5107651574678312e-37
+// stddev(f - f_Boost): 9.7523151904908366e-19
 const testcase_ellint_3<double>
 data092[10] =
 {
   { 0.0000000000000000, 0.0000000000000000, 0.10000000000000001, 
 	  0.0000000000000000 },
-  { 0.17435710107516605, 0.0000000000000000, 0.10000000000000001, 
+  { 0.17470938780535167, 0.0000000000000000, 0.10000000000000001, 
 	  0.17453292519943295 },
-  { 0.34769194715329604, 0.0000000000000000, 0.10000000000000001, 
+  { 0.35045931581655582, 0.0000000000000000, 0.10000000000000001, 
 	  0.34906585039886590 },
-  { 0.51913731575866107, 0.0000000000000000, 0.10000000000000001, 
+  { 0.52819841383849875, 0.0000000000000000, 0.10000000000000001, 
 	  0.52359877559829882 },
-  { 0.68810051897078450, 0.0000000000000000, 0.10000000000000001, 
+  { 0.70868910807992958, 0.0000000000000000, 0.10000000000000001, 
 	  0.69813170079773179 },
-  { 0.85432615661706823, 0.0000000000000000, 0.10000000000000001, 
+  { 0.89241311307249638, 0.0000000000000000, 0.10000000000000001, 
 	  0.87266462599716477 },
-  { 1.0179006647340794, 0.0000000000000000, 0.10000000000000001, 
+  { 1.0794871444666669, 0.0000000000000000, 0.10000000000000001, 
 	  1.0471975511965976 },
-  { 1.1792120640746322, 0.0000000000000000, 0.10000000000000001, 
+  { 1.2696086247356864, 0.0000000000000000, 0.10000000000000001, 
 	  1.2217304763960306 },
-  { 1.3388834245070498, 0.0000000000000000, 0.10000000000000001, 
+  { 1.4620562617494721, 0.0000000000000000, 0.10000000000000001, 
 	  1.3962634015954636 },
-  { 1.4976955329233277, 0.0000000000000000, 0.10000000000000001, 
+  { 1.6557647109660167, 0.0000000000000000, 0.10000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler092 = 2.5000000000000020e-13;
 
 // Test data for k=0.0000000000000000, nu=0.20000000000000001.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 2.2402804784409065e-16
+// max(|f - f_Boost|): 2.2204460492503131e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 2.0831888697465320e-16
+// mean(f - f_Boost): -1.9428902930940238e-17
+// variance(f - f_Boost): 4.6602749271592373e-35
+// stddev(f - f_Boost): 6.8266206333435850e-18
 const testcase_ellint_3<double>
 data093[10] =
 {
   { 0.0000000000000000, 0.0000000000000000, 0.20000000000000001, 
 	  0.0000000000000000 },
-  { 0.17418191132226074, 0.0000000000000000, 0.20000000000000001, 
+  { 0.17488649304197776, 0.0000000000000000, 0.20000000000000001, 
 	  0.17453292519943295 },
-  { 0.34633712256943405, 0.0000000000000000, 0.20000000000000001, 
+  { 0.35187284488675424, 0.0000000000000000, 0.20000000000000001, 
 	  0.34906585039886590 },
-  { 0.51480684302043700, 0.0000000000000000, 0.20000000000000001, 
+  { 0.53294400750146131, 0.0000000000000000, 0.20000000000000001, 
 	  0.52359877559829882 },
-  { 0.67855102942481937, 0.0000000000000000, 0.20000000000000001, 
+  { 0.71982347021822823, 0.0000000000000000, 0.20000000000000001, 
 	  0.69813170079773179 },
-  { 0.83723056090326253, 0.0000000000000000, 0.20000000000000001, 
+  { 0.91377311030258745, 0.0000000000000000, 0.20000000000000001, 
 	  0.87266462599716477 },
-  { 0.99114645269578161, 0.0000000000000000, 0.20000000000000001, 
+  { 1.1153429007215137, 0.0000000000000000, 0.20000000000000001, 
 	  1.0471975511965976 },
-  { 1.1411014627915537, 0.0000000000000000, 0.20000000000000001, 
+  { 1.3241202847784086, 0.0000000000000000, 0.20000000000000001, 
 	  1.2217304763960306 },
-  { 1.2882448138013969, 0.0000000000000000, 0.20000000000000001, 
+  { 1.5385854914338242, 0.0000000000000000, 0.20000000000000001, 
 	  1.3962634015954636 },
-  { 1.4339343023863691, 0.0000000000000000, 0.20000000000000001, 
+  { 1.7562036827601815, 0.0000000000000000, 0.20000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler093 = 2.5000000000000020e-13;
 
-// Test data for k=0.0000000000000000, nu=0.29999999999999999.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 2.2972291118632678e-16
+// Test data for k=0.0000000000000000, nu=0.30000000000000004.
+// max(|f - f_Boost|): 2.2204460492503131e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 2.0642101770923591e-16
+// mean(f - f_Boost): -1.9428902930940238e-17
+// variance(f - f_Boost): 4.6602749271592373e-35
+// stddev(f - f_Boost): 6.8266206333435850e-18
 const testcase_ellint_3<double>
 data094[10] =
 {
-  { 0.0000000000000000, 0.0000000000000000, 0.29999999999999999, 
+  { 0.0000000000000000, 0.0000000000000000, 0.30000000000000004, 
 	  0.0000000000000000 },
-  { 0.17400735186871724, 0.0000000000000000, 0.29999999999999999, 
+  { 0.17506424509761404, 0.0000000000000000, 0.30000000000000004, 
 	  0.17453292519943295 },
-  { 0.34500091027020219, 0.0000000000000000, 0.29999999999999999, 
+  { 0.35330695794774630, 0.0000000000000000, 0.30000000000000004, 
 	  0.34906585039886590 },
-  { 0.51060069523901530, 0.0000000000000000, 0.29999999999999999, 
+  { 0.53784398359522367, 0.0000000000000000, 0.30000000000000004, 
 	  0.52359877559829882 },
-  { 0.66944393961375448, 0.0000000000000000, 0.29999999999999999, 
+  { 0.73159289408687844, 0.0000000000000000, 0.30000000000000004, 
 	  0.69813170079773179 },
-  { 0.82123776744538157, 0.0000000000000000, 0.29999999999999999, 
+  { 0.93699031797084975, 0.0000000000000000, 0.30000000000000004, 
 	  0.87266462599716477 },
-  { 0.96657579245516501, 0.0000000000000000, 0.29999999999999999, 
+  { 1.1555098909390267, 0.0000000000000000, 0.30000000000000004, 
 	  1.0471975511965976 },
-  { 1.1066703663542414, 0.0000000000000000, 0.29999999999999999, 
+  { 1.3870184960144325, 0.0000000000000000, 0.30000000000000004, 
 	  1.2217304763960306 },
-  { 1.2431094251944901, 0.0000000000000000, 0.29999999999999999, 
+  { 1.6291980835772994, 0.0000000000000000, 0.30000000000000004, 
 	  1.3962634015954636 },
-  { 1.3776795151134889, 0.0000000000000000, 0.29999999999999999, 
+  { 1.8774607092226381, 0.0000000000000000, 0.30000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler094 = 2.5000000000000020e-13;
 
 // Test data for k=0.0000000000000000, nu=0.40000000000000002.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 2.3524218164111537e-16
+// max(|f - f_Boost|): 2.2204460492503131e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 2.0449580089795878e-16
+// mean(f - f_Boost): -1.9428902930940238e-17
+// variance(f - f_Boost): 4.6602749271592373e-35
+// stddev(f - f_Boost): 6.8266206333435850e-18
 const testcase_ellint_3<double>
 data095[10] =
 {
   { 0.0000000000000000, 0.0000000000000000, 0.40000000000000002, 
 	  0.0000000000000000 },
-  { 0.17383341868035862, 0.0000000000000000, 0.40000000000000002, 
+  { 0.17524264820030025, 0.0000000000000000, 0.40000000000000002, 
 	  0.17453292519943295 },
-  { 0.34368286022299821, 0.0000000000000000, 0.40000000000000002, 
+  { 0.35476219513871499, 0.0000000000000000, 0.40000000000000002, 
 	  0.34906585039886590 },
-  { 0.50651268947499395, 0.0000000000000000, 0.40000000000000002, 
+  { 0.54290749235440094, 0.0000000000000000, 0.40000000000000002, 
 	  0.52359877559829882 },
-  { 0.66074441806097539, 0.0000000000000000, 0.40000000000000002, 
+  { 0.74406433757109913, 0.0000000000000000, 0.40000000000000002, 
 	  0.69813170079773179 },
-  { 0.80622931670113474, 0.0000000000000000, 0.40000000000000002, 
+  { 0.96236826162553313, 0.0000000000000000, 0.40000000000000002, 
 	  0.87266462599716477 },
-  { 0.94389791565435210, 0.0000000000000000, 0.40000000000000002, 
+  { 1.2009785880262487, 0.0000000000000000, 0.40000000000000002, 
 	  1.0471975511965976 },
-  { 1.0753503387899728, 0.0000000000000000, 0.40000000000000002, 
+  { 1.4608000106167567, 0.0000000000000000, 0.40000000000000002, 
 	  1.2217304763960306 },
-  { 1.2025374759127518, 0.0000000000000000, 0.40000000000000002, 
+  { 1.7389349574753439, 0.0000000000000000, 0.40000000000000002, 
 	  1.3962634015954636 },
-  { 1.3275651989026320, 0.0000000000000000, 0.40000000000000002, 
+  { 2.0278893379868057, 0.0000000000000000, 0.40000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler095 = 2.5000000000000020e-13;
 
 // Test data for k=0.0000000000000000, nu=0.50000000000000000.
-// max(|f - f_GSL|): 3.3306690738754696e-16
-// max(|f - f_GSL| / |f_GSL|): 3.6090167266677240e-16
+// max(|f - f_Boost|): 2.2204460492503131e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 2.0254203825026289e-16
+// mean(f - f_Boost): -1.9428902930940238e-17
+// variance(f - f_Boost): 4.6602749271592373e-35
+// stddev(f - f_Boost): 6.8266206333435850e-18
 const testcase_ellint_3<double>
 data096[10] =
 {
   { 0.0000000000000000, 0.0000000000000000, 0.50000000000000000, 
 	  0.0000000000000000 },
-  { 0.17366010776037044, 0.0000000000000000, 0.50000000000000000, 
+  { 0.17542170661831016, 0.0000000000000000, 0.50000000000000000, 
 	  0.17453292519943295 },
-  { 0.34238253799539309, 0.0000000000000000, 0.50000000000000000, 
+  { 0.35623911740195419, 0.0000000000000000, 0.50000000000000000, 
 	  0.34906585039886590 },
-  { 0.50253707775976397, 0.0000000000000000, 0.50000000000000000, 
+  { 0.54814449099863127, 0.0000000000000000, 0.50000000000000000, 
 	  0.52359877559829882 },
-  { 0.65242145347295766, 0.0000000000000000, 0.50000000000000000, 
+  { 0.75731546607718081, 0.0000000000000000, 0.50000000000000000, 
 	  0.69813170079773179 },
-  { 0.79210420018698058, 0.0000000000000000, 0.50000000000000000, 
+  { 0.99028751188233310, 0.0000000000000000, 0.50000000000000000, 
 	  0.87266462599716477 },
-  { 0.92287437995632171, 0.0000000000000000, 0.50000000000000000, 
+  { 1.2531022857760581, 0.0000000000000000, 0.50000000000000000, 
 	  1.0471975511965976 },
-  { 1.0466900550798659, 0.0000000000000000, 0.50000000000000000, 
+  { 1.5491761777615785, 0.0000000000000000, 0.50000000000000000, 
 	  1.2217304763960306 },
-  { 1.1658007366618623, 0.0000000000000000, 0.50000000000000000, 
+  { 1.8758359693666533, 0.0000000000000000, 0.50000000000000000, 
 	  1.3962634015954636 },
-  { 1.2825498301618641, 0.0000000000000000, 0.50000000000000000, 
+  { 2.2214414690791831, 0.0000000000000000, 0.50000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler096 = 2.5000000000000020e-13;
 
-// Test data for k=0.0000000000000000, nu=0.59999999999999998.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 2.4581288258006758e-16
+// Test data for k=0.0000000000000000, nu=0.60000000000000009.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 2.1742785192400269e-16
+// mean(f - f_Boost): 1.3877787807814457e-17
+// variance(f - f_Boost): 2.3776912893669577e-35
+// stddev(f - f_Boost): 4.8761575952454181e-18
 const testcase_ellint_3<double>
 data097[10] =
 {
-  { 0.0000000000000000, 0.0000000000000000, 0.59999999999999998, 
+  { 0.0000000000000000, 0.0000000000000000, 0.60000000000000009, 
 	  0.0000000000000000 },
-  { 0.17348741514884700, 0.0000000000000000, 0.59999999999999998, 
+  { 0.17560142466065651, 0.0000000000000000, 0.60000000000000009, 
 	  0.17453292519943295 },
-  { 0.34109952405241289, 0.0000000000000000, 0.59999999999999998, 
+  { 0.35773830754879005, 0.0000000000000000, 0.60000000000000009, 
 	  0.34906585039886590 },
-  { 0.49866850781226285, 0.0000000000000000, 0.59999999999999998, 
+  { 0.55356583986445973, 0.0000000000000000, 0.60000000000000009, 
 	  0.52359877559829882 },
-  { 0.64444732407062499, 0.0000000000000000, 0.59999999999999998, 
+  { 0.77143701715151514, 0.0000000000000000, 0.60000000000000009, 
 	  0.69813170079773179 },
-  { 0.77877564686544720, 0.0000000000000000, 0.59999999999999998, 
+  { 1.0212334940541210, 0.0000000000000000, 0.60000000000000009, 
 	  0.87266462599716477 },
-  { 0.90330743691883475, 0.0000000000000000, 0.59999999999999998, 
+  { 1.3137928444460387, 0.0000000000000000, 0.60000000000000009, 
 	  1.0471975511965976 },
-  { 1.0203257987604104, 0.0000000000000000, 0.59999999999999998, 
+  { 1.6579755004159076, 0.0000000000000000, 0.60000000000000009, 
 	  1.2217304763960306 },
-  { 1.1323247918768629, 0.0000000000000000, 0.59999999999999998, 
+  { 2.0537461418295506, 0.0000000000000000, 0.60000000000000009, 
 	  1.3962634015954636 },
-  { 1.2418235332245127, 0.0000000000000000, 0.59999999999999998, 
+  { 2.4836470664490253, 0.0000000000000000, 0.60000000000000009, 
 	  1.5707963267948966 },
 };
 const double toler097 = 2.5000000000000020e-13;
 
-// Test data for k=0.0000000000000000, nu=0.69999999999999996.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 2.5088894797856263e-16
+// Test data for k=0.0000000000000000, nu=0.70000000000000007.
+// max(|f - f_Boost|): 2.2204460492503131e-16 at index 4
+// max(|f - f_Boost| / |f_Boost|): 3.0903019454022601e-16
+// mean(f - f_Boost): -6.9388939039072284e-17
+// variance(f - f_Boost): 5.9442282234173945e-34
+// stddev(f - f_Boost): 2.4380787976227090e-17
 const testcase_ellint_3<double>
 data098[10] =
 {
-  { 0.0000000000000000, 0.0000000000000000, 0.69999999999999996, 
+  { 0.0000000000000000, 0.0000000000000000, 0.70000000000000007, 
 	  0.0000000000000000 },
-  { 0.17331533692234474, 0.0000000000000000, 0.69999999999999996, 
+  { 0.17578180667760368, 0.0000000000000000, 0.70000000000000007, 
 	  0.17453292519943295 },
-  { 0.33983341309265935, 0.0000000000000000, 0.69999999999999996, 
+  { 0.35926037139410999, 0.0000000000000000, 0.70000000000000007, 
 	  0.34906585039886590 },
-  { 0.49490198805931979, 0.0000000000000000, 0.69999999999999996, 
+  { 0.55918341315855080, 0.0000000000000000, 0.70000000000000007, 
 	  0.52359877559829882 },
-  { 0.63679715525145297, 0.0000000000000000, 0.69999999999999996, 
+  { 0.78653584856932546, 0.0000000000000000, 0.70000000000000007, 
 	  0.69813170079773179 },
-  { 0.76616861049481944, 0.0000000000000000, 0.69999999999999996, 
+  { 1.0558379029273324, 0.0000000000000000, 0.70000000000000007, 
 	  0.87266462599716477 },
-  { 0.88503143209004198, 0.0000000000000000, 0.69999999999999996, 
+  { 1.3858662544850615, 0.0000000000000000, 0.70000000000000007, 
 	  1.0471975511965976 },
-  { 0.99596060249112173, 0.0000000000000000, 0.69999999999999996, 
+  { 1.7970491170359040, 0.0000000000000000, 0.70000000000000007, 
 	  1.2217304763960306 },
-  { 1.1016495050260424, 0.0000000000000000, 0.69999999999999996, 
+  { 2.2992404490153917, 0.0000000000000000, 0.70000000000000007, 
 	  1.3962634015954636 },
-  { 1.2047457872617382, 0.0000000000000000, 0.69999999999999996, 
+  { 2.8678686047727382, 0.0000000000000000, 0.70000000000000007, 
 	  1.5707963267948966 },
 };
 const double toler098 = 2.5000000000000020e-13;
 
 // Test data for k=0.0000000000000000, nu=0.80000000000000004.
-// max(|f - f_GSL|): 3.3306690738754696e-16
-// max(|f - f_GSL| / |f_GSL|): 3.8375904358197891e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 2.2373744057922657e-16
+// mean(f - f_Boost): 1.0269562977782698e-16
+// variance(f - f_Boost): 1.4388836606733082e-32
+// stddev(f - f_Boost): 1.1995347684303728e-16
 const testcase_ellint_3<double>
 data099[10] =
 {
   { 0.0000000000000000, 0.0000000000000000, 0.80000000000000004, 
 	  0.0000000000000000 },
-  { 0.17314386919344210, 0.0000000000000000, 0.80000000000000004, 
+  { 0.17596285706118869, 0.0000000000000000, 0.80000000000000004, 
 	  0.17453292519943295 },
-  { 0.33858381342073240, 0.0000000000000000, 0.80000000000000004, 
+  { 0.36080593896484231, 0.0000000000000000, 0.80000000000000004, 
 	  0.34906585039886590 },
-  { 0.49123285640844727, 0.0000000000000000, 0.80000000000000004, 
+  { 0.56501022706967863, 0.0000000000000000, 0.80000000000000004, 
 	  0.52359877559829882 },
-  { 0.62944854858904509, 0.0000000000000000, 0.80000000000000004, 
+  { 0.80273891984116930, 0.0000000000000000, 0.80000000000000004, 
 	  0.69813170079773179 },
-  { 0.75421778305499343, 0.0000000000000000, 0.80000000000000004, 
+  { 1.0949425007763358, 0.0000000000000000, 0.80000000000000004, 
 	  0.87266462599716477 },
-  { 0.86790634112156617, 0.0000000000000000, 0.80000000000000004, 
+  { 1.4736985692253419, 0.0000000000000000, 0.80000000000000004, 
 	  1.0471975511965976 },
-  { 0.97334918087427558, 0.0000000000000000, 0.80000000000000004, 
+  { 1.9848676587180696, 0.0000000000000000, 0.80000000000000004, 
 	  1.2217304763960306 },
-  { 1.0734012615283985, 0.0000000000000000, 0.80000000000000004, 
+  { 2.6726187823193546, 0.0000000000000000, 0.80000000000000004, 
 	  1.3962634015954636 },
-  { 1.1708024551734544, 0.0000000000000000, 0.80000000000000004, 
+  { 3.5124073655203634, 0.0000000000000000, 0.80000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler099 = 2.5000000000000020e-13;
 
 // Test data for k=0.0000000000000000, nu=0.90000000000000002.
-// max(|f - f_GSL|): 1.1102230246251565e-16
-// max(|f - f_GSL| / |f_GSL|): 1.7838310376154469e-16
+// max(|f - f_Boost|): 2.2204460492503131e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 6.6108624815885066e-16
+// mean(f - f_Boost): 2.1371793224034264e-16
+// variance(f - f_Boost): 5.6389326618626776e-33
+// stddev(f - f_Boost): 7.5092826966779442e-17
 const testcase_ellint_3<double>
 data100[10] =
 {
   { 0.0000000000000000, 0.0000000000000000, 0.90000000000000002, 
 	  0.0000000000000000 },
-  { 0.17297300811030597, 0.0000000000000000, 0.90000000000000002, 
+  { 0.17614458024574997, 0.0000000000000000, 0.90000000000000002, 
 	  0.17453292519943295 },
-  { 0.33735034635360817, 0.0000000000000000, 0.90000000000000002, 
+  { 0.36237566578821978, 0.0000000000000000, 0.90000000000000002, 
 	  0.34906585039886590 },
-  { 0.48765675230233130, 0.0000000000000000, 0.90000000000000002, 
+  { 0.57106058859196640, 0.0000000000000000, 0.90000000000000002, 
 	  0.52359877559829882 },
-  { 0.62238126886123568, 0.0000000000000000, 0.90000000000000002, 
+  { 0.82019857015755915, 0.0000000000000000, 0.90000000000000002, 
 	  0.69813170079773179 },
-  { 0.74286600807269243, 0.0000000000000000, 0.90000000000000002, 
+  { 1.1397014388908147, 0.0000000000000000, 0.90000000000000002, 
 	  0.87266462599716477 },
-  { 0.85181283909264949, 0.0000000000000000, 0.90000000000000002, 
+  { 1.5845952415154960, 0.0000000000000000, 0.90000000000000002, 
 	  1.0471975511965976 },
-  { 0.95228683995371133, 0.0000000000000000, 0.90000000000000002, 
+  { 2.2620531413370775, 0.0000000000000000, 0.90000000000000002, 
 	  1.2217304763960306 },
-  { 1.0472730487412552, 0.0000000000000000, 0.90000000000000002, 
+  { 3.3587842061975066, 0.0000000000000000, 0.90000000000000002, 
 	  1.3962634015954636 },
-  { 1.1395754288497419, 0.0000000000000000, 0.90000000000000002, 
+  { 4.9672941328980507, 0.0000000000000000, 0.90000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler100 = 2.5000000000000020e-13;
 
 // Test data for k=0.10000000000000009, nu=0.0000000000000000.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.1735566504509650e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 3.1735566504509645e-16
+// mean(f - f_Boost): -5.8286708792820721e-17
+// variance(f - f_Boost): 4.1942474344433133e-34
+// stddev(f - f_Boost): 2.0479861900030756e-17
 const testcase_ellint_3<double>
 data101[10] =
 {
   { 0.0000000000000000, 0.10000000000000009, 0.0000000000000000, 
 	  0.0000000000000000 },
-  { 0.17454173353063659, 0.10000000000000009, 0.0000000000000000, 
+  { 0.17454173353063662, 0.10000000000000009, 0.0000000000000000, 
 	  0.17453292519943295 },
-  { 0.34913506721468091, 0.10000000000000009, 0.0000000000000000, 
+  { 0.34913506721468096, 0.10000000000000009, 0.0000000000000000, 
 	  0.34906585039886590 },
-  { 0.52382550016538942, 0.10000000000000009, 0.0000000000000000, 
+  { 0.52382550016538953, 0.10000000000000009, 0.0000000000000000, 
 	  0.52359877559829882 },
   { 0.69864700854177020, 0.10000000000000009, 0.0000000000000000, 
 	  0.69813170079773179 },
-  { 0.87361792586964870, 0.10000000000000009, 0.0000000000000000, 
+  { 0.87361792586964859, 0.10000000000000009, 0.0000000000000000, 
 	  0.87266462599716477 },
-  { 1.0487386319621683, 0.10000000000000009, 0.0000000000000000, 
+  { 1.0487386319621685, 0.10000000000000009, 0.0000000000000000, 
 	  1.0471975511965976 },
-  { 1.2239913752078757, 0.10000000000000009, 0.0000000000000000, 
+  { 1.2239913752078759, 0.10000000000000009, 0.0000000000000000, 
 	  1.2217304763960306 },
-  { 1.3993423113684049, 0.10000000000000009, 0.0000000000000000, 
+  { 1.3993423113684051, 0.10000000000000009, 0.0000000000000000, 
 	  1.3962634015954636 },
-  { 1.5747455615173562, 0.10000000000000009, 0.0000000000000000, 
+  { 1.5747455615173560, 0.10000000000000009, 0.0000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler101 = 2.5000000000000020e-13;
 
 // Test data for k=0.10000000000000009, nu=0.10000000000000001.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.3097339877269682e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 3.0305747373482148e-16
+// mean(f - f_Boost): -3.0531133177191807e-17
+// variance(f - f_Boost): 1.1508025840536076e-34
+// stddev(f - f_Boost): 1.0727546709539920e-17
 const testcase_ellint_3<double>
 data102[10] =
 {
   { 0.0000000000000000, 0.10000000000000009, 0.10000000000000001, 
 	  0.0000000000000000 },
-  { 0.17436589347616613, 0.10000000000000009, 0.10000000000000001, 
+  { 0.17471821213559732, 0.10000000000000009, 0.10000000000000001, 
 	  0.17453292519943295 },
-  { 0.34776067871237359, 0.10000000000000009, 0.10000000000000001, 
+  { 0.35052902610011138, 0.10000000000000009, 0.10000000000000001, 
 	  0.34906585039886590 },
-  { 0.51936064354727796, 0.10000000000000009, 0.10000000000000001, 
+  { 0.52842865990255727, 0.10000000000000009, 0.10000000000000001, 
 	  0.52359877559829882 },
-  { 0.68860303749364349, 0.10000000000000009, 0.10000000000000001, 
+  { 0.70921799731166713, 0.10000000000000009, 0.10000000000000001, 
 	  0.69813170079773179 },
-  { 0.85524561882332051, 0.10000000000000009, 0.10000000000000001, 
+  { 0.89340330535868662, 0.10000000000000009, 0.10000000000000001, 
 	  0.87266462599716477 },
-  { 1.0193708301908335, 0.10000000000000009, 0.10000000000000001, 
+  { 1.0811075784236857, 0.10000000000000009, 0.10000000000000001, 
 	  1.0471975511965976 },
-  { 1.1813474067123044, 0.10000000000000009, 0.10000000000000001, 
+  { 1.2720133232666426, 0.10000000000000009, 0.10000000000000001, 
 	  1.2217304763960306 },
-  { 1.3417670770424983, 0.10000000000000009, 0.10000000000000001, 
+  { 1.4653630031861395, 0.10000000000000009, 0.10000000000000001, 
 	  1.3962634015954636 },
-  { 1.5013711111199950, 0.10000000000000009, 0.10000000000000001, 
+  { 1.6600374067558428, 0.10000000000000009, 0.10000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler102 = 2.5000000000000020e-13;
 
 // Test data for k=0.10000000000000009, nu=0.20000000000000001.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.4399947764827574e-16
+// max(|f - f_Boost|): 2.2204460492503131e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 1.6736714959992433e-16
+// mean(f - f_Boost): 5.5511151231257830e-18
+// variance(f - f_Boost): 3.8043060629871325e-36
+// stddev(f - f_Boost): 1.9504630380981673e-18
 const testcase_ellint_3<double>
 data103[10] =
 {
   { 0.0000000000000000, 0.10000000000000009, 0.20000000000000001, 
 	  0.0000000000000000 },
-  { 0.17419068786141340, 0.10000000000000009, 0.20000000000000001, 
+  { 0.17489533344059083, 0.10000000000000009, 0.20000000000000001, 
 	  0.17453292519943295 },
-  { 0.34640537686230133, 0.10000000000000009, 0.20000000000000001, 
+  { 0.35194305707815038, 0.10000000000000009, 0.20000000000000001, 
 	  0.34906585039886590 },
-  { 0.51502689171753946, 0.10000000000000009, 0.20000000000000001, 
+  { 0.53317790741512527, 0.10000000000000009, 0.20000000000000001, 
 	  0.52359877559829882 },
-  { 0.67904147863672715, 0.10000000000000009, 0.20000000000000001, 
+  { 0.72036681615081222, 0.10000000000000009, 0.20000000000000001, 
 	  0.69813170079773179 },
-  { 0.83811885126105179, 0.10000000000000009, 0.20000000000000001, 
+  { 0.91480372268244303, 0.10000000000000009, 0.20000000000000001, 
 	  0.87266462599716477 },
-  { 0.99255278555742787, 0.10000000000000009, 0.20000000000000001, 
+  { 1.1170528708071514, 0.10000000000000009, 0.20000000000000001, 
 	  1.0471975511965976 },
-  { 1.1431260546194930, 0.10000000000000009, 0.20000000000000001, 
+  { 1.3266916802718358, 0.10000000000000009, 0.20000000000000001, 
 	  1.2217304763960306 },
-  { 1.2909589656532101, 0.10000000000000009, 0.20000000000000001, 
+  { 1.5421622241831547, 0.10000000000000009, 0.20000000000000001, 
 	  1.3962634015954636 },
-  { 1.4373749386463430, 0.10000000000000009, 0.20000000000000001, 
+  { 1.7608656115083421, 0.10000000000000009, 0.20000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler103 = 2.5000000000000020e-13;
 
-// Test data for k=0.10000000000000009, nu=0.29999999999999999.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.5650492137236872e-16
+// Test data for k=0.10000000000000009, nu=0.30000000000000004.
+// max(|f - f_Boost|): 2.2204460492503131e-16 at index 6
+// max(|f - f_Boost| / |f_Boost|): 1.9186071760326645e-16
+// mean(f - f_Boost): -1.6653345369377347e-17
+// variance(f - f_Boost): 3.4238754566884194e-35
+// stddev(f - f_Boost): 5.8513891142945016e-18
 const testcase_ellint_3<double>
 data104[10] =
 {
-  { 0.0000000000000000, 0.10000000000000009, 0.29999999999999999, 
+  { 0.0000000000000000, 0.10000000000000009, 0.30000000000000004, 
 	  0.0000000000000000 },
-  { 0.17401611261390104, 0.10000000000000009, 0.29999999999999999, 
+  { 0.17507310163441189, 0.10000000000000009, 0.30000000000000004, 
 	  0.17453292519943295 },
-  { 0.34506869507511773, 0.10000000000000009, 0.29999999999999999, 
+  { 0.35337768072524217, 0.10000000000000009, 0.30000000000000004, 
 	  0.34906585039886590 },
-  { 0.51081757604259859, 0.10000000000000009, 0.29999999999999999, 
+  { 0.53808167801629170, 0.10000000000000009, 0.30000000000000004, 
 	  0.52359877559829882 },
-  { 0.66992297597712303, 0.10000000000000009, 0.29999999999999999, 
+  { 0.73215166755955019, 0.10000000000000009, 0.30000000000000004, 
 	  0.69813170079773179 },
-  { 0.82209722856174228, 0.10000000000000009, 0.29999999999999999, 
+  { 0.93806546000201219, 0.10000000000000009, 0.30000000000000004, 
 	  0.87266462599716477 },
-  { 0.96792430487669590, 0.10000000000000009, 0.29999999999999999, 
+  { 1.1573218723395986, 0.10000000000000009, 0.30000000000000004, 
 	  1.0471975511965976 },
-  { 1.1085964108954092, 0.10000000000000009, 0.29999999999999999, 
+  { 1.3897859679542097, 0.10000000000000009, 0.30000000000000004, 
 	  1.2217304763960306 },
-  { 1.2456748370836999, 0.10000000000000009, 0.29999999999999999, 
+  { 1.6331009404328622, 0.10000000000000009, 0.30000000000000004, 
 	  1.3962634015954636 },
-  { 1.3809159606704959, 0.10000000000000009, 0.29999999999999999, 
+  { 1.8826015946315438, 0.10000000000000009, 0.30000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler104 = 2.5000000000000020e-13;
 
 // Test data for k=0.10000000000000009, nu=0.40000000000000002.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.6854758534459740e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.0338059536914377e-16
+// mean(f - f_Boost): 2.7755575615628914e-17
+// variance(f - f_Boost): 9.5107651574678308e-35
+// stddev(f - f_Boost): 9.7523151904908362e-18
 const testcase_ellint_3<double>
 data105[10] =
 {
   { 0.0000000000000000, 0.10000000000000009, 0.40000000000000002, 
 	  0.0000000000000000 },
-  { 0.17384216369897931, 0.10000000000000009, 0.40000000000000002, 
+  { 0.17525152094559704, 0.10000000000000009, 0.40000000000000002, 
 	  0.17453292519943295 },
-  { 0.34375018311376787, 0.10000000000000009, 0.40000000000000002, 
+  { 0.35483343742825979, 0.10000000000000009, 0.40000000000000002, 
 	  0.34906585039886590 },
-  { 0.50672650758380455, 0.10000000000000009, 0.40000000000000002, 
+  { 0.54314913099505446, 0.10000000000000009, 0.40000000000000002, 
 	  0.52359877559829882 },
-  { 0.66121264213337616, 0.10000000000000009, 0.40000000000000002, 
+  { 0.74463962034766862, 0.10000000000000009, 0.40000000000000002, 
 	  0.69813170079773179 },
-  { 0.80706202005774441, 0.10000000000000009, 0.40000000000000002, 
+  { 0.96349276837570441, 0.10000000000000009, 0.40000000000000002, 
 	  0.87266462599716477 },
-  { 0.94519376138245870, 0.10000000000000009, 0.40000000000000002, 
+  { 1.2029081382746343, 0.10000000000000009, 0.40000000000000002, 
 	  1.0471975511965976 },
-  { 1.0771880300759584, 0.10000000000000009, 0.40000000000000002, 
+  { 1.4638022887050806, 0.10000000000000009, 0.40000000000000002, 
 	  1.2217304763960306 },
-  { 1.2049711557188272, 0.10000000000000009, 0.40000000000000002, 
+  { 1.7432413830105224, 0.10000000000000009, 0.40000000000000002, 
 	  1.3962634015954636 },
-  { 1.3306223265207477, 0.10000000000000009, 0.40000000000000002, 
+  { 2.0336367403076760, 0.10000000000000009, 0.40000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler105 = 2.5000000000000020e-13;
 
 // Test data for k=0.10000000000000009, nu=0.50000000000000000.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.8017534281650347e-16
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.9864616042835278e-16
+// mean(f - f_Boost): 9.4368957093138303e-17
+// variance(f - f_Boost): 7.7794254682023874e-32
+// stddev(f - f_Boost): 2.7891621444803792e-16
 const testcase_ellint_3<double>
 data106[10] =
 {
   { 0.0000000000000000, 0.10000000000000009, 0.50000000000000000, 
 	  0.0000000000000000 },
-  { 0.17366883711936548, 0.10000000000000009, 0.50000000000000000, 
+  { 0.17543059564292182, 0.10000000000000009, 0.50000000000000000, 
 	  0.17453292519943295 },
-  { 0.34244940634881882, 0.10000000000000009, 0.50000000000000000, 
+  { 0.35631088838721664, 0.10000000000000009, 0.50000000000000000, 
 	  0.34906585039886590 },
-  { 0.50274793281634367, 0.10000000000000009, 0.50000000000000000, 
+  { 0.54839023346436455, 0.10000000000000009, 0.50000000000000000, 
 	  0.52359877559829882 },
-  { 0.65287941633275082, 0.10000000000000009, 0.50000000000000000, 
+  { 0.75790846946088830, 0.10000000000000009, 0.50000000000000000, 
 	  0.69813170079773179 },
-  { 0.79291198790315398, 0.10000000000000009, 0.50000000000000000, 
+  { 0.99146713686720678, 0.10000000000000009, 0.50000000000000000, 
 	  0.87266462599716477 },
-  { 0.92412201537880323, 0.10000000000000009, 0.50000000000000000, 
+  { 1.2551692247937198, 0.10000000000000009, 0.50000000000000000, 
 	  1.0471975511965976 },
-  { 1.0484480076799372, 0.10000000000000009, 0.50000000000000000, 
+  { 1.5524660788146873, 0.10000000000000009, 0.50000000000000000, 
 	  1.2217304763960306 },
-  { 1.1681168130475206, 0.10000000000000009, 0.50000000000000000, 
+  { 1.8806578570830670, 0.10000000000000009, 0.50000000000000000, 
 	  1.3962634015954636 },
-  { 1.2854480708580160, 0.10000000000000009, 0.50000000000000000, 
+  { 2.2279868912966849, 0.10000000000000009, 0.50000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler106 = 2.5000000000000020e-13;
 
-// Test data for k=0.10000000000000009, nu=0.59999999999999998.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.9142834151672032e-16
+// Test data for k=0.10000000000000009, nu=0.60000000000000009.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 2.6726146516228014e-16
+// mean(f - f_Boost): -3.6082248300317589e-17
+// variance(f - f_Boost): 1.6073193116120635e-34
+// stddev(f - f_Boost): 1.2678009747638087e-17
 const testcase_ellint_3<double>
 data107[10] =
 {
-  { 0.0000000000000000, 0.10000000000000009, 0.59999999999999998, 
+  { 0.0000000000000000, 0.10000000000000009, 0.60000000000000009, 
 	  0.0000000000000000 },
-  { 0.17349612891469013, 0.10000000000000009, 0.59999999999999998, 
+  { 0.17561033003590576, 0.10000000000000009, 0.60000000000000009, 
 	  0.17453292519943295 },
-  { 0.34116594505539444, 0.10000000000000009, 0.59999999999999998, 
+  { 0.35781061668171932, 0.10000000000000009, 0.60000000000000009, 
 	  0.34906585039886590 },
-  { 0.49887649430466674, 0.10000000000000009, 0.59999999999999998, 
+  { 0.55381585659629196, 0.10000000000000009, 0.60000000000000009, 
 	  0.52359877559829882 },
-  { 0.64489553282165146, 0.10000000000000009, 0.59999999999999998, 
+  { 0.77204910484575640, 0.10000000000000009, 0.60000000000000009, 
 	  0.69813170079773179 },
-  { 0.77956016553782437, 0.10000000000000009, 0.59999999999999998, 
+  { 1.0224751740393108, 0.10000000000000009, 0.60000000000000009, 
 	  0.87266462599716477 },
-  { 0.90451074530096287, 0.10000000000000009, 0.59999999999999998, 
+  { 1.3160230906351114, 0.10000000000000009, 0.60000000000000009, 
 	  1.0471975511965976 },
-  { 1.0220113666961632, 0.10000000000000009, 0.59999999999999998, 
+  { 1.6616282844233206, 0.10000000000000009, 0.60000000000000009, 
 	  1.2217304763960306 },
-  { 1.1345351441065563, 0.10000000000000009, 0.59999999999999998, 
+  { 2.0592555664850392, 0.10000000000000009, 0.60000000000000009, 
 	  1.3962634015954636 },
-  { 1.2445798942989255, 0.10000000000000009, 0.59999999999999998, 
+  { 2.4913004919173822, 0.10000000000000009, 0.60000000000000009, 
 	  1.5707963267948966 },
 };
 const double toler107 = 2.5000000000000020e-13;
 
-// Test data for k=0.10000000000000009, nu=0.69999999999999996.
-// max(|f - f_GSL|): 6.6613381477509392e-16
-// max(|f - f_GSL| / |f_GSL|): 5.5172091551439012e-16
+// Test data for k=0.10000000000000009, nu=0.70000000000000007.
+// max(|f - f_Boost|): 2.2204460492503131e-16 at index 5
+// max(|f - f_Boost| / |f_Boost|): 2.1004074871280821e-16
+// mean(f - f_Boost): 3.3306690738754695e-17
+// variance(f - f_Boost): 1.3695501826753678e-34
+// stddev(f - f_Boost): 1.1702778228589003e-17
 const testcase_ellint_3<double>
 data108[10] =
 {
-  { 0.0000000000000000, 0.10000000000000009, 0.69999999999999996, 
+  { 0.0000000000000000, 0.10000000000000009, 0.70000000000000007, 
 	  0.0000000000000000 },
-  { 0.17332403516105047, 0.10000000000000009, 0.69999999999999996, 
+  { 0.17579072847532518, 0.10000000000000009, 0.70000000000000007, 
 	  0.17453292519943295 },
-  { 0.33989939374896883, 0.10000000000000009, 0.69999999999999996, 
+  { 0.35933322840606297, 0.10000000000000009, 0.70000000000000007, 
 	  0.34906585039886590 },
-  { 0.49510719568614070, 0.10000000000000009, 0.69999999999999996, 
+  { 0.55943788649460324, 0.10000000000000009, 0.70000000000000007, 
 	  0.52359877559829882 },
-  { 0.63723607776354974, 0.10000000000000009, 0.69999999999999996, 
+  { 0.78716856504031707, 0.10000000000000009, 0.70000000000000007, 
 	  0.69813170079773179 },
-  { 0.76693133887935327, 0.10000000000000009, 0.69999999999999996, 
+  { 1.0571501305617423, 0.10000000000000009, 0.70000000000000007, 
 	  0.87266462599716477 },
-  { 0.88619382078823805, 0.10000000000000009, 0.69999999999999996, 
+  { 1.3882948301743525, 0.10000000000000009, 0.70000000000000007, 
 	  1.0471975511965976 },
-  { 0.99758012018676490, 0.10000000000000009, 0.69999999999999996, 
+  { 1.8011785680114223, 0.10000000000000009, 0.70000000000000007, 
 	  1.2217304763960306 },
-  { 1.1037642270814410, 0.10000000000000009, 0.69999999999999996, 
+  { 2.3057268183616464, 0.10000000000000009, 0.70000000000000007, 
 	  1.3962634015954636 },
-  { 1.2073745911083185, 0.10000000000000009, 0.69999999999999996, 
+  { 2.8771910188009739, 0.10000000000000009, 0.70000000000000007, 
 	  1.5707963267948966 },
 };
 const double toler108 = 2.5000000000000020e-13;
 
 // Test data for k=0.10000000000000009, nu=0.80000000000000004.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.1294144515772258e-16
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 3.3133043868392355e-16
+// mean(f - f_Boost): 1.8041124150158794e-16
+// variance(f - f_Boost): 6.1843750436434569e-32
+// stddev(f - f_Boost): 2.4868403735751633e-16
 const testcase_ellint_3<double>
 data109[10] =
 {
   { 0.0000000000000000, 0.10000000000000009, 0.80000000000000004, 
 	  0.0000000000000000 },
-  { 0.17315255197057014, 0.10000000000000009, 0.80000000000000004, 
+  { 0.17597179535373417, 0.10000000000000009, 0.80000000000000004, 
 	  0.17453292519943295 },
-  { 0.33864936055747991, 0.10000000000000009, 0.80000000000000004, 
+  { 0.36087935387831499, 0.10000000000000009, 0.80000000000000004, 
 	  0.34906585039886590 },
-  { 0.49143537041117613, 0.10000000000000009, 0.80000000000000004, 
+  { 0.56526935244526444, 0.10000000000000009, 0.80000000000000004, 
 	  0.52359877559829882 },
-  { 0.62987861760047492, 0.10000000000000009, 0.80000000000000004, 
+  { 0.80339402590612397, 0.10000000000000009, 0.80000000000000004, 
 	  0.69813170079773179 },
-  { 0.75496005490917517, 0.10000000000000009, 0.80000000000000004, 
+  { 1.0963358646374459, 0.10000000000000009, 0.80000000000000004, 
 	  0.87266462599716477 },
-  { 0.86903081862701881, 0.10000000000000009, 0.80000000000000004, 
+  { 1.4763748483246868, 0.10000000000000009, 0.80000000000000004, 
 	  1.0471975511965976 },
-  { 0.97490814820725591, 0.10000000000000009, 0.80000000000000004, 
+  { 1.9896610222794102, 0.10000000000000009, 0.80000000000000004, 
 	  1.2217304763960306 },
-  { 1.0754290107171083, 0.10000000000000009, 0.80000000000000004, 
+  { 2.6806423920122024, 0.10000000000000009, 0.80000000000000004, 
 	  1.3962634015954636 },
-  { 1.1733158866987732, 0.10000000000000009, 0.80000000000000004, 
+  { 3.5246199613295612, 0.10000000000000009, 0.80000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler109 = 2.5000000000000020e-13;
 
 // Test data for k=0.10000000000000009, nu=0.90000000000000002.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.2325599449457852e-16
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.5624826890976725e-16
+// mean(f - f_Boost): 2.3314683517128288e-16
+// variance(f - f_Boost): 2.9401198977189756e-31
+// stddev(f - f_Boost): 5.4222872459129045e-16
 const testcase_ellint_3<double>
 data110[10] =
 {
   { 0.0000000000000000, 0.10000000000000009, 0.90000000000000002, 
 	  0.0000000000000000 },
-  { 0.17298167549096563, 0.10000000000000009, 0.90000000000000002, 
+  { 0.17615353510599349, 0.10000000000000009, 0.90000000000000002, 
 	  0.17453292519943295 },
-  { 0.33741546662741589, 0.10000000000000009, 0.90000000000000002, 
+  { 0.36244964892922371, 0.10000000000000009, 0.90000000000000002, 
 	  0.34906585039886590 },
-  { 0.48785665376856868, 0.10000000000000009, 0.90000000000000002, 
+  { 0.57132457590110530, 0.10000000000000009, 0.90000000000000002, 
 	  0.52359877559829882 },
-  { 0.62280288554518959, 0.10000000000000009, 0.90000000000000002, 
+  { 0.82087808820385000, 0.10000000000000009, 0.90000000000000002, 
 	  0.69813170079773179 },
-  { 0.74358903115455188, 0.10000000000000009, 0.90000000000000002, 
+  { 1.1411894342144451, 0.10000000000000009, 0.90000000000000002, 
 	  0.87266462599716477 },
-  { 0.85290207679298335, 0.10000000000000009, 0.90000000000000002, 
+  { 1.5875929286844597, 0.10000000000000009, 0.90000000000000002, 
 	  1.0471975511965976 },
-  { 0.95379006645397379, 0.10000000000000009, 0.90000000000000002, 
+  { 2.2678622986596659, 0.10000000000000009, 0.90000000000000002, 
 	  1.2217304763960306 },
-  { 1.0492213119872327, 0.10000000000000009, 0.90000000000000002, 
+  { 3.3697528941897903, 0.10000000000000009, 0.90000000000000002, 
 	  1.3962634015954636 },
-  { 1.1419839485283374, 0.10000000000000009, 0.90000000000000002, 
+  { 4.9862890417305499, 0.10000000000000009, 0.90000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler110 = 2.5000000000000020e-13;
 
-// Test data for k=0.19999999999999996, nu=0.0000000000000000.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.2156475739151676e-16
+// Test data for k=0.20000000000000018, nu=0.0000000000000000.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 6
+// max(|f - f_Boost| / |f_Boost|): 4.2156475739151676e-16
+// mean(f - f_Boost): -5.2735593669694933e-17
+// variance(f - f_Boost): 3.0473442641042680e-32
+// stddev(f - f_Boost): 1.7456644190978597e-16
 const testcase_ellint_3<double>
 data111[10] =
 {
-  { 0.0000000000000000, 0.19999999999999996, 0.0000000000000000, 
+  { 0.0000000000000000, 0.20000000000000018, 0.0000000000000000, 
 	  0.0000000000000000 },
-  { 0.17456817290292809, 0.19999999999999996, 0.0000000000000000, 
+  { 0.17456817290292806, 0.20000000000000018, 0.0000000000000000, 
 	  0.17453292519943295 },
-  { 0.34934315932086801, 0.19999999999999996, 0.0000000000000000, 
+  { 0.34934315932086796, 0.20000000000000018, 0.0000000000000000, 
 	  0.34906585039886590 },
-  { 0.52450880529443988, 0.19999999999999996, 0.0000000000000000, 
+  { 0.52450880529443988, 0.20000000000000018, 0.0000000000000000, 
 	  0.52359877559829882 },
-  { 0.70020491009844876, 0.19999999999999996, 0.0000000000000000, 
+  { 0.70020491009844887, 0.20000000000000018, 0.0000000000000000, 
 	  0.69813170079773179 },
-  { 0.87651006649967955, 0.19999999999999996, 0.0000000000000000, 
+  { 0.87651006649967977, 0.20000000000000018, 0.0000000000000000, 
 	  0.87266462599716477 },
-  { 1.0534305870298994, 0.19999999999999996, 0.0000000000000000, 
+  { 1.0534305870298994, 0.20000000000000018, 0.0000000000000000, 
 	  1.0471975511965976 },
-  { 1.2308975521670784, 0.19999999999999996, 0.0000000000000000, 
+  { 1.2308975521670789, 0.20000000000000018, 0.0000000000000000, 
 	  1.2217304763960306 },
-  { 1.4087733584990738, 0.19999999999999996, 0.0000000000000000, 
+  { 1.4087733584990738, 0.20000000000000018, 0.0000000000000000, 
 	  1.3962634015954636 },
-  { 1.5868678474541660, 0.19999999999999996, 0.0000000000000000, 
+  { 1.5868678474541662, 0.20000000000000018, 0.0000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler111 = 2.5000000000000020e-13;
 
-// Test data for k=0.19999999999999996, nu=0.10000000000000001.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.3374593253183472e-16
+// Test data for k=0.20000000000000018, nu=0.10000000000000001.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 6
+// max(|f - f_Boost| / |f_Boost|): 4.0890622182605400e-16
+// mean(f - f_Boost): -3.8857805861880476e-17
+// variance(f - f_Boost): 2.8794792590749608e-32
+// stddev(f - f_Boost): 1.6969028431454054e-16
 const testcase_ellint_3<double>
 data112[10] =
 {
-  { 0.0000000000000000, 0.19999999999999996, 0.10000000000000001, 
+  { 0.0000000000000000, 0.20000000000000018, 0.10000000000000001, 
 	  0.0000000000000000 },
-  { 0.17439228502691748, 0.19999999999999996, 0.10000000000000001, 
+  { 0.17474469953608965, 0.20000000000000018, 0.10000000000000001, 
 	  0.17453292519943295 },
-  { 0.34796731137565740, 0.19999999999999996, 0.10000000000000001, 
+  { 0.35073860234984255, 0.20000000000000018, 0.10000000000000001, 
 	  0.34906585039886590 },
-  { 0.52003370294544848, 0.19999999999999996, 0.10000000000000001, 
+  { 0.52912258712951521, 0.20000000000000018, 0.10000000000000001, 
 	  0.52359877559829882 },
-  { 0.69012222258631462, 0.19999999999999996, 0.10000000000000001, 
+  { 0.71081701558898069, 0.20000000000000018, 0.10000000000000001, 
 	  0.69813170079773179 },
-  { 0.85803491465566772, 0.19999999999999996, 0.10000000000000001, 
+  { 0.89640758521169384, 0.20000000000000018, 0.10000000000000001, 
 	  0.87266462599716477 },
-  { 1.0238463961099364, 0.19999999999999996, 0.10000000000000001, 
+  { 1.0860417038089853, 0.20000000000000018, 0.10000000000000001, 
 	  1.0471975511965976 },
-  { 1.1878691059202153, 0.19999999999999996, 0.10000000000000001, 
+  { 1.2793599255528623, 0.20000000000000018, 0.10000000000000001, 
 	  1.2217304763960306 },
-  { 1.3505985031831940, 0.19999999999999996, 0.10000000000000001, 
+  { 1.4754938544089076, 0.20000000000000018, 0.10000000000000001, 
 	  1.3962634015954636 },
-  { 1.5126513474261087, 0.19999999999999996, 0.10000000000000001, 
+  { 1.6731552050562593, 0.20000000000000018, 0.10000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler112 = 2.5000000000000020e-13;
 
-// Test data for k=0.19999999999999996, nu=0.20000000000000001.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.4549984059502760e-16
+// Test data for k=0.20000000000000018, nu=0.20000000000000001.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 6
+// max(|f - f_Boost| / |f_Boost|): 3.9570963716579749e-16
+// mean(f - f_Boost): -5.8286708792820721e-17
+// variance(f - f_Boost): 3.1158217732380362e-32
+// stddev(f - f_Boost): 1.7651690494788412e-16
 const testcase_ellint_3<double>
 data113[10] =
 {
-  { 0.0000000000000000, 0.19999999999999996, 0.20000000000000001, 
+  { 0.0000000000000000, 0.20000000000000018, 0.20000000000000001, 
 	  0.0000000000000000 },
-  { 0.17421703179583747, 0.19999999999999996, 0.20000000000000001, 
+  { 0.17492186907740698, 0.20000000000000018, 0.20000000000000001, 
 	  0.17453292519943295 },
-  { 0.34661057411998791, 0.19999999999999996, 0.20000000000000001, 
+  { 0.35215414286134267, 0.20000000000000018, 0.20000000000000001, 
 	  0.34906585039886590 },
-  { 0.51569006052647393, 0.19999999999999996, 0.20000000000000001, 
+  { 0.53388285615182440, 0.20000000000000018, 0.20000000000000001, 
 	  0.52359877559829882 },
-  { 0.68052412821107244, 0.19999999999999996, 0.20000000000000001, 
+  { 0.72200960282688265, 0.20000000000000018, 0.20000000000000001, 
 	  0.69813170079773179 },
-  { 0.84081341263313825, 0.19999999999999996, 0.20000000000000001, 
+  { 0.91793087614428526, 0.20000000000000018, 0.20000000000000001, 
 	  0.87266462599716477 },
-  { 0.99683359988842890, 0.19999999999999996, 0.20000000000000001, 
+  { 1.1222602841587976, 0.20000000000000018, 0.20000000000000001, 
 	  1.0471975511965976 },
-  { 1.1493086715118852, 0.19999999999999996, 0.20000000000000001, 
+  { 1.3345489407496247, 0.20000000000000018, 0.20000000000000001, 
 	  1.2217304763960306 },
-  { 1.2992699693957541, 0.19999999999999996, 0.20000000000000001, 
+  { 1.5531225705475502, 0.20000000000000018, 0.20000000000000001, 
 	  1.3962634015954636 },
-  { 1.4479323932249564, 0.19999999999999996, 0.20000000000000001, 
+  { 1.7751816279738935, 0.20000000000000018, 0.20000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler113 = 2.5000000000000020e-13;
 
-// Test data for k=0.19999999999999996, nu=0.29999999999999999.
-// max(|f - f_GSL|): 6.6613381477509392e-16
-// max(|f - f_GSL| / |f_GSL|): 5.3140668101543467e-16
+// Test data for k=0.20000000000000018, nu=0.30000000000000004.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.6785817924053817e-16
+// mean(f - f_Boost): -1.1102230246251566e-17
+// variance(f - f_Boost): 9.9840208317034302e-32
+// stddev(f - f_Boost): 3.1597501217190311e-16
 const testcase_ellint_3<double>
 data114[10] =
 {
-  { 0.0000000000000000, 0.19999999999999996, 0.29999999999999999, 
+  { 0.0000000000000000, 0.20000000000000018, 0.30000000000000004, 
 	  0.0000000000000000 },
-  { 0.17404240913577704, 0.19999999999999996, 0.29999999999999999, 
+  { 0.17509968571715159, 0.20000000000000018, 0.30000000000000004, 
 	  0.17453292519943295 },
-  { 0.34527248032587193, 0.19999999999999996, 0.29999999999999999, 
+  { 0.35359030214835629, 0.20000000000000018, 0.30000000000000004, 
 	  0.34906585039886590 },
-  { 0.51147118981668416, 0.19999999999999996, 0.29999999999999999, 
+  { 0.53879807274537084, 0.20000000000000018, 0.30000000000000004, 
 	  0.52359877559829882 },
-  { 0.67137107867777601, 0.19999999999999996, 0.29999999999999999, 
+  { 0.73384116418059731, 0.20000000000000018, 0.30000000000000004, 
 	  0.69813170079773179 },
-  { 0.82470418188668893, 0.19999999999999996, 0.29999999999999999, 
+  { 0.94132799329524031, 0.20000000000000018, 0.30000000000000004, 
 	  0.87266462599716477 },
-  { 0.97202873223594299, 0.19999999999999996, 0.29999999999999999, 
+  { 1.1628407021801439, 0.20000000000000018, 0.30000000000000004, 
 	  1.0471975511965976 },
-  { 1.1144773569375266, 0.19999999999999996, 0.29999999999999999, 
+  { 1.3982440216739438, 0.20000000000000018, 0.30000000000000004, 
 	  1.2217304763960306 },
-  { 1.2535292433701000, 0.19999999999999996, 0.29999999999999999, 
+  { 1.6450634983653640, 0.20000000000000018, 0.30000000000000004, 
 	  1.3962634015954636 },
-  { 1.3908453514752477, 0.19999999999999996, 0.29999999999999999, 
+  { 1.8983924169967099, 0.20000000000000018, 0.30000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler114 = 2.5000000000000020e-13;
 
-// Test data for k=0.19999999999999996, nu=0.40000000000000002.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.6788709752760483e-16
+// Test data for k=0.20000000000000018, nu=0.40000000000000002.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 6
+// max(|f - f_Boost| / |f_Boost|): 3.6738449250038925e-16
+// mean(f - f_Boost): -3.0531133177191807e-17
+// variance(f - f_Boost): 2.7810428396951687e-32
+// stddev(f - f_Boost): 1.6676458975739331e-16
 const testcase_ellint_3<double>
 data115[10] =
 {
-  { 0.0000000000000000, 0.19999999999999996, 0.40000000000000002, 
+  { 0.0000000000000000, 0.20000000000000018, 0.40000000000000002, 
 	  0.0000000000000000 },
-  { 0.17386841301066674, 0.19999999999999996, 0.40000000000000002, 
+  { 0.17527815368535152, 0.20000000000000018, 0.40000000000000002, 
 	  0.17453292519943295 },
-  { 0.34395257914113253, 0.19999999999999996, 0.40000000000000002, 
+  { 0.35504762134297801, 0.20000000000000018, 0.40000000000000002, 
 	  0.34906585039886590 },
-  { 0.50737088376869466, 0.19999999999999996, 0.40000000000000002, 
+  { 0.54387742353211344, 0.20000000000000018, 0.40000000000000002, 
 	  0.52359877559829882 },
-  { 0.66262801717277631, 0.19999999999999996, 0.40000000000000002, 
+  { 0.74637910471804259, 0.20000000000000018, 0.40000000000000002, 
 	  0.69813170079773179 },
-  { 0.80958766645079094, 0.19999999999999996, 0.40000000000000002, 
+  { 0.96690539714174639, 0.20000000000000018, 0.40000000000000002, 
 	  0.87266462599716477 },
-  { 0.94913754236162040, 0.19999999999999996, 0.40000000000000002, 
+  { 1.2087859420184757, 0.20000000000000018, 0.40000000000000002, 
 	  1.0471975511965976 },
-  { 1.0827985514222997, 0.19999999999999996, 0.40000000000000002, 
+  { 1.4729799844168852, 0.20000000000000018, 0.40000000000000002, 
 	  1.2217304763960306 },
-  { 1.2124212429050478, 0.19999999999999996, 0.40000000000000002, 
+  { 1.7564445064596661, 0.20000000000000018, 0.40000000000000002, 
 	  1.3962634015954636 },
-  { 1.3400002519661005, 0.19999999999999996, 0.40000000000000002, 
+  { 2.0512956926676806, 0.20000000000000018, 0.40000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler115 = 2.5000000000000020e-13;
 
-// Test data for k=0.19999999999999996, nu=0.50000000000000000.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.7788201301356829e-16
+// Test data for k=0.20000000000000018, nu=0.50000000000000000.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.3841806057292116e-16
+// mean(f - f_Boost): 3.6082248300317589e-17
+// variance(f - f_Boost): 8.9638010532618564e-32
+// stddev(f - f_Boost): 2.9939607634806868e-16
 const testcase_ellint_3<double>
 data116[10] =
 {
-  { 0.0000000000000000, 0.19999999999999996, 0.50000000000000000, 
+  { 0.0000000000000000, 0.20000000000000018, 0.50000000000000000, 
 	  0.0000000000000000 },
-  { 0.17369503942181799, 0.19999999999999996, 0.50000000000000000, 
+  { 0.17545727725228877, 0.20000000000000018, 0.50000000000000000, 
 	  0.17453292519943295 },
-  { 0.34265043534362660, 0.19999999999999996, 0.50000000000000000, 
+  { 0.35652666242062175, 0.20000000000000018, 0.50000000000000000, 
 	  0.34906585039886590 },
-  { 0.50338337208655415, 0.19999999999999996, 0.50000000000000000, 
+  { 0.54913090549102406, 0.20000000000000018, 0.50000000000000000, 
 	  0.52359877559829882 },
-  { 0.65426373297163609, 0.19999999999999996, 0.50000000000000000, 
+  { 0.75970161209211551, 0.20000000000000018, 0.50000000000000000, 
 	  0.69813170079773179 },
-  { 0.79536193036145808, 0.19999999999999996, 0.50000000000000000, 
+  { 0.99504737401590326, 0.20000000000000018, 0.50000000000000000, 
 	  0.87266462599716477 },
-  { 0.92791875910061605, 0.19999999999999996, 0.50000000000000000, 
+  { 1.2614666007124373, 0.20000000000000018, 0.50000000000000000, 
 	  1.0471975511965976 },
-  { 1.0538145052725829, 0.19999999999999996, 0.50000000000000000, 
+  { 1.5625255355205498, 0.20000000000000018, 0.50000000000000000, 
 	  1.2217304763960306 },
-  { 1.1752060022875899, 0.19999999999999996, 0.50000000000000000, 
+  { 1.8954460255613346, 0.20000000000000018, 0.50000000000000000, 
 	  1.3962634015954636 },
-  { 1.2943374404397372, 0.19999999999999996, 0.50000000000000000, 
+  { 2.2481046259421302, 0.20000000000000018, 0.50000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler116 = 2.5000000000000020e-13;
 
-// Test data for k=0.19999999999999996, nu=0.59999999999999998.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.8899223779598256e-16
+// Test data for k=0.20000000000000018, nu=0.60000000000000009.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.5317584994994743e-16
+// mean(f - f_Boost): -1.3877787807814457e-17
+// variance(f - f_Boost): 1.0045745697575397e-31
+// stddev(f - f_Boost): 3.1695024369095219e-16
 const testcase_ellint_3<double>
 data117[10] =
 {
-  { 0.0000000000000000, 0.19999999999999996, 0.59999999999999998, 
+  { 0.0000000000000000, 0.20000000000000018, 0.60000000000000009, 
 	  0.0000000000000000 },
-  { 0.17352228440746925, 0.19999999999999996, 0.59999999999999998, 
+  { 0.17563706072900442, 0.20000000000000018, 0.60000000000000009, 
 	  0.17453292519943295 },
-  { 0.34136562863713626, 0.19999999999999996, 0.59999999999999998, 
+  { 0.35802800926807238, 0.20000000000000018, 0.60000000000000009, 
 	  0.34906585039886590 },
-  { 0.49950328177638481, 0.19999999999999996, 0.59999999999999998, 
+  { 0.55456942250515051, 0.20000000000000018, 0.60000000000000009, 
 	  0.52359877559829882 },
-  { 0.64625032705690799, 0.19999999999999996, 0.59999999999999998, 
+  { 0.77390003828438203, 0.20000000000000018, 0.60000000000000009, 
 	  0.69813170079773179 },
-  { 0.78193941198403083, 0.19999999999999996, 0.59999999999999998, 
+  { 1.0262441366366397, 0.20000000000000018, 0.60000000000000009, 
 	  0.87266462599716477 },
-  { 0.90817230934317128, 0.19999999999999996, 0.59999999999999998, 
+  { 1.3228192988439669, 0.20000000000000018, 0.60000000000000009, 
 	  1.0471975511965976 },
-  { 1.0271563751276462, 0.19999999999999996, 0.59999999999999998, 
+  { 1.6728005754680795, 0.20000000000000018, 0.60000000000000009, 
 	  1.2217304763960306 },
-  { 1.1412999379040518, 0.19999999999999996, 0.59999999999999998, 
+  { 2.0761587107468511, 0.20000000000000018, 0.60000000000000009, 
 	  1.3962634015954636 },
-  { 1.2530330675914556, 0.19999999999999996, 0.59999999999999998, 
+  { 2.5148333891629315, 0.20000000000000018, 0.60000000000000009, 
 	  1.5707963267948966 },
 };
 const double toler117 = 2.5000000000000020e-13;
 
-// Test data for k=0.19999999999999996, nu=0.69999999999999996.
-// max(|f - f_GSL|): 6.6613381477509392e-16
-// max(|f - f_GSL| / |f_GSL|): 5.9999318361775115e-16
+// Test data for k=0.20000000000000018, nu=0.70000000000000007.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.2209418045118284e-16
+// mean(f - f_Boost): 2.4980018054066023e-17
+// variance(f - f_Boost): 9.1989071679544611e-32
+// stddev(f - f_Boost): 3.0329700242426498e-16
 const testcase_ellint_3<double>
 data118[10] =
 {
-  { 0.0000000000000000, 0.19999999999999996, 0.69999999999999996, 
+  { 0.0000000000000000, 0.20000000000000018, 0.70000000000000007, 
 	  0.0000000000000000 },
-  { 0.17335014404233895, 0.19999999999999996, 0.69999999999999996, 
+  { 0.17581750846781172, 0.20000000000000018, 0.70000000000000007, 
 	  0.17453292519943295 },
-  { 0.34009775298617811, 0.19999999999999996, 0.69999999999999996, 
+  { 0.35955226882028513, 0.20000000000000018, 0.70000000000000007, 
 	  0.34906585039886590 },
-  { 0.49572560201923810, 0.19999999999999996, 0.69999999999999996, 
+  { 0.56020489659466499, 0.20000000000000018, 0.70000000000000007, 
 	  0.52359877559829882 },
-  { 0.63856276669886503, 0.19999999999999996, 0.69999999999999996, 
+  { 0.78908196988531498, 0.20000000000000018, 0.70000000000000007, 
 	  0.69813170079773179 },
-  { 0.76924438644867565, 0.19999999999999996, 0.69999999999999996, 
+  { 1.0611336754143517, 0.20000000000000018, 0.70000000000000007, 
 	  0.87266462599716477 },
-  { 0.88973060843856466, 0.19999999999999996, 0.69999999999999996, 
+  { 1.3956969951058884, 0.20000000000000018, 0.70000000000000007, 
 	  1.0471975511965976 },
-  { 1.0025230471636377, 0.19999999999999996, 0.69999999999999996, 
+  { 1.8138131612209609, 0.20000000000000018, 0.70000000000000007, 
 	  1.2217304763960306 },
-  { 1.1102356376093103, 0.19999999999999996, 0.69999999999999996, 
+  { 2.3256365528879561, 0.20000000000000018, 0.70000000000000007, 
 	  1.3962634015954636 },
-  { 1.2154356555075863, 0.19999999999999996, 0.69999999999999996, 
+  { 2.9058704854500963, 0.20000000000000018, 0.70000000000000007, 
 	  1.5707963267948966 },
 };
 const double toler118 = 2.5000000000000020e-13;
 
-// Test data for k=0.19999999999999996, nu=0.80000000000000004.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 5.0901276230707249e-16
+// Test data for k=0.20000000000000018, nu=0.80000000000000004.
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.7399960886656824e-16
+// mean(f - f_Boost): 1.3877787807814457e-16
+// variance(f - f_Boost): 1.7585404776158019e-31
+// stddev(f - f_Boost): 4.1934955319110593e-16
 const testcase_ellint_3<double>
 data119[10] =
 {
-  { 0.0000000000000000, 0.19999999999999996, 0.80000000000000004, 
+  { 0.0000000000000000, 0.20000000000000018, 0.80000000000000004, 
 	  0.0000000000000000 },
-  { 0.17317861443718538, 0.19999999999999996, 0.80000000000000004, 
+  { 0.17599862486281712, 0.20000000000000018, 0.80000000000000004, 
 	  0.17453292519943295 },
-  { 0.33884641598718701, 0.19999999999999996, 0.80000000000000004, 
+  { 0.36110007227128776, 0.20000000000000018, 0.80000000000000004, 
 	  0.34906585039886590 },
-  { 0.49204565281259494, 0.19999999999999996, 0.80000000000000004, 
+  { 0.56605039658567224, 0.20000000000000018, 0.80000000000000004, 
 	  0.52359877559829882 },
-  { 0.63117851188220320, 0.19999999999999996, 0.80000000000000004, 
+  { 0.80537523874517691, 0.20000000000000018, 0.80000000000000004, 
 	  0.69813170079773179 },
-  { 0.75721095949544170, 0.19999999999999996, 0.80000000000000004, 
+  { 1.1005662342414086, 0.20000000000000018, 0.80000000000000004, 
 	  0.87266462599716477 },
-  { 0.87245201443919118, 0.19999999999999996, 0.80000000000000004, 
+  { 1.4845340298105778, 0.20000000000000018, 0.80000000000000004, 
 	  1.0471975511965976 },
-  { 0.97966584238831089, 0.19999999999999996, 0.80000000000000004, 
+  { 2.0043332244969392, 0.20000000000000018, 0.80000000000000004, 
 	  1.2217304763960306 },
-  { 1.0816336325174360, 0.19999999999999996, 0.80000000000000004, 
+  { 2.7052856676744761, 0.20000000000000018, 0.80000000000000004, 
 	  1.3962634015954636 },
-  { 1.1810223448909909, 0.19999999999999996, 0.80000000000000004, 
+  { 3.5622166386422633, 0.20000000000000018, 0.80000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler119 = 2.5000000000000020e-13;
 
-// Test data for k=0.19999999999999996, nu=0.90000000000000002.
-// max(|f - f_GSL|): 6.6613381477509392e-16
-// max(|f - f_GSL| / |f_GSL|): 6.4833128442756722e-16
+// Test data for k=0.20000000000000018, nu=0.90000000000000002.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.1718503329017390e-16
+// mean(f - f_Boost): 2.3592239273284576e-16
+// variance(f - f_Boost): 2.9295534376290287e-31
+// stddev(f - f_Boost): 5.4125349307224141e-16
 const testcase_ellint_3<double>
 data120[10] =
 {
-  { 0.0000000000000000, 0.19999999999999996, 0.90000000000000002, 
+  { 0.0000000000000000, 0.20000000000000018, 0.90000000000000002, 
 	  0.0000000000000000 },
-  { 0.17300769173837277, 0.19999999999999996, 0.90000000000000002, 
+  { 0.17618041435044951, 0.20000000000000018, 0.90000000000000002, 
 	  0.17453292519943295 },
-  { 0.33761123827372508, 0.19999999999999996, 0.90000000000000002, 
+  { 0.36267207636502929, 0.20000000000000018, 0.90000000000000002, 
 	  0.34906585039886590 },
-  { 0.48845905690769426, 0.19999999999999996, 0.90000000000000002, 
+  { 0.57212028758237743, 0.20000000000000018, 0.90000000000000002, 
 	  0.52359877559829882 },
-  { 0.62407720017324952, 0.19999999999999996, 0.90000000000000002, 
+  { 0.82293323876704483, 0.20000000000000018, 0.90000000000000002, 
 	  0.69813170079773179 },
-  { 0.74578146525124289, 0.19999999999999996, 0.90000000000000002, 
+  { 1.1457077279880388, 0.20000000000000018, 0.90000000000000002, 
 	  0.87266462599716477 },
-  { 0.85621583540073076, 0.19999999999999996, 0.90000000000000002, 
+  { 1.5967346899325681, 0.20000000000000018, 0.90000000000000002, 
 	  1.0471975511965976 },
-  { 0.95837725988001199, 0.19999999999999996, 0.90000000000000002, 
+  { 2.2856537353421724, 0.20000000000000018, 0.90000000000000002, 
 	  1.2217304763960306 },
-  { 1.0551821412633928, 0.19999999999999996, 0.90000000000000002, 
+  { 3.4034714304613902, 0.20000000000000018, 0.90000000000000002, 
 	  1.3962634015954636 },
-  { 1.1493679916141861, 0.19999999999999996, 0.90000000000000002, 
+  { 5.0448269356200370, 0.20000000000000018, 0.90000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler120 = 2.5000000000000020e-13;
 
 // Test data for k=0.30000000000000004, nu=0.0000000000000000.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 6.3361874537309281e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.2241249691539529e-16
+// mean(f - f_Boost): 2.7755575615628914e-17
+// variance(f - f_Boost): 2.1399221604302621e-32
+// stddev(f - f_Boost): 1.4628472785736254e-16
 const testcase_ellint_3<double>
 data121[10] =
 {
@@ -3528,19 +3890,19 @@ data121[10] =
 	  0.0000000000000000 },
   { 0.17461228653000099, 0.30000000000000004, 0.0000000000000000, 
 	  0.17453292519943295 },
-  { 0.34969146102798415, 0.30000000000000004, 0.0000000000000000, 
+  { 0.34969146102798421, 0.30000000000000004, 0.0000000000000000, 
 	  0.34906585039886590 },
-  { 0.52565822873726320, 0.30000000000000004, 0.0000000000000000, 
+  { 0.52565822873726309, 0.30000000000000004, 0.0000000000000000, 
 	  0.52359877559829882 },
-  { 0.70284226512408532, 0.30000000000000004, 0.0000000000000000, 
+  { 0.70284226512408543, 0.30000000000000004, 0.0000000000000000, 
 	  0.69813170079773179 },
-  { 0.88144139195111182, 0.30000000000000004, 0.0000000000000000, 
+  { 0.88144139195111171, 0.30000000000000004, 0.0000000000000000, 
 	  0.87266462599716477 },
   { 1.0614897067260520, 0.30000000000000004, 0.0000000000000000, 
 	  1.0471975511965976 },
-  { 1.2428416824174218, 0.30000000000000004, 0.0000000000000000, 
+  { 1.2428416824174220, 0.30000000000000004, 0.0000000000000000, 
 	  1.2217304763960306 },
-  { 1.4251795877015927, 0.30000000000000004, 0.0000000000000000, 
+  { 1.4251795877015929, 0.30000000000000004, 0.0000000000000000, 
 	  1.3962634015954636 },
   { 1.6080486199305128, 0.30000000000000004, 0.0000000000000000, 
 	  1.5707963267948966 },
@@ -3548,559 +3910,619 @@ data121[10] =
 const double toler121 = 2.5000000000000020e-13;
 
 // Test data for k=0.30000000000000004, nu=0.10000000000000001.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 6.3908043711907203e-16
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.1872304407982844e-16
+// mean(f - f_Boost): 7.2164496600635178e-17
+// variance(f - f_Boost): 4.3555500115139682e-32
+// stddev(f - f_Boost): 2.0869954507650391e-16
 const testcase_ellint_3<double>
 data122[10] =
 {
   { 0.0000000000000000, 0.30000000000000004, 0.10000000000000001, 
 	  0.0000000000000000 },
-  { 0.17443631884814376, 0.30000000000000004, 0.10000000000000001, 
+  { 0.17478889331392972, 0.30000000000000004, 0.10000000000000001, 
 	  0.17453292519943295 },
-  { 0.34831316835124926, 0.30000000000000004, 0.10000000000000001, 
+  { 0.35108939018329183, 0.30000000000000004, 0.10000000000000001, 
 	  0.34906585039886590 },
-  { 0.52116586276523857, 0.30000000000000004, 0.10000000000000001, 
+  { 0.53028990896115835, 0.30000000000000004, 0.10000000000000001, 
 	  0.52359877559829882 },
-  { 0.69269385837910036, 0.30000000000000004, 0.10000000000000001, 
+  { 0.71352417052371409, 0.30000000000000004, 0.10000000000000001, 
 	  0.69813170079773179 },
-  { 0.86279023163070856, 0.30000000000000004, 0.10000000000000001, 
+  { 0.90153086032405894, 0.30000000000000004, 0.10000000000000001, 
 	  0.87266462599716477 },
-  { 1.0315321461438263, 0.30000000000000004, 0.10000000000000001, 
+  { 1.0945187977283313, 0.30000000000000004, 0.10000000000000001, 
 	  1.0471975511965976 },
-  { 1.1991449111869024, 0.30000000000000004, 0.10000000000000001, 
+  { 1.2920699268385683, 0.30000000000000004, 0.10000000000000001, 
 	  1.2217304763960306 },
-  { 1.3659561780923213, 0.30000000000000004, 0.10000000000000001, 
+  { 1.4931243665896394, 0.30000000000000004, 0.10000000000000001, 
 	  1.3962634015954636 },
-  { 1.5323534693557528, 0.30000000000000004, 0.10000000000000001, 
+  { 1.6960848815118226, 0.30000000000000004, 0.10000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler122 = 2.5000000000000020e-13;
 
 // Test data for k=0.30000000000000004, nu=0.20000000000000001.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 6.4447238179454079e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 6.2247497610332889e-16
+// mean(f - f_Boost): 6.6613381477509390e-17
+// variance(f - f_Boost): 1.7591111235252501e-32
+// stddev(f - f_Boost): 1.3263148659067538e-16
 const testcase_ellint_3<double>
 data123[10] =
 {
   { 0.0000000000000000, 0.30000000000000004, 0.20000000000000001, 
 	  0.0000000000000000 },
-  { 0.17426098615372088, 0.30000000000000004, 0.20000000000000001, 
+  { 0.17496614335337535, 0.30000000000000004, 0.20000000000000001, 
 	  0.17453292519943295 },
-  { 0.34695402664689923, 0.30000000000000004, 0.20000000000000001, 
+  { 0.35250745937139372, 0.30000000000000004, 0.20000000000000001, 
 	  0.34906585039886590 },
-  { 0.51680555567038933, 0.30000000000000004, 0.20000000000000001, 
+  { 0.53506875002836884, 0.30000000000000004, 0.20000000000000001, 
 	  0.52359877559829882 },
-  { 0.68303375225260210, 0.30000000000000004, 0.20000000000000001, 
+  { 0.72479106622248191, 0.30000000000000004, 0.20000000000000001, 
 	  0.69813170079773179 },
-  { 0.84540662891295026, 0.30000000000000004, 0.20000000000000001, 
+  { 0.92326451535891607, 0.30000000000000004, 0.20000000000000001, 
 	  0.87266462599716477 },
-  { 1.0041834051646927, 0.30000000000000004, 0.20000000000000001, 
+  { 1.1312092060698349, 0.30000000000000004, 0.20000000000000001, 
 	  1.0471975511965976 },
-  { 1.1599952702345711, 0.30000000000000004, 0.20000000000000001, 
+  { 1.3481473154592321, 0.30000000000000004, 0.20000000000000001, 
 	  1.2217304763960306 },
-  { 1.3137179520499165, 0.30000000000000004, 0.20000000000000001, 
+  { 1.5722049569662750, 0.30000000000000004, 0.20000000000000001, 
 	  1.3962634015954636 },
-  { 1.4663658145259877, 0.30000000000000004, 0.20000000000000001, 
+  { 1.8002173372290500, 0.30000000000000004, 0.20000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler123 = 2.5000000000000020e-13;
 
-// Test data for k=0.30000000000000004, nu=0.29999999999999999.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 6.4979715256503266e-16
+// Test data for k=0.30000000000000004, nu=0.30000000000000004.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 6.1678685180047551e-16
+// mean(f - f_Boost): 1.0547118733938987e-16
+// variance(f - f_Boost): 7.5633408838247182e-32
+// stddev(f - f_Boost): 2.7501528837184157e-16
 const testcase_ellint_3<double>
 data124[10] =
 {
-  { 0.0000000000000000, 0.30000000000000004, 0.29999999999999999, 
+  { 0.0000000000000000, 0.30000000000000004, 0.30000000000000004, 
 	  0.0000000000000000 },
-  { 0.17408628437042842, 0.30000000000000004, 0.29999999999999999, 
+  { 0.17514404084107435, 0.30000000000000004, 0.30000000000000004, 
 	  0.17453292519943295 },
-  { 0.34561356761638401, 0.30000000000000004, 0.29999999999999999, 
+  { 0.35394619108645647, 0.30000000000000004, 0.30000000000000004, 
 	  0.34906585039886590 },
-  { 0.51257058617875850, 0.30000000000000004, 0.29999999999999999, 
+  { 0.54000325463372689, 0.30000000000000004, 0.30000000000000004, 
 	  0.52359877559829882 },
-  { 0.67382207124602878, 0.30000000000000004, 0.29999999999999999, 
+  { 0.73670193794067651, 0.30000000000000004, 0.30000000000000004, 
 	  0.69813170079773179 },
-  { 0.82914751587825131, 0.30000000000000004, 0.29999999999999999, 
+  { 0.94689345491722177, 0.30000000000000004, 0.30000000000000004, 
 	  0.87266462599716477 },
-  { 0.97907434814374938, 0.30000000000000004, 0.29999999999999999, 
+  { 1.1723274608389140, 0.30000000000000004, 0.30000000000000004, 
 	  1.0471975511965976 },
-  { 1.1246399297351584, 0.30000000000000004, 0.29999999999999999, 
+  { 1.4128880552936287, 0.30000000000000004, 0.30000000000000004, 
 	  1.2217304763960306 },
-  { 1.2671793970398149, 0.30000000000000004, 0.29999999999999999, 
+  { 1.6659010047449661, 0.30000000000000004, 0.30000000000000004, 
 	  1.3962634015954636 },
-  { 1.4081767433479091, 0.30000000000000004, 0.29999999999999999, 
+  { 1.9260216862473254, 0.30000000000000004, 0.30000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler124 = 2.5000000000000020e-13;
 
 // Test data for k=0.30000000000000004, nu=0.40000000000000002.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 6.5505716921759864e-16
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 6.3983279132797385e-16
+// mean(f - f_Boost): 1.1657341758564144e-16
+// variance(f - f_Boost): 1.8245832308692586e-31
+// stddev(f - f_Boost): 4.2715140534349863e-16
 const testcase_ellint_3<double>
 data125[10] =
 {
   { 0.0000000000000000, 0.30000000000000004, 0.40000000000000002, 
 	  0.0000000000000000 },
-  { 0.17391220945982727, 0.30000000000000004, 0.40000000000000002, 
+  { 0.17532259000954434, 0.30000000000000004, 0.40000000000000002, 
 	  0.17453292519943295 },
-  { 0.34429133937639689, 0.30000000000000004, 0.40000000000000002, 
+  { 0.35540612770983693, 0.30000000000000004, 0.40000000000000002, 
 	  0.34906585039886590 },
-  { 0.50845471668581632, 0.30000000000000004, 0.40000000000000002, 
+  { 0.54510265552938919, 0.30000000000000004, 0.40000000000000002, 
 	  0.52359877559829882 },
-  { 0.66502347027873854, 0.30000000000000004, 0.40000000000000002, 
+  { 0.74932476310965057, 0.30000000000000004, 0.40000000000000002, 
 	  0.69813170079773179 },
-  { 0.81389191978012254, 0.30000000000000004, 0.40000000000000002, 
+  { 0.97272793583093109, 0.30000000000000004, 0.40000000000000002, 
 	  0.87266462599716477 },
-  { 0.95590618002140570, 0.30000000000000004, 0.40000000000000002, 
+  { 1.2188928987074241, 0.30000000000000004, 0.40000000000000002, 
 	  1.0471975511965976 },
-  { 1.0924915195213121, 0.30000000000000004, 0.40000000000000002, 
+  { 1.4888771674085941, 0.30000000000000004, 0.40000000000000002, 
 	  1.2217304763960306 },
-  { 1.2253651604038061, 0.30000000000000004, 0.40000000000000002, 
+  { 1.7794558498219191, 0.30000000000000004, 0.40000000000000002, 
 	  1.3962634015954636 },
-  { 1.3563643538969763, 0.30000000000000004, 0.40000000000000002, 
+  { 2.0822121773175528, 0.30000000000000004, 0.40000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler125 = 2.5000000000000020e-13;
 
 // Test data for k=0.30000000000000004, nu=0.50000000000000000.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 6.7807908859023716e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 6.0516138451673425e-16
+// mean(f - f_Boost): 4.7184478546569152e-17
+// variance(f - f_Boost): 1.9448563670505968e-32
+// stddev(f - f_Boost): 1.3945810722401896e-16
 const testcase_ellint_3<double>
 data126[10] =
 {
   { 0.0000000000000000, 0.30000000000000004, 0.50000000000000000, 
 	  0.0000000000000000 },
-  { 0.17373875742088232, 0.30000000000000004, 0.50000000000000000, 
+  { 0.17550179513158179, 0.30000000000000004, 0.50000000000000000, 
 	  0.17453292519943295 },
-  { 0.34298690571124157, 0.30000000000000004, 0.50000000000000000, 
+  { 0.35688783251681200, 0.30000000000000004, 0.50000000000000000, 
 	  0.34906585039886590 },
-  { 0.50445214859646936, 0.30000000000000004, 0.50000000000000000, 
+  { 0.55037700010142798, 0.30000000000000004, 0.50000000000000000, 
 	  0.52359877559829882 },
-  { 0.65660648352418516, 0.30000000000000004, 0.50000000000000000, 
+  { 0.76273839789895992, 0.30000000000000004, 0.50000000000000000, 
 	  0.69813170079773179 },
-  { 0.79953670639287289, 0.30000000000000004, 0.50000000000000000, 
+  { 1.0011570518830419, 0.30000000000000004, 0.50000000000000000, 
 	  0.87266462599716477 },
-  { 0.93443393926588536, 0.30000000000000004, 0.50000000000000000, 
+  { 1.2722987414055109, 0.30000000000000004, 0.50000000000000000, 
 	  1.0471975511965976 },
-  { 1.0630838369016911, 0.30000000000000004, 0.50000000000000000, 
+  { 1.5799590511080066, 0.30000000000000004, 0.50000000000000000, 
 	  1.2217304763960306 },
-  { 1.1875197325653029, 0.30000000000000004, 0.50000000000000000, 
+  { 1.9212367220124293, 0.30000000000000004, 0.50000000000000000, 
 	  1.3962634015954636 },
-  { 1.3098448759814962, 0.30000000000000004, 0.50000000000000000, 
+  { 2.2833505881933971, 0.30000000000000004, 0.50000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler126 = 2.5000000000000020e-13;
 
-// Test data for k=0.30000000000000004, nu=0.59999999999999998.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 7.0057999499931649e-16
+// Test data for k=0.30000000000000004, nu=0.60000000000000009.
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 5.2121157428443725e-16
+// mean(f - f_Boost): 1.9428902930940239e-16
+// variance(f - f_Boost): 1.5987596229703424e-31
+// stddev(f - f_Boost): 3.9984492281012430e-16
 const testcase_ellint_3<double>
 data127[10] =
 {
-  { 0.0000000000000000, 0.30000000000000004, 0.59999999999999998, 
+  { 0.0000000000000000, 0.30000000000000004, 0.60000000000000009, 
 	  0.0000000000000000 },
-  { 0.17356592428950823, 0.30000000000000004, 0.59999999999999998, 
+  { 0.17568166052076745, 0.30000000000000004, 0.60000000000000009, 
 	  0.17453292519943295 },
-  { 0.34169984536697379, 0.30000000000000004, 0.59999999999999998, 
+  { 0.35839189074731181, 0.30000000000000004, 0.60000000000000009, 
 	  0.34906585039886590 },
-  { 0.50055748266498457, 0.30000000000000004, 0.59999999999999998, 
+  { 0.55583724744367558, 0.30000000000000004, 0.60000000000000009, 
 	  0.52359877559829882 },
-  { 0.64854298527106768, 0.30000000000000004, 0.59999999999999998, 
+  { 0.77703498090888223, 0.30000000000000004, 0.60000000000000009, 
 	  0.69813170079773179 },
-  { 0.78599329284207431, 0.30000000000000004, 0.59999999999999998, 
+  { 1.0326772113675962, 0.30000000000000004, 0.60000000000000009, 
 	  0.87266462599716477 },
-  { 0.91445452089128199, 0.30000000000000004, 0.59999999999999998, 
+  { 1.3345139983717369, 0.30000000000000004, 0.60000000000000009, 
 	  1.0471975511965976 },
-  { 1.0360412952290587, 0.30000000000000004, 0.59999999999999998, 
+  { 1.6921742922838403, 0.30000000000000004, 0.60000000000000009, 
 	  1.2217304763960306 },
-  { 1.1530473919778641, 0.30000000000000004, 0.59999999999999998, 
+  { 2.1056608968472186, 0.30000000000000004, 0.60000000000000009, 
 	  1.3962634015954636 },
-  { 1.2677758800420669, 0.30000000000000004, 0.59999999999999998, 
+  { 2.5560975528589061, 0.30000000000000004, 0.60000000000000009, 
 	  1.5707963267948966 },
 };
 const double toler127 = 2.5000000000000020e-13;
 
-// Test data for k=0.30000000000000004, nu=0.69999999999999996.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 7.2239502844122443e-16
+// Test data for k=0.30000000000000004, nu=0.70000000000000007.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 6.0088945789059381e-16
+// mean(f - f_Boost): 2.1094237467877973e-16
+// variance(f - f_Boost): 3.0253363535298873e-31
+// stddev(f - f_Boost): 5.5003057674368314e-16
 const testcase_ellint_3<double>
 data128[10] =
 {
-  { 0.0000000000000000, 0.30000000000000004, 0.69999999999999996, 
+  { 0.0000000000000000, 0.30000000000000004, 0.70000000000000007, 
 	  0.0000000000000000 },
-  { 0.17339370613812224, 0.30000000000000004, 0.69999999999999996, 
+  { 0.17586219053197988, 0.30000000000000004, 0.70000000000000007, 
 	  0.17453292519943295 },
-  { 0.34042975138455933, 0.30000000000000004, 0.69999999999999996, 
+  { 0.35991891074557669, 0.30000000000000004, 0.70000000000000007, 
 	  0.34906585039886590 },
-  { 0.49676568368075985, 0.30000000000000004, 0.69999999999999996, 
+  { 0.56149538019961731, 0.30000000000000004, 0.70000000000000007, 
 	  0.52359877559829882 },
-  { 0.64080774055753720, 0.30000000000000004, 0.69999999999999996, 
+  { 0.79232303189667685, 0.30000000000000004, 0.70000000000000007, 
 	  0.69813170079773179 },
-  { 0.77318507779667278, 0.30000000000000004, 0.69999999999999996, 
+  { 1.0679345542878826, 0.30000000000000004, 0.70000000000000007, 
 	  0.87266462599716477 },
-  { 0.89579782346548609, 0.30000000000000004, 0.69999999999999996, 
+  { 1.4084400085913955, 0.30000000000000004, 0.70000000000000007, 
 	  1.0471975511965976 },
-  { 1.0110573286052202, 0.30000000000000004, 0.69999999999999996, 
+  { 1.8357382859296454, 0.30000000000000004, 0.70000000000000007, 
 	  1.2217304763960306 },
-  { 1.1214710972949635, 0.30000000000000004, 0.69999999999999996, 
+  { 2.3604197996171519, 0.30000000000000004, 0.70000000000000007, 
 	  1.3962634015954636 },
-  { 1.2294913236274982, 0.30000000000000004, 0.69999999999999996, 
+  { 2.9562123549913872, 0.30000000000000004, 0.70000000000000007, 
 	  1.5707963267948966 },
 };
 const double toler128 = 2.5000000000000020e-13;
 
 // Test data for k=0.30000000000000004, nu=0.80000000000000004.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 7.4358357000101250e-16
+// max(|f - f_Boost|): 2.2204460492503131e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 6.1197887707781618e-16
+// mean(f - f_Boost): 3.4416913763379854e-16
+// variance(f - f_Boost): 4.3461914185990199e-31
+// stddev(f - f_Boost): 6.5925650687718054e-16
 const testcase_ellint_3<double>
 data129[10] =
 {
   { 0.0000000000000000, 0.30000000000000004, 0.80000000000000004, 
 	  0.0000000000000000 },
-  { 0.17322209907520358, 0.30000000000000004, 0.80000000000000004, 
+  { 0.17604338956191670, 0.30000000000000004, 0.80000000000000004, 
 	  0.17453292519943295 },
-  { 0.33917623046949996, 0.30000000000000004, 0.80000000000000004, 
+  { 0.36146952517410791, 0.30000000000000004, 0.80000000000000004, 
 	  0.34906585039886590 },
-  { 0.49307204894329176, 0.30000000000000004, 0.80000000000000004, 
+  { 0.56736453393774644, 0.30000000000000004, 0.80000000000000004, 
 	  0.52359877559829882 },
-  { 0.63337802830291734, 0.30000000000000004, 0.80000000000000004, 
+  { 0.80873149979001091, 0.30000000000000004, 0.80000000000000004, 
 	  0.69813170079773179 },
-  { 0.76104540997689407, 0.30000000000000004, 0.80000000000000004, 
+  { 1.1077903069860620, 0.30000000000000004, 0.80000000000000004, 
 	  0.87266462599716477 },
-  { 0.87832009635450714, 0.30000000000000004, 0.80000000000000004, 
+  { 1.4985874311132998, 0.30000000000000004, 0.80000000000000004, 
 	  1.0471975511965976 },
-  { 0.98787879723171790, 0.30000000000000004, 0.80000000000000004, 
+  { 2.0298167266724954, 0.30000000000000004, 0.80000000000000004, 
 	  1.2217304763960306 },
-  { 1.0924036340069339, 0.30000000000000004, 0.80000000000000004, 
+  { 2.7483929054985432, 0.30000000000000004, 0.80000000000000004, 
 	  1.3962634015954636 },
-  { 1.1944567571590048, 0.30000000000000004, 0.80000000000000004, 
+  { 3.6283050484567170, 0.30000000000000004, 0.80000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler129 = 2.5000000000000020e-13;
 
 // Test data for k=0.30000000000000004, nu=0.90000000000000002.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 7.6419688299804087e-16
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 5.1301806687926828e-16
+// mean(f - f_Boost): 4.1633363423443370e-16
+// variance(f - f_Boost): 2.2835347143080263e-31
+// stddev(f - f_Boost): 4.7786344433405093e-16
 const testcase_ellint_3<double>
 data130[10] =
 {
   { 0.0000000000000000, 0.30000000000000004, 0.90000000000000002, 
 	  0.0000000000000000 },
-  { 0.17305109924485945, 0.30000000000000004, 0.90000000000000002, 
+  { 0.17622526204962433, 0.30000000000000004, 0.90000000000000002, 
 	  0.17453292519943295 },
-  { 0.33793890239556984, 0.30000000000000004, 0.90000000000000002, 
+  { 0.36304439230777141, 0.30000000000000004, 0.90000000000000002, 
 	  0.34906585039886590 },
-  { 0.48947218005089738, 0.30000000000000004, 0.90000000000000002, 
+  { 0.57345914744719195, 0.30000000000000004, 0.90000000000000002, 
 	  0.52359877559829882 },
-  { 0.62623332340775151, 0.30000000000000004, 0.90000000000000002, 
+  { 0.82641512928845162, 0.30000000000000004, 0.90000000000000002, 
 	  0.69813170079773179 },
-  { 0.74951596581511148, 0.30000000000000004, 0.90000000000000002, 
+  { 1.1534256210757743, 0.30000000000000004, 0.90000000000000002, 
 	  0.87266462599716477 },
-  { 0.86189886597755994, 0.30000000000000004, 0.90000000000000002, 
+  { 1.6124900353411677, 0.30000000000000004, 0.90000000000000002, 
 	  1.0471975511965976 },
-  { 0.96629451153092005, 0.30000000000000004, 0.90000000000000002, 
+  { 2.3165905514845089, 0.30000000000000004, 0.90000000000000002, 
 	  1.2217304763960306 },
-  { 1.0655269133492682, 0.30000000000000004, 0.90000000000000002, 
+  { 3.4625619526539824, 0.30000000000000004, 0.90000000000000002, 
 	  1.3962634015954636 },
-  { 1.1622376896064914, 0.30000000000000004, 0.90000000000000002, 
+  { 5.1479514944016787, 0.30000000000000004, 0.90000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler130 = 2.5000000000000020e-13;
 
-// Test data for k=0.39999999999999991, nu=0.0000000000000000.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 5.4157225142938039e-16
+// Test data for k=0.40000000000000013, nu=0.0000000000000000.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 1.0831445028587608e-15
+// mean(f - f_Boost): 1.7486012637846215e-16
+// variance(f - f_Boost): 3.1664095331106078e-31
+// stddev(f - f_Boost): 5.6270858649132121e-16
 const testcase_ellint_3<double>
 data131[10] =
 {
-  { 0.0000000000000000, 0.39999999999999991, 0.0000000000000000, 
+  { 0.0000000000000000, 0.40000000000000013, 0.0000000000000000, 
 	  0.0000000000000000 },
-  { 0.17467414669441528, 0.39999999999999991, 0.0000000000000000, 
+  { 0.17467414669441528, 0.40000000000000013, 0.0000000000000000, 
 	  0.17453292519943295 },
-  { 0.35018222772483443, 0.39999999999999991, 0.0000000000000000, 
+  { 0.35018222772483443, 0.40000000000000013, 0.0000000000000000, 
 	  0.34906585039886590 },
-  { 0.52729015917508737, 0.39999999999999991, 0.0000000000000000, 
+  { 0.52729015917508748, 0.40000000000000013, 0.0000000000000000, 
 	  0.52359877559829882 },
-  { 0.70662374407341244, 0.39999999999999991, 0.0000000000000000, 
+  { 0.70662374407341244, 0.40000000000000013, 0.0000000000000000, 
 	  0.69813170079773179 },
-  { 0.88859210497602170, 0.39999999999999991, 0.0000000000000000, 
+  { 0.88859210497602159, 0.40000000000000013, 0.0000000000000000, 
 	  0.87266462599716477 },
-  { 1.0733136290471379, 0.39999999999999991, 0.0000000000000000, 
+  { 1.0733136290471381, 0.40000000000000013, 0.0000000000000000, 
 	  1.0471975511965976 },
-  { 1.2605612170157061, 0.39999999999999991, 0.0000000000000000, 
+  { 1.2605612170157066, 0.40000000000000013, 0.0000000000000000, 
 	  1.2217304763960306 },
-  { 1.4497513956433439, 0.39999999999999991, 0.0000000000000000, 
+  { 1.4497513956433439, 0.40000000000000013, 0.0000000000000000, 
 	  1.3962634015954636 },
-  { 1.6399998658645112, 0.39999999999999991, 0.0000000000000000, 
+  { 1.6399998658645112, 0.40000000000000013, 0.0000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler131 = 2.5000000000000020e-13;
 
-// Test data for k=0.39999999999999991, nu=0.10000000000000001.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 5.6859551010103832e-16
+// Test data for k=0.40000000000000013, nu=0.10000000000000001.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 1.0263824105456986e-15
+// mean(f - f_Boost): 1.7486012637846215e-16
+// variance(f - f_Boost): 3.1664095331106078e-31
+// stddev(f - f_Boost): 5.6270858649132121e-16
 const testcase_ellint_3<double>
 data132[10] =
 {
-  { 0.0000000000000000, 0.39999999999999991, 0.10000000000000001, 
+  { 0.0000000000000000, 0.40000000000000013, 0.10000000000000001, 
 	  0.0000000000000000 },
-  { 0.17449806706684670, 0.39999999999999991, 0.10000000000000001, 
+  { 0.17485086590796767, 0.40000000000000013, 0.10000000000000001, 
 	  0.17453292519943295 },
-  { 0.34880048623856075, 0.39999999999999991, 0.10000000000000001, 
+  { 0.35158366412506992, 0.40000000000000013, 0.10000000000000001, 
 	  0.34906585039886590 },
-  { 0.52277322065757392, 0.39999999999999991, 0.10000000000000001, 
+  { 0.53194731675711726, 0.40000000000000013, 0.10000000000000001, 
 	  0.52359877559829882 },
-  { 0.69638072056918365, 0.39999999999999991, 0.10000000000000001, 
+  { 0.71740615528010931, 0.40000000000000013, 0.10000000000000001, 
 	  0.69813170079773179 },
-  { 0.86968426619831540, 0.39999999999999991, 0.10000000000000001, 
+  { 0.90896157773487030, 0.40000000000000013, 0.10000000000000001, 
 	  0.87266462599716477 },
-  { 1.0428044206578095, 0.39999999999999991, 0.10000000000000001, 
+  { 1.1069605483834348, 0.40000000000000013, 0.10000000000000001, 
 	  1.0471975511965976 },
-  { 1.2158651158274378, 0.39999999999999991, 0.10000000000000001, 
+  { 1.3109353428823001, 0.40000000000000013, 0.10000000000000001, 
 	  1.2217304763960306 },
-  { 1.3889447129893324, 0.39999999999999991, 0.10000000000000001, 
+  { 1.5195460789903450, 0.40000000000000013, 0.10000000000000001, 
 	  1.3962634015954636 },
-  { 1.5620566886683604, 0.39999999999999991, 0.10000000000000001, 
+  { 1.7306968836847190, 0.40000000000000013, 0.10000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler132 = 2.5000000000000020e-13;
 
-// Test data for k=0.39999999999999991, nu=0.20000000000000001.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 5.9444065952225719e-16
+// Test data for k=0.40000000000000013, nu=0.20000000000000001.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 9.6644296021947179e-16
+// mean(f - f_Boost): 2.0816681711721685e-16
+// variance(f - f_Boost): 3.0360740073926687e-31
+// stddev(f - f_Boost): 5.5100580826273227e-16
 const testcase_ellint_3<double>
 data133[10] =
 {
-  { 0.0000000000000000, 0.39999999999999991, 0.20000000000000001, 
+  { 0.0000000000000000, 0.40000000000000013, 0.20000000000000001, 
 	  0.0000000000000000 },
-  { 0.17432262290723397, 0.39999999999999991, 0.20000000000000001, 
+  { 0.17502822886437389, 0.40000000000000013, 0.20000000000000001, 
 	  0.17453292519943295 },
-  { 0.34743795258968596, 0.39999999999999991, 0.20000000000000001, 
+  { 0.35300530062530805, 0.40000000000000013, 0.20000000000000001, 
 	  0.34906585039886590 },
-  { 0.51838919472805112, 0.39999999999999991, 0.20000000000000001, 
+  { 0.53675259548210896, 0.40000000000000013, 0.20000000000000001, 
 	  0.52359877559829882 },
-  { 0.68663134739057907, 0.39999999999999991, 0.20000000000000001, 
+  { 0.72878006428676934, 0.40000000000000013, 0.20000000000000001, 
 	  0.69813170079773179 },
-  { 0.85206432981833979, 0.39999999999999991, 0.20000000000000001, 
+  { 0.93100219010583574, 0.40000000000000013, 0.20000000000000001, 
 	  0.87266462599716477 },
-  { 1.0149595349004430, 0.39999999999999991, 0.20000000000000001, 
+  { 1.1443487271187611, 0.40000000000000013, 0.20000000000000001, 
 	  1.0471975511965976 },
-  { 1.1758349405464676, 0.39999999999999991, 0.20000000000000001, 
+  { 1.3683427764108813, 0.40000000000000013, 0.20000000000000001, 
 	  1.2217304763960306 },
-  { 1.3353337673882637, 0.39999999999999991, 0.20000000000000001, 
+  { 1.6008221459300933, 0.40000000000000013, 0.20000000000000001, 
 	  1.3962634015954636 },
-  { 1.4941414344266770, 0.39999999999999991, 0.20000000000000001, 
+  { 1.8380358826317627, 0.40000000000000013, 0.20000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler133 = 2.5000000000000020e-13;
 
-// Test data for k=0.39999999999999991, nu=0.29999999999999999.
-// max(|f - f_GSL|): 1.1102230246251565e-15
-// max(|f - f_GSL| / |f_GSL|): 7.7406350888907249e-16
+// Test data for k=0.40000000000000013, nu=0.30000000000000004.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 9.0271556462838835e-16
+// mean(f - f_Boost): 2.0816681711721685e-16
+// variance(f - f_Boost): 3.0360740073926687e-31
+// stddev(f - f_Boost): 5.5100580826273227e-16
 const testcase_ellint_3<double>
 data134[10] =
 {
-  { 0.0000000000000000, 0.39999999999999991, 0.29999999999999999, 
+  { 0.0000000000000000, 0.40000000000000013, 0.30000000000000004, 
 	  0.0000000000000000 },
-  { 0.17414781013591540, 0.39999999999999991, 0.29999999999999999, 
+  { 0.17520623975982899, 0.40000000000000013, 0.30000000000000004, 
 	  0.17453292519943295 },
-  { 0.34609415696777285, 0.39999999999999991, 0.29999999999999999, 
+  { 0.35444766141612105, 0.40000000000000013, 0.30000000000000004, 
 	  0.34906585039886590 },
-  { 0.51413131295862535, 0.39999999999999991, 0.29999999999999999, 
+  { 0.54171455841536009, 0.40000000000000013, 0.30000000000000004, 
 	  0.52359877559829882 },
-  { 0.67733527622935630, 0.39999999999999991, 0.29999999999999999, 
+  { 0.74080517001084012, 0.40000000000000013, 0.30000000000000004, 
 	  0.69813170079773179 },
-  { 0.83558675182733266, 0.39999999999999991, 0.29999999999999999, 
+  { 0.95496950509296574, 0.40000000000000013, 0.30000000000000004, 
 	  0.87266462599716477 },
-  { 0.98940140808865906, 0.39999999999999991, 0.29999999999999999, 
+  { 1.1862627879844718, 0.40000000000000013, 0.30000000000000004, 
 	  1.0471975511965976 },
-  { 1.1396968797728058, 0.39999999999999991, 0.29999999999999999, 
+  { 1.4346501803799458, 0.40000000000000013, 0.30000000000000004, 
 	  1.2217304763960306 },
-  { 1.2875920037865090, 0.39999999999999991, 0.29999999999999999, 
+  { 1.6971744798077699, 0.40000000000000013, 0.30000000000000004, 
 	  1.3962634015954636 },
-  { 1.4342789859950078, 0.39999999999999991, 0.29999999999999999, 
+  { 1.9677924132520139, 0.40000000000000013, 0.30000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler134 = 2.5000000000000020e-13;
 
-// Test data for k=0.39999999999999991, nu=0.40000000000000002.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 6.4314214811441816e-16
+// Test data for k=0.40000000000000013, nu=0.40000000000000002.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 8.3436329231972794e-16
+// mean(f - f_Boost): 2.3037127760972000e-16
+// variance(f - f_Boost): 2.9507053793392374e-31
+// stddev(f - f_Boost): 5.4320395611033958e-16
 const testcase_ellint_3<double>
 data135[10] =
 {
-  { 0.0000000000000000, 0.39999999999999991, 0.40000000000000002, 
+  { 0.0000000000000000, 0.40000000000000013, 0.40000000000000002, 
 	  0.0000000000000000 },
-  { 0.17397362471112707, 0.39999999999999991, 0.40000000000000002, 
+  { 0.17538490283034375, 0.40000000000000013, 0.40000000000000002, 
 	  0.17453292519943295 },
-  { 0.34476864603333196, 0.39999999999999991, 0.40000000000000002, 
+  { 0.35591129064319948, 0.40000000000000013, 0.40000000000000002, 
 	  0.34906585039886590 },
-  { 0.50999329415379346, 0.39999999999999991, 0.40000000000000002, 
+  { 0.54684250413264535, 0.40000000000000013, 0.40000000000000002, 
 	  0.52359877559829882 },
-  { 0.66845674551396006, 0.39999999999999991, 0.40000000000000002, 
+  { 0.75355027742668290, 0.40000000000000013, 0.40000000000000002, 
 	  0.69813170079773179 },
-  { 0.82012848346231748, 0.39999999999999991, 0.40000000000000002, 
+  { 0.98117935026780634, 0.40000000000000013, 0.40000000000000002, 
 	  0.87266462599716477 },
-  { 0.96582449258349057, 0.39999999999999991, 0.40000000000000002, 
+  { 1.2337464222030736, 0.40000000000000013, 0.40000000000000002, 
 	  1.0471975511965976 },
-  { 1.1068473749476286, 0.39999999999999991, 0.40000000000000002, 
+  { 1.5125183419289221, 0.40000000000000013, 0.40000000000000002, 
 	  1.2217304763960306 },
-  { 1.2447132729159989, 0.39999999999999991, 0.40000000000000002, 
+  { 1.8140224451130313, 0.40000000000000013, 0.40000000000000002, 
 	  1.3962634015954636 },
-  { 1.3809986210732901, 0.39999999999999991, 0.40000000000000002, 
+  { 2.1289968719280026, 0.40000000000000013, 0.40000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler135 = 2.5000000000000020e-13;
 
-// Test data for k=0.39999999999999991, nu=0.50000000000000000.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 6.6621057007519435e-16
+// Test data for k=0.40000000000000013, nu=0.50000000000000000.
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 5.7013794022122431e-16
+// mean(f - f_Boost): 2.3037127760972000e-16
+// variance(f - f_Boost): 1.4989821857033475e-31
+// stddev(f - f_Boost): 3.8716691306248618e-16
 const testcase_ellint_3<double>
 data136[10] =
 {
-  { 0.0000000000000000, 0.39999999999999991, 0.50000000000000000, 
+  { 0.0000000000000000, 0.40000000000000013, 0.50000000000000000, 
 	  0.0000000000000000 },
-  { 0.17380006262854136, 0.39999999999999991, 0.50000000000000000, 
+  { 0.17556422235224273, 0.40000000000000013, 0.50000000000000000, 
 	  0.17453292519943295 },
-  { 0.34346098216756610, 0.39999999999999991, 0.50000000000000000, 
+  { 0.35739675341763921, 0.40000000000000013, 0.50000000000000000, 
 	  0.34906585039886590 },
-  { 0.50596929935059420, 0.39999999999999991, 0.50000000000000000, 
+  { 0.55214655195037188, 0.40000000000000013, 0.50000000000000000, 
 	  0.52359877559829882 },
-  { 0.65996392089131251, 0.39999999999999991, 0.50000000000000000, 
+  { 0.76709520942047438, 0.40000000000000013, 0.50000000000000000, 
 	  0.69813170079773179 },
-  { 0.80558463511364786, 0.39999999999999991, 0.50000000000000000, 
+  { 1.0100278761577499, 0.40000000000000013, 0.50000000000000000, 
 	  0.87266462599716477 },
-  { 0.94397834522857704, 0.39999999999999991, 0.50000000000000000, 
+  { 1.2882265661384342, 0.40000000000000013, 0.50000000000000000, 
 	  1.0471975511965976 },
-  { 1.0768075114108115, 0.39999999999999991, 0.50000000000000000, 
+  { 1.6059059780051876, 0.40000000000000013, 0.50000000000000000, 
 	  1.2217304763960306 },
-  { 1.2059184624251333, 0.39999999999999991, 0.50000000000000000, 
+  { 1.9600182740224081, 0.40000000000000013, 0.50000000000000000, 
 	  1.3962634015954636 },
-  { 1.3331797176377398, 0.39999999999999991, 0.50000000000000000, 
+  { 2.3367461373176512, 0.40000000000000013, 0.50000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler136 = 2.5000000000000020e-13;
 
-// Test data for k=0.39999999999999991, nu=0.59999999999999998.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 6.8853630717730749e-16
+// Test data for k=0.40000000000000013, nu=0.60000000000000009.
+// max(|f - f_Boost|): 2.2204460492503131e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 8.4792115132836117e-16
+// mean(f - f_Boost): 2.3037127760972000e-16
+// variance(f - f_Boost): 4.8893797490374802e-31
+// stddev(f - f_Boost): 6.9924099915819294e-16
 const testcase_ellint_3<double>
 data137[10] =
 {
-  { 0.0000000000000000, 0.39999999999999991, 0.59999999999999998, 
+  { 0.0000000000000000, 0.40000000000000013, 0.60000000000000009, 
 	  0.0000000000000000 },
-  { 0.17362711992081245, 0.39999999999999991, 0.59999999999999998, 
+  { 0.17574420264267029, 0.40000000000000013, 0.60000000000000009, 
 	  0.17453292519943295 },
-  { 0.34217074276403953, 0.39999999999999991, 0.59999999999999998, 
+  { 0.35890463689046265, 0.40000000000000013, 0.60000000000000009, 
 	  0.34906585039886590 },
-  { 0.50205389185761606, 0.39999999999999991, 0.59999999999999998, 
+  { 0.55763773975194486, 0.40000000000000013, 0.60000000000000009, 
 	  0.52359877559829882 },
-  { 0.65182834920372734, 0.39999999999999991, 0.59999999999999998, 
+  { 0.78153324227761267, 0.40000000000000013, 0.60000000000000009, 
 	  0.69813170079773179 },
-  { 0.79186512820565136, 0.39999999999999991, 0.59999999999999998, 
+  { 1.0420205885765887, 0.40000000000000013, 0.60000000000000009, 
 	  0.87266462599716477 },
-  { 0.92365535916287134, 0.39999999999999991, 0.59999999999999998, 
+  { 1.3517205230381770, 0.40000000000000013, 0.60000000000000009, 
 	  1.0471975511965976 },
-  { 1.0491915663957907, 0.39999999999999991, 0.59999999999999998, 
+  { 1.7210360970313896, 0.40000000000000013, 0.60000000000000009, 
 	  1.2217304763960306 },
-  { 1.1705934291745106, 0.39999999999999991, 0.59999999999999998, 
+  { 2.1500780510169246, 0.40000000000000013, 0.60000000000000009, 
 	  1.3962634015954636 },
-  { 1.2899514672527024, 0.39999999999999991, 0.59999999999999998, 
+  { 2.6186940209850191, 0.40000000000000013, 0.60000000000000009, 
 	  1.5707963267948966 },
 };
 const double toler137 = 2.5000000000000020e-13;
 
-// Test data for k=0.39999999999999991, nu=0.69999999999999996.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 7.1018730557776469e-16
+// Test data for k=0.40000000000000013, nu=0.70000000000000007.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 5.8573292020719759e-16
+// mean(f - f_Boost): 2.2759572004815707e-16
+// variance(f - f_Boost): 2.9613098824898137e-31
+// stddev(f - f_Boost): 5.4417918762938862e-16
 const testcase_ellint_3<double>
 data138[10] =
 {
-  { 0.0000000000000000, 0.39999999999999991, 0.69999999999999996, 
+  { 0.0000000000000000, 0.40000000000000013, 0.70000000000000007, 
 	  0.0000000000000000 },
-  { 0.17345479265712868, 0.39999999999999991, 0.69999999999999996, 
+  { 0.17592484806010436, 0.40000000000000013, 0.70000000000000007, 
 	  0.17453292519943295 },
-  { 0.34089751955950354, 0.39999999999999991, 0.69999999999999996, 
+  { 0.36043555139631439, 0.40000000000000013, 0.70000000000000007, 
 	  0.34906585039886590 },
-  { 0.49824200167361332, 0.39999999999999991, 0.69999999999999996, 
+  { 0.56332813669944881, 0.40000000000000013, 0.70000000000000007, 
 	  0.52359877559829882 },
-  { 0.64402450341199402, 0.39999999999999991, 0.69999999999999996, 
+  { 0.79697424562157548, 0.40000000000000013, 0.70000000000000007, 
 	  0.69813170079773179 },
-  { 0.77889207804122873, 0.39999999999999991, 0.69999999999999996, 
+  { 1.0778155987523672, 0.40000000000000013, 0.70000000000000007, 
 	  0.87266462599716477 },
-  { 0.90468169720957992, 0.39999999999999991, 0.69999999999999996, 
+  { 1.4272018169896268, 0.40000000000000013, 0.70000000000000007, 
 	  1.0471975511965976 },
-  { 1.0236847823692916, 0.39999999999999991, 0.69999999999999996, 
+  { 1.8684377907453382, 0.40000000000000013, 0.70000000000000007, 
 	  1.2217304763960306 },
-  { 1.1382465247425166, 0.39999999999999991, 0.69999999999999996, 
+  { 2.4128677409207473, 0.40000000000000013, 0.70000000000000007, 
 	  1.3962634015954636 },
-  { 1.2506255923253344, 0.39999999999999991, 0.69999999999999996, 
+  { 3.0327078743873246, 0.40000000000000013, 0.70000000000000007, 
 	  1.5707963267948966 },
 };
 const double toler138 = 2.5000000000000020e-13;
 
-// Test data for k=0.39999999999999991, nu=0.80000000000000004.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 7.3122171115555478e-16
+// Test data for k=0.40000000000000013, nu=0.80000000000000004.
+// max(|f - f_Boost|): 3.5527136788005009e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 9.5273712585384737e-16
+// mean(f - f_Boost): 4.5241588253475131e-16
+// variance(f - f_Boost): 1.1866477068555882e-30
+// stddev(f - f_Boost): 1.0893336067778265e-15
 const testcase_ellint_3<double>
 data139[10] =
 {
-  { 0.0000000000000000, 0.39999999999999991, 0.80000000000000004, 
+  { 0.0000000000000000, 0.40000000000000013, 0.80000000000000004, 
 	  0.0000000000000000 },
-  { 0.17328307694277154, 0.39999999999999991, 0.80000000000000004, 
+  { 0.17610616300487833, 0.40000000000000013, 0.80000000000000004, 
 	  0.17453292519943295 },
-  { 0.33964091800132007, 0.39999999999999991, 0.80000000000000004, 
+  { 0.36199013167171978, 0.40000000000000013, 0.80000000000000004, 
 	  0.34906585039886590 },
-  { 0.49452889372467440, 0.39999999999999991, 0.80000000000000004, 
+  { 0.56923097361842434, 0.40000000000000013, 0.80000000000000004, 
 	  0.52359877559829882 },
-  { 0.63652940095937316, 0.39999999999999991, 0.80000000000000004, 
+  { 0.81354878456624347, 0.40000000000000013, 0.80000000000000004, 
 	  0.69813170079773179 },
-  { 0.76659772511159097, 0.39999999999999991, 0.80000000000000004, 
+  { 1.1182902719261825, 0.40000000000000013, 0.80000000000000004, 
 	  0.87266462599716477 },
-  { 0.88691047977338111, 0.39999999999999991, 0.80000000000000004, 
+  { 1.5192950589409022, 0.40000000000000013, 0.80000000000000004, 
 	  1.0471975511965976 },
-  { 1.0000273200611638, 0.39999999999999991, 0.80000000000000004, 
+  { 2.0678761710223981, 0.40000000000000013, 0.80000000000000004, 
 	  1.2217304763960306 },
-  { 1.1084787902188009, 0.39999999999999991, 0.80000000000000004, 
+  { 2.8135222249879788, 0.40000000000000013, 0.80000000000000004, 
 	  1.3962634015954636 },
-  { 1.2146499565727209, 0.39999999999999991, 0.80000000000000004, 
+  { 3.7289548002199902, 0.40000000000000013, 0.80000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler139 = 2.5000000000000020e-13;
 
-// Test data for k=0.39999999999999991, nu=0.90000000000000002.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 7.5168974431077345e-16
+// Test data for k=0.40000000000000013, nu=0.90000000000000002.
+// max(|f - f_Boost|): 6.2172489379008766e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 1.1718379478872251e-15
+// mean(f - f_Boost): 8.4099394115355610e-16
+// variance(f - f_Boost): 3.5684096037099424e-30
+// stddev(f - f_Boost): 1.8890234523980751e-15
 const testcase_ellint_3<double>
 data140[10] =
 {
-  { 0.0000000000000000, 0.39999999999999991, 0.90000000000000002, 
+  { 0.0000000000000000, 0.40000000000000013, 0.90000000000000002, 
 	  0.0000000000000000 },
-  { 0.17311196891868127, 0.39999999999999991, 0.90000000000000002, 
+  { 0.17628815191971123, 0.40000000000000013, 0.90000000000000002, 
 	  0.17453292519943295 },
-  { 0.33840055664911906, 0.39999999999999991, 0.90000000000000002, 
+  { 0.36356903815378772, 0.40000000000000013, 0.90000000000000002, 
 	  0.34906585039886590 },
-  { 0.49091013944075329, 0.39999999999999991, 0.90000000000000002, 
+  { 0.57536079447000310, 0.40000000000000013, 0.90000000000000002, 
 	  0.52359877559829882 },
-  { 0.62932228186809580, 0.39999999999999991, 0.90000000000000002, 
+  { 0.83141355850172571, 0.40000000000000013, 0.90000000000000002, 
 	  0.69813170079773179 },
-  { 0.75492278323019801, 0.39999999999999991, 0.90000000000000002, 
+  { 1.1646481598721361, 0.40000000000000013, 0.90000000000000002, 
 	  0.87266462599716477 },
-  { 0.87021659043854294, 0.39999999999999991, 0.90000000000000002, 
+  { 1.6357275034001995, 0.40000000000000013, 0.90000000000000002, 
 	  1.0471975511965976 },
-  { 0.97800245228239246, 0.39999999999999991, 0.90000000000000002, 
+  { 2.3628787566572402, 0.40000000000000013, 0.90000000000000002, 
 	  1.2217304763960306 },
-  { 1.0809625773173697, 0.39999999999999991, 0.90000000000000002, 
+  { 3.5521010369134962, 0.40000000000000013, 0.90000000000000002, 
 	  1.3962634015954636 },
-  { 1.1815758115929846, 0.39999999999999991, 0.90000000000000002, 
+  { 5.3055535102872513, 0.40000000000000013, 0.90000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler140 = 2.5000000000000020e-13;
 
 // Test data for k=0.50000000000000000, nu=0.0000000000000000.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 3.1201497220602069e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.4551389361831220e-16
+// mean(f - f_Boost): -1.3877787807814457e-17
+// variance(f - f_Boost): 2.5893058141206173e-32
+// stddev(f - f_Boost): 1.6091320064309879e-16
 const testcase_ellint_3<double>
 data141[10] =
 {
@@ -4108,289 +4530,319 @@ data141[10] =
 	  0.0000000000000000 },
   { 0.17475385514035785, 0.50000000000000000, 0.0000000000000000, 
 	  0.17453292519943295 },
-  { 0.35081868470101585, 0.50000000000000000, 0.0000000000000000, 
+  { 0.35081868470101579, 0.50000000000000000, 0.0000000000000000, 
 	  0.34906585039886590 },
   { 0.52942862705190574, 0.50000000000000000, 0.0000000000000000, 
 	  0.52359877559829882 },
-  { 0.71164727562630314, 0.50000000000000000, 0.0000000000000000, 
+  { 0.71164727562630326, 0.50000000000000000, 0.0000000000000000, 
 	  0.69813170079773179 },
   { 0.89824523594227768, 0.50000000000000000, 0.0000000000000000, 
 	  0.87266462599716477 },
-  { 1.0895506700518851, 0.50000000000000000, 0.0000000000000000, 
+  { 1.0895506700518853, 0.50000000000000000, 0.0000000000000000, 
 	  1.0471975511965976 },
-  { 1.2853005857432931, 0.50000000000000000, 0.0000000000000000, 
+  { 1.2853005857432933, 0.50000000000000000, 0.0000000000000000, 
 	  1.2217304763960306 },
-  { 1.4845545520549484, 0.50000000000000000, 0.0000000000000000, 
+  { 1.4845545520549488, 0.50000000000000000, 0.0000000000000000, 
 	  1.3962634015954636 },
-  { 1.6857503548125963, 0.50000000000000000, 0.0000000000000000, 
+  { 1.6857503548125961, 0.50000000000000000, 0.0000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler141 = 2.5000000000000020e-13;
 
 // Test data for k=0.50000000000000000, nu=0.10000000000000001.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 3.1662857256911530e-16
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.7416868347177582e-16
+// mean(f - f_Boost): 2.7755575615628915e-18
+// variance(f - f_Boost): 5.4326441655972001e-32
+// stddev(f - f_Boost): 2.3308033305273100e-16
 const testcase_ellint_3<double>
 data142[10] =
 {
   { 0.0000000000000000, 0.50000000000000000, 0.10000000000000001, 
 	  0.0000000000000000 },
-  { 0.17457763120814676, 0.50000000000000000, 0.10000000000000001, 
+  { 0.17493071928248824, 0.50000000000000000, 0.10000000000000001, 
 	  0.17453292519943295 },
-  { 0.34943246340849154, 0.50000000000000000, 0.10000000000000001, 
+  { 0.35222467688034798, 0.50000000000000000, 0.10000000000000001, 
 	  0.34906585039886590 },
-  { 0.52487937869610790, 0.50000000000000000, 0.10000000000000001, 
+  { 0.53411928652008112, 0.50000000000000000, 0.10000000000000001, 
 	  0.52359877559829882 },
-  { 0.70127785096388384, 0.50000000000000000, 0.10000000000000001, 
+  { 0.72256398117177589, 0.50000000000000000, 0.10000000000000001, 
 	  0.69813170079773179 },
-  { 0.87898815988624479, 0.50000000000000000, 0.10000000000000001, 
+  { 0.91899583232771009, 0.50000000000000000, 0.10000000000000001, 
 	  0.87266462599716477 },
-  { 1.0582764576094172, 0.50000000000000000, 0.10000000000000001, 
+  { 1.1240549163055360, 0.50000000000000000, 0.10000000000000001, 
 	  1.0471975511965976 },
-  { 1.2391936844060205, 0.50000000000000000, 0.10000000000000001, 
+  { 1.3372938086286021, 0.50000000000000000, 0.10000000000000001, 
 	  1.2217304763960306 },
-  { 1.4214793542995841, 0.50000000000000000, 0.10000000000000001, 
+  { 1.5570024469132429, 0.50000000000000000, 0.10000000000000001, 
 	  1.3962634015954636 },
-  { 1.6045524936084892, 0.50000000000000000, 0.10000000000000001, 
+  { 1.7803034946545480, 0.50000000000000000, 0.10000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler142 = 2.5000000000000020e-13;
 
 // Test data for k=0.50000000000000000, nu=0.20000000000000001.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 3.2114786773102175e-16
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.1198767993730867e-16
+// mean(f - f_Boost): 2.7755575615628914e-17
+// variance(f - f_Boost): 5.0311947683004831e-32
+// stddev(f - f_Boost): 2.2430324938128922e-16
 const testcase_ellint_3<double>
 data143[10] =
 {
   { 0.0000000000000000, 0.50000000000000000, 0.20000000000000001, 
 	  0.0000000000000000 },
-  { 0.17440204336345433, 0.50000000000000000, 0.20000000000000001, 
+  { 0.17510822779582402, 0.50000000000000000, 0.20000000000000001, 
 	  0.17453292519943295 },
-  { 0.34806552388338824, 0.50000000000000000, 0.20000000000000001, 
+  { 0.35365094725531487, 0.50000000000000000, 0.20000000000000001, 
 	  0.34906585039886590 },
-  { 0.52046416757129810, 0.50000000000000000, 0.20000000000000001, 
+  { 0.53895933237328697, 0.50000000000000000, 0.20000000000000001, 
 	  0.52359877559829882 },
-  { 0.69140924550993865, 0.50000000000000000, 0.20000000000000001, 
+  { 0.73408090840070794, 0.50000000000000000, 0.20000000000000001, 
 	  0.69813170079773179 },
-  { 0.86104678636125520, 0.50000000000000000, 0.20000000000000001, 
+  { 0.94145442818535396, 0.50000000000000000, 0.20000000000000001, 
 	  0.87266462599716477 },
-  { 1.0297439459053981, 0.50000000000000000, 0.20000000000000001, 
+  { 1.1624120186296487, 0.50000000000000000, 0.20000000000000001, 
 	  1.0471975511965976 },
-  { 1.1979214112912033, 0.50000000000000000, 0.20000000000000001, 
+  { 1.3965823372867114, 0.50000000000000000, 0.20000000000000001, 
 	  1.2217304763960306 },
-  { 1.3659033858648930, 0.50000000000000000, 0.20000000000000001, 
+  { 1.6414308440430099, 0.50000000000000000, 0.20000000000000001, 
 	  1.3962634015954636 },
-  { 1.5338490483665983, 0.50000000000000000, 0.20000000000000001, 
+  { 1.8922947612264018, 0.50000000000000000, 0.20000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler143 = 2.5000000000000020e-13;
 
-// Test data for k=0.50000000000000000, nu=0.29999999999999999.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 3.2557837230041312e-16
+// Test data for k=0.50000000000000000, nu=0.30000000000000004.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.3800262770228813e-16
+// mean(f - f_Boost): 5.8286708792820721e-17
+// variance(f - f_Boost): 8.5027191584278157e-32
+// stddev(f - f_Boost): 2.9159422419567599e-16
 const testcase_ellint_3<double>
 data144[10] =
 {
-  { 0.0000000000000000, 0.50000000000000000, 0.29999999999999999, 
+  { 0.0000000000000000, 0.50000000000000000, 0.30000000000000004, 
 	  0.0000000000000000 },
-  { 0.17422708752228896, 0.50000000000000000, 0.29999999999999999, 
+  { 0.17528638488102041, 0.50000000000000000, 0.30000000000000004, 
 	  0.17453292519943295 },
-  { 0.34671739434855858, 0.50000000000000000, 0.29999999999999999, 
+  { 0.35509802222332720, 0.50000000000000000, 0.30000000000000004, 
 	  0.34906585039886590 },
-  { 0.51617616305641878, 0.50000000000000000, 0.29999999999999999, 
+  { 0.54395740731866193, 0.50000000000000000, 0.30000000000000004, 
 	  0.52359877559829882 },
-  { 0.68200047612545167, 0.50000000000000000, 0.29999999999999999, 
+  { 0.74625871438752667, 0.50000000000000000, 0.30000000000000004, 
 	  0.69813170079773179 },
-  { 0.84427217869498372, 0.50000000000000000, 0.29999999999999999, 
+  { 0.96588271186092023, 0.50000000000000000, 0.30000000000000004, 
 	  0.87266462599716477 },
-  { 1.0035637821389782, 0.50000000000000000, 0.29999999999999999, 
+  { 1.2054319584357329, 0.50000000000000000, 0.30000000000000004, 
 	  1.0471975511965976 },
-  { 1.1606800483933111, 0.50000000000000000, 0.29999999999999999, 
+  { 1.4651077994832871, 0.50000000000000000, 0.30000000000000004, 
 	  1.2217304763960306 },
-  { 1.3164407134643459, 0.50000000000000000, 0.29999999999999999, 
+  { 1.7416018368052644, 0.50000000000000000, 0.30000000000000004, 
 	  1.3962634015954636 },
-  { 1.4715681939859637, 0.50000000000000000, 0.29999999999999999, 
+  { 2.0277924458111314, 0.50000000000000000, 0.30000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler144 = 2.5000000000000020e-13;
 
 // Test data for k=0.50000000000000000, nu=0.40000000000000002.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 3.2992508582900068e-16
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.0439932918341581e-16
+// mean(f - f_Boost): 3.0531133177191807e-17
+// variance(f - f_Boost): 9.0809736800018602e-32
+// stddev(f - f_Boost): 3.0134653938616686e-16
 const testcase_ellint_3<double>
 data145[10] =
 {
   { 0.0000000000000000, 0.50000000000000000, 0.40000000000000002, 
 	  0.0000000000000000 },
-  { 0.17405275963859917, 0.50000000000000000, 0.40000000000000002, 
+  { 0.17546519477859268, 0.50000000000000000, 0.40000000000000002, 
 	  0.17453292519943295 },
-  { 0.34538761957029329, 0.50000000000000000, 0.40000000000000002, 
+  { 0.35656644822531680, 0.50000000000000000, 0.40000000000000002, 
 	  0.34906585039886590 },
-  { 0.51200902646603907, 0.50000000000000000, 0.40000000000000002, 
+  { 0.54912289677411319, 0.50000000000000000, 0.40000000000000002, 
 	  0.52359877559829882 },
-  { 0.67301522212868792, 0.50000000000000000, 0.40000000000000002, 
+  { 0.75916731611690047, 0.50000000000000000, 0.40000000000000002, 
 	  0.69813170079773179 },
-  { 0.82853844466313320, 0.50000000000000000, 0.40000000000000002, 
+  { 0.99260415631328214, 0.50000000000000000, 0.40000000000000002, 
 	  0.87266462599716477 },
-  { 0.97942097862681488, 0.50000000000000000, 0.40000000000000002, 
+  { 1.2541925856918670, 0.50000000000000000, 0.40000000000000002, 
 	  1.0471975511965976 },
-  { 1.1268429801220614, 0.50000000000000000, 0.40000000000000002, 
+  { 1.5456393705347609, 0.50000000000000000, 0.40000000000000002, 
 	  1.2217304763960306 },
-  { 1.2720406704533922, 0.50000000000000000, 0.40000000000000002, 
+  { 1.8631904972952076, 0.50000000000000000, 0.40000000000000002, 
 	  1.3962634015954636 },
-  { 1.4161679518465340, 0.50000000000000000, 0.40000000000000002, 
+  { 2.1962905366178065, 0.50000000000000000, 0.40000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler145 = 2.5000000000000020e-13;
 
 // Test data for k=0.50000000000000000, nu=0.50000000000000000.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 3.3419255755184137e-16
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.6797816859260978e-16
+// mean(f - f_Boost): 9.4368957093138303e-17
+// variance(f - f_Boost): 7.7794254682023874e-32
+// stddev(f - f_Boost): 2.7891621444803792e-16
 const testcase_ellint_3<double>
 data146[10] =
 {
   { 0.0000000000000000, 0.50000000000000000, 0.50000000000000000, 
 	  0.0000000000000000 },
-  { 0.17387905570381157, 0.50000000000000000, 0.50000000000000000, 
+  { 0.17564466176941509, 0.50000000000000000, 0.50000000000000000, 
 	  0.17453292519943295 },
-  { 0.34407576010465207, 0.50000000000000000, 0.50000000000000000, 
+  { 0.35805679276065394, 0.50000000000000000, 0.50000000000000000, 
 	  0.34906585039886590 },
-  { 0.50795686560160824, 0.50000000000000000, 0.50000000000000000, 
+  { 0.55446601496200032, 0.50000000000000000, 0.50000000000000000, 
 	  0.52359877559829882 },
-  { 0.66442115453330164, 0.50000000000000000, 0.50000000000000000, 
+  { 0.77288783578259013, 0.50000000000000000, 0.50000000000000000, 
 	  0.69813170079773179 },
-  { 0.81373829119355345, 0.50000000000000000, 0.50000000000000000, 
+  { 1.0220246013918972, 0.50000000000000000, 0.50000000000000000, 
 	  0.87266462599716477 },
-  { 0.95705743313235825, 0.50000000000000000, 0.50000000000000000, 
+  { 1.3101681612463965, 0.50000000000000000, 0.50000000000000000, 
 	  1.0471975511965976 },
-  { 1.0959131991362554, 0.50000000000000000, 0.50000000000000000, 
+  { 1.6422994881851025, 0.50000000000000000, 0.50000000000000000, 
 	  1.2217304763960306 },
-  { 1.2318900529754597, 0.50000000000000000, 0.50000000000000000, 
+  { 2.0152636030998816, 0.50000000000000000, 0.50000000000000000, 
 	  1.3962634015954636 },
-  { 1.3664739530045971, 0.50000000000000000, 0.50000000000000000, 
+  { 2.4136715042011945, 0.50000000000000000, 0.50000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler146 = 2.5000000000000020e-13;
 
-// Test data for k=0.50000000000000000, nu=0.59999999999999998.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 3.3838494104749599e-16
+// Test data for k=0.50000000000000000, nu=0.60000000000000009.
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.9178421578645735e-16
+// mean(f - f_Boost): 1.3322676295501878e-16
+// variance(f - f_Boost): 1.7749370367472766e-31
+// stddev(f - f_Boost): 4.2130001622920411e-16
 const testcase_ellint_3<double>
 data147[10] =
 {
-  { 0.0000000000000000, 0.50000000000000000, 0.59999999999999998, 
+  { 0.0000000000000000, 0.50000000000000000, 0.60000000000000009, 
 	  0.0000000000000000 },
-  { 0.17370597174637581, 0.50000000000000000, 0.59999999999999998, 
+  { 0.17582479017522740, 0.50000000000000000, 0.60000000000000009, 
 	  0.17453292519943295 },
-  { 0.34278139158591414, 0.50000000000000000, 0.59999999999999998, 
+  { 0.35956964546660036, 0.50000000000000000, 0.60000000000000009, 
 	  0.34906585039886590 },
-  { 0.50401419439302708, 0.50000000000000000, 0.59999999999999998, 
+  { 0.55999790372984193, 0.50000000000000000, 0.60000000000000009, 
 	  0.52359877559829882 },
-  { 0.65618938076167210, 0.50000000000000000, 0.59999999999999998, 
+  { 0.78751507911209895, 0.50000000000000000, 0.60000000000000009, 
 	  0.69813170079773179 },
-  { 0.79977959248855424, 0.50000000000000000, 0.59999999999999998, 
+  { 1.0546620505035220, 0.50000000000000000, 0.60000000000000009, 
 	  0.87266462599716477 },
-  { 0.93625925190753545, 0.50000000000000000, 0.59999999999999998, 
+  { 1.3754438357425935, 0.50000000000000000, 0.60000000000000009, 
 	  1.0471975511965976 },
-  { 1.0674905658379708, 0.50000000000000000, 0.59999999999999998, 
+  { 1.7615727400820127, 0.50000000000000000, 0.60000000000000009, 
 	  1.2217304763960306 },
-  { 1.1953481298023050, 0.50000000000000000, 0.59999999999999998, 
+  { 2.2134638067565242, 0.50000000000000000, 0.60000000000000009, 
 	  1.3962634015954636 },
-  { 1.3215740290190876, 0.50000000000000000, 0.59999999999999998, 
+  { 2.7090491861753558, 0.50000000000000000, 0.60000000000000009, 
 	  1.5707963267948966 },
 };
 const double toler147 = 2.5000000000000020e-13;
 
-// Test data for k=0.50000000000000000, nu=0.69999999999999996.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 3.4250604066951477e-16
+// Test data for k=0.50000000000000000, nu=0.70000000000000007.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.0745105182189226e-16
+// mean(f - f_Boost): 4.1633363423443370e-17
+// variance(f - f_Boost): 1.9996383743576116e-32
+// stddev(f - f_Boost): 1.4140857026211713e-16
 const testcase_ellint_3<double>
 data148[10] =
 {
-  { 0.0000000000000000, 0.50000000000000000, 0.69999999999999996, 
+  { 0.0000000000000000, 0.50000000000000000, 0.70000000000000007, 
 	  0.0000000000000000 },
-  { 0.17353350383131641, 0.50000000000000000, 0.69999999999999996, 
+  { 0.17600558435914915, 0.50000000000000000, 0.70000000000000007, 
 	  0.17453292519943295 },
-  { 0.34150410405436771, 0.50000000000000000, 0.69999999999999996, 
+  { 0.36110561926726259, 0.50000000000000000, 0.70000000000000007, 
 	  0.34906585039886590 },
-  { 0.50017589696443487, 0.50000000000000000, 0.69999999999999996, 
+  { 0.56573074641137111, 0.50000000000000000, 0.70000000000000007, 
 	  0.52359877559829882 },
-  { 0.64829398188419951, 0.50000000000000000, 0.69999999999999996, 
+  { 0.80316073084237205, 0.50000000000000000, 0.70000000000000007, 
 	  0.69813170079773179 },
-  { 0.78658270782402073, 0.50000000000000000, 0.69999999999999996, 
+  { 1.0911910688131461, 0.50000000000000000, 0.70000000000000007, 
 	  0.87266462599716477 },
-  { 0.91684738336675053, 0.50000000000000000, 0.69999999999999996, 
+  { 1.4530946406380640, 0.50000000000000000, 0.70000000000000007, 
 	  1.0471975511965976 },
-  { 1.0412486789555935, 0.50000000000000000, 0.69999999999999996, 
+  { 1.9144386536785372, 0.50000000000000000, 0.70000000000000007, 
 	  1.2217304763960306 },
-  { 1.1619021847612001, 0.50000000000000000, 0.69999999999999996, 
+  { 2.4878788958234970, 0.50000000000000000, 0.70000000000000007, 
 	  1.3962634015954636 },
-  { 1.2807475181182502, 0.50000000000000000, 0.69999999999999996, 
+  { 3.1433945297859225, 0.50000000000000000, 0.70000000000000007, 
 	  1.5707963267948966 },
 };
 const double toler148 = 2.5000000000000020e-13;
 
 // Test data for k=0.50000000000000000, nu=0.80000000000000004.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.5715240651179632e-16
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.4380477375534667e-16
+// mean(f - f_Boost): 2.3037127760972000e-16
+// variance(f - f_Boost): 1.4989821857033475e-31
+// stddev(f - f_Boost): 3.8716691306248618e-16
 const testcase_ellint_3<double>
 data149[10] =
 {
   { 0.0000000000000000, 0.50000000000000000, 0.80000000000000004, 
 	  0.0000000000000000 },
-  { 0.17336164805979126, 0.50000000000000000, 0.80000000000000004, 
+  { 0.17618704872620228, 0.50000000000000000, 0.80000000000000004, 
 	  0.17453292519943295 },
-  { 0.34024350132086773, 0.50000000000000000, 0.80000000000000004, 
+  { 0.36266535159745827, 0.50000000000000000, 0.80000000000000004, 
 	  0.34906585039886590 },
-  { 0.49643719555734073, 0.50000000000000000, 0.80000000000000004, 
+  { 0.57167789954529158, 0.50000000000000000, 0.80000000000000004, 
 	  0.52359877559829882 },
-  { 0.64071162456976150, 0.50000000000000000, 0.80000000000000004, 
+  { 0.81995752984315018, 0.50000000000000000, 0.80000000000000004, 
 	  0.69813170079773179 },
-  { 0.77407836177211908, 0.50000000000000000, 0.80000000000000004, 
+  { 1.1325112162158122, 0.50000000000000000, 0.80000000000000004, 
 	  0.87266462599716477 },
-  { 0.89867058251905652, 0.50000000000000000, 0.80000000000000004, 
+  { 1.5479055930718042, 0.50000000000000000, 0.80000000000000004, 
 	  1.0471975511965976 },
-  { 1.0169181822134910, 0.50000000000000000, 0.80000000000000004, 
+  { 2.1215243941010486, 0.50000000000000000, 0.80000000000000004, 
 	  1.2217304763960306 },
-  { 1.1311363312779448, 0.50000000000000000, 0.80000000000000004, 
+  { 2.9069405767650132, 0.50000000000000000, 0.80000000000000004, 
 	  1.3962634015954636 },
-  { 1.2434165408189539, 0.50000000000000000, 0.80000000000000004, 
+  { 3.8750701888108066, 0.50000000000000000, 0.80000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler149 = 2.5000000000000020e-13;
 
 // Test data for k=0.50000000000000000, nu=0.90000000000000002.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.4664649039489274e-16
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.6192315188521289e-16
+// mean(f - f_Boost): 3.5249581031848718e-16
+// variance(f - f_Boost): 2.5029385557256515e-31
+// stddev(f - f_Boost): 5.0029376927217987e-16
 const testcase_ellint_3<double>
 data150[10] =
 {
   { 0.0000000000000000, 0.50000000000000000, 0.90000000000000002, 
 	  0.0000000000000000 },
-  { 0.17319040056865681, 0.50000000000000000, 0.90000000000000002, 
+  { 0.17636918772384180, 0.50000000000000000, 0.90000000000000002, 
 	  0.17453292519943295 },
-  { 0.33899920036578557, 0.50000000000000000, 0.90000000000000002, 
+  { 0.36424950570740700, 0.50000000000000000, 0.90000000000000002, 
 	  0.34906585039886590 },
-  { 0.49279362182695174, 0.50000000000000000, 0.90000000000000002, 
+  { 0.57785404590231426, 0.50000000000000000, 0.90000000000000002, 
 	  0.52359877559829882 },
-  { 0.63342123379746151, 0.50000000000000000, 0.90000000000000002, 
+  { 0.83806480521716531, 0.50000000000000000, 0.90000000000000002, 
 	  0.69813170079773179 },
-  { 0.76220595179550321, 0.50000000000000000, 0.90000000000000002, 
+  { 1.1798568683069752, 0.50000000000000000, 0.90000000000000002, 
 	  0.87266462599716477 },
-  { 0.88160004743532294, 0.50000000000000000, 0.90000000000000002, 
+  { 1.6678766243739607, 0.50000000000000000, 0.90000000000000002, 
 	  1.0471975511965976 },
-  { 0.99427448642310123, 0.50000000000000000, 0.90000000000000002, 
+  { 2.4282976450693483, 0.50000000000000000, 0.90000000000000002, 
 	  1.2217304763960306 },
-  { 1.1027091512470095, 0.50000000000000000, 0.90000000000000002, 
+  { 3.6810787666126656, 0.50000000000000000, 0.90000000000000002, 
 	  1.3962634015954636 },
-  { 1.2091116095504744, 0.50000000000000000, 0.90000000000000002, 
+  { 5.5355132096026454, 0.50000000000000000, 0.90000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler150 = 2.5000000000000020e-13;
 
 // Test data for k=0.60000000000000009, nu=0.0000000000000000.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.3664899092028927e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.3664899092028927e-16
+// mean(f - f_Boost): 3.0531133177191807e-17
+// variance(f - f_Boost): 7.8758646268991113e-33
+// stddev(f - f_Boost): 8.8746068233466605e-17
 const testcase_ellint_3<double>
 data151[10] =
 {
@@ -4398,19 +4850,19 @@ data151[10] =
 	  0.0000000000000000 },
   { 0.17485154362988359, 0.60000000000000009, 0.0000000000000000, 
 	  0.17453292519943295 },
-  { 0.35160509865544326, 0.60000000000000009, 0.0000000000000000, 
+  { 0.35160509865544320, 0.60000000000000009, 0.0000000000000000, 
 	  0.34906585039886590 },
   { 0.53210652578446138, 0.60000000000000009, 0.0000000000000000, 
 	  0.52359877559829882 },
   { 0.71805304664485659, 0.60000000000000009, 0.0000000000000000, 
 	  0.69813170079773179 },
-  { 0.91082759030195970, 0.60000000000000009, 0.0000000000000000, 
+  { 0.91082759030195981, 0.60000000000000009, 0.0000000000000000, 
 	  0.87266462599716477 },
   { 1.1112333229323361, 0.60000000000000009, 0.0000000000000000, 
 	  1.0471975511965976 },
   { 1.3191461190365270, 0.60000000000000009, 0.0000000000000000, 
 	  1.2217304763960306 },
-  { 1.5332022105084775, 0.60000000000000009, 0.0000000000000000, 
+  { 1.5332022105084779, 0.60000000000000009, 0.0000000000000000, 
 	  1.3962634015954636 },
   { 1.7507538029157526, 0.60000000000000009, 0.0000000000000000, 
 	  1.5707963267948966 },
@@ -4418,559 +4870,619 @@ data151[10] =
 const double toler151 = 2.5000000000000020e-13;
 
 // Test data for k=0.60000000000000009, nu=0.10000000000000001.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.4937942733669112e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.2335247010355137e-16
+// mean(f - f_Boost): 8.6042284408449634e-17
+// variance(f - f_Boost): 2.2835347143080263e-33
+// stddev(f - f_Boost): 4.7786344433405099e-17
 const testcase_ellint_3<double>
 data152[10] =
 {
   { 0.0000000000000000, 0.60000000000000009, 0.10000000000000001, 
 	  0.0000000000000000 },
-  { 0.17467514275022011, 0.60000000000000009, 0.10000000000000001, 
+  { 0.17502858548476194, 0.60000000000000009, 0.10000000000000001, 
 	  0.17453292519943295 },
-  { 0.35021333086258255, 0.60000000000000009, 0.10000000000000001, 
+  { 0.35301673150537388, 0.60000000000000009, 0.10000000000000001, 
 	  0.34906585039886590 },
-  { 0.52751664092962691, 0.60000000000000009, 0.10000000000000001, 
+  { 0.53683932476326812, 0.60000000000000009, 0.10000000000000001, 
 	  0.52359877559829882 },
-  { 0.70752126971957874, 0.60000000000000009, 0.10000000000000001, 
+  { 0.72914228589586771, 0.60000000000000009, 0.10000000000000001, 
 	  0.69813170079773179 },
-  { 0.89111058756112871, 0.60000000000000009, 0.10000000000000001, 
+  { 0.93208036718354692, 0.60000000000000009, 0.10000000000000001, 
 	  0.87266462599716477 },
-  { 1.0789241202877768, 0.60000000000000009, 0.10000000000000001, 
+  { 1.1468984688863377, 0.60000000000000009, 0.10000000000000001, 
 	  1.0471975511965976 },
-  { 1.2710800210399946, 0.60000000000000009, 0.10000000000000001, 
+  { 1.3733904977062528, 0.60000000000000009, 0.10000000000000001, 
 	  1.2217304763960306 },
-  { 1.4669060574440276, 0.60000000000000009, 0.10000000000000001, 
+  { 1.6094225663372157, 0.60000000000000009, 0.10000000000000001, 
 	  1.3962634015954636 },
-  { 1.6648615773343014, 0.60000000000000009, 0.10000000000000001, 
+  { 1.8508766487100685, 0.60000000000000009, 0.10000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler152 = 2.5000000000000020e-13;
 
 // Test data for k=0.60000000000000009, nu=0.20000000000000001.
-// max(|f - f_GSL|): 6.6613381477509392e-16
-// max(|f - f_GSL| / |f_GSL|): 4.1891472451898755e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 2.2547200163366559e-16
+// mean(f - f_Boost): -2.4980018054066023e-17
+// variance(f - f_Boost): 2.1685495635542404e-32
+// stddev(f - f_Boost): 1.4725995937641163e-16
 const testcase_ellint_3<double>
 data153[10] =
 {
   { 0.0000000000000000, 0.60000000000000009, 0.20000000000000001, 
 	  0.0000000000000000 },
-  { 0.17449937871800650, 0.60000000000000009, 0.20000000000000001, 
+  { 0.17520627248155893, 0.60000000000000009, 0.20000000000000001, 
 	  0.17453292519943295 },
-  { 0.34884093647346553, 0.60000000000000009, 0.20000000000000001, 
+  { 0.35444873935437748, 0.60000000000000009, 0.20000000000000001, 
 	  0.34906585039886590 },
-  { 0.52306221119844087, 0.60000000000000009, 0.20000000000000001, 
+  { 0.54172310557682524, 0.60000000000000009, 0.20000000000000001, 
 	  0.52359877559829882 },
-  { 0.69749955678982223, 0.60000000000000009, 0.20000000000000001, 
+  { 0.74084300280734672, 0.60000000000000009, 0.20000000000000001, 
 	  0.69813170079773179 },
-  { 0.87274610682416853, 0.60000000000000009, 0.20000000000000001, 
+  { 0.95509001527006121, 0.60000000000000009, 0.20000000000000001, 
 	  0.87266462599716477 },
-  { 1.0494620540750792, 0.60000000000000009, 0.20000000000000001, 
+  { 1.1865688084431796, 0.60000000000000009, 0.20000000000000001, 
 	  1.0471975511965976 },
-  { 1.2280847305507339, 0.60000000000000009, 0.20000000000000001, 
+  { 1.4352978868932600, 0.60000000000000009, 0.20000000000000001, 
 	  1.2217304763960306 },
-  { 1.4085436279696888, 0.60000000000000009, 0.20000000000000001, 
+  { 1.6983400371331818, 0.60000000000000009, 0.20000000000000001, 
 	  1.3962634015954636 },
-  { 1.5901418016279374, 0.60000000000000009, 0.20000000000000001, 
+  { 1.9695980282802217, 0.60000000000000009, 0.20000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler153 = 2.5000000000000020e-13;
 
-// Test data for k=0.60000000000000009, nu=0.29999999999999999.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.7339932380431439e-16
+// Test data for k=0.60000000000000009, nu=0.30000000000000004.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 2.9470074709717020e-16
+// mean(f - f_Boost): 3.0531133177191807e-17
+// variance(f - f_Boost): 1.1508025840536076e-34
+// stddev(f - f_Boost): 1.0727546709539920e-17
 const testcase_ellint_3<double>
 data154[10] =
 {
-  { 0.0000000000000000, 0.60000000000000009, 0.29999999999999999, 
+  { 0.0000000000000000, 0.60000000000000009, 0.30000000000000004, 
 	  0.0000000000000000 },
-  { 0.17432424744393932, 0.60000000000000009, 0.29999999999999999, 
+  { 0.17538460882640122, 0.60000000000000009, 0.30000000000000004, 
 	  0.17453292519943295 },
-  { 0.34748744127146447, 0.60000000000000009, 0.29999999999999999, 
+  { 0.35590165133735557, 0.60000000000000009, 0.30000000000000004, 
 	  0.34906585039886590 },
-  { 0.51873632743924825, 0.60000000000000009, 0.29999999999999999, 
+  { 0.54676661152254535, 0.60000000000000009, 0.30000000000000004, 
 	  0.52359877559829882 },
-  { 0.68794610396313116, 0.60000000000000009, 0.29999999999999999, 
+  { 0.75321709418305305, 0.60000000000000009, 0.30000000000000004, 
 	  0.69813170079773179 },
-  { 0.85558070175468726, 0.60000000000000009, 0.29999999999999999, 
+  { 0.98012637808992920, 0.60000000000000009, 0.30000000000000004, 
 	  0.87266462599716477 },
-  { 1.0224416343605653, 0.60000000000000009, 0.29999999999999999, 
+  { 1.2310891277158875, 0.60000000000000009, 0.30000000000000004, 
 	  1.0471975511965976 },
-  { 1.1893144457936788, 0.60000000000000009, 0.29999999999999999, 
+  { 1.5069157924585623, 0.60000000000000009, 0.30000000000000004, 
 	  1.2217304763960306 },
-  { 1.3566435377982575, 0.60000000000000009, 0.29999999999999999, 
+  { 1.8039583598337940, 0.60000000000000009, 0.30000000000000004, 
 	  1.3962634015954636 },
-  { 1.5243814243493585, 0.60000000000000009, 0.29999999999999999, 
+  { 2.1134154405060599, 0.60000000000000009, 0.30000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler154 = 2.5000000000000020e-13;
 
 // Test data for k=0.60000000000000009, nu=0.40000000000000002.
-// max(|f - f_GSL|): 6.6613381477509392e-16
-// max(|f - f_GSL| / |f_GSL|): 4.5440898085101625e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 2.8974839914337670e-16
+// mean(f - f_Boost): -1.3877787807814457e-17
+// variance(f - f_Boost): 2.2849613290816465e-32
+// stddev(f - f_Boost): 1.5116088545260797e-16
 const testcase_ellint_3<double>
 data155[10] =
 {
   { 0.0000000000000000, 0.60000000000000009, 0.40000000000000002, 
 	  0.0000000000000000 },
-  { 0.17414974487670717, 0.60000000000000009, 0.40000000000000002, 
+  { 0.17556359876533037, 0.60000000000000009, 0.40000000000000002, 
 	  0.17453292519943295 },
-  { 0.34615238767335027, 0.60000000000000009, 0.40000000000000002, 
+  { 0.35737601674244679, 0.60000000000000009, 0.40000000000000002, 
 	  0.34906585039886590 },
-  { 0.51453257838108557, 0.60000000000000009, 0.40000000000000002, 
+  { 0.55197933771320218, 0.60000000000000009, 0.40000000000000002, 
 	  0.52359877559829882 },
-  { 0.67882386787534399, 0.60000000000000009, 0.40000000000000002, 
+  { 0.76633591620002905, 0.60000000000000009, 0.40000000000000002, 
 	  0.69813170079773179 },
-  { 0.83948470233173578, 0.60000000000000009, 0.40000000000000002, 
+  { 1.0075231136019616, 0.60000000000000009, 0.40000000000000002, 
 	  0.87266462599716477 },
-  { 0.99753496200073977, 0.60000000000000009, 0.40000000000000002, 
+  { 1.2815842073813450, 0.60000000000000009, 0.40000000000000002, 
 	  1.0471975511965976 },
-  { 1.1541101404388487, 0.60000000000000009, 0.40000000000000002, 
+  { 1.5911666941449827, 0.60000000000000009, 0.40000000000000002, 
 	  1.2217304763960306 },
-  { 1.3100911323398816, 0.60000000000000009, 0.40000000000000002, 
+  { 1.9323227566025762, 0.60000000000000009, 0.40000000000000002, 
 	  1.3962634015954636 },
-  { 1.4659345278069984, 0.60000000000000009, 0.40000000000000002, 
+  { 2.2925036420985130, 0.60000000000000009, 0.40000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler155 = 2.5000000000000020e-13;
 
 // Test data for k=0.60000000000000009, nu=0.50000000000000000.
-// max(|f - f_GSL|): 6.6613381477509392e-16
-// max(|f - f_GSL| / |f_GSL|): 4.7124937590522226e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 2.1397785842303966e-16
+// mean(f - f_Boost): 9.1593399531575410e-17
+// variance(f - f_Boost): 1.5339913122479866e-32
+// stddev(f - f_Boost): 1.2385440291923362e-16
 const testcase_ellint_3<double>
 data156[10] =
 {
   { 0.0000000000000000, 0.60000000000000009, 0.50000000000000000, 
 	  0.0000000000000000 },
-  { 0.17397586700252807, 0.60000000000000009, 0.50000000000000000, 
+  { 0.17574324658480217, 0.60000000000000009, 0.50000000000000000, 
 	  0.17453292519943295 },
-  { 0.34483533397138516, 0.60000000000000009, 0.50000000000000000, 
+  { 0.35887240603169313, 0.60000000000000009, 0.50000000000000000, 
 	  0.34906585039886590 },
-  { 0.51044500461706477, 0.60000000000000009, 0.50000000000000000, 
+  { 0.55737161826345261, 0.60000000000000009, 0.50000000000000000, 
 	  0.52359877559829882 },
-  { 0.67009988034712664, 0.60000000000000009, 0.50000000000000000, 
+  { 0.78028227313077458, 0.60000000000000009, 0.50000000000000000, 
 	  0.69813170079773179 },
-  { 0.82434762375735193, 0.60000000000000009, 0.50000000000000000, 
+  { 1.0376989776486290, 0.60000000000000009, 0.50000000000000000, 
 	  0.87266462599716477 },
-  { 0.97447346702798998, 0.60000000000000009, 0.50000000000000000, 
+  { 1.3395933991042928, 0.60000000000000009, 0.50000000000000000, 
 	  1.0471975511965976 },
-  { 1.1219494000522143, 0.60000000000000009, 0.50000000000000000, 
+  { 1.6924049626591784, 0.60000000000000009, 0.50000000000000000, 
 	  1.2217304763960306 },
-  { 1.2680242605954486, 0.60000000000000009, 0.50000000000000000, 
+  { 2.0931011856518920, 0.60000000000000009, 0.50000000000000000, 
 	  1.3962634015954636 },
-  { 1.4135484285693078, 0.60000000000000009, 0.50000000000000000, 
+  { 2.5239007084492711, 0.60000000000000009, 0.50000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler156 = 2.5000000000000020e-13;
 
-// Test data for k=0.60000000000000009, nu=0.59999999999999998.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.0652177678695900e-16
+// Test data for k=0.60000000000000009, nu=0.60000000000000009.
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.6651378277398083e-16
+// mean(f - f_Boost): 1.1934897514720432e-16
+// variance(f - f_Boost): 1.7585404776158019e-33
+// stddev(f - f_Boost): 4.1934955319110598e-17
 const testcase_ellint_3<double>
 data157[10] =
 {
-  { 0.0000000000000000, 0.60000000000000009, 0.59999999999999998, 
+  { 0.0000000000000000, 0.60000000000000009, 0.60000000000000009, 
 	  0.0000000000000000 },
-  { 0.17380260984469353, 0.60000000000000009, 0.59999999999999998, 
+  { 0.17592355661219386, 0.60000000000000009, 0.60000000000000009, 
 	  0.17453292519943295 },
-  { 0.34353585361777839, 0.60000000000000009, 0.59999999999999998, 
+  { 0.36039141192661606, 0.60000000000000009, 0.60000000000000009, 
 	  0.34906585039886590 },
-  { 0.50646805774321380, 0.60000000000000009, 0.59999999999999998, 
+  { 0.56295472636903854, 0.60000000000000009, 0.60000000000000009, 
 	  0.52359877559829882 },
-  { 0.66174468108625506, 0.60000000000000009, 0.59999999999999998, 
+  { 0.79515295130165986, 0.60000000000000009, 0.60000000000000009, 
 	  0.69813170079773179 },
-  { 0.81007462280278408, 0.60000000000000009, 0.59999999999999998, 
+  { 1.0711886441942242, 0.60000000000000009, 0.60000000000000009, 
 	  0.87266462599716477 },
-  { 0.95303466945718729, 0.60000000000000009, 0.59999999999999998, 
+  { 1.4072952835139891, 0.60000000000000009, 0.60000000000000009, 
 	  1.0471975511965976 },
-  { 1.0924118588677505, 0.60000000000000009, 0.59999999999999998, 
+  { 1.8174863977376825, 0.60000000000000009, 0.60000000000000009, 
 	  1.2217304763960306 },
-  { 1.2297640574847937, 0.60000000000000009, 0.59999999999999998, 
+  { 2.3029921578542232, 0.60000000000000009, 0.60000000000000009, 
 	  1.3962634015954636 },
-  { 1.3662507535812816, 0.60000000000000009, 0.59999999999999998, 
+  { 2.8388723099514972, 0.60000000000000009, 0.60000000000000009, 
 	  1.5707963267948966 },
 };
 const double toler157 = 2.5000000000000020e-13;
 
-// Test data for k=0.60000000000000009, nu=0.69999999999999996.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.1692457486457856e-16
+// Test data for k=0.60000000000000009, nu=0.70000000000000007.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 2.0027679235921772e-16
+// mean(f - f_Boost): -1.3877787807814457e-17
+// variance(f - f_Boost): 2.2849613290816465e-32
+// stddev(f - f_Boost): 1.5116088545260797e-16
 const testcase_ellint_3<double>
 data158[10] =
 {
-  { 0.0000000000000000, 0.60000000000000009, 0.69999999999999996, 
+  { 0.0000000000000000, 0.60000000000000009, 0.70000000000000007, 
 	  0.0000000000000000 },
-  { 0.17362996946312007, 0.60000000000000009, 0.69999999999999996, 
+  { 0.17610453321631936, 0.60000000000000009, 0.70000000000000007, 
 	  0.17453292519943295 },
-  { 0.34225353454870588, 0.60000000000000009, 0.69999999999999996, 
+  { 0.36193365056369764, 0.60000000000000009, 0.70000000000000007, 
 	  0.34906585039886590 },
-  { 0.50259656397799524, 0.60000000000000009, 0.69999999999999996, 
+  { 0.56874098962268527, 0.60000000000000009, 0.70000000000000007, 
 	  0.52359877559829882 },
-  { 0.65373184496628933, 0.60000000000000009, 0.69999999999999996, 
+  { 0.81106198671477181, 0.60000000000000009, 0.70000000000000007, 
 	  0.69813170079773179 },
-  { 0.79658372884056439, 0.60000000000000009, 0.69999999999999996, 
+  { 1.1086886419010082, 0.60000000000000009, 0.70000000000000007, 
 	  0.87266462599716477 },
-  { 0.93303240100245421, 0.60000000000000009, 0.69999999999999996, 
+  { 1.4879048567239257, 0.60000000000000009, 0.70000000000000007, 
 	  1.0471975511965976 },
-  { 1.0651547944716557, 0.60000000000000009, 0.69999999999999996, 
+  { 1.9780310073615925, 0.60000000000000009, 0.70000000000000007, 
 	  1.2217304763960306 },
-  { 1.1947676204853441, 0.60000000000000009, 0.69999999999999996, 
+  { 2.5941545586772712, 0.60000000000000009, 0.70000000000000007, 
 	  1.3962634015954636 },
-  { 1.3232737468822813, 0.60000000000000009, 0.69999999999999996, 
+  { 3.3029735898397159, 0.60000000000000009, 0.70000000000000007, 
 	  1.5707963267948966 },
 };
 const double toler158 = 2.5000000000000020e-13;
 
 // Test data for k=0.60000000000000009, nu=0.80000000000000004.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.2705175719241326e-16
+// max(|f - f_Boost|): 2.2204460492503131e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 7.3044933435043190e-16
+// mean(f - f_Boost): 2.6367796834847468e-16
+// variance(f - f_Boost): 8.5834655546147173e-33
+// stddev(f - f_Boost): 9.2646994309662939e-17
 const testcase_ellint_3<double>
 data159[10] =
 {
   { 0.0000000000000000, 0.60000000000000009, 0.80000000000000004, 
 	  0.0000000000000000 },
-  { 0.17345794195390685, 0.60000000000000009, 0.80000000000000004, 
+  { 0.17628618080795252, 0.60000000000000009, 0.80000000000000004, 
 	  0.17453292519943295 },
-  { 0.34098797854531027, 0.60000000000000009, 0.80000000000000004, 
+  { 0.36349976272521012, 0.60000000000000009, 0.80000000000000004, 
 	  0.34906585039886590 },
-  { 0.49882569168826213, 0.60000000000000009, 0.80000000000000004, 
+  { 0.57474392342151914, 0.60000000000000009, 0.80000000000000004, 
 	  0.52359877559829882 },
-  { 0.64603758566475511, 0.60000000000000009, 0.80000000000000004, 
+  { 0.82814493499158170, 0.60000000000000009, 0.80000000000000004, 
 	  0.69813170079773179 },
-  { 0.78380365594769730, 0.60000000000000009, 0.80000000000000004, 
+  { 1.1511281795998280, 0.60000000000000009, 0.80000000000000004, 
 	  0.87266462599716477 },
-  { 0.91430946255611190, 0.60000000000000009, 0.80000000000000004, 
+  { 1.5864286332503075, 0.60000000000000009, 0.80000000000000004, 
 	  1.0471975511965976 },
-  { 1.0398955217270607, 0.60000000000000009, 0.80000000000000004, 
+  { 2.1958944866494527, 0.60000000000000009, 0.80000000000000004, 
 	  1.2217304763960306 },
-  { 1.1625948314277679, 0.60000000000000009, 0.80000000000000004, 
+  { 3.0398358172574604, 0.60000000000000009, 0.80000000000000004, 
 	  1.3962634015954636 },
-  { 1.2840021261752192, 0.60000000000000009, 0.80000000000000004, 
+  { 4.0867036409261832, 0.60000000000000009, 0.80000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler159 = 2.5000000000000020e-13;
 
 // Test data for k=0.60000000000000009, nu=0.90000000000000002.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.5585887739668036e-16
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 4.5952142720718732e-16
+// mean(f - f_Boost): 4.6351811278100284e-16
+// variance(f - f_Boost): 2.1278339779151204e-31
+// stddev(f - f_Boost): 4.6128450851021651e-16
 const testcase_ellint_3<double>
 data160[10] =
 {
   { 0.0000000000000000, 0.60000000000000009, 0.90000000000000002, 
 	  0.0000000000000000 },
-  { 0.17328652344890030, 0.60000000000000009, 0.90000000000000002, 
+  { 0.17646850384035848, 0.60000000000000009, 0.90000000000000002, 
 	  0.17453292519943295 },
-  { 0.33973880062929018, 0.60000000000000009, 0.90000000000000002, 
+  { 0.36509041515134105, 0.60000000000000009, 0.90000000000000002, 
 	  0.34906585039886590 },
-  { 0.49515092233122743, 0.60000000000000009, 0.90000000000000002, 
+  { 0.58097838596260631, 0.60000000000000009, 0.90000000000000002, 
 	  0.52359877559829882 },
-  { 0.63864042139737043, 0.60000000000000009, 0.90000000000000002, 
+  { 0.84656453396163722, 0.60000000000000009, 0.90000000000000002, 
 	  0.69813170079773179 },
-  { 0.77167205646538850, 0.60000000000000009, 0.90000000000000002, 
+  { 1.1997828426963724, 0.60000000000000009, 0.90000000000000002, 
 	  0.87266462599716477 },
-  { 0.89673202848034383, 0.60000000000000009, 0.90000000000000002, 
+  { 1.7112436789225605, 0.60000000000000009, 0.90000000000000002, 
 	  1.0471975511965976 },
-  { 1.0163984492661304, 0.60000000000000009, 0.90000000000000002, 
+  { 2.5193168553672312, 0.60000000000000009, 0.90000000000000002, 
 	  1.2217304763960306 },
-  { 1.1328845785162431, 0.60000000000000009, 0.90000000000000002, 
+  { 3.8656670488606690, 0.60000000000000009, 0.90000000000000002, 
 	  1.3962634015954636 },
-  { 1.2479362973851873, 0.60000000000000009, 0.90000000000000002, 
+  { 5.8709993116265604, 0.60000000000000009, 0.90000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler160 = 2.5000000000000020e-13;
 
-// Test data for k=0.69999999999999996, nu=0.0000000000000000.
-// max(|f - f_GSL|): 3.3306690738754696e-16
-// max(|f - f_GSL| / |f_GSL|): 3.5930208052157665e-16
+// Test data for k=0.70000000000000018, nu=0.0000000000000000.
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 4.1569224977685422e-16
+// mean(f - f_Boost): 7.7715611723760953e-17
+// variance(f - f_Boost): 1.6571557210371951e-32
+// stddev(f - f_Boost): 1.2873056051447903e-16
 const testcase_ellint_3<double>
 data161[10] =
 {
-  { 0.0000000000000000, 0.69999999999999996, 0.0000000000000000, 
+  { 0.0000000000000000, 0.70000000000000018, 0.0000000000000000, 
 	  0.0000000000000000 },
-  { 0.17496737466916723, 0.69999999999999996, 0.0000000000000000, 
+  { 0.17496737466916723, 0.70000000000000018, 0.0000000000000000, 
 	  0.17453292519943295 },
-  { 0.35254687535677925, 0.69999999999999996, 0.0000000000000000, 
+  { 0.35254687535677931, 0.70000000000000018, 0.0000000000000000, 
 	  0.34906585039886590 },
-  { 0.53536740275997119, 0.69999999999999996, 0.0000000000000000, 
+  { 0.53536740275997130, 0.70000000000000018, 0.0000000000000000, 
 	  0.52359877559829882 },
-  { 0.72603797651684454, 0.69999999999999996, 0.0000000000000000, 
+  { 0.72603797651684454, 0.70000000000000018, 0.0000000000000000, 
 	  0.69813170079773179 },
-  { 0.92698296348313458, 0.69999999999999996, 0.0000000000000000, 
+  { 0.92698296348313447, 0.70000000000000018, 0.0000000000000000, 
 	  0.87266462599716477 },
-  { 1.1400447527693316, 0.69999999999999996, 0.0000000000000000, 
+  { 1.1400447527693318, 0.70000000000000018, 0.0000000000000000, 
 	  1.0471975511965976 },
-  { 1.3657668117194073, 0.69999999999999996, 0.0000000000000000, 
+  { 1.3657668117194073, 0.70000000000000018, 0.0000000000000000, 
 	  1.2217304763960306 },
-  { 1.6024686895959159, 0.69999999999999996, 0.0000000000000000, 
+  { 1.6024686895959164, 0.70000000000000018, 0.0000000000000000, 
 	  1.3962634015954636 },
-  { 1.8456939983747236, 0.69999999999999996, 0.0000000000000000, 
+  { 1.8456939983747236, 0.70000000000000018, 0.0000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler161 = 2.5000000000000020e-13;
 
-// Test data for k=0.69999999999999996, nu=0.10000000000000001.
-// max(|f - f_GSL|): 3.3306690738754696e-16
-// max(|f - f_GSL| / |f_GSL|): 3.6735282577377367e-16
+// Test data for k=0.70000000000000018, nu=0.10000000000000001.
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 3.9552278747527691e-16
+// mean(f - f_Boost): 1.1102230246251565e-16
+// variance(f - f_Boost): 1.3695501826753678e-32
+// stddev(f - f_Boost): 1.1702778228589004e-16
 const testcase_ellint_3<double>
 data162[10] =
 {
-  { 0.0000000000000000, 0.69999999999999996, 0.10000000000000001, 
+  { 0.0000000000000000, 0.70000000000000018, 0.10000000000000001, 
 	  0.0000000000000000 },
-  { 0.17479076384884684, 0.69999999999999996, 0.10000000000000001, 
+  { 0.17514462737300920, 0.70000000000000018, 0.10000000000000001, 
 	  0.17453292519943295 },
-  { 0.35114844900396364, 0.69999999999999996, 0.10000000000000001, 
+  { 0.35396527997470451, 0.70000000000000018, 0.10000000000000001, 
 	  0.34906585039886590 },
-  { 0.53072776947527001, 0.69999999999999996, 0.10000000000000001, 
+  { 0.54015179589433981, 0.70000000000000018, 0.10000000000000001, 
 	  0.52359877559829882 },
-  { 0.71530198262386235, 0.69999999999999996, 0.10000000000000001, 
+  { 0.73734430854477728, 0.70000000000000018, 0.10000000000000001, 
 	  0.69813170079773179 },
-  { 0.90666760677828306, 0.69999999999999996, 0.10000000000000001, 
+  { 0.94888950796697047, 0.70000000000000018, 0.10000000000000001, 
 	  0.87266462599716477 },
-  { 1.1063366517438080, 0.69999999999999996, 0.10000000000000001, 
+  { 1.1772807959736322, 0.70000000000000018, 0.10000000000000001, 
 	  1.0471975511965976 },
-  { 1.3149477243092149, 0.69999999999999996, 0.10000000000000001, 
+  { 1.4231796401075834, 0.70000000000000018, 0.10000000000000001, 
 	  1.2217304763960306 },
-  { 1.5314886725038925, 0.69999999999999996, 0.10000000000000001, 
+  { 1.6841856799887471, 0.70000000000000018, 0.10000000000000001, 
 	  1.3962634015954636 },
-  { 1.7528050171757608, 0.69999999999999996, 0.10000000000000001, 
+  { 1.9541347343119564, 0.70000000000000018, 0.10000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler162 = 2.5000000000000020e-13;
 
-// Test data for k=0.69999999999999996, nu=0.20000000000000001.
-// max(|f - f_GSL|): 3.3306690738754696e-16
-// max(|f - f_GSL| / |f_GSL|): 3.7517969287516802e-16
+// Test data for k=0.70000000000000018, nu=0.20000000000000001.
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 3.7430437016285820e-16
+// mean(f - f_Boost): 3.3306690738754695e-17
+// variance(f - f_Boost): 1.3695501826753678e-34
+// stddev(f - f_Boost): 1.1702778228589003e-17
 const testcase_ellint_3<double>
 data163[10] =
 {
-  { 0.0000000000000000, 0.69999999999999996, 0.20000000000000001, 
+  { 0.0000000000000000, 0.70000000000000018, 0.20000000000000001, 
 	  0.0000000000000000 },
-  { 0.17461479077791475, 0.69999999999999996, 0.20000000000000001, 
+  { 0.17532252613350796, 0.70000000000000018, 0.20000000000000001, 
 	  0.17453292519943295 },
-  { 0.34976950621407538, 0.69999999999999996, 0.20000000000000001, 
+  { 0.35540417596807522, 0.70000000000000018, 0.20000000000000001, 
 	  0.34906585039886590 },
-  { 0.52622533231350177, 0.69999999999999996, 0.20000000000000001, 
+  { 0.54508913033361928, 0.70000000000000018, 0.20000000000000001, 
 	  0.52359877559829882 },
-  { 0.70508774017895215, 0.69999999999999996, 0.20000000000000001, 
+  { 0.74927635777718415, 0.70000000000000018, 0.20000000000000001, 
 	  0.69813170079773179 },
-  { 0.88775302531730294, 0.69999999999999996, 0.20000000000000001, 
+  { 0.97261706337936338, 0.70000000000000018, 0.20000000000000001, 
 	  0.87266462599716477 },
-  { 1.0756195476149006, 0.69999999999999996, 0.20000000000000001, 
+  { 1.2187303976209327, 0.70000000000000018, 0.20000000000000001, 
 	  1.0471975511965976 },
-  { 1.2695349716654374, 0.69999999999999996, 0.20000000000000001, 
+  { 1.4887796709222487, 0.70000000000000018, 0.20000000000000001, 
 	  1.2217304763960306 },
-  { 1.4690814617070540, 0.69999999999999996, 0.20000000000000001, 
+  { 1.7796581281839214, 0.70000000000000018, 0.20000000000000001, 
 	  1.3962634015954636 },
-  { 1.6721098780092145, 0.69999999999999996, 0.20000000000000001, 
+  { 2.0829290325820207, 0.70000000000000018, 0.20000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler163 = 2.5000000000000020e-13;
 
-// Test data for k=0.69999999999999996, nu=0.29999999999999999.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.8280039841080712e-16
+// Test data for k=0.70000000000000018, nu=0.30000000000000004.
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 4.2570807706941696e-16
+// mean(f - f_Boost): 8.8817841970012528e-17
+// variance(f - f_Boost): 1.5582437633995295e-32
+// stddev(f - f_Boost): 1.2482963443828271e-16
 const testcase_ellint_3<double>
 data164[10] =
 {
-  { 0.0000000000000000, 0.69999999999999996, 0.29999999999999999, 
+  { 0.0000000000000000, 0.70000000000000018, 0.30000000000000004, 
 	  0.0000000000000000 },
-  { 0.17443945136076175, 0.69999999999999996, 0.29999999999999999, 
+  { 0.17550107516328570, 0.70000000000000018, 0.30000000000000004, 
 	  0.17453292519943295 },
-  { 0.34840956983535287, 0.69999999999999996, 0.29999999999999999, 
+  { 0.35686409576571965, 0.70000000000000018, 0.30000000000000004, 
 	  0.34906585039886590 },
-  { 0.52185308551329168, 0.69999999999999996, 0.29999999999999999, 
+  { 0.55018827316513352, 0.70000000000000018, 0.30000000000000004, 
 	  0.52359877559829882 },
-  { 0.69535240431168255, 0.69999999999999996, 0.29999999999999999, 
+  { 0.76189759494390275, 0.70000000000000018, 0.30000000000000004, 
 	  0.69813170079773179 },
-  { 0.87007983473964923, 0.69999999999999996, 0.29999999999999999, 
+  { 0.99844623430885626, 0.70000000000000018, 0.30000000000000004, 
 	  0.87266462599716477 },
-  { 1.0474657975577066, 0.69999999999999996, 0.29999999999999999, 
+  { 1.2652862989039833, 0.70000000000000018, 0.30000000000000004, 
 	  1.0471975511965976 },
-  { 1.2286225419931891, 0.69999999999999996, 0.29999999999999999, 
+  { 1.5647666808691361, 0.70000000000000018, 0.30000000000000004, 
 	  1.2217304763960306 },
-  { 1.4136490671013271, 0.69999999999999996, 0.29999999999999999, 
+  { 1.8932499694938165, 0.70000000000000018, 0.30000000000000004, 
 	  1.3962634015954636 },
-  { 1.6011813647733213, 0.69999999999999996, 0.29999999999999999, 
+  { 2.2392290510988535, 0.70000000000000018, 0.30000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler164 = 2.5000000000000020e-13;
 
-// Test data for k=0.69999999999999996, nu=0.40000000000000002.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.3472957053482092e-16
+// Test data for k=0.70000000000000018, nu=0.40000000000000002.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 4.3719045096496910e-16
+// mean(f - f_Boost): 1.3600232051658169e-16
+// variance(f - f_Boost): 1.1718213750516114e-32
+// stddev(f - f_Boost): 1.0825069861444829e-16
 const testcase_ellint_3<double>
 data165[10] =
 {
-  { 0.0000000000000000, 0.69999999999999996, 0.40000000000000002, 
+  { 0.0000000000000000, 0.70000000000000018, 0.40000000000000002, 
 	  0.0000000000000000 },
-  { 0.17426474153983229, 0.69999999999999996, 0.40000000000000002, 
+  { 0.17568027871494424, 0.70000000000000018, 0.40000000000000002, 
 	  0.17453292519943295 },
-  { 0.34706817945773732, 0.69999999999999996, 0.40000000000000002, 
+  { 0.35834559208180261, 0.70000000000000018, 0.40000000000000002, 
 	  0.34906585039886590 },
-  { 0.51760452851738148, 0.69999999999999996, 0.40000000000000002, 
+  { 0.55545885451190613, 0.70000000000000018, 0.40000000000000002, 
 	  0.52359877559829882 },
-  { 0.68605801534722755, 0.69999999999999996, 0.40000000000000002, 
+  { 0.77528120402568113, 0.70000000000000018, 0.40000000000000002, 
 	  0.69813170079773179 },
-  { 0.85351339387296532, 0.69999999999999996, 0.40000000000000002, 
+  { 1.0267241287600322, 0.70000000000000018, 0.40000000000000002, 
 	  0.87266462599716477 },
-  { 1.0215297967969539, 0.69999999999999996, 0.40000000000000002, 
+  { 1.3181380338980246, 0.70000000000000018, 0.40000000000000002, 
 	  1.0471975511965976 },
-  { 1.1915051074460530, 0.69999999999999996, 0.40000000000000002, 
+  { 1.6542840785132087, 0.70000000000000018, 0.40000000000000002, 
 	  1.2217304763960306 },
-  { 1.3639821911744707, 0.69999999999999996, 0.40000000000000002, 
+  { 2.0315595131131823, 0.70000000000000018, 0.40000000000000002, 
 	  1.3962634015954636 },
-  { 1.5382162002954762, 0.69999999999999996, 0.40000000000000002, 
+  { 2.4342502915307880, 0.70000000000000018, 0.40000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler165 = 2.5000000000000020e-13;
 
-// Test data for k=0.69999999999999996, nu=0.50000000000000000.
-// max(|f - f_GSL|): 3.3306690738754696e-16
-// max(|f - f_GSL| / |f_GSL|): 3.9748346743390620e-16
+// Test data for k=0.70000000000000018, nu=0.50000000000000000.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 4.0277361210295499e-16
+// mean(f - f_Boost): 1.6930901125533636e-16
+// variance(f - f_Boost): 6.3799163752809956e-32
+// stddev(f - f_Boost): 2.5258496343371268e-16
 const testcase_ellint_3<double>
 data166[10] =
 {
-  { 0.0000000000000000, 0.69999999999999996, 0.50000000000000000, 
+  { 0.0000000000000000, 0.70000000000000018, 0.50000000000000000, 
 	  0.0000000000000000 },
-  { 0.17409065729516096, 0.69999999999999996, 0.50000000000000000, 
+  { 0.17586014108156545, 0.70000000000000018, 0.50000000000000000, 
 	  0.17453292519943295 },
-  { 0.34574489064986091, 0.69999999999999996, 0.50000000000000000, 
+  { 0.35984923894341653, 0.70000000000000018, 0.50000000000000000, 
 	  0.34906585039886590 },
-  { 0.51347361925579782, 0.69999999999999996, 0.50000000000000000, 
+  { 0.56091135606739995, 0.70000000000000018, 0.50000000000000000, 
 	  0.52359877559829882 },
-  { 0.67717079489579279, 0.69999999999999996, 0.50000000000000000, 
+  { 0.78951212635197054, 0.70000000000000018, 0.50000000000000000, 
 	  0.69813170079773179 },
-  { 0.83793902055292280, 0.69999999999999996, 0.50000000000000000, 
+  { 1.0578865732938731, 0.70000000000000018, 0.50000000000000000, 
 	  0.87266462599716477 },
-  { 0.99752863545289705, 0.69999999999999996, 0.50000000000000000, 
+  { 1.3789149005151722, 0.70000000000000018, 0.50000000000000000, 
 	  1.0471975511965976 },
-  { 1.1576240080401501, 0.69999999999999996, 0.50000000000000000, 
+  { 1.7620212286086228, 0.70000000000000018, 0.50000000000000000, 
 	  1.2217304763960306 },
-  { 1.3191464023923762, 0.69999999999999996, 0.50000000000000000, 
+  { 2.2051554347435589, 0.70000000000000018, 0.50000000000000000, 
 	  1.3962634015954636 },
-  { 1.4818433192178544, 0.69999999999999996, 0.50000000000000000, 
+  { 2.6868019968236996, 0.70000000000000018, 0.50000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler166 = 2.5000000000000020e-13;
 
-// Test data for k=0.69999999999999996, nu=0.59999999999999998.
-// max(|f - f_GSL|): 3.3306690738754696e-16
-// max(|f - f_GSL| / |f_GSL|): 4.0457157538295173e-16
+// Test data for k=0.70000000000000018, nu=0.60000000000000009.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 5.8597454441867134e-16
+// mean(f - f_Boost): 2.5535129566378598e-16
+// variance(f - f_Boost): 2.8561208198482198e-31
+// stddev(f - f_Boost): 5.3442687243889785e-16
 const testcase_ellint_3<double>
 data167[10] =
 {
-  { 0.0000000000000000, 0.69999999999999996, 0.59999999999999998, 
+  { 0.0000000000000000, 0.70000000000000018, 0.60000000000000009, 
 	  0.0000000000000000 },
-  { 0.17391719464391614, 0.69999999999999996, 0.59999999999999998, 
+  { 0.17604066659721918, 0.70000000000000018, 0.60000000000000009, 
 	  0.17453292519943295 },
-  { 0.34443927423869031, 0.69999999999999996, 0.59999999999999998, 
+  { 0.36137563278353424, 0.70000000000000018, 0.60000000000000009, 
 	  0.34906585039886590 },
-  { 0.50945473266486063, 0.69999999999999996, 0.59999999999999998, 
+  { 0.56655721272747606, 0.70000000000000018, 0.60000000000000009, 
 	  0.52359877559829882 },
-  { 0.66866056326513812, 0.69999999999999996, 0.59999999999999998, 
+  { 0.80468966552978305, 0.70000000000000018, 0.60000000000000009, 
 	  0.69813170079773179 },
-  { 0.82325830002337352, 0.69999999999999996, 0.59999999999999998, 
+  { 1.0924902943683852, 0.70000000000000018, 0.60000000000000009, 
 	  0.87266462599716477 },
-  { 0.97522808245669368, 0.69999999999999996, 0.59999999999999998, 
+  { 1.4499247992499800, 0.70000000000000018, 0.60000000000000009, 
 	  1.0471975511965976 },
-  { 1.1265300613705285, 0.69999999999999996, 0.59999999999999998, 
+  { 1.8953714382113818, 0.70000000000000018, 0.60000000000000009, 
 	  1.2217304763960306 },
-  { 1.2784066076152001, 0.69999999999999996, 0.59999999999999998, 
+  { 2.4323229949248670, 0.70000000000000018, 0.60000000000000009, 
 	  1.3962634015954636 },
-  { 1.4309994736080540, 0.69999999999999996, 0.59999999999999998, 
+  { 3.0314573496746746, 0.70000000000000018, 0.60000000000000009, 
 	  1.5707963267948966 },
 };
 const double toler167 = 2.5000000000000020e-13;
 
-// Test data for k=0.69999999999999996, nu=0.69999999999999996.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 5.4867405596732161e-16
+// Test data for k=0.70000000000000018, nu=0.70000000000000007.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 3.2316852368580916e-16
+// mean(f - f_Boost): 7.7715611723760953e-17
+// variance(f - f_Boost): 7.4564398834547797e-34
+// stddev(f - f_Boost): 2.7306482533374340e-17
 const testcase_ellint_3<double>
 data168[10] =
 {
-  { 0.0000000000000000, 0.69999999999999996, 0.69999999999999996, 
+  { 0.0000000000000000, 0.70000000000000018, 0.70000000000000007, 
 	  0.0000000000000000 },
-  { 0.17374434963995031, 0.69999999999999996, 0.69999999999999996, 
+  { 0.17622185963747933, 0.70000000000000018, 0.70000000000000007, 
 	  0.17453292519943295 },
-  { 0.34315091562900674, 0.69999999999999996, 0.69999999999999996, 
+  { 0.36292539360435261, 0.70000000000000018, 0.70000000000000007, 
 	  0.34906585039886590 },
-  { 0.50554262375653347, 0.69999999999999996, 0.69999999999999996, 
+  { 0.57240892970150015, 0.70000000000000018, 0.70000000000000007, 
 	  0.52359877559829882 },
-  { 0.66050025406305801, 0.69999999999999996, 0.69999999999999996, 
+  { 0.82093084713182629, 0.70000000000000018, 0.70000000000000007, 
 	  0.69813170079773179 },
-  { 0.80938620118847404, 0.69999999999999996, 0.69999999999999996, 
+  { 1.1312609022179871, 0.70000000000000018, 0.70000000000000007, 
 	  0.87266462599716477 },
-  { 0.95443223855852144, 0.69999999999999996, 0.69999999999999996, 
+  { 1.5345768067715795, 0.70000000000000018, 0.70000000000000007, 
 	  1.0471975511965976 },
-  { 1.0978573207128304, 0.69999999999999996, 0.69999999999999996, 
+  { 2.0668847445934424, 0.70000000000000018, 0.70000000000000007, 
 	  1.2217304763960306 },
-  { 1.2411754575007123, 0.69999999999999996, 0.69999999999999996, 
+  { 2.7483444537551245, 0.70000000000000018, 0.70000000000000007, 
 	  1.3962634015954636 },
-  { 1.3848459188329196, 0.69999999999999996, 0.69999999999999996, 
+  { 3.5408408771788569, 0.70000000000000018, 0.70000000000000007, 
 	  1.5707963267948966 },
 };
 const double toler168 = 2.5000000000000020e-13;
 
-// Test data for k=0.69999999999999996, nu=0.80000000000000004.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.1829502028913879e-16
+// Test data for k=0.70000000000000018, nu=0.80000000000000004.
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 4.1198716111867353e-16
+// mean(f - f_Boost): 2.2482016248659419e-16
+// variance(f - f_Boost): 5.4326441655972001e-32
+// stddev(f - f_Boost): 2.3308033305273100e-16
 const testcase_ellint_3<double>
 data169[10] =
 {
-  { 0.0000000000000000, 0.69999999999999996, 0.80000000000000004, 
+  { 0.0000000000000000, 0.70000000000000018, 0.80000000000000004, 
 	  0.0000000000000000 },
-  { 0.17357211837335740, 0.69999999999999996, 0.80000000000000004, 
+  { 0.17640372461994805, 0.70000000000000018, 0.80000000000000004, 
 	  0.17453292519943295 },
-  { 0.34187941416012108, 0.69999999999999996, 0.80000000000000004, 
+  { 0.36449916621651091, 0.70000000000000018, 0.80000000000000004, 
 	  0.34906585039886590 },
-  { 0.50173239465478259, 0.69999999999999996, 0.80000000000000004, 
+  { 0.57848021800372584, 0.70000000000000018, 0.80000000000000004, 
 	  0.52359877559829882 },
-  { 0.65266550725988315, 0.69999999999999996, 0.80000000000000004, 
+  { 0.83837480968392586, 0.70000000000000018, 0.80000000000000004, 
 	  0.69813170079773179 },
-  { 0.79624879865249298, 0.69999999999999996, 0.80000000000000004, 
+  { 1.1751669030061143, 0.70000000000000018, 0.80000000000000004, 
 	  0.87266462599716477 },
-  { 0.93497577043296920, 0.69999999999999996, 0.80000000000000004, 
+  { 1.6381851899173603, 0.70000000000000018, 0.80000000000000004, 
 	  1.0471975511965976 },
-  { 1.0713041566930750, 0.69999999999999996, 0.80000000000000004, 
+  { 2.3002065924302197, 0.70000000000000018, 0.80000000000000004, 
 	  1.2217304763960306 },
-  { 1.2069772023255654, 0.69999999999999996, 0.80000000000000004, 
+  { 3.2337600665337871, 0.70000000000000018, 0.80000000000000004, 
 	  1.3962634015954636 },
-  { 1.3427110650397531, 0.69999999999999996, 0.80000000000000004, 
+  { 4.4042405729076970, 0.70000000000000018, 0.80000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler169 = 2.5000000000000020e-13;
 
-// Test data for k=0.69999999999999996, nu=0.90000000000000002.
-// max(|f - f_GSL|): 3.3306690738754696e-16
-// max(|f - f_GSL| / |f_GSL|): 4.2494869624129105e-16
+// Test data for k=0.70000000000000018, nu=0.90000000000000002.
+// max(|f - f_Boost|): 3.5527136788005009e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 8.5869439826269878e-16
+// mean(f - f_Boost): 7.4384942649885490e-16
+// variance(f - f_Boost): 9.7403930714297352e-31
+// stddev(f - f_Boost): 9.8693429727767263e-16
 const testcase_ellint_3<double>
 data170[10] =
 {
-  { 0.0000000000000000, 0.69999999999999996, 0.90000000000000002, 
+  { 0.0000000000000000, 0.70000000000000018, 0.90000000000000002, 
 	  0.0000000000000000 },
-  { 0.17340049697003637, 0.69999999999999996, 0.90000000000000002, 
+  { 0.17658626600478800, 0.70000000000000018, 0.90000000000000002, 
 	  0.17453292519943295 },
-  { 0.34062438249741556, 0.69999999999999996, 0.90000000000000002, 
+  { 0.36609762156017206, 0.70000000000000018, 0.90000000000000002, 
 	  0.34906585039886590 },
-  { 0.49801946510076867, 0.69999999999999996, 0.90000000000000002, 
+  { 0.58478615187842409, 0.70000000000000018, 0.90000000000000002, 
 	  0.52359877559829882 },
-  { 0.64513432604750476, 0.69999999999999996, 0.90000000000000002, 
+  { 0.85718862878291846, 0.70000000000000018, 0.90000000000000002, 
 	  0.69813170079773179 },
-  { 0.78378145487573758, 0.69999999999999996, 0.90000000000000002, 
+  { 1.2255385617397643, 0.70000000000000018, 0.90000000000000002, 
 	  0.87266462599716477 },
-  { 0.91671799500854623, 0.69999999999999996, 0.90000000000000002, 
+  { 1.7696521899992941, 0.70000000000000018, 0.90000000000000002, 
 	  1.0471975511965976 },
-  { 1.0466193579463123, 0.69999999999999996, 0.90000000000000002, 
+  { 2.6476314987883507, 0.70000000000000018, 0.90000000000000002, 
 	  1.2217304763960306 },
-  { 1.1754218079199146, 0.69999999999999996, 0.90000000000000002, 
+  { 4.1373434902898083, 0.70000000000000018, 0.90000000000000002, 
 	  1.3962634015954636 },
-  { 1.3040500499695913, 0.69999999999999996, 0.90000000000000002, 
+  { 6.3796094177887763, 0.70000000000000018, 0.90000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler170 = 2.5000000000000020e-13;
 
 // Test data for k=0.80000000000000004, nu=0.0000000000000000.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.1175183168766718e-16
+// max(|f - f_Boost|): 1.5543122344752192e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 7.7898565163847540e-16
+// mean(f - f_Boost): 2.3869795029440865e-16
+// variance(f - f_Boost): 2.1368406725192426e-31
+// stddev(f - f_Boost): 4.6225974002926564e-16
 const testcase_ellint_3<double>
 data171[10] =
 {
@@ -4978,596 +5490,654 @@ data171[10] =
 	  0.0000000000000000 },
   { 0.17510154241338899, 0.80000000000000004, 0.0000000000000000, 
 	  0.17453292519943295 },
-  { 0.35365068839779390, 0.80000000000000004, 0.0000000000000000, 
+  { 0.35365068839779396, 0.80000000000000004, 0.0000000000000000, 
 	  0.34906585039886590 },
   { 0.53926804409084550, 0.80000000000000004, 0.0000000000000000, 
 	  0.52359877559829882 },
-  { 0.73587926028070361, 0.80000000000000004, 0.0000000000000000, 
+  { 0.73587926028070372, 0.80000000000000004, 0.0000000000000000, 
 	  0.69813170079773179 },
   { 0.94770942970071170, 0.80000000000000004, 0.0000000000000000, 
 	  0.87266462599716477 },
   { 1.1789022995388236, 0.80000000000000004, 0.0000000000000000, 
 	  1.0471975511965976 },
-  { 1.4323027881876009, 0.80000000000000004, 0.0000000000000000, 
+  { 1.4323027881876012, 0.80000000000000004, 0.0000000000000000, 
 	  1.2217304763960306 },
-  { 1.7069629739121674, 0.80000000000000004, 0.0000000000000000, 
+  { 1.7069629739121677, 0.80000000000000004, 0.0000000000000000, 
 	  1.3962634015954636 },
-  { 1.9953027776647296, 0.80000000000000004, 0.0000000000000000, 
+  { 1.9953027776647294, 0.80000000000000004, 0.0000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler171 = 2.5000000000000020e-13;
 
 // Test data for k=0.80000000000000004, nu=0.10000000000000001.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.1537164503193145e-16
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 8.3898786942190374e-16
+// mean(f - f_Boost): 2.3869795029440865e-16
+// variance(f - f_Boost): 2.9190059990693968e-31
+// stddev(f - f_Boost): 5.4027826155319237e-16
 const testcase_ellint_3<double>
 data172[10] =
 {
   { 0.0000000000000000, 0.80000000000000004, 0.10000000000000001, 
 	  0.0000000000000000 },
-  { 0.17492468824017163, 0.80000000000000004, 0.10000000000000001, 
+  { 0.17527903952342144, 0.80000000000000004, 0.10000000000000001, 
 	  0.17453292519943295 },
-  { 0.35224443521476911, 0.80000000000000004, 0.10000000000000001, 
+  { 0.35507705313548549, 0.80000000000000004, 0.10000000000000001, 
 	  0.34906585039886590 },
-  { 0.53456851853226950, 0.80000000000000004, 0.10000000000000001, 
+  { 0.54411455987643553, 0.80000000000000004, 0.10000000000000001, 
 	  0.52359877559829882 },
-  { 0.72488875602364922, 0.80000000000000004, 0.10000000000000001, 
+  { 0.74745625666804383, 0.80000000000000004, 0.10000000000000001, 
 	  0.69813170079773179 },
-  { 0.92661354274638952, 0.80000000000000004, 0.10000000000000001, 
+  { 0.97046953684238557, 0.80000000000000004, 0.10000000000000001, 
 	  0.87266462599716477 },
-  { 1.1432651144499075, 0.80000000000000004, 0.10000000000000001, 
+  { 1.2183080025184605, 0.80000000000000004, 0.10000000000000001, 
 	  1.0471975511965976 },
-  { 1.3774479927211429, 0.80000000000000004, 0.10000000000000001, 
+  { 1.4943711151994405, 0.80000000000000004, 0.10000000000000001, 
 	  1.2217304763960306 },
-  { 1.6287092337196041, 0.80000000000000004, 0.10000000000000001, 
+  { 1.7972401309544201, 0.80000000000000004, 0.10000000000000001, 
 	  1.3962634015954636 },
-  { 1.8910755418379521, 0.80000000000000004, 0.10000000000000001, 
+  { 2.1172616484005085, 0.80000000000000004, 0.10000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler172 = 2.5000000000000020e-13;
 
 // Test data for k=0.80000000000000004, nu=0.20000000000000001.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.1894552974436829e-16
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 7.8513740186068518e-16
+// mean(f - f_Boost): 2.8310687127941490e-16
+// variance(f - f_Boost): 2.7528339102381189e-31
+// stddev(f - f_Boost): 5.2467455724840699e-16
 const testcase_ellint_3<double>
 data173[10] =
 {
   { 0.0000000000000000, 0.80000000000000004, 0.20000000000000001, 
 	  0.0000000000000000 },
-  { 0.17474847286224940, 0.80000000000000004, 0.20000000000000001, 
+  { 0.17545718375086419, 0.80000000000000004, 0.20000000000000001, 
 	  0.17453292519943295 },
-  { 0.35085779529084682, 0.80000000000000004, 0.20000000000000001, 
+  { 0.35652404627248163, 0.80000000000000004, 0.20000000000000001, 
 	  0.34906585039886590 },
-  { 0.53000829263059146, 0.80000000000000004, 0.20000000000000001, 
+  { 0.54911638512920913, 0.80000000000000004, 0.20000000000000001, 
 	  0.52359877559829882 },
-  { 0.71443466027453384, 0.80000000000000004, 0.20000000000000001, 
+  { 0.75967684282131176, 0.80000000000000004, 0.20000000000000001, 
 	  0.69813170079773179 },
-  { 0.90698196872715420, 0.80000000000000004, 0.20000000000000001, 
+  { 0.99513526893543769, 0.80000000000000004, 0.20000000000000001, 
 	  0.87266462599716477 },
-  { 1.1108198200558579, 0.80000000000000004, 0.20000000000000001, 
+  { 1.2622192109995993, 0.80000000000000004, 0.20000000000000001, 
 	  1.0471975511965976 },
-  { 1.3284988909963957, 0.80000000000000004, 0.20000000000000001, 
+  { 1.5654106676347741, 0.80000000000000004, 0.20000000000000001, 
 	  1.2217304763960306 },
-  { 1.5600369318140328, 0.80000000000000004, 0.20000000000000001, 
+  { 1.9029531718534984, 0.80000000000000004, 0.20000000000000001, 
 	  1.3962634015954636 },
-  { 1.8007226661734588, 0.80000000000000004, 0.20000000000000001, 
+  { 2.2624789434186798, 0.80000000000000004, 0.20000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler173 = 2.5000000000000020e-13;
 
-// Test data for k=0.80000000000000004, nu=0.29999999999999999.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.2247517409029886e-16
+// Test data for k=0.80000000000000004, nu=0.30000000000000004.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 7.2825261583337354e-16
+// mean(f - f_Boost): 2.6367796834847468e-16
+// variance(f - f_Boost): 2.8249350208968825e-31
+// stddev(f - f_Boost): 5.3150117788175054e-16
 const testcase_ellint_3<double>
 data174[10] =
 {
-  { 0.0000000000000000, 0.80000000000000004, 0.29999999999999999, 
+  { 0.0000000000000000, 0.80000000000000004, 0.30000000000000004, 
 	  0.0000000000000000 },
-  { 0.17457289217669889, 0.80000000000000004, 0.29999999999999999, 
+  { 0.17563597931587369, 0.80000000000000004, 0.30000000000000004, 
 	  0.17453292519943295 },
-  { 0.34949028801501258, 0.80000000000000004, 0.29999999999999999, 
+  { 0.35799220412005128, 0.80000000000000004, 0.30000000000000004, 
 	  0.34906585039886590 },
-  { 0.52558024362769307, 0.80000000000000004, 0.29999999999999999, 
+  { 0.55428253691111318, 0.80000000000000004, 0.30000000000000004, 
 	  0.52359877559829882 },
-  { 0.70447281740094891, 0.80000000000000004, 0.29999999999999999, 
+  { 0.77260647376977365, 0.80000000000000004, 0.30000000000000004, 
 	  0.69813170079773179 },
-  { 0.88864745641528986, 0.80000000000000004, 0.29999999999999999, 
+  { 1.0220015271210958, 0.80000000000000004, 0.30000000000000004, 
 	  0.87266462599716477 },
-  { 1.0811075819341462, 0.80000000000000004, 0.29999999999999999, 
+  { 1.3115965312302671, 0.80000000000000004, 0.30000000000000004, 
 	  1.0471975511965976 },
-  { 1.2844589654082377, 0.80000000000000004, 0.29999999999999999, 
+  { 1.6478518468813512, 0.80000000000000004, 0.30000000000000004, 
 	  1.2217304763960306 },
-  { 1.4991461361277847, 0.80000000000000004, 0.29999999999999999, 
+  { 2.0290458414203481, 0.80000000000000004, 0.30000000000000004, 
 	  1.3962634015954636 },
-  { 1.7214611048717301, 0.80000000000000004, 0.29999999999999999, 
+  { 2.4392042002725693, 0.80000000000000004, 0.30000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler174 = 2.5000000000000020e-13;
 
 // Test data for k=0.80000000000000004, nu=0.40000000000000002.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.2596216594752862e-16
+// max(|f - f_Boost|): 2.2204460492503131e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 8.3462748389836647e-16
+// mean(f - f_Boost): 3.3861802251067273e-16
+// variance(f - f_Boost): 4.3719465706454422e-31
+// stddev(f - f_Boost): 6.6120696991527871e-16
 const testcase_ellint_3<double>
 data175[10] =
 {
   { 0.0000000000000000, 0.80000000000000004, 0.40000000000000002, 
 	  0.0000000000000000 },
-  { 0.17439794211872175, 0.80000000000000004, 0.40000000000000002, 
+  { 0.17581543047866136, 0.80000000000000004, 0.40000000000000002, 
 	  0.17453292519943295 },
-  { 0.34814144964568972, 0.80000000000000004, 0.40000000000000002, 
+  { 0.35948208343061633, 0.80000000000000004, 0.40000000000000002, 
 	  0.34906585039886590 },
-  { 0.52127776285273064, 0.80000000000000004, 0.40000000000000002, 
+  { 0.55962280893702021, 0.80000000000000004, 0.40000000000000002, 
 	  0.52359877559829882 },
-  { 0.69496411438966588, 0.80000000000000004, 0.40000000000000002, 
+  { 0.78632063889234116, 0.80000000000000004, 0.40000000000000002, 
 	  0.69813170079773179 },
-  { 0.87146878427509589, 0.80000000000000004, 0.40000000000000002, 
+  { 1.0514333069550323, 0.80000000000000004, 0.40000000000000002, 
 	  0.87266462599716477 },
-  { 1.0537579024937762, 0.80000000000000004, 0.40000000000000002, 
+  { 1.3677213138838757, 0.80000000000000004, 0.40000000000000002, 
 	  1.0471975511965976 },
-  { 1.2445534387922637, 0.80000000000000004, 0.40000000000000002, 
+  { 1.7451736773665165, 0.80000000000000004, 0.40000000000000002, 
 	  1.2217304763960306 },
-  { 1.4446769766361993, 0.80000000000000004, 0.40000000000000002, 
+  { 2.1830100424586831, 0.80000000000000004, 0.40000000000000002, 
 	  1.3962634015954636 },
-  { 1.6512267838651289, 0.80000000000000004, 0.40000000000000002, 
+  { 2.6604037035529724, 0.80000000000000004, 0.40000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler175 = 2.5000000000000020e-13;
 
 // Test data for k=0.80000000000000004, nu=0.50000000000000000.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.2940800093915668e-16
+// max(|f - f_Boost|): 2.6645352591003757e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 9.0388243828581744e-16
+// mean(f - f_Boost): 3.8580250105724191e-16
+// variance(f - f_Boost): 6.4106456575047741e-31
+// stddev(f - f_Boost): 8.0066507713929764e-16
 const testcase_ellint_3<double>
 data176[10] =
 {
   { 0.0000000000000000, 0.80000000000000004, 0.50000000000000000, 
 	  0.0000000000000000 },
-  { 0.17422361866118044, 0.80000000000000004, 0.50000000000000000, 
+  { 0.17599554153999472, 0.80000000000000004, 0.50000000000000000, 
 	  0.17453292519943295 },
-  { 0.34681083254170475, 0.80000000000000004, 0.50000000000000000, 
+  { 0.36099426243351540, 0.80000000000000004, 0.50000000000000000, 
 	  0.34906585039886590 },
-  { 0.51709470815494440, 0.80000000000000004, 0.50000000000000000, 
+  { 0.56514786174780673, 0.80000000000000004, 0.50000000000000000, 
 	  0.52359877559829882 },
-  { 0.68587375344080237, 0.80000000000000004, 0.50000000000000000, 
+  { 0.80090697622371010, 0.80000000000000004, 0.50000000000000000, 
 	  0.69813170079773179 },
-  { 0.85532571852810624, 0.80000000000000004, 0.50000000000000000, 
+  { 1.0838891627679339, 0.80000000000000004, 0.50000000000000000, 
 	  0.87266462599716477 },
-  { 1.0284677391874903, 0.80000000000000004, 0.50000000000000000, 
+  { 1.4323506654466280, 0.80000000000000004, 0.50000000000000000, 
 	  1.0471975511965976 },
-  { 1.2081693942686225, 0.80000000000000004, 0.50000000000000000, 
+  { 1.8625761085390575, 0.80000000000000004, 0.50000000000000000, 
 	  1.2217304763960306 },
-  { 1.3955803006426311, 0.80000000000000004, 0.50000000000000000, 
+  { 2.3768757305654766, 0.80000000000000004, 0.50000000000000000, 
 	  1.3962634015954636 },
-  { 1.5884528947755532, 0.80000000000000004, 0.50000000000000000, 
+  { 2.9478781158239746, 0.80000000000000004, 0.50000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler176 = 2.5000000000000020e-13;
 
-// Test data for k=0.80000000000000004, nu=0.59999999999999998.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.3281408974056389e-16
+// Test data for k=0.80000000000000004, nu=0.60000000000000009.
+// max(|f - f_Boost|): 3.5527136788005009e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 1.0631099169042069e-15
+// mean(f - f_Boost): 4.8294701571194306e-16
+// variance(f - f_Boost): 1.1633910328160319e-30
+// stddev(f - f_Boost): 1.0786060600682865e-15
 const testcase_ellint_3<double>
 data177[10] =
 {
-  { 0.0000000000000000, 0.80000000000000004, 0.59999999999999998, 
+  { 0.0000000000000000, 0.80000000000000004, 0.60000000000000009, 
 	  0.0000000000000000 },
-  { 0.17404991781414089, 0.80000000000000004, 0.59999999999999998, 
+  { 0.17617631684170665, 0.80000000000000004, 0.60000000000000009, 
 	  0.17453292519943295 },
-  { 0.34549800443625167, 0.80000000000000004, 0.59999999999999998, 
+  { 0.36252934193666231, 0.80000000000000004, 0.60000000000000009, 
 	  0.34906585039886590 },
-  { 0.51302536167001545, 0.80000000000000004, 0.59999999999999998, 
+  { 0.57086932622945163, 0.80000000000000004, 0.60000000000000009, 
 	  0.52359877559829882 },
-  { 0.67717065003912236, 0.80000000000000004, 0.59999999999999998, 
+  { 0.81646796740150973, 0.80000000000000004, 0.60000000000000009, 
 	  0.69813170079773179 },
-  { 0.84011512421134416, 0.80000000000000004, 0.59999999999999998, 
+  { 1.1199552158519064, 0.80000000000000004, 0.60000000000000009, 
 	  0.87266462599716477 },
-  { 1.0049863847088740, 0.80000000000000004, 0.59999999999999998, 
+  { 1.5079766673336394, 0.80000000000000004, 0.60000000000000009, 
 	  1.0471975511965976 },
-  { 1.1748145941898920, 0.80000000000000004, 0.59999999999999998, 
+  { 2.0082747447038165, 0.80000000000000004, 0.60000000000000009, 
 	  1.2217304763960306 },
-  { 1.3510319699755071, 0.80000000000000004, 0.59999999999999998, 
+  { 2.6315146066775523, 0.80000000000000004, 0.60000000000000009, 
 	  1.3962634015954636 },
-  { 1.5319262547427865, 0.80000000000000004, 0.59999999999999998, 
+  { 3.3418121892288051, 0.80000000000000004, 0.60000000000000009, 
 	  1.5707963267948966 },
 };
 const double toler177 = 2.5000000000000020e-13;
 
-// Test data for k=0.80000000000000004, nu=0.69999999999999996.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 4.3618176466061808e-16
+// Test data for k=0.80000000000000004, nu=0.70000000000000007.
+// max(|f - f_Boost|): 2.2204460492503131e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 5.6544679145741375e-16
+// mean(f - f_Boost): 3.2751579226442120e-16
+// variance(f - f_Boost): 4.4236851331020672e-31
+// stddev(f - f_Boost): 6.6510789599147505e-16
 const testcase_ellint_3<double>
 data178[10] =
 {
-  { 0.0000000000000000, 0.80000000000000004, 0.69999999999999996, 
+  { 0.0000000000000000, 0.80000000000000004, 0.70000000000000007, 
 	  0.0000000000000000 },
-  { 0.17387683562442199, 0.80000000000000004, 0.69999999999999996, 
+  { 0.17635776076721221, 0.80000000000000004, 0.70000000000000007, 
 	  0.17453292519943295 },
-  { 0.34420254775101611, 0.80000000000000004, 0.69999999999999996, 
+  { 0.36408794649916976, 0.80000000000000004, 0.70000000000000007, 
 	  0.34906585039886590 },
-  { 0.50906439222143673, 0.80000000000000004, 0.69999999999999996, 
+  { 0.57679992290624138, 0.80000000000000004, 0.70000000000000007, 
 	  0.52359877559829882 },
-  { 0.66882693152688422, 0.80000000000000004, 0.69999999999999996, 
+  { 0.83312441418142813, 0.80000000000000004, 0.70000000000000007, 
 	  0.69813170079773179 },
-  { 0.82574792844091316, 0.80000000000000004, 0.69999999999999996, 
+  { 1.1603958891464856, 0.80000000000000004, 0.70000000000000007, 
 	  0.87266462599716477 },
-  { 0.98310431309490931, 0.80000000000000004, 0.69999999999999996, 
+  { 1.5982855143796213, 0.80000000000000004, 0.70000000000000007, 
 	  1.0471975511965976 },
-  { 1.1440884535113258, 0.80000000000000004, 0.69999999999999996, 
+  { 2.1962484408371821, 0.80000000000000004, 0.70000000000000007, 
 	  1.2217304763960306 },
-  { 1.3103743938952537, 0.80000000000000004, 0.69999999999999996, 
+  { 2.9873281786111869, 0.80000000000000004, 0.70000000000000007, 
 	  1.3962634015954636 },
-  { 1.4806912324625332, 0.80000000000000004, 0.69999999999999996, 
+  { 3.9268876980046397, 0.80000000000000004, 0.70000000000000007, 
 	  1.5707963267948966 },
 };
 const double toler178 = 2.5000000000000020e-13;
 
 // Test data for k=0.80000000000000004, nu=0.80000000000000004.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.3951228558314112e-16
+// max(|f - f_Boost|): 4.4408920985006262e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 9.0176949165011079e-16
+// mean(f - f_Boost): 7.0499162063697436e-16
+// variance(f - f_Boost): 1.7230805408026989e-30
+// stddev(f - f_Boost): 1.3126616246400665e-15
 const testcase_ellint_3<double>
 data179[10] =
 {
   { 0.0000000000000000, 0.80000000000000004, 0.80000000000000004, 
 	  0.0000000000000000 },
-  { 0.17370436817515203, 0.80000000000000004, 0.80000000000000004, 
+  { 0.17653987774203392, 0.80000000000000004, 0.80000000000000004, 
 	  0.17453292519943295 },
-  { 0.34292405894783395, 0.80000000000000004, 0.80000000000000004, 
+  { 0.36567072568046877, 0.80000000000000004, 0.80000000000000004, 
 	  0.34906585039886590 },
-  { 0.50520682176250076, 0.80000000000000004, 0.80000000000000004, 
+  { 0.58295359996558616, 0.80000000000000004, 0.80000000000000004, 
 	  0.52359877559829882 },
-  { 0.66081751679736178, 0.80000000000000004, 0.80000000000000004, 
+  { 0.85101998309176108, 0.80000000000000004, 0.80000000000000004, 
 	  0.69813170079773179 },
-  { 0.81214672249355102, 0.80000000000000004, 0.80000000000000004, 
+  { 1.2062322059736537, 0.80000000000000004, 0.80000000000000004, 
 	  0.87266462599716477 },
-  { 0.96264481387685552, 0.80000000000000004, 0.80000000000000004, 
+  { 1.7090321420917429, 0.80000000000000004, 0.80000000000000004, 
 	  1.0471975511965976 },
-  { 1.1156611352656258, 0.80000000000000004, 0.80000000000000004, 
+  { 2.4529058049405066, 0.80000000000000004, 0.80000000000000004, 
 	  1.2217304763960306 },
-  { 1.2730756225143889, 0.80000000000000004, 0.80000000000000004, 
+  { 3.5368893360106948, 0.80000000000000004, 0.80000000000000004, 
 	  1.3962634015954636 },
-  { 1.4339837018309471, 0.80000000000000004, 0.80000000000000004, 
+  { 4.9246422058196062, 0.80000000000000004, 0.80000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler179 = 2.5000000000000020e-13;
 
 // Test data for k=0.80000000000000004, nu=0.90000000000000002.
-// max(|f - f_GSL|): 3.3306690738754696e-16
-// max(|f - f_GSL| / |f_GSL|): 4.4280684534289690e-16
+// max(|f - f_Boost|): 4.4408920985006262e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 7.7782721357365268e-16
+// mean(f - f_Boost): 8.9928064994637676e-16
+// variance(f - f_Boost): 1.5485199571025344e-30
+// stddev(f - f_Boost): 1.2443954183066307e-15
 const testcase_ellint_3<double>
 data180[10] =
 {
   { 0.0000000000000000, 0.80000000000000004, 0.90000000000000002, 
 	  0.0000000000000000 },
-  { 0.17353251158533151, 0.80000000000000004, 0.90000000000000002, 
+  { 0.17672267223433513, 0.80000000000000004, 0.90000000000000002, 
 	  0.17453292519943295 },
-  { 0.34166214791545768, 0.80000000000000004, 0.90000000000000002, 
+  { 0.36727835537196063, 0.80000000000000004, 0.90000000000000002, 
 	  0.34906585039886590 },
-  { 0.50144799535130569, 0.80000000000000004, 0.90000000000000002, 
+  { 0.58934569363716649, 0.80000000000000004, 0.90000000000000002, 
 	  0.52359877559829882 },
-  { 0.65311976193814425, 0.80000000000000004, 0.90000000000000002, 
+  { 0.87032723471138851, 0.80000000000000004, 0.90000000000000002, 
 	  0.69813170079773179 },
-  { 0.79924384892320866, 0.80000000000000004, 0.90000000000000002, 
+  { 1.2588676111323349, 0.80000000000000004, 0.90000000000000002, 
 	  0.87266462599716477 },
-  { 0.94345762353365603, 0.80000000000000004, 0.90000000000000002, 
+  { 1.8498731900660019, 0.80000000000000004, 0.90000000000000002, 
 	  1.0471975511965976 },
-  { 1.0892582069219161, 0.80000000000000004, 0.90000000000000002, 
+  { 2.8368381299300420, 0.80000000000000004, 0.90000000000000002, 
 	  1.2217304763960306 },
-  { 1.2387000876610268, 0.80000000000000004, 0.90000000000000002, 
+  { 4.5674844191654058, 0.80000000000000004, 0.90000000000000002, 
 	  1.3962634015954636 },
-  { 1.3911845406776222, 0.80000000000000004, 0.90000000000000002, 
+  { 7.2263259298637115, 0.80000000000000004, 0.90000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler180 = 2.5000000000000020e-13;
 
-// Test data for k=0.89999999999999991, nu=0.0000000000000000.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 3.8945813740035884e-16
+// Test data for k=0.90000000000000013, nu=0.0000000000000000.
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 4.3381508715713360e-16
+// mean(f - f_Boost): 5.8286708792820721e-17
+// variance(f - f_Boost): 4.1942474344433133e-34
+// stddev(f - f_Boost): 2.0479861900030756e-17
 const testcase_ellint_3<double>
 data181[10] =
 {
-  { 0.0000000000000000, 0.89999999999999991, 0.0000000000000000, 
+  { 0.0000000000000000, 0.90000000000000013, 0.0000000000000000, 
 	  0.0000000000000000 },
-  { 0.17525427376115024, 0.89999999999999991, 0.0000000000000000, 
+  { 0.17525427376115027, 0.90000000000000013, 0.0000000000000000, 
 	  0.17453292519943295 },
-  { 0.35492464591297446, 0.89999999999999991, 0.0000000000000000, 
+  { 0.35492464591297446, 0.90000000000000013, 0.0000000000000000, 
 	  0.34906585039886590 },
-  { 0.54388221416157112, 0.89999999999999991, 0.0000000000000000, 
+  { 0.54388221416157123, 0.90000000000000013, 0.0000000000000000, 
 	  0.52359877559829882 },
-  { 0.74797400423532490, 0.89999999999999991, 0.0000000000000000, 
+  { 0.74797400423532512, 0.90000000000000013, 0.0000000000000000, 
 	  0.69813170079773179 },
-  { 0.97463898451966458, 0.89999999999999991, 0.0000000000000000, 
+  { 0.97463898451966446, 0.90000000000000013, 0.0000000000000000, 
 	  0.87266462599716477 },
-  { 1.2334463254523440, 0.89999999999999991, 0.0000000000000000, 
+  { 1.2334463254523440, 0.90000000000000013, 0.0000000000000000, 
 	  1.0471975511965976 },
-  { 1.5355247765594910, 0.89999999999999991, 0.0000000000000000, 
+  { 1.5355247765594915, 0.90000000000000013, 0.0000000000000000, 
 	  1.2217304763960306 },
-  { 1.8882928567775117, 0.89999999999999991, 0.0000000000000000, 
+  { 1.8882928567775128, 0.90000000000000013, 0.0000000000000000, 
 	  1.3962634015954636 },
-  { 2.2805491384227703, 0.89999999999999991, 0.0000000000000000, 
+  { 2.2805491384227707, 0.90000000000000013, 0.0000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler181 = 2.5000000000000020e-13;
 
-// Test data for k=0.89999999999999991, nu=0.10000000000000001.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 4.1237990617685137e-16
+// Test data for k=0.90000000000000013, nu=0.10000000000000001.
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 4.1500594295134815e-16
+// mean(f - f_Boost): 9.1593399531575410e-17
+// variance(f - f_Boost): 1.0357223256482469e-33
+// stddev(f - f_Boost): 3.2182640128619758e-17
 const testcase_ellint_3<double>
 data182[10] =
 {
-  { 0.0000000000000000, 0.89999999999999991, 0.10000000000000001, 
+  { 0.0000000000000000, 0.90000000000000013, 0.10000000000000001, 
 	  0.0000000000000000 },
-  { 0.17507714233254656, 0.89999999999999991, 0.10000000000000001, 
+  { 0.17543204932716244, 0.90000000000000013, 0.10000000000000001, 
 	  0.17453292519943295 },
-  { 0.35350932904326521, 0.89999999999999991, 0.10000000000000001, 
+  { 0.35636022898551184, 0.90000000000000013, 0.10000000000000001, 
 	  0.34906585039886590 },
-  { 0.53911129989870976, 0.89999999999999991, 0.10000000000000001, 
+  { 0.54880278898382595, 0.90000000000000013, 0.10000000000000001, 
 	  0.52359877559829882 },
-  { 0.73666644254508395, 0.89999999999999991, 0.10000000000000001, 
+  { 0.75988834774529268, 0.90000000000000013, 0.10000000000000001, 
 	  0.69813170079773179 },
-  { 0.95250736612100195, 0.89999999999999991, 0.10000000000000001, 
+  { 0.99853303003568117, 0.90000000000000013, 0.10000000000000001, 
 	  0.87266462599716477 },
-  { 1.1950199550905594, 0.89999999999999991, 0.10000000000000001, 
+  { 1.2759958823999022, 0.90000000000000013, 0.10000000000000001, 
 	  1.0471975511965976 },
-  { 1.4741687286340848, 0.89999999999999991, 0.10000000000000001, 
+  { 1.6051187364639401, 0.90000000000000013, 0.10000000000000001, 
 	  1.2217304763960306 },
-  { 1.7968678183506053, 0.89999999999999991, 0.10000000000000001, 
+  { 1.9941406879519474, 0.90000000000000013, 0.10000000000000001, 
 	  1.3962634015954636 },
-  { 2.1537868513875287, 0.89999999999999991, 0.10000000000000001, 
+  { 2.4295011187834890, 0.90000000000000013, 0.10000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler182 = 2.5000000000000020e-13;
 
-// Test data for k=0.89999999999999991, nu=0.20000000000000001.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 4.3446165733924066e-16
+// Test data for k=0.90000000000000013, nu=0.20000000000000001.
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.9533518431433547e-16
+// mean(f - f_Boost): 1.0269562977782698e-16
+// variance(f - f_Boost): 1.4388836606733082e-32
+// stddev(f - f_Boost): 1.1995347684303728e-16
 const testcase_ellint_3<double>
 data183[10] =
 {
-  { 0.0000000000000000, 0.89999999999999991, 0.20000000000000001, 
+  { 0.0000000000000000, 0.90000000000000013, 0.20000000000000001, 
 	  0.0000000000000000 },
-  { 0.17490065089140927, 0.89999999999999991, 0.20000000000000001, 
+  { 0.17561047321968409, 0.90000000000000013, 0.20000000000000001, 
 	  0.17453292519943295 },
-  { 0.35211377590661436, 0.89999999999999991, 0.20000000000000001, 
+  { 0.35781659944356109, 0.90000000000000013, 0.20000000000000001, 
 	  0.34906585039886590 },
-  { 0.53448220334204100, 0.89999999999999991, 0.20000000000000001, 
+  { 0.55388150905215283, 0.90000000000000013, 0.20000000000000001, 
 	  0.52359877559829882 },
-  { 0.72591368943179579, 0.89999999999999991, 0.20000000000000001, 
+  { 0.77246874123251441, 0.90000000000000013, 0.20000000000000001, 
 	  0.69813170079773179 },
-  { 0.93192539780038763, 0.89999999999999991, 0.20000000000000001, 
+  { 1.0244466254771925, 0.90000000000000013, 0.20000000000000001, 
 	  0.87266462599716477 },
-  { 1.1600809679692683, 0.89999999999999991, 0.20000000000000001, 
+  { 1.3234824077640801, 0.90000000000000013, 0.20000000000000001, 
 	  1.0471975511965976 },
-  { 1.4195407225882508, 0.89999999999999991, 0.20000000000000001, 
+  { 1.6849848968804240, 0.90000000000000013, 0.20000000000000001, 
 	  1.2217304763960306 },
-  { 1.7168966476424521, 0.89999999999999991, 0.20000000000000001, 
+  { 2.1185749045502278, 0.90000000000000013, 0.20000000000000001, 
 	  1.3962634015954636 },
-  { 2.0443194576468895, 0.89999999999999991, 0.20000000000000001, 
+  { 2.6076835743348417, 0.90000000000000013, 0.20000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler183 = 2.5000000000000020e-13;
 
-// Test data for k=0.89999999999999991, nu=0.29999999999999999.
-// max(|f - f_GSL|): 1.1102230246251565e-15
-// max(|f - f_GSL| / |f_GSL|): 5.6974600067013622e-16
+// Test data for k=0.90000000000000013, nu=0.30000000000000004.
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.9712691025502371e-16
+// mean(f - f_Boost): 6.9388939039072284e-17
+// variance(f - f_Boost): 5.9442282234173945e-34
+// stddev(f - f_Boost): 2.4380787976227090e-17
 const testcase_ellint_3<double>
 data184[10] =
 {
-  { 0.0000000000000000, 0.89999999999999991, 0.29999999999999999, 
+  { 0.0000000000000000, 0.90000000000000013, 0.30000000000000004, 
 	  0.0000000000000000 },
-  { 0.17472479532647531, 0.89999999999999991, 0.29999999999999999, 
+  { 0.17578954966746221, 0.90000000000000013, 0.30000000000000004, 
 	  0.17453292519943295 },
-  { 0.35073750187374114, 0.89999999999999991, 0.29999999999999999, 
+  { 0.35929429810867447, 0.90000000000000013, 0.30000000000000004, 
 	  0.34906585039886590 },
-  { 0.52998766129466957, 0.89999999999999991, 0.29999999999999999, 
+  { 0.55912757154240822, 0.90000000000000013, 0.30000000000000004, 
 	  0.52359877559829882 },
-  { 0.71566993548699553, 0.89999999999999991, 0.29999999999999999, 
+  { 0.78578314722025389, 0.90000000000000013, 0.30000000000000004, 
 	  0.69813170079773179 },
-  { 0.91271517762560195, 0.89999999999999991, 0.29999999999999999, 
+  { 1.0526941001131365, 0.90000000000000013, 0.30000000000000004, 
 	  0.87266462599716477 },
-  { 1.1281241199843370, 0.89999999999999991, 0.29999999999999999, 
+  { 1.3769682234538601, 0.90000000000000013, 0.30000000000000004, 
 	  1.0471975511965976 },
-  { 1.3704929576917448, 0.89999999999999991, 0.29999999999999999, 
+  { 1.7779437432911240, 0.90000000000000013, 0.30000000000000004, 
 	  1.2217304763960306 },
-  { 1.6461981511487711, 0.89999999999999991, 0.29999999999999999, 
+  { 2.2676509341813635, 0.90000000000000013, 0.30000000000000004, 
 	  1.3962634015954636 },
-  { 1.9486280260314426, 0.89999999999999991, 0.29999999999999999, 
+  { 2.8256506968858517, 0.90000000000000013, 0.30000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler184 = 2.5000000000000020e-13;
 
-// Test data for k=0.89999999999999991, nu=0.40000000000000002.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 4.7646208744449464e-16
+// Test data for k=0.90000000000000013, nu=0.40000000000000002.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 4.7042235432234642e-16
+// mean(f - f_Boost): 1.8041124150158794e-16
+// variance(f - f_Boost): 8.5834655546147173e-33
+// stddev(f - f_Boost): 9.2646994309662939e-17
 const testcase_ellint_3<double>
 data185[10] =
 {
-  { 0.0000000000000000, 0.89999999999999991, 0.40000000000000002, 
+  { 0.0000000000000000, 0.90000000000000013, 0.40000000000000002, 
 	  0.0000000000000000 },
-  { 0.17454957156468837, 0.89999999999999991, 0.40000000000000002, 
+  { 0.17596928293938452, 0.90000000000000013, 0.40000000000000002, 
 	  0.17453292519943295 },
-  { 0.34938003933330430, 0.89999999999999991, 0.40000000000000002, 
+  { 0.36079388642472821, 0.90000000000000013, 0.40000000000000002, 
 	  0.34906585039886590 },
-  { 0.52562093533067433, 0.89999999999999991, 0.40000000000000002, 
+  { 0.56455096667115612, 0.90000000000000013, 0.40000000000000002, 
 	  0.52359877559829882 },
-  { 0.70589461324915670, 0.89999999999999991, 0.40000000000000002, 
+  { 0.79990996997869435, 0.90000000000000013, 0.40000000000000002, 
 	  0.69813170079773179 },
-  { 0.89472658511942849, 0.89999999999999991, 0.40000000000000002, 
+  { 1.0836647913872215, 0.90000000000000013, 0.40000000000000002, 
 	  0.87266462599716477 },
-  { 1.0987419542323440, 0.89999999999999991, 0.40000000000000002, 
+  { 1.4378726836091849, 0.90000000000000013, 0.40000000000000002, 
 	  1.0471975511965976 },
-  { 1.3261349565496301, 0.89999999999999991, 0.40000000000000002, 
+  { 1.8880446720682853, 0.90000000000000013, 0.40000000000000002, 
 	  1.2217304763960306 },
-  { 1.5831293909853763, 0.89999999999999991, 0.40000000000000002, 
+  { 2.4505848932025232, 0.90000000000000013, 0.40000000000000002, 
 	  1.3962634015954636 },
-  { 1.8641114227238351, 0.89999999999999991, 0.40000000000000002, 
+  { 3.1000689868578624, 0.90000000000000013, 0.40000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler185 = 2.5000000000000020e-13;
 
-// Test data for k=0.89999999999999991, nu=0.50000000000000000.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 4.9652155758573562e-16
+// Test data for k=0.90000000000000013, nu=0.50000000000000000.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 4.3939646155354115e-16
+// mean(f - f_Boost): 1.5820678100908481e-16
+// variance(f - f_Boost): 1.0089970755557622e-32
+// stddev(f - f_Boost): 1.0044884646205561e-16
 const testcase_ellint_3<double>
 data186[10] =
 {
-  { 0.0000000000000000, 0.89999999999999991, 0.50000000000000000, 
+  { 0.0000000000000000, 0.90000000000000013, 0.50000000000000000, 
 	  0.0000000000000000 },
-  { 0.17437497557073334, 0.89999999999999991, 0.50000000000000000, 
+  { 0.17614967734498183, 0.90000000000000013, 0.50000000000000000, 
 	  0.17453292519943295 },
-  { 0.34804093691586013, 0.89999999999999991, 0.50000000000000000, 
+  { 0.36231594750319435, 0.90000000000000013, 0.50000000000000000, 
 	  0.34906585039886590 },
-  { 0.52137576320372891, 0.89999999999999991, 0.50000000000000000, 
+  { 0.57016256984349567, 0.90000000000000013, 0.50000000000000000, 
 	  0.52359877559829882 },
-  { 0.69655163996912262, 0.89999999999999991, 0.50000000000000000, 
+  { 0.81494025918293422, 0.90000000000000013, 0.50000000000000000, 
 	  0.69813170079773179 },
-  { 0.87783188683054236, 0.89999999999999991, 0.50000000000000000, 
+  { 1.1178482279283477, 0.90000000000000013, 0.50000000000000000, 
 	  0.87266462599716477 },
-  { 1.0716015959755185, 0.89999999999999991, 0.50000000000000000, 
+  { 1.5081455873012106, 0.90000000000000013, 0.50000000000000000, 
 	  1.0471975511965976 },
-  { 1.2857636916026749, 0.89999999999999991, 0.50000000000000000, 
+  { 2.0213599730863998, 0.90000000000000013, 0.50000000000000000, 
 	  1.2217304763960306 },
-  { 1.5264263913252358, 0.89999999999999991, 0.50000000000000000, 
+  { 2.6822467012926832, 0.90000000000000013, 0.50000000000000000, 
 	  1.3962634015954636 },
-  { 1.7888013241937863, 0.89999999999999991, 0.50000000000000000, 
+  { 3.4591069002104686, 0.90000000000000013, 0.50000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler186 = 2.5000000000000020e-13;
 
-// Test data for k=0.89999999999999991, nu=0.59999999999999998.
-// max(|f - f_GSL|): 6.6613381477509392e-16
-// max(|f - f_GSL| / |f_GSL|): 3.8702201113622378e-16
+// Test data for k=0.90000000000000013, nu=0.60000000000000009.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.4914274070443813e-16
+// mean(f - f_Boost): 3.4694469519536142e-16
+// variance(f - f_Boost): 2.5224926888894056e-31
+// stddev(f - f_Boost): 5.0224423231027804e-16
 const testcase_ellint_3<double>
 data187[10] =
 {
-  { 0.0000000000000000, 0.89999999999999991, 0.59999999999999998, 
+  { 0.0000000000000000, 0.90000000000000013, 0.60000000000000009, 
 	  0.0000000000000000 },
-  { 0.17420100334657812, 0.89999999999999991, 0.59999999999999998, 
+  { 0.17633073723493825, 0.90000000000000013, 0.60000000000000009, 
 	  0.17453292519943295 },
-  { 0.34671975876122157, 0.89999999999999991, 0.59999999999999998, 
+  { 0.36386108723492810, 0.90000000000000013, 0.60000000000000009, 
 	  0.34906585039886590 },
-  { 0.51724631570707946, 0.89999999999999991, 0.59999999999999998, 
+  { 0.57597424744716241, 0.90000000000000013, 0.60000000000000009, 
 	  0.52359877559829882 },
-  { 0.68760879113743023, 0.89999999999999991, 0.59999999999999998, 
+  { 0.83098051948501150, 0.90000000000000013, 0.60000000000000009, 
 	  0.69813170079773179 },
-  { 0.86192157779698364, 0.89999999999999991, 0.59999999999999998, 
+  { 1.1558706545698916, 0.90000000000000013, 0.60000000000000009, 
 	  0.87266462599716477 },
-  { 1.0464279696166354, 0.89999999999999991, 0.59999999999999998, 
+  { 1.5905576379415669, 0.90000000000000013, 0.60000000000000009, 
 	  1.0471975511965976 },
-  { 1.2488156247094004, 0.89999999999999991, 0.59999999999999998, 
+  { 2.1875186010215084, 0.90000000000000013, 0.60000000000000009, 
 	  1.2217304763960306 },
-  { 1.4750988777188470, 0.89999999999999991, 0.59999999999999998, 
+  { 2.9885767771316853, 0.90000000000000013, 0.60000000000000009, 
 	  1.3962634015954636 },
-  { 1.7211781128919525, 0.89999999999999991, 0.59999999999999998, 
+  { 3.9549939883570238, 0.90000000000000013, 0.60000000000000009, 
 	  1.5707963267948966 },
 };
 const double toler187 = 2.5000000000000020e-13;
 
-// Test data for k=0.89999999999999991, nu=0.69999999999999996.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.3410843563834748e-16
+// Test data for k=0.90000000000000013, nu=0.70000000000000007.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 5.5442489886293633e-16
+// mean(f - f_Boost): 4.3576253716537392e-16
+// variance(f - f_Boost): 2.2187568928205130e-31
+// stddev(f - f_Boost): 4.7103682370070737e-16
 const testcase_ellint_3<double>
 data188[10] =
 {
-  { 0.0000000000000000, 0.89999999999999991, 0.69999999999999996, 
+  { 0.0000000000000000, 0.90000000000000013, 0.70000000000000007, 
 	  0.0000000000000000 },
-  { 0.17402765093102207, 0.89999999999999991, 0.69999999999999996, 
+  { 0.17651246700160939, 0.90000000000000013, 0.70000000000000007, 
 	  0.17453292519943295 },
-  { 0.34541608382635131, 0.89999999999999991, 0.69999999999999996, 
+  { 0.36542993547358982, 0.90000000000000013, 0.70000000000000007, 
 	  0.34906585039886590 },
-  { 0.51322715827061682, 0.89999999999999991, 0.69999999999999996, 
+  { 0.58199897877674867, 0.90000000000000013, 0.70000000000000007, 
 	  0.52359877559829882 },
-  { 0.67903717872440272, 0.89999999999999991, 0.69999999999999996, 
+  { 0.84815633587352857, 0.90000000000000013, 0.70000000000000007, 
 	  0.69813170079773179 },
-  { 0.84690113601682671, 0.89999999999999991, 0.69999999999999996, 
+  { 1.1985495623872375, 0.90000000000000013, 0.70000000000000007, 
 	  0.87266462599716477 },
-  { 1.0229914311548418, 0.89999999999999991, 0.69999999999999996, 
+  { 1.6892158134027691, 0.90000000000000013, 0.70000000000000007, 
 	  1.0471975511965976 },
-  { 1.2148329639709381, 0.89999999999999991, 0.69999999999999996, 
+  { 2.4029722191094236, 0.90000000000000013, 0.70000000000000007, 
 	  1.2217304763960306 },
-  { 1.4283586501307799, 0.89999999999999991, 0.69999999999999996, 
+  { 3.4201084941340061, 0.90000000000000013, 0.70000000000000007, 
 	  1.3962634015954636 },
-  { 1.6600480747670940, 0.89999999999999991, 0.69999999999999996, 
+  { 4.6985482312992444, 0.90000000000000013, 0.70000000000000007, 
 	  1.5707963267948966 },
 };
 const double toler188 = 2.5000000000000020e-13;
 
-// Test data for k=0.89999999999999991, nu=0.80000000000000004.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.3100928058463168e-16
+// Test data for k=0.90000000000000013, nu=0.80000000000000004.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 4.9362432595976420e-16
+// mean(f - f_Boost): 3.0531133177191805e-16
+// variance(f - f_Boost): 1.1508025840536076e-32
+// stddev(f - f_Boost): 1.0727546709539920e-16
 const testcase_ellint_3<double>
 data189[10] =
 {
-  { 0.0000000000000000, 0.89999999999999991, 0.80000000000000004, 
+  { 0.0000000000000000, 0.90000000000000013, 0.80000000000000004, 
 	  0.0000000000000000 },
-  { 0.17385491439925146, 0.89999999999999991, 0.80000000000000004, 
+  { 0.17669487107954862, 0.90000000000000013, 0.80000000000000004, 
 	  0.17453292519943295 },
-  { 0.34412950523113928, 0.89999999999999991, 0.80000000000000004, 
+  { 0.36702314729628421, 0.90000000000000013, 0.80000000000000004, 
 	  0.34906585039886590 },
-  { 0.50931321668729590, 0.89999999999999991, 0.80000000000000004, 
+  { 0.58825099711365492, 0.90000000000000013, 0.80000000000000004, 
 	  0.52359877559829882 },
-  { 0.67081081392296327, 0.89999999999999991, 0.80000000000000004, 
+  { 0.86661711422209031, 0.90000000000000013, 0.80000000000000004, 
 	  0.69813170079773179 },
-  { 0.83268846097293259, 0.89999999999999991, 0.80000000000000004, 
+  { 1.2469779109884802, 0.90000000000000013, 0.80000000000000004, 
 	  0.87266462599716477 },
-  { 1.0010985015814027, 0.89999999999999991, 0.80000000000000004, 
+  { 1.8105469760531578, 0.90000000000000013, 0.80000000000000004, 
 	  1.0471975511965976 },
-  { 1.1834394045489678, 0.89999999999999991, 0.80000000000000004, 
+  { 2.6989505165893752, 0.90000000000000013, 0.80000000000000004, 
 	  1.2217304763960306 },
-  { 1.3855695891683182, 0.89999999999999991, 0.80000000000000004, 
+  { 4.0935213267757433, 0.90000000000000013, 0.80000000000000004, 
 	  1.3962634015954636 },
-  { 1.6044591960982202, 0.89999999999999991, 0.80000000000000004, 
+  { 5.9820740813645727, 0.90000000000000013, 0.80000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler189 = 2.5000000000000020e-13;
 
-// Test data for k=0.89999999999999991, nu=0.90000000000000002.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 5.7167507456081732e-16
+// Test data for k=0.90000000000000013, nu=0.90000000000000002.
+// max(|f - f_Boost|): 2.6645352591003757e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 4.9577148062669782e-16
+// mean(f - f_Boost): 5.9119376061289588e-16
+// variance(f - f_Boost): 1.7340883003959522e-31
+// stddev(f - f_Boost): 4.1642385863395872e-16
 const testcase_ellint_3<double>
 data190[10] =
 {
-  { 0.0000000000000000, 0.89999999999999991, 0.90000000000000002, 
+  { 0.0000000000000000, 0.90000000000000013, 0.90000000000000002, 
 	  0.0000000000000000 },
-  { 0.17368278986240135, 0.89999999999999991, 0.90000000000000002, 
+  { 0.17687795394604169, 0.90000000000000013, 0.90000000000000002, 
 	  0.17453292519943295 },
-  { 0.34285962963961397, 0.89999999999999991, 0.90000000000000002, 
+  { 0.36864140434751286, 0.90000000000000013, 0.90000000000000002, 
 	  0.34906585039886590 },
-  { 0.50549974644993312, 0.89999999999999991, 0.90000000000000002, 
+  { 0.59474595366817051, 0.90000000000000013, 0.90000000000000002, 
 	  0.52359877559829882 },
-  { 0.66290623857720876, 0.89999999999999991, 0.90000000000000002, 
+  { 0.88654237226056665, 0.90000000000000013, 0.90000000000000002, 
 	  0.69813170079773179 },
-  { 0.81921183128847175, 0.89999999999999991, 0.90000000000000002, 
+  { 1.3026595810616726, 0.90000000000000013, 0.90000000000000002, 
 	  0.87266462599716477 },
-  { 0.98058481956066390, 0.89999999999999991, 0.90000000000000002, 
+  { 1.9653635459278080, 0.90000000000000013, 0.90000000000000002, 
 	  1.0471975511965976 },
-  { 1.1543223520473569, 0.89999999999999991, 0.90000000000000002, 
+  { 3.1451407527189468, 0.90000000000000013, 0.90000000000000002, 
 	  1.2217304763960306 },
-  { 1.3462119782292934, 0.89999999999999991, 0.90000000000000002, 
+  { 5.3745230680316132, 0.90000000000000013, 0.90000000000000002, 
 	  1.3962634015954636 },
-  { 1.5536420236310948, 0.89999999999999991, 0.90000000000000002, 
+  { 8.9942562031858717, 0.90000000000000013, 0.90000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler190 = 2.5000000000000020e-13;
 
-template<typename Tp, unsigned int Num>
+template<typename Ret, unsigned int Num>
   void
-  test(const testcase_ellint_3<Tp> (&data)[Num], Tp toler)
+  test(const testcase_ellint_3<Ret> (&data)[Num], Ret toler)
   {
-    const Tp eps = std::numeric_limits<Tp>::epsilon();
-    Tp max_abs_diff = -Tp(1);
-    Tp max_abs_frac = -Tp(1);
+    bool test __attribute__((unused)) = true;
+    const Ret eps = std::numeric_limits<Ret>::epsilon();
+    Ret max_abs_diff = -Ret(1);
+    Ret max_abs_frac = -Ret(1);
     unsigned int num_datum = Num;
     for (unsigned int i = 0; i < num_datum; ++i)
   	 {
-	const Tp f = std::ellint_3(data[i].k, data[i].nu,
+	const Ret f = std::ellint_3(data[i].k, data[i].nu,
 		     data[i].phi);
-	const Tp f0 = data[i].f0;
-	const Tp diff = f - f0;
+	const Ret f0 = data[i].f0;
+	const Ret diff = f - f0;
 	if (std::abs(diff) > max_abs_diff)
 	  max_abs_diff = std::abs(diff);
-	if (std::abs(f0) > Tp(10) * eps
-	 && std::abs(f) > Tp(10) * eps)
+	if (std::abs(f0) > Ret(10) * eps
+	 && std::abs(f) > Ret(10) * eps)
 	  {
-	    const Tp frac = diff / f0;
+	    const Ret frac = diff / f0;
 	    if (std::abs(frac) > max_abs_frac)
 	      max_abs_frac = std::abs(frac);
 	  }
diff --git a/libstdc++-v3/testsuite/special_functions/13_ellint_3/pr66689.cc b/libstdc++-v3/testsuite/special_functions/13_ellint_3/pr66689.cc
new file mode 100644
index 00000000000..e261003592d
--- /dev/null
+++ b/libstdc++-v3/testsuite/special_functions/13_ellint_3/pr66689.cc
@@ -0,0 +1,26 @@
+// { dg-do run { target c++11 } }
+// { dg-require-c-std "" }
+// { dg-options "-D__STDCPP_WANT_MATH_SPEC_FUNCS__" }
+// { dg-add-options ieee }
+
+#include <cmath>
+#include <testsuite_hooks.h>
+
+void
+test01()
+{
+  const double pi = 3.141592654;
+
+  double Pi1 = std::ellint_3(0.75, 0.0, pi / 2.0);
+  VERIFY(std::abs(Pi1 - 1.91099) < 0.00001);
+
+  double Pi2 = std::ellint_3(0.75, 0.5, pi / 2.0);
+  VERIFY(std::abs(Pi2 - 2.80011) < 0.00001);
+}
+
+int
+main()
+{
+  test01();
+  return 0;
+}
diff --git a/libstdc++-v3/testsuite/special_functions/14_expint/pr68397.cc b/libstdc++-v3/testsuite/special_functions/14_expint/pr68397.cc
new file mode 100644
index 00000000000..8da16d1fc69
--- /dev/null
+++ b/libstdc++-v3/testsuite/special_functions/14_expint/pr68397.cc
@@ -0,0 +1,47 @@
+// { dg-do run { target c++11 } }
+// { dg-options "-D__STDCPP_WANT_MATH_SPEC_FUNCS__" }
+// Copyright (C) 2017 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// PR libstdc++/68397 -  std::tr1::expint fails in __expint_En_cont_frac
+// for some long double arguments due to low __max_iter value
+
+#include <cmath>
+#include <testsuite_hooks.h>
+
+int
+test01()
+{
+  // Answers from Wolfram Alpha.
+  long double ans_ok = -0.10001943365331651406888645149537315243646135979573L;
+  long double ans_bomb = -0.10777727809650077516264612749163100483995270163783L;
+
+  auto Ei_ok = std::expint(-1.500001L);
+  auto diff_ok = Ei_ok - ans_ok;
+  VERIFY(std::abs(diff_ok) < 1.0e-15);
+
+  auto Ei_bomb = std::expint(-1.450001L);
+  auto diff_bomb = Ei_bomb - ans_bomb;
+  VERIFY(std::abs(diff_bomb) < 1.0e-15);
+}
+
+int
+main()
+{
+  test01();
+  return 0;
+}
diff --git a/libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/06_comp_ellint_3/check_value.cc b/libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/06_comp_ellint_3/check_value.cc
index 0c187d71188..ed11917401f 100644
--- a/libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/06_comp_ellint_3/check_value.cc
+++ b/libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/06_comp_ellint_3/check_value.cc
@@ -1,6 +1,7 @@
-// 2007-02-04  Edward Smith-Rowland <3dw4rd@verizon.net>
+// { dg-do run { target c++11 } }
+// { dg-options "-D__STDCPP_WANT_MATH_SPEC_FUNCS__" }
 //
-// Copyright (C) 2007-2017 Free Software Foundation, Inc.
+// Copyright (C) 2016-2018 Free Software Foundation, Inc.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
 // software; you can redistribute it and/or modify it under the
@@ -18,826 +19,490 @@
 // <http://www.gnu.org/licenses/>.
 
 //  comp_ellint_3
-
-
 //  Compare against values generated by the GNU Scientific Library.
 //  The GSL can be found on the web: http://www.gnu.org/software/gsl/
-
+#include <limits>
 #include <tr1/cmath>
 #if defined(__TEST_DEBUG)
-#include <iostream>
-#define VERIFY(A) \
-if (!(A)) \
-  { \
-    std::cout << "line " << __LINE__ \
-      << "  max_abs_frac = " << max_abs_frac \
-      << std::endl; \
-  }
+#  include <iostream>
+#  define VERIFY(A) \
+  if (!(A)) \
+    { \
+      std::cout << "line " << __LINE__ \
+	<< "  max_abs_frac = " << max_abs_frac \
+	<< std::endl; \
+    }
 #else
-#include <testsuite_hooks.h>
+#  include <testsuite_hooks.h>
 #endif
-#include "../testcase.h"
-
+#include <specfun_testcase.h>
 
 // Test data for k=-0.90000000000000002.
-testcase_comp_ellint_3<double> data001[] = {
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 5
+// max(|f - f_Boost| / |f_Boost|): 1.2838262090802751e-16
+// mean(f - f_Boost): 4.4408920985006264e-17
+// variance(f - f_Boost): 2.4347558803117648e-34
+// stddev(f - f_Boost): 1.5603704304785339e-17
+const testcase_comp_ellint_3<double>
+data001[10] =
+{
   { 2.2805491384227703, -0.90000000000000002, 0.0000000000000000 },
-  { 2.1537868513875287, -0.90000000000000002, 0.10000000000000001 },
-  { 2.0443194576468890, -0.90000000000000002, 0.20000000000000001 },
-  { 1.9486280260314426, -0.90000000000000002, 0.29999999999999999 },
-  { 1.8641114227238349, -0.90000000000000002, 0.40000000000000002 },
-  { 1.7888013241937861, -0.90000000000000002, 0.50000000000000000 },
-  { 1.7211781128919523, -0.90000000000000002, 0.59999999999999998 },
-  { 1.6600480747670938, -0.90000000000000002, 0.69999999999999996 },
-  { 1.6044591960982204, -0.90000000000000002, 0.80000000000000004 },
-  { 1.5536420236310946, -0.90000000000000002, 0.90000000000000002 },
+  { 2.4295011187834885, -0.90000000000000002, 0.10000000000000001 },
+  { 2.6076835743348412, -0.90000000000000002, 0.20000000000000001 },
+  { 2.8256506968858512, -0.90000000000000002, 0.30000000000000004 },
+  { 3.1000689868578619, -0.90000000000000002, 0.40000000000000002 },
+  { 3.4591069002104677, -0.90000000000000002, 0.50000000000000000 },
+  { 3.9549939883570229, -0.90000000000000002, 0.60000000000000009 },
+  { 4.6985482312992435, -0.90000000000000002, 0.70000000000000007 },
+  { 5.9820740813645710, -0.90000000000000002, 0.80000000000000004 },
+  { 8.9942562031858699, -0.90000000000000002, 0.90000000000000002 },
 };
-
-// Test function for k=-0.90000000000000002.
-template <typename Tp>
-void test001()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data001)
-                         / sizeof(testcase_comp_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::comp_ellint_3(Tp(data001[i].k), Tp(data001[i].nu));
-      const Tp f0 = data001[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+const double toler001 = 2.5000000000000020e-13;
 
 // Test data for k=-0.80000000000000004.
-testcase_comp_ellint_3<double> data002[] = {
-  { 1.9953027776647296, -0.80000000000000004, 0.0000000000000000 },
-  { 1.8910755418379521, -0.80000000000000004, 0.10000000000000001 },
-  { 1.8007226661734588, -0.80000000000000004, 0.20000000000000001 },
-  { 1.7214611048717301, -0.80000000000000004, 0.29999999999999999 },
-  { 1.6512267838651289, -0.80000000000000004, 0.40000000000000002 },
-  { 1.5884528947755532, -0.80000000000000004, 0.50000000000000000 },
-  { 1.5319262547427865, -0.80000000000000004, 0.59999999999999998 },
-  { 1.4806912324625332, -0.80000000000000004, 0.69999999999999996 },
-  { 1.4339837018309474, -0.80000000000000004, 0.80000000000000004 },
-  { 1.3911845406776222, -0.80000000000000004, 0.90000000000000002 },
-};
-
-// Test function for k=-0.80000000000000004.
-template <typename Tp>
-void test002()
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 4.1949393471095187e-16
+// mean(f - f_Boost): 9.5479180117763459e-16
+// variance(f - f_Boost): 5.4782007307014711e-34
+// stddev(f - f_Boost): 2.3405556457178006e-17
+const testcase_comp_ellint_3<double>
+data002[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data002)
-                         / sizeof(testcase_comp_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::comp_ellint_3(Tp(data002[i].k), Tp(data002[i].nu));
-      const Tp f0 = data002[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.69999999999999996.
-testcase_comp_ellint_3<double> data003[] = {
-  { 1.8456939983747236, -0.69999999999999996, 0.0000000000000000 },
-  { 1.7528050171757608, -0.69999999999999996, 0.10000000000000001 },
-  { 1.6721098780092147, -0.69999999999999996, 0.20000000000000001 },
-  { 1.6011813647733213, -0.69999999999999996, 0.29999999999999999 },
-  { 1.5382162002954762, -0.69999999999999996, 0.40000000000000002 },
-  { 1.4818433192178544, -0.69999999999999996, 0.50000000000000000 },
-  { 1.4309994736080540, -0.69999999999999996, 0.59999999999999998 },
-  { 1.3848459188329196, -0.69999999999999996, 0.69999999999999996 },
-  { 1.3427110650397533, -0.69999999999999996, 0.80000000000000004 },
-  { 1.3040500499695911, -0.69999999999999996, 0.90000000000000002 },
+  { 1.9953027776647294, -0.80000000000000004, 0.0000000000000000 },
+  { 2.1172616484005085, -0.80000000000000004, 0.10000000000000001 },
+  { 2.2624789434186798, -0.80000000000000004, 0.20000000000000001 },
+  { 2.4392042002725698, -0.80000000000000004, 0.30000000000000004 },
+  { 2.6604037035529728, -0.80000000000000004, 0.40000000000000002 },
+  { 2.9478781158239751, -0.80000000000000004, 0.50000000000000000 },
+  { 3.3418121892288055, -0.80000000000000004, 0.60000000000000009 },
+  { 3.9268876980046397, -0.80000000000000004, 0.70000000000000007 },
+  { 4.9246422058196071, -0.80000000000000004, 0.80000000000000004 },
+  { 7.2263259298637132, -0.80000000000000004, 0.90000000000000002 },
 };
+const double toler002 = 2.5000000000000020e-13;
 
-// Test function for k=-0.69999999999999996.
-template <typename Tp>
-void test003()
+// Test data for k=-0.69999999999999996.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 3
+// max(|f - f_Boost| / |f_Boost|): 1.9832236886714888e-16
+// mean(f - f_Boost): -1.5543122344752191e-16
+// variance(f - f_Boost): 2.9825759533819119e-33
+// stddev(f - f_Boost): 5.4612965066748680e-17
+const testcase_comp_ellint_3<double>
+data003[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data003)
-                         / sizeof(testcase_comp_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::comp_ellint_3(Tp(data003[i].k), Tp(data003[i].nu));
-      const Tp f0 = data003[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+  { 1.8456939983747234, -0.69999999999999996, 0.0000000000000000 },
+  { 1.9541347343119564, -0.69999999999999996, 0.10000000000000001 },
+  { 2.0829290325820202, -0.69999999999999996, 0.20000000000000001 },
+  { 2.2392290510988535, -0.69999999999999996, 0.30000000000000004 },
+  { 2.4342502915307880, -0.69999999999999996, 0.40000000000000002 },
+  { 2.6868019968236996, -0.69999999999999996, 0.50000000000000000 },
+  { 3.0314573496746742, -0.69999999999999996, 0.60000000000000009 },
+  { 3.5408408771788564, -0.69999999999999996, 0.70000000000000007 },
+  { 4.4042405729076961, -0.69999999999999996, 0.80000000000000004 },
+  { 6.3796094177887754, -0.69999999999999996, 0.90000000000000002 },
+};
+const double toler003 = 2.5000000000000020e-13;
 
 // Test data for k=-0.59999999999999998.
-testcase_comp_ellint_3<double> data004[] = {
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 2
+// max(|f - f_Boost| / |f_Boost|): 2.2547200163366559e-16
+// mean(f - f_Boost): -1.9984014443252818e-16
+// variance(f - f_Boost): 4.9303806576313241e-33
+// stddev(f - f_Boost): 7.0216669371534022e-17
+const testcase_comp_ellint_3<double>
+data004[10] =
+{
   { 1.7507538029157526, -0.59999999999999998, 0.0000000000000000 },
-  { 1.6648615773343014, -0.59999999999999998, 0.10000000000000001 },
-  { 1.5901418016279374, -0.59999999999999998, 0.20000000000000001 },
-  { 1.5243814243493585, -0.59999999999999998, 0.29999999999999999 },
-  { 1.4659345278069984, -0.59999999999999998, 0.40000000000000002 },
-  { 1.4135484285693078, -0.59999999999999998, 0.50000000000000000 },
-  { 1.3662507535812816, -0.59999999999999998, 0.59999999999999998 },
-  { 1.3232737468822811, -0.59999999999999998, 0.69999999999999996 },
-  { 1.2840021261752192, -0.59999999999999998, 0.80000000000000004 },
-  { 1.2479362973851875, -0.59999999999999998, 0.90000000000000002 },
+  { 1.8508766487100685, -0.59999999999999998, 0.10000000000000001 },
+  { 1.9695980282802217, -0.59999999999999998, 0.20000000000000001 },
+  { 2.1134154405060599, -0.59999999999999998, 0.30000000000000004 },
+  { 2.2925036420985130, -0.59999999999999998, 0.40000000000000002 },
+  { 2.5239007084492711, -0.59999999999999998, 0.50000000000000000 },
+  { 2.8388723099514972, -0.59999999999999998, 0.60000000000000009 },
+  { 3.3029735898397159, -0.59999999999999998, 0.70000000000000007 },
+  { 4.0867036409261832, -0.59999999999999998, 0.80000000000000004 },
+  { 5.8709993116265604, -0.59999999999999998, 0.90000000000000002 },
 };
-
-// Test function for k=-0.59999999999999998.
-template <typename Tp>
-void test004()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data004)
-                         / sizeof(testcase_comp_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::comp_ellint_3(Tp(data004[i].k), Tp(data004[i].nu));
-      const Tp f0 = data004[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+const double toler004 = 2.5000000000000020e-13;
 
 // Test data for k=-0.50000000000000000.
-testcase_comp_ellint_3<double> data005[] = {
-  { 1.6857503548125963, -0.50000000000000000, 0.0000000000000000 },
-  { 1.6045524936084892, -0.50000000000000000, 0.10000000000000001 },
-  { 1.5338490483665983, -0.50000000000000000, 0.20000000000000001 },
-  { 1.4715681939859637, -0.50000000000000000, 0.29999999999999999 },
-  { 1.4161679518465340, -0.50000000000000000, 0.40000000000000002 },
-  { 1.3664739530045971, -0.50000000000000000, 0.50000000000000000 },
-  { 1.3215740290190876, -0.50000000000000000, 0.59999999999999998 },
-  { 1.2807475181182502, -0.50000000000000000, 0.69999999999999996 },
-  { 1.2434165408189539, -0.50000000000000000, 0.80000000000000004 },
-  { 1.2091116095504744, -0.50000000000000000, 0.90000000000000002 },
-};
-
-// Test function for k=-0.50000000000000000.
-template <typename Tp>
-void test005()
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 3
+// max(|f - f_Boost| / |f_Boost|): 2.1900131385114407e-16
+// mean(f - f_Boost): 2.4424906541753446e-16
+// variance(f - f_Boost): 7.3651365379430888e-33
+// stddev(f - f_Boost): 8.5820373676319358e-17
+const testcase_comp_ellint_3<double>
+data005[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data005)
-                         / sizeof(testcase_comp_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::comp_ellint_3(Tp(data005[i].k), Tp(data005[i].nu));
-      const Tp f0 = data005[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.40000000000000002.
-testcase_comp_ellint_3<double> data006[] = {
-  { 1.6399998658645112, -0.40000000000000002, 0.0000000000000000 },
-  { 1.5620566886683604, -0.40000000000000002, 0.10000000000000001 },
-  { 1.4941414344266770, -0.40000000000000002, 0.20000000000000001 },
-  { 1.4342789859950078, -0.40000000000000002, 0.29999999999999999 },
-  { 1.3809986210732901, -0.40000000000000002, 0.40000000000000002 },
-  { 1.3331797176377398, -0.40000000000000002, 0.50000000000000000 },
-  { 1.2899514672527024, -0.40000000000000002, 0.59999999999999998 },
-  { 1.2506255923253344, -0.40000000000000002, 0.69999999999999996 },
-  { 1.2146499565727209, -0.40000000000000002, 0.80000000000000004 },
-  { 1.1815758115929846, -0.40000000000000002, 0.90000000000000002 },
+  { 1.6857503548125961, -0.50000000000000000, 0.0000000000000000 },
+  { 1.7803034946545482, -0.50000000000000000, 0.10000000000000001 },
+  { 1.8922947612264021, -0.50000000000000000, 0.20000000000000001 },
+  { 2.0277924458111314, -0.50000000000000000, 0.30000000000000004 },
+  { 2.1962905366178065, -0.50000000000000000, 0.40000000000000002 },
+  { 2.4136715042011945, -0.50000000000000000, 0.50000000000000000 },
+  { 2.7090491861753558, -0.50000000000000000, 0.60000000000000009 },
+  { 3.1433945297859229, -0.50000000000000000, 0.70000000000000007 },
+  { 3.8750701888108070, -0.50000000000000000, 0.80000000000000004 },
+  { 5.5355132096026463, -0.50000000000000000, 0.90000000000000002 },
 };
-
-// Test function for k=-0.40000000000000002.
-template <typename Tp>
-void test006()
+const double toler005 = 2.5000000000000020e-13;
+
+// Test data for k=-0.39999999999999991.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.1718164615986397e-16
+// mean(f - f_Boost): 6.2172489379008762e-16
+// variance(f - f_Boost): 1.6458949750907531e-31
+// stddev(f - f_Boost): 4.0569631192441877e-16
+const testcase_comp_ellint_3<double>
+data006[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data006)
-                         / sizeof(testcase_comp_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::comp_ellint_3(Tp(data006[i].k), Tp(data006[i].nu));
-      const Tp f0 = data006[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.30000000000000004.
-testcase_comp_ellint_3<double> data007[] = {
-  { 1.6080486199305126, -0.30000000000000004, 0.0000000000000000 },
-  { 1.5323534693557526, -0.30000000000000004, 0.10000000000000001 },
-  { 1.4663658145259875, -0.30000000000000004, 0.20000000000000001 },
-  { 1.4081767433479089, -0.30000000000000004, 0.29999999999999999 },
-  { 1.3563643538969761, -0.30000000000000004, 0.40000000000000002 },
-  { 1.3098448759814960, -0.30000000000000004, 0.50000000000000000 },
-  { 1.2677758800420666, -0.30000000000000004, 0.59999999999999998 },
-  { 1.2294913236274980, -0.30000000000000004, 0.69999999999999996 },
-  { 1.1944567571590046, -0.30000000000000004, 0.80000000000000004 },
-  { 1.1622376896064912, -0.30000000000000004, 0.90000000000000002 },
+  { 1.6399998658645112, -0.39999999999999991, 0.0000000000000000 },
+  { 1.7306968836847190, -0.39999999999999991, 0.10000000000000001 },
+  { 1.8380358826317627, -0.39999999999999991, 0.20000000000000001 },
+  { 1.9677924132520139, -0.39999999999999991, 0.30000000000000004 },
+  { 2.1289968719280026, -0.39999999999999991, 0.40000000000000002 },
+  { 2.3367461373176512, -0.39999999999999991, 0.50000000000000000 },
+  { 2.6186940209850191, -0.39999999999999991, 0.60000000000000009 },
+  { 3.0327078743873246, -0.39999999999999991, 0.70000000000000007 },
+  { 3.7289548002199902, -0.39999999999999991, 0.80000000000000004 },
+  { 5.3055535102872513, -0.39999999999999991, 0.90000000000000002 },
 };
-
-// Test function for k=-0.30000000000000004.
-template <typename Tp>
-void test007()
+const double toler006 = 2.5000000000000020e-13;
+
+// Test data for k=-0.29999999999999993.
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 3.9274792319434433e-16
+// mean(f - f_Boost): 6.2172489379008762e-16
+// variance(f - f_Boost): 8.7651211691223537e-33
+// stddev(f - f_Boost): 9.3622225828712025e-17
+const testcase_comp_ellint_3<double>
+data007[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data007)
-                         / sizeof(testcase_comp_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::comp_ellint_3(Tp(data007[i].k), Tp(data007[i].nu));
-      const Tp f0 = data007[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.19999999999999996.
-testcase_comp_ellint_3<double> data008[] = {
-  { 1.5868678474541664, -0.19999999999999996, 0.0000000000000000 },
-  { 1.5126513474261092, -0.19999999999999996, 0.10000000000000001 },
-  { 1.4479323932249568, -0.19999999999999996, 0.20000000000000001 },
-  { 1.3908453514752481, -0.19999999999999996, 0.29999999999999999 },
-  { 1.3400002519661010, -0.19999999999999996, 0.40000000000000002 },
-  { 1.2943374404397376, -0.19999999999999996, 0.50000000000000000 },
-  { 1.2530330675914561, -0.19999999999999996, 0.59999999999999998 },
-  { 1.2154356555075867, -0.19999999999999996, 0.69999999999999996 },
-  { 1.1810223448909913, -0.19999999999999996, 0.80000000000000004 },
-  { 1.1493679916141863, -0.19999999999999996, 0.90000000000000002 },
+  { 1.6080486199305128, -0.29999999999999993, 0.0000000000000000 },
+  { 1.6960848815118226, -0.29999999999999993, 0.10000000000000001 },
+  { 1.8002173372290500, -0.29999999999999993, 0.20000000000000001 },
+  { 1.9260216862473254, -0.29999999999999993, 0.30000000000000004 },
+  { 2.0822121773175533, -0.29999999999999993, 0.40000000000000002 },
+  { 2.2833505881933971, -0.29999999999999993, 0.50000000000000000 },
+  { 2.5560975528589065, -0.29999999999999993, 0.60000000000000009 },
+  { 2.9562123549913877, -0.29999999999999993, 0.70000000000000007 },
+  { 3.6283050484567170, -0.29999999999999993, 0.80000000000000004 },
+  { 5.1479514944016795, -0.29999999999999993, 0.90000000000000002 },
 };
+const double toler007 = 2.5000000000000020e-13;
 
-// Test function for k=-0.19999999999999996.
-template <typename Tp>
-void test008()
+// Test data for k=-0.19999999999999996.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 1.9753938705764407e-16
+// mean(f - f_Boost): 3.1086244689504381e-16
+// variance(f - f_Boost): 4.1147374377268827e-32
+// stddev(f - f_Boost): 2.0284815596220939e-16
+const testcase_comp_ellint_3<double>
+data008[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data008)
-                         / sizeof(testcase_comp_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::comp_ellint_3(Tp(data008[i].k), Tp(data008[i].nu));
-      const Tp f0 = data008[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.099999999999999978.
-testcase_comp_ellint_3<double> data009[] = {
-  { 1.5747455615173562, -0.099999999999999978, 0.0000000000000000 },
-  { 1.5013711111199950, -0.099999999999999978, 0.10000000000000001 },
-  { 1.4373749386463430, -0.099999999999999978, 0.20000000000000001 },
-  { 1.3809159606704959, -0.099999999999999978, 0.29999999999999999 },
-  { 1.3306223265207477, -0.099999999999999978, 0.40000000000000002 },
-  { 1.2854480708580160, -0.099999999999999978, 0.50000000000000000 },
-  { 1.2445798942989255, -0.099999999999999978, 0.59999999999999998 },
-  { 1.2073745911083187, -0.099999999999999978, 0.69999999999999996 },
-  { 1.1733158866987732, -0.099999999999999978, 0.80000000000000004 },
-  { 1.1419839485283374, -0.099999999999999978, 0.90000000000000002 },
+  { 1.5868678474541662, -0.19999999999999996, 0.0000000000000000 },
+  { 1.6731552050562593, -0.19999999999999996, 0.10000000000000001 },
+  { 1.7751816279738935, -0.19999999999999996, 0.20000000000000001 },
+  { 1.8983924169967101, -0.19999999999999996, 0.30000000000000004 },
+  { 2.0512956926676806, -0.19999999999999996, 0.40000000000000002 },
+  { 2.2481046259421302, -0.19999999999999996, 0.50000000000000000 },
+  { 2.5148333891629315, -0.19999999999999996, 0.60000000000000009 },
+  { 2.9058704854500967, -0.19999999999999996, 0.70000000000000007 },
+  { 3.5622166386422633, -0.19999999999999996, 0.80000000000000004 },
+  { 5.0448269356200370, -0.19999999999999996, 0.90000000000000002 },
 };
+const double toler008 = 2.5000000000000020e-13;
 
-// Test function for k=-0.099999999999999978.
-template <typename Tp>
-void test009()
+// Test data for k=-0.099999999999999978.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 5
+// max(|f - f_Boost| / |f_Boost|): 1.9932308021417639e-16
+// mean(f - f_Boost): 0.0000000000000000
+// variance(f - f_Boost): 6.8368087769470551e-64
+// stddev(f - f_Boost): 2.6147291976315738e-32
+const testcase_comp_ellint_3<double>
+data009[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data009)
-                         / sizeof(testcase_comp_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::comp_ellint_3(Tp(data009[i].k), Tp(data009[i].nu));
-      const Tp f0 = data009[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+  { 1.5747455615173560, -0.099999999999999978, 0.0000000000000000 },
+  { 1.6600374067558428, -0.099999999999999978, 0.10000000000000001 },
+  { 1.7608656115083421, -0.099999999999999978, 0.20000000000000001 },
+  { 1.8826015946315438, -0.099999999999999978, 0.30000000000000004 },
+  { 2.0336367403076760, -0.099999999999999978, 0.40000000000000002 },
+  { 2.2279868912966849, -0.099999999999999978, 0.50000000000000000 },
+  { 2.4913004919173827, -0.099999999999999978, 0.60000000000000009 },
+  { 2.8771910188009744, -0.099999999999999978, 0.70000000000000007 },
+  { 3.5246199613295617, -0.099999999999999978, 0.80000000000000004 },
+  { 4.9862890417305508, -0.099999999999999978, 0.90000000000000002 },
+};
+const double toler009 = 2.5000000000000020e-13;
 
 // Test data for k=0.0000000000000000.
-testcase_comp_ellint_3<double> data010[] = {
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 2.1899085000907084e-16
+// mean(f - f_Boost): -2.2204460492503131e-16
+// variance(f - f_Boost): 5.4782007307014711e-32
+// stddev(f - f_Boost): 2.3405556457178008e-16
+const testcase_comp_ellint_3<double>
+data010[10] =
+{
   { 1.5707963267948966, 0.0000000000000000, 0.0000000000000000 },
-  { 1.4976955329233277, 0.0000000000000000, 0.10000000000000001 },
-  { 1.4339343023863691, 0.0000000000000000, 0.20000000000000001 },
-  { 1.3776795151134889, 0.0000000000000000, 0.29999999999999999 },
-  { 1.3275651989026322, 0.0000000000000000, 0.40000000000000002 },
-  { 1.2825498301618641, 0.0000000000000000, 0.50000000000000000 },
-  { 1.2418235332245127, 0.0000000000000000, 0.59999999999999998 },
-  { 1.2047457872617382, 0.0000000000000000, 0.69999999999999996 },
-  { 1.1708024551734544, 0.0000000000000000, 0.80000000000000004 },
-  { 1.1395754288497419, 0.0000000000000000, 0.90000000000000002 },
+  { 1.6557647109660170, 0.0000000000000000, 0.10000000000000001 },
+  { 1.7562036827601817, 0.0000000000000000, 0.20000000000000001 },
+  { 1.8774607092226381, 0.0000000000000000, 0.30000000000000004 },
+  { 2.0278893379868062, 0.0000000000000000, 0.40000000000000002 },
+  { 2.2214414690791831, 0.0000000000000000, 0.50000000000000000 },
+  { 2.4836470664490258, 0.0000000000000000, 0.60000000000000009 },
+  { 2.8678686047727386, 0.0000000000000000, 0.70000000000000007 },
+  { 3.5124073655203634, 0.0000000000000000, 0.80000000000000004 },
+  { 4.9672941328980516, 0.0000000000000000, 0.90000000000000002 },
 };
-
-// Test function for k=0.0000000000000000.
-template <typename Tp>
-void test010()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data010)
-                         / sizeof(testcase_comp_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::comp_ellint_3(Tp(data010[i].k), Tp(data010[i].nu));
-      const Tp f0 = data010[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+const double toler010 = 2.5000000000000020e-13;
 
 // Test data for k=0.10000000000000009.
-testcase_comp_ellint_3<double> data011[] = {
-  { 1.5747455615173562, 0.10000000000000009, 0.0000000000000000 },
-  { 1.5013711111199950, 0.10000000000000009, 0.10000000000000001 },
-  { 1.4373749386463430, 0.10000000000000009, 0.20000000000000001 },
-  { 1.3809159606704959, 0.10000000000000009, 0.29999999999999999 },
-  { 1.3306223265207477, 0.10000000000000009, 0.40000000000000002 },
-  { 1.2854480708580160, 0.10000000000000009, 0.50000000000000000 },
-  { 1.2445798942989255, 0.10000000000000009, 0.59999999999999998 },
-  { 1.2073745911083187, 0.10000000000000009, 0.69999999999999996 },
-  { 1.1733158866987732, 0.10000000000000009, 0.80000000000000004 },
-  { 1.1419839485283374, 0.10000000000000009, 0.90000000000000002 },
-};
-
-// Test function for k=0.10000000000000009.
-template <typename Tp>
-void test011()
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 5
+// max(|f - f_Boost| / |f_Boost|): 1.9932308021417639e-16
+// mean(f - f_Boost): -2.2204460492503132e-17
+// variance(f - f_Boost): 6.0868897007794120e-35
+// stddev(f - f_Boost): 7.8018521523926693e-18
+const testcase_comp_ellint_3<double>
+data011[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data011)
-                         / sizeof(testcase_comp_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::comp_ellint_3(Tp(data011[i].k), Tp(data011[i].nu));
-      const Tp f0 = data011[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.19999999999999996.
-testcase_comp_ellint_3<double> data012[] = {
-  { 1.5868678474541664, 0.19999999999999996, 0.0000000000000000 },
-  { 1.5126513474261092, 0.19999999999999996, 0.10000000000000001 },
-  { 1.4479323932249568, 0.19999999999999996, 0.20000000000000001 },
-  { 1.3908453514752481, 0.19999999999999996, 0.29999999999999999 },
-  { 1.3400002519661010, 0.19999999999999996, 0.40000000000000002 },
-  { 1.2943374404397376, 0.19999999999999996, 0.50000000000000000 },
-  { 1.2530330675914561, 0.19999999999999996, 0.59999999999999998 },
-  { 1.2154356555075867, 0.19999999999999996, 0.69999999999999996 },
-  { 1.1810223448909913, 0.19999999999999996, 0.80000000000000004 },
-  { 1.1493679916141863, 0.19999999999999996, 0.90000000000000002 },
+  { 1.5747455615173560, 0.10000000000000009, 0.0000000000000000 },
+  { 1.6600374067558428, 0.10000000000000009, 0.10000000000000001 },
+  { 1.7608656115083421, 0.10000000000000009, 0.20000000000000001 },
+  { 1.8826015946315440, 0.10000000000000009, 0.30000000000000004 },
+  { 2.0336367403076760, 0.10000000000000009, 0.40000000000000002 },
+  { 2.2279868912966849, 0.10000000000000009, 0.50000000000000000 },
+  { 2.4913004919173827, 0.10000000000000009, 0.60000000000000009 },
+  { 2.8771910188009744, 0.10000000000000009, 0.70000000000000007 },
+  { 3.5246199613295617, 0.10000000000000009, 0.80000000000000004 },
+  { 4.9862890417305508, 0.10000000000000009, 0.90000000000000002 },
 };
-
-// Test function for k=0.19999999999999996.
-template <typename Tp>
-void test012()
+const double toler011 = 2.5000000000000020e-13;
+
+// Test data for k=0.20000000000000018.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 1.9753938705764407e-16
+// mean(f - f_Boost): 3.1086244689504381e-16
+// variance(f - f_Boost): 4.1147374377268827e-32
+// stddev(f - f_Boost): 2.0284815596220939e-16
+const testcase_comp_ellint_3<double>
+data012[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data012)
-                         / sizeof(testcase_comp_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::comp_ellint_3(Tp(data012[i].k), Tp(data012[i].nu));
-      const Tp f0 = data012[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.30000000000000004.
-testcase_comp_ellint_3<double> data013[] = {
-  { 1.6080486199305126, 0.30000000000000004, 0.0000000000000000 },
-  { 1.5323534693557526, 0.30000000000000004, 0.10000000000000001 },
-  { 1.4663658145259875, 0.30000000000000004, 0.20000000000000001 },
-  { 1.4081767433479089, 0.30000000000000004, 0.29999999999999999 },
-  { 1.3563643538969761, 0.30000000000000004, 0.40000000000000002 },
-  { 1.3098448759814960, 0.30000000000000004, 0.50000000000000000 },
-  { 1.2677758800420666, 0.30000000000000004, 0.59999999999999998 },
-  { 1.2294913236274980, 0.30000000000000004, 0.69999999999999996 },
-  { 1.1944567571590046, 0.30000000000000004, 0.80000000000000004 },
-  { 1.1622376896064912, 0.30000000000000004, 0.90000000000000002 },
+  { 1.5868678474541662, 0.20000000000000018, 0.0000000000000000 },
+  { 1.6731552050562593, 0.20000000000000018, 0.10000000000000001 },
+  { 1.7751816279738935, 0.20000000000000018, 0.20000000000000001 },
+  { 1.8983924169967101, 0.20000000000000018, 0.30000000000000004 },
+  { 2.0512956926676806, 0.20000000000000018, 0.40000000000000002 },
+  { 2.2481046259421302, 0.20000000000000018, 0.50000000000000000 },
+  { 2.5148333891629315, 0.20000000000000018, 0.60000000000000009 },
+  { 2.9058704854500967, 0.20000000000000018, 0.70000000000000007 },
+  { 3.5622166386422633, 0.20000000000000018, 0.80000000000000004 },
+  { 5.0448269356200370, 0.20000000000000018, 0.90000000000000002 },
 };
+const double toler012 = 2.5000000000000020e-13;
 
-// Test function for k=0.30000000000000004.
-template <typename Tp>
-void test013()
+// Test data for k=0.30000000000000004.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 3.4585997630846713e-16
+// mean(f - f_Boost): 5.1070259132757197e-16
+// variance(f - f_Boost): 1.7591111235252501e-32
+// stddev(f - f_Boost): 1.3263148659067538e-16
+const testcase_comp_ellint_3<double>
+data013[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data013)
-                         / sizeof(testcase_comp_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::comp_ellint_3(Tp(data013[i].k), Tp(data013[i].nu));
-      const Tp f0 = data013[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.39999999999999991.
-testcase_comp_ellint_3<double> data014[] = {
-  { 1.6399998658645112, 0.39999999999999991, 0.0000000000000000 },
-  { 1.5620566886683604, 0.39999999999999991, 0.10000000000000001 },
-  { 1.4941414344266770, 0.39999999999999991, 0.20000000000000001 },
-  { 1.4342789859950078, 0.39999999999999991, 0.29999999999999999 },
-  { 1.3809986210732901, 0.39999999999999991, 0.40000000000000002 },
-  { 1.3331797176377398, 0.39999999999999991, 0.50000000000000000 },
-  { 1.2899514672527024, 0.39999999999999991, 0.59999999999999998 },
-  { 1.2506255923253344, 0.39999999999999991, 0.69999999999999996 },
-  { 1.2146499565727209, 0.39999999999999991, 0.80000000000000004 },
-  { 1.1815758115929846, 0.39999999999999991, 0.90000000000000002 },
+  { 1.6080486199305128, 0.30000000000000004, 0.0000000000000000 },
+  { 1.6960848815118228, 0.30000000000000004, 0.10000000000000001 },
+  { 1.8002173372290500, 0.30000000000000004, 0.20000000000000001 },
+  { 1.9260216862473254, 0.30000000000000004, 0.30000000000000004 },
+  { 2.0822121773175533, 0.30000000000000004, 0.40000000000000002 },
+  { 2.2833505881933975, 0.30000000000000004, 0.50000000000000000 },
+  { 2.5560975528589065, 0.30000000000000004, 0.60000000000000009 },
+  { 2.9562123549913877, 0.30000000000000004, 0.70000000000000007 },
+  { 3.6283050484567174, 0.30000000000000004, 0.80000000000000004 },
+  { 5.1479514944016795, 0.30000000000000004, 0.90000000000000002 },
 };
-
-// Test function for k=0.39999999999999991.
-template <typename Tp>
-void test014()
+const double toler013 = 2.5000000000000020e-13;
+
+// Test data for k=0.40000000000000013.
+// max(|f - f_Boost|): 2.6645352591003757e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 6.7696531428672557e-16
+// mean(f - f_Boost): 1.1990408665951691e-15
+// variance(f - f_Boost): 2.6514491536595121e-31
+// stddev(f - f_Boost): 5.1492224205791612e-16
+const testcase_comp_ellint_3<double>
+data014[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data014)
-                         / sizeof(testcase_comp_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::comp_ellint_3(Tp(data014[i].k), Tp(data014[i].nu));
-      const Tp f0 = data014[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.50000000000000000.
-testcase_comp_ellint_3<double> data015[] = {
-  { 1.6857503548125963, 0.50000000000000000, 0.0000000000000000 },
-  { 1.6045524936084892, 0.50000000000000000, 0.10000000000000001 },
-  { 1.5338490483665983, 0.50000000000000000, 0.20000000000000001 },
-  { 1.4715681939859637, 0.50000000000000000, 0.29999999999999999 },
-  { 1.4161679518465340, 0.50000000000000000, 0.40000000000000002 },
-  { 1.3664739530045971, 0.50000000000000000, 0.50000000000000000 },
-  { 1.3215740290190876, 0.50000000000000000, 0.59999999999999998 },
-  { 1.2807475181182502, 0.50000000000000000, 0.69999999999999996 },
-  { 1.2434165408189539, 0.50000000000000000, 0.80000000000000004 },
-  { 1.2091116095504744, 0.50000000000000000, 0.90000000000000002 },
+  { 1.6399998658645112, 0.40000000000000013, 0.0000000000000000 },
+  { 1.7306968836847190, 0.40000000000000013, 0.10000000000000001 },
+  { 1.8380358826317629, 0.40000000000000013, 0.20000000000000001 },
+  { 1.9677924132520141, 0.40000000000000013, 0.30000000000000004 },
+  { 2.1289968719280030, 0.40000000000000013, 0.40000000000000002 },
+  { 2.3367461373176512, 0.40000000000000013, 0.50000000000000000 },
+  { 2.6186940209850196, 0.40000000000000013, 0.60000000000000009 },
+  { 3.0327078743873246, 0.40000000000000013, 0.70000000000000007 },
+  { 3.7289548002199906, 0.40000000000000013, 0.80000000000000004 },
+  { 5.3055535102872522, 0.40000000000000013, 0.90000000000000002 },
 };
+const double toler014 = 2.5000000000000020e-13;
 
-// Test function for k=0.50000000000000000.
-template <typename Tp>
-void test015()
+// Test data for k=0.50000000000000000.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 3
+// max(|f - f_Boost| / |f_Boost|): 2.1900131385114407e-16
+// mean(f - f_Boost): 2.4424906541753446e-16
+// variance(f - f_Boost): 7.3651365379430888e-33
+// stddev(f - f_Boost): 8.5820373676319358e-17
+const testcase_comp_ellint_3<double>
+data015[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data015)
-                         / sizeof(testcase_comp_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::comp_ellint_3(Tp(data015[i].k), Tp(data015[i].nu));
-      const Tp f0 = data015[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+  { 1.6857503548125961, 0.50000000000000000, 0.0000000000000000 },
+  { 1.7803034946545482, 0.50000000000000000, 0.10000000000000001 },
+  { 1.8922947612264021, 0.50000000000000000, 0.20000000000000001 },
+  { 2.0277924458111314, 0.50000000000000000, 0.30000000000000004 },
+  { 2.1962905366178065, 0.50000000000000000, 0.40000000000000002 },
+  { 2.4136715042011945, 0.50000000000000000, 0.50000000000000000 },
+  { 2.7090491861753558, 0.50000000000000000, 0.60000000000000009 },
+  { 3.1433945297859229, 0.50000000000000000, 0.70000000000000007 },
+  { 3.8750701888108070, 0.50000000000000000, 0.80000000000000004 },
+  { 5.5355132096026463, 0.50000000000000000, 0.90000000000000002 },
+};
+const double toler015 = 2.5000000000000020e-13;
 
 // Test data for k=0.60000000000000009.
-testcase_comp_ellint_3<double> data016[] = {
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 2
+// max(|f - f_Boost| / |f_Boost|): 2.2547200163366559e-16
+// mean(f - f_Boost): -2.2204460492503131e-16
+// variance(f - f_Boost): 6.0868897007794117e-33
+// stddev(f - f_Boost): 7.8018521523926690e-17
+const testcase_comp_ellint_3<double>
+data016[10] =
+{
   { 1.7507538029157526, 0.60000000000000009, 0.0000000000000000 },
-  { 1.6648615773343014, 0.60000000000000009, 0.10000000000000001 },
-  { 1.5901418016279374, 0.60000000000000009, 0.20000000000000001 },
-  { 1.5243814243493585, 0.60000000000000009, 0.29999999999999999 },
-  { 1.4659345278069984, 0.60000000000000009, 0.40000000000000002 },
-  { 1.4135484285693078, 0.60000000000000009, 0.50000000000000000 },
-  { 1.3662507535812816, 0.60000000000000009, 0.59999999999999998 },
-  { 1.3232737468822811, 0.60000000000000009, 0.69999999999999996 },
-  { 1.2840021261752192, 0.60000000000000009, 0.80000000000000004 },
-  { 1.2479362973851875, 0.60000000000000009, 0.90000000000000002 },
+  { 1.8508766487100687, 0.60000000000000009, 0.10000000000000001 },
+  { 1.9695980282802217, 0.60000000000000009, 0.20000000000000001 },
+  { 2.1134154405060599, 0.60000000000000009, 0.30000000000000004 },
+  { 2.2925036420985130, 0.60000000000000009, 0.40000000000000002 },
+  { 2.5239007084492711, 0.60000000000000009, 0.50000000000000000 },
+  { 2.8388723099514976, 0.60000000000000009, 0.60000000000000009 },
+  { 3.3029735898397159, 0.60000000000000009, 0.70000000000000007 },
+  { 4.0867036409261832, 0.60000000000000009, 0.80000000000000004 },
+  { 5.8709993116265613, 0.60000000000000009, 0.90000000000000002 },
 };
-
-// Test function for k=0.60000000000000009.
-template <typename Tp>
-void test016()
+const double toler016 = 2.5000000000000020e-13;
+
+// Test data for k=0.70000000000000018.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 2.9298727220933567e-16
+// mean(f - f_Boost): 4.8849813083506892e-16
+// variance(f - f_Boost): 2.0476296953421943e-31
+// stddev(f - f_Boost): 4.5250742483877478e-16
+const testcase_comp_ellint_3<double>
+data017[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data016)
-                         / sizeof(testcase_comp_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::comp_ellint_3(Tp(data016[i].k), Tp(data016[i].nu));
-      const Tp f0 = data016[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.69999999999999996.
-testcase_comp_ellint_3<double> data017[] = {
-  { 1.8456939983747236, 0.69999999999999996, 0.0000000000000000 },
-  { 1.7528050171757608, 0.69999999999999996, 0.10000000000000001 },
-  { 1.6721098780092147, 0.69999999999999996, 0.20000000000000001 },
-  { 1.6011813647733213, 0.69999999999999996, 0.29999999999999999 },
-  { 1.5382162002954762, 0.69999999999999996, 0.40000000000000002 },
-  { 1.4818433192178544, 0.69999999999999996, 0.50000000000000000 },
-  { 1.4309994736080540, 0.69999999999999996, 0.59999999999999998 },
-  { 1.3848459188329196, 0.69999999999999996, 0.69999999999999996 },
-  { 1.3427110650397533, 0.69999999999999996, 0.80000000000000004 },
-  { 1.3040500499695911, 0.69999999999999996, 0.90000000000000002 },
+  { 1.8456939983747238, 0.70000000000000018, 0.0000000000000000 },
+  { 1.9541347343119566, 0.70000000000000018, 0.10000000000000001 },
+  { 2.0829290325820207, 0.70000000000000018, 0.20000000000000001 },
+  { 2.2392290510988540, 0.70000000000000018, 0.30000000000000004 },
+  { 2.4342502915307880, 0.70000000000000018, 0.40000000000000002 },
+  { 2.6868019968237000, 0.70000000000000018, 0.50000000000000000 },
+  { 3.0314573496746746, 0.70000000000000018, 0.60000000000000009 },
+  { 3.5408408771788569, 0.70000000000000018, 0.70000000000000007 },
+  { 4.4042405729076970, 0.70000000000000018, 0.80000000000000004 },
+  { 6.3796094177887763, 0.70000000000000018, 0.90000000000000002 },
 };
-
-// Test function for k=0.69999999999999996.
-template <typename Tp>
-void test017()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data017)
-                         / sizeof(testcase_comp_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::comp_ellint_3(Tp(data017[i].k), Tp(data017[i].nu));
-      const Tp f0 = data017[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+const double toler017 = 2.5000000000000020e-13;
 
 // Test data for k=0.80000000000000004.
-testcase_comp_ellint_3<double> data018[] = {
-  { 1.9953027776647296, 0.80000000000000004, 0.0000000000000000 },
-  { 1.8910755418379521, 0.80000000000000004, 0.10000000000000001 },
-  { 1.8007226661734588, 0.80000000000000004, 0.20000000000000001 },
-  { 1.7214611048717301, 0.80000000000000004, 0.29999999999999999 },
-  { 1.6512267838651289, 0.80000000000000004, 0.40000000000000002 },
-  { 1.5884528947755532, 0.80000000000000004, 0.50000000000000000 },
-  { 1.5319262547427865, 0.80000000000000004, 0.59999999999999998 },
-  { 1.4806912324625332, 0.80000000000000004, 0.69999999999999996 },
-  { 1.4339837018309474, 0.80000000000000004, 0.80000000000000004 },
-  { 1.3911845406776222, 0.80000000000000004, 0.90000000000000002 },
-};
-
-// Test function for k=0.80000000000000004.
-template <typename Tp>
-void test018()
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 4.1949393471095187e-16
+// mean(f - f_Boost): 9.5479180117763459e-16
+// variance(f - f_Boost): 5.4782007307014711e-34
+// stddev(f - f_Boost): 2.3405556457178006e-17
+const testcase_comp_ellint_3<double>
+data018[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data018)
-                         / sizeof(testcase_comp_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::comp_ellint_3(Tp(data018[i].k), Tp(data018[i].nu));
-      const Tp f0 = data018[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.89999999999999991.
-testcase_comp_ellint_3<double> data019[] = {
-  { 2.2805491384227699, 0.89999999999999991, 0.0000000000000000 },
-  { 2.1537868513875282, 0.89999999999999991, 0.10000000000000001 },
-  { 2.0443194576468890, 0.89999999999999991, 0.20000000000000001 },
-  { 1.9486280260314424, 0.89999999999999991, 0.29999999999999999 },
-  { 1.8641114227238347, 0.89999999999999991, 0.40000000000000002 },
-  { 1.7888013241937859, 0.89999999999999991, 0.50000000000000000 },
-  { 1.7211781128919521, 0.89999999999999991, 0.59999999999999998 },
-  { 1.6600480747670936, 0.89999999999999991, 0.69999999999999996 },
-  { 1.6044591960982200, 0.89999999999999991, 0.80000000000000004 },
-  { 1.5536420236310944, 0.89999999999999991, 0.90000000000000002 },
+  { 1.9953027776647294, 0.80000000000000004, 0.0000000000000000 },
+  { 2.1172616484005085, 0.80000000000000004, 0.10000000000000001 },
+  { 2.2624789434186798, 0.80000000000000004, 0.20000000000000001 },
+  { 2.4392042002725698, 0.80000000000000004, 0.30000000000000004 },
+  { 2.6604037035529728, 0.80000000000000004, 0.40000000000000002 },
+  { 2.9478781158239751, 0.80000000000000004, 0.50000000000000000 },
+  { 3.3418121892288055, 0.80000000000000004, 0.60000000000000009 },
+  { 3.9268876980046397, 0.80000000000000004, 0.70000000000000007 },
+  { 4.9246422058196071, 0.80000000000000004, 0.80000000000000004 },
+  { 7.2263259298637132, 0.80000000000000004, 0.90000000000000002 },
 };
-
-// Test function for k=0.89999999999999991.
-template <typename Tp>
-void test019()
+const double toler018 = 2.5000000000000020e-13;
+
+// Test data for k=0.90000000000000013.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 3
+// max(|f - f_Boost| / |f_Boost|): 1.5716352001310461e-16
+// mean(f - f_Boost): 4.4408920985006264e-17
+// variance(f - f_Boost): 2.4347558803117648e-34
+// stddev(f - f_Boost): 1.5603704304785339e-17
+const testcase_comp_ellint_3<double>
+data019[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data019)
-                         / sizeof(testcase_comp_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::comp_ellint_3(Tp(data019[i].k), Tp(data019[i].nu));
-      const Tp f0 = data019[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+  { 2.2805491384227707, 0.90000000000000013, 0.0000000000000000 },
+  { 2.4295011187834890, 0.90000000000000013, 0.10000000000000001 },
+  { 2.6076835743348421, 0.90000000000000013, 0.20000000000000001 },
+  { 2.8256506968858521, 0.90000000000000013, 0.30000000000000004 },
+  { 3.1000689868578628, 0.90000000000000013, 0.40000000000000002 },
+  { 3.4591069002104686, 0.90000000000000013, 0.50000000000000000 },
+  { 3.9549939883570242, 0.90000000000000013, 0.60000000000000009 },
+  { 4.6985482312992453, 0.90000000000000013, 0.70000000000000007 },
+  { 5.9820740813645727, 0.90000000000000013, 0.80000000000000004 },
+  { 8.9942562031858735, 0.90000000000000013, 0.90000000000000002 },
+};
+const double toler019 = 2.5000000000000020e-13;
+
+template<typename Ret, unsigned int Num>
+  void
+  test(const testcase_comp_ellint_3<Ret> (&data)[Num], Ret toler)
+  {
+    bool test __attribute__((unused)) = true;
+    const Ret eps = std::numeric_limits<Ret>::epsilon();
+    Ret max_abs_diff = -Ret(1);
+    Ret max_abs_frac = -Ret(1);
+    unsigned int num_datum = Num;
+    for (unsigned int i = 0; i < num_datum; ++i)
+      {
+	const Ret f = std::tr1::comp_ellint_3(data[i].k, data[i].nu);
+	const Ret f0 = data[i].f0;
+	const Ret diff = f - f0;
+	if (std::abs(diff) > max_abs_diff)
+	  max_abs_diff = std::abs(diff);
+	if (std::abs(f0) > Ret(10) * eps
+	 && std::abs(f) > Ret(10) * eps)
+	  {
+	    const Ret frac = diff / f0;
+	    if (std::abs(frac) > max_abs_frac)
+	      max_abs_frac = std::abs(frac);
+	  }
+      }
+    VERIFY(max_abs_frac < toler);
+  }
 
-int main(int, char**)
+int
+main()
 {
-  test001<double>();
-  test002<double>();
-  test003<double>();
-  test004<double>();
-  test005<double>();
-  test006<double>();
-  test007<double>();
-  test008<double>();
-  test009<double>();
-  test010<double>();
-  test011<double>();
-  test012<double>();
-  test013<double>();
-  test014<double>();
-  test015<double>();
-  test016<double>();
-  test017<double>();
-  test018<double>();
-  test019<double>();
+  test(data001, toler001);
+  test(data002, toler002);
+  test(data003, toler003);
+  test(data004, toler004);
+  test(data005, toler005);
+  test(data006, toler006);
+  test(data007, toler007);
+  test(data008, toler008);
+  test(data009, toler009);
+  test(data010, toler010);
+  test(data011, toler011);
+  test(data012, toler012);
+  test(data013, toler013);
+  test(data014, toler014);
+  test(data015, toler015);
+  test(data016, toler016);
+  test(data017, toler017);
+  test(data018, toler018);
+  test(data019, toler019);
   return 0;
 }
diff --git a/libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/06_comp_ellint_3/pr66689.cc b/libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/06_comp_ellint_3/pr66689.cc
new file mode 100644
index 00000000000..7b274d64d2b
--- /dev/null
+++ b/libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/06_comp_ellint_3/pr66689.cc
@@ -0,0 +1,20 @@
+
+#include <tr1/cmath>
+#include <testsuite_hooks.h>
+
+void
+test01()
+{
+  double Pi1 = std::tr1::comp_ellint_3(0.75, 0.0);
+  VERIFY(std::abs(Pi1 - 1.91099) < 0.00001);
+
+  double Pi2 = std::tr1::comp_ellint_3(0.75, 0.5);
+  VERIFY(std::abs(Pi2 - 2.80011) < 0.00001);
+}
+
+int
+main()
+{
+  test01();
+  return 0;
+}
diff --git a/libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/14_ellint_3/check_value.cc b/libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/14_ellint_3/check_value.cc
index 2e402c68793..e0bd7037480 100644
--- a/libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/14_ellint_3/check_value.cc
+++ b/libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/14_ellint_3/check_value.cc
@@ -1,6 +1,7 @@
-// 2007-02-04  Edward Smith-Rowland <3dw4rd@verizon.net>
+// { dg-do run { target c++11 } }
+// { dg-options "-D__STDCPP_WANT_MATH_SPEC_FUNCS__" }
 //
-// Copyright (C) 2007-2017 Free Software Foundation, Inc.
+// Copyright (C) 2016-2018 Free Software Foundation, Inc.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
 // software; you can redistribute it and/or modify it under the
@@ -18,10098 +19,6324 @@
 // <http://www.gnu.org/licenses/>.
 
 //  ellint_3
-
-
 //  Compare against values generated by the GNU Scientific Library.
 //  The GSL can be found on the web: http://www.gnu.org/software/gsl/
-
+#include <limits>
 #include <tr1/cmath>
 #if defined(__TEST_DEBUG)
-#include <iostream>
-#define VERIFY(A) \
-if (!(A)) \
-  { \
-    std::cout << "line " << __LINE__ \
-      << "  max_abs_frac = " << max_abs_frac \
-      << std::endl; \
-  }
+#  include <iostream>
+#  define VERIFY(A) \
+  if (!(A)) \
+    { \
+      std::cout << "line " << __LINE__ \
+	<< "  max_abs_frac = " << max_abs_frac \
+	<< std::endl; \
+    }
 #else
-#include <testsuite_hooks.h>
+#  include <testsuite_hooks.h>
 #endif
-#include "../testcase.h"
-
+#include <specfun_testcase.h>
 
 // Test data for k=-0.90000000000000002, nu=0.0000000000000000.
-testcase_ellint_3<double> data001[] = {
-  { -0.0000000000000000, -0.90000000000000002, 0.0000000000000000,
-          0.0000000000000000 },
-  { 0.17525427376115027, -0.90000000000000002, 0.0000000000000000,
-          0.17453292519943295 },
-  { 0.35492464591297446, -0.90000000000000002, 0.0000000000000000,
-          0.34906585039886590 },
-  { 0.54388221416157134, -0.90000000000000002, 0.0000000000000000,
-          0.52359877559829882 },
-  { 0.74797400423532523, -0.90000000000000002, 0.0000000000000000,
-          0.69813170079773179 },
-  { 0.97463898451966458, -0.90000000000000002, 0.0000000000000000,
-          0.87266462599716477 },
-  { 1.2334463254523440, -0.90000000000000002, 0.0000000000000000,
-          1.0471975511965976 },
-  { 1.5355247765594910, -0.90000000000000002, 0.0000000000000000,
-          1.2217304763960306 },
-  { 1.8882928567775124, -0.90000000000000002, 0.0000000000000000,
-          1.3962634015954636 },
-  { 2.2805491384227703, -0.90000000000000002, 0.0000000000000000,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.90000000000000002, nu=0.0000000000000000.
-template <typename Tp>
-void test001()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data001)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data001[i].k), Tp(data001[i].nu),
-                   Tp(data001[i].phi));
-      const Tp f0 = data001[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 5.7842011620951154e-16
+// mean(f - f_Boost): 5.8286708792820721e-17
+// variance(f - f_Boost): 4.1942474344433133e-34
+// stddev(f - f_Boost): 2.0479861900030756e-17
+const testcase_ellint_3<double>
+data001[10] =
+{
+  { 0.0000000000000000, -0.90000000000000002, 0.0000000000000000, 
+	  0.0000000000000000 },
+  { 0.17525427376115027, -0.90000000000000002, 0.0000000000000000, 
+	  0.17453292519943295 },
+  { 0.35492464591297446, -0.90000000000000002, 0.0000000000000000, 
+	  0.34906585039886590 },
+  { 0.54388221416157123, -0.90000000000000002, 0.0000000000000000, 
+	  0.52359877559829882 },
+  { 0.74797400423532512, -0.90000000000000002, 0.0000000000000000, 
+	  0.69813170079773179 },
+  { 0.97463898451966446, -0.90000000000000002, 0.0000000000000000, 
+	  0.87266462599716477 },
+  { 1.2334463254523438, -0.90000000000000002, 0.0000000000000000, 
+	  1.0471975511965976 },
+  { 1.5355247765594913, -0.90000000000000002, 0.0000000000000000, 
+	  1.2217304763960306 },
+  { 1.8882928567775126, -0.90000000000000002, 0.0000000000000000, 
+	  1.3962634015954636 },
+  { 2.2805491384227703, -0.90000000000000002, 0.0000000000000000, 
+	  1.5707963267948966 },
+};
+const double toler001 = 2.5000000000000020e-13;
 
 // Test data for k=-0.90000000000000002, nu=0.10000000000000001.
-testcase_ellint_3<double> data002[] = {
-  { -0.0000000000000000, -0.90000000000000002, 0.10000000000000001,
-          0.0000000000000000 },
-  { 0.17507714233254659, -0.90000000000000002, 0.10000000000000001,
-          0.17453292519943295 },
-  { 0.35350932904326521, -0.90000000000000002, 0.10000000000000001,
-          0.34906585039886590 },
-  { 0.53911129989870998, -0.90000000000000002, 0.10000000000000001,
-          0.52359877559829882 },
-  { 0.73666644254508429, -0.90000000000000002, 0.10000000000000001,
-          0.69813170079773179 },
-  { 0.95250736612100184, -0.90000000000000002, 0.10000000000000001,
-          0.87266462599716477 },
-  { 1.1950199550905594, -0.90000000000000002, 0.10000000000000001,
-          1.0471975511965976 },
-  { 1.4741687286340848, -0.90000000000000002, 0.10000000000000001,
-          1.2217304763960306 },
-  { 1.7968678183506059, -0.90000000000000002, 0.10000000000000001,
-          1.3962634015954636 },
-  { 2.1537868513875287, -0.90000000000000002, 0.10000000000000001,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.90000000000000002, nu=0.10000000000000001.
-template <typename Tp>
-void test002()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data002)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data002[i].k), Tp(data002[i].nu),
-                   Tp(data002[i].phi));
-      const Tp f0 = data002[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 4.1500594295134815e-16
+// mean(f - f_Boost): 1.0269562977782698e-16
+// variance(f - f_Boost): 1.4388836606733082e-32
+// stddev(f - f_Boost): 1.1995347684303728e-16
+const testcase_ellint_3<double>
+data002[10] =
+{
+  { 0.0000000000000000, -0.90000000000000002, 0.10000000000000001, 
+	  0.0000000000000000 },
+  { 0.17543204932716244, -0.90000000000000002, 0.10000000000000001, 
+	  0.17453292519943295 },
+  { 0.35636022898551184, -0.90000000000000002, 0.10000000000000001, 
+	  0.34906585039886590 },
+  { 0.54880278898382584, -0.90000000000000002, 0.10000000000000001, 
+	  0.52359877559829882 },
+  { 0.75988834774529268, -0.90000000000000002, 0.10000000000000001, 
+	  0.69813170079773179 },
+  { 0.99853303003568117, -0.90000000000000002, 0.10000000000000001, 
+	  0.87266462599716477 },
+  { 1.2759958823999022, -0.90000000000000002, 0.10000000000000001, 
+	  1.0471975511965976 },
+  { 1.6051187364639401, -0.90000000000000002, 0.10000000000000001, 
+	  1.2217304763960306 },
+  { 1.9941406879519472, -0.90000000000000002, 0.10000000000000001, 
+	  1.3962634015954636 },
+  { 2.4295011187834881, -0.90000000000000002, 0.10000000000000001, 
+	  1.5707963267948966 },
+};
+const double toler002 = 2.5000000000000020e-13;
 
 // Test data for k=-0.90000000000000002, nu=0.20000000000000001.
-testcase_ellint_3<double> data003[] = {
-  { -0.0000000000000000, -0.90000000000000002, 0.20000000000000001,
-          0.0000000000000000 },
-  { 0.17490065089140930, -0.90000000000000002, 0.20000000000000001,
-          0.17453292519943295 },
-  { 0.35211377590661436, -0.90000000000000002, 0.20000000000000001,
-          0.34906585039886590 },
-  { 0.53448220334204122, -0.90000000000000002, 0.20000000000000001,
-          0.52359877559829882 },
-  { 0.72591368943179613, -0.90000000000000002, 0.20000000000000001,
-          0.69813170079773179 },
-  { 0.93192539780038763, -0.90000000000000002, 0.20000000000000001,
-          0.87266462599716477 },
-  { 1.1600809679692683, -0.90000000000000002, 0.20000000000000001,
-          1.0471975511965976 },
-  { 1.4195407225882508, -0.90000000000000002, 0.20000000000000001,
-          1.2217304763960306 },
-  { 1.7168966476424528, -0.90000000000000002, 0.20000000000000001,
-          1.3962634015954636 },
-  { 2.0443194576468890, -0.90000000000000002, 0.20000000000000001,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.90000000000000002, nu=0.20000000000000001.
-template <typename Tp>
-void test003()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data003)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data003[i].k), Tp(data003[i].nu),
-                   Tp(data003[i].phi));
-      const Tp f0 = data003[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.90000000000000002, nu=0.29999999999999999.
-testcase_ellint_3<double> data004[] = {
-  { -0.0000000000000000, -0.90000000000000002, 0.29999999999999999,
-          0.0000000000000000 },
-  { 0.17472479532647534, -0.90000000000000002, 0.29999999999999999,
-          0.17453292519943295 },
-  { 0.35073750187374114, -0.90000000000000002, 0.29999999999999999,
-          0.34906585039886590 },
-  { 0.52998766129466979, -0.90000000000000002, 0.29999999999999999,
-          0.52359877559829882 },
-  { 0.71566993548699587, -0.90000000000000002, 0.29999999999999999,
-          0.69813170079773179 },
-  { 0.91271517762560195, -0.90000000000000002, 0.29999999999999999,
-          0.87266462599716477 },
-  { 1.1281241199843370, -0.90000000000000002, 0.29999999999999999,
-          1.0471975511965976 },
-  { 1.3704929576917448, -0.90000000000000002, 0.29999999999999999,
-          1.2217304763960306 },
-  { 1.6461981511487715, -0.90000000000000002, 0.29999999999999999,
-          1.3962634015954636 },
-  { 1.9486280260314426, -0.90000000000000002, 0.29999999999999999,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.90000000000000002, nu=0.29999999999999999.
-template <typename Tp>
-void test004()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data004)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data004[i].k), Tp(data004[i].nu),
-                   Tp(data004[i].phi));
-      const Tp f0 = data004[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 5.2711357908578066e-16
+// mean(f - f_Boost): 8.0491169285323847e-17
+// variance(f - f_Boost): 7.9985534974304465e-34
+// stddev(f - f_Boost): 2.8281714052423424e-17
+const testcase_ellint_3<double>
+data003[10] =
+{
+  { 0.0000000000000000, -0.90000000000000002, 0.20000000000000001, 
+	  0.0000000000000000 },
+  { 0.17561047321968409, -0.90000000000000002, 0.20000000000000001, 
+	  0.17453292519943295 },
+  { 0.35781659944356109, -0.90000000000000002, 0.20000000000000001, 
+	  0.34906585039886590 },
+  { 0.55388150905215283, -0.90000000000000002, 0.20000000000000001, 
+	  0.52359877559829882 },
+  { 0.77246874123251441, -0.90000000000000002, 0.20000000000000001, 
+	  0.69813170079773179 },
+  { 1.0244466254771925, -0.90000000000000002, 0.20000000000000001, 
+	  0.87266462599716477 },
+  { 1.3234824077640801, -0.90000000000000002, 0.20000000000000001, 
+	  1.0471975511965976 },
+  { 1.6849848968804237, -0.90000000000000002, 0.20000000000000001, 
+	  1.2217304763960306 },
+  { 2.1185749045502273, -0.90000000000000002, 0.20000000000000001, 
+	  1.3962634015954636 },
+  { 2.6076835743348412, -0.90000000000000002, 0.20000000000000001, 
+	  1.5707963267948966 },
+};
+const double toler003 = 2.5000000000000020e-13;
+
+// Test data for k=-0.90000000000000002, nu=0.30000000000000004.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 4.9955372494296814e-16
+// mean(f - f_Boost): 5.8286708792820721e-17
+// variance(f - f_Boost): 4.1942474344433133e-34
+// stddev(f - f_Boost): 2.0479861900030756e-17
+const testcase_ellint_3<double>
+data004[10] =
+{
+  { 0.0000000000000000, -0.90000000000000002, 0.30000000000000004, 
+	  0.0000000000000000 },
+  { 0.17578954966746221, -0.90000000000000002, 0.30000000000000004, 
+	  0.17453292519943295 },
+  { 0.35929429810867447, -0.90000000000000002, 0.30000000000000004, 
+	  0.34906585039886590 },
+  { 0.55912757154240811, -0.90000000000000002, 0.30000000000000004, 
+	  0.52359877559829882 },
+  { 0.78578314722025389, -0.90000000000000002, 0.30000000000000004, 
+	  0.69813170079773179 },
+  { 1.0526941001131365, -0.90000000000000002, 0.30000000000000004, 
+	  0.87266462599716477 },
+  { 1.3769682234538601, -0.90000000000000002, 0.30000000000000004, 
+	  1.0471975511965976 },
+  { 1.7779437432911238, -0.90000000000000002, 0.30000000000000004, 
+	  1.2217304763960306 },
+  { 2.2676509341813631, -0.90000000000000002, 0.30000000000000004, 
+	  1.3962634015954636 },
+  { 2.8256506968858512, -0.90000000000000002, 0.30000000000000004, 
+	  1.5707963267948966 },
+};
+const double toler004 = 2.5000000000000020e-13;
 
 // Test data for k=-0.90000000000000002, nu=0.40000000000000002.
-testcase_ellint_3<double> data005[] = {
-  { -0.0000000000000000, -0.90000000000000002, 0.40000000000000002,
-          0.0000000000000000 },
-  { 0.17454957156468839, -0.90000000000000002, 0.40000000000000002,
-          0.17453292519943295 },
-  { 0.34938003933330430, -0.90000000000000002, 0.40000000000000002,
-          0.34906585039886590 },
-  { 0.52562093533067455, -0.90000000000000002, 0.40000000000000002,
-          0.52359877559829882 },
-  { 0.70589461324915703, -0.90000000000000002, 0.40000000000000002,
-          0.69813170079773179 },
-  { 0.89472658511942849, -0.90000000000000002, 0.40000000000000002,
-          0.87266462599716477 },
-  { 1.0987419542323440, -0.90000000000000002, 0.40000000000000002,
-          1.0471975511965976 },
-  { 1.3261349565496301, -0.90000000000000002, 0.40000000000000002,
-          1.2217304763960306 },
-  { 1.5831293909853767, -0.90000000000000002, 0.40000000000000002,
-          1.3962634015954636 },
-  { 1.8641114227238349, -0.90000000000000002, 0.40000000000000002,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.90000000000000002, nu=0.40000000000000002.
-template <typename Tp>
-void test005()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data005)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data005[i].k), Tp(data005[i].nu),
-                   Tp(data005[i].phi));
-      const Tp f0 = data005[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 4.7042235432234642e-16
+// mean(f - f_Boost): 2.0261570199409106e-16
+// variance(f - f_Boost): 5.8024227149195491e-32
+// stddev(f - f_Boost): 2.4088218520512364e-16
+const testcase_ellint_3<double>
+data005[10] =
+{
+  { 0.0000000000000000, -0.90000000000000002, 0.40000000000000002, 
+	  0.0000000000000000 },
+  { 0.17596928293938452, -0.90000000000000002, 0.40000000000000002, 
+	  0.17453292519943295 },
+  { 0.36079388642472821, -0.90000000000000002, 0.40000000000000002, 
+	  0.34906585039886590 },
+  { 0.56455096667115612, -0.90000000000000002, 0.40000000000000002, 
+	  0.52359877559829882 },
+  { 0.79990996997869435, -0.90000000000000002, 0.40000000000000002, 
+	  0.69813170079773179 },
+  { 1.0836647913872215, -0.90000000000000002, 0.40000000000000002, 
+	  0.87266462599716477 },
+  { 1.4378726836091849, -0.90000000000000002, 0.40000000000000002, 
+	  1.0471975511965976 },
+  { 1.8880446720682853, -0.90000000000000002, 0.40000000000000002, 
+	  1.2217304763960306 },
+  { 2.4505848932025227, -0.90000000000000002, 0.40000000000000002, 
+	  1.3962634015954636 },
+  { 3.1000689868578615, -0.90000000000000002, 0.40000000000000002, 
+	  1.5707963267948966 },
+};
+const double toler005 = 2.5000000000000020e-13;
 
 // Test data for k=-0.90000000000000002, nu=0.50000000000000000.
-testcase_ellint_3<double> data006[] = {
-  { -0.0000000000000000, -0.90000000000000002, 0.50000000000000000,
-          0.0000000000000000 },
-  { 0.17437497557073336, -0.90000000000000002, 0.50000000000000000,
-          0.17453292519943295 },
-  { 0.34804093691586013, -0.90000000000000002, 0.50000000000000000,
-          0.34906585039886590 },
-  { 0.52137576320372914, -0.90000000000000002, 0.50000000000000000,
-          0.52359877559829882 },
-  { 0.69655163996912284, -0.90000000000000002, 0.50000000000000000,
-          0.69813170079773179 },
-  { 0.87783188683054236, -0.90000000000000002, 0.50000000000000000,
-          0.87266462599716477 },
-  { 1.0716015959755185, -0.90000000000000002, 0.50000000000000000,
-          1.0471975511965976 },
-  { 1.2857636916026747, -0.90000000000000002, 0.50000000000000000,
-          1.2217304763960306 },
-  { 1.5264263913252365, -0.90000000000000002, 0.50000000000000000,
-          1.3962634015954636 },
-  { 1.7888013241937861, -0.90000000000000002, 0.50000000000000000,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.90000000000000002, nu=0.50000000000000000.
-template <typename Tp>
-void test006()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data006)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data006[i].k), Tp(data006[i].nu),
-                   Tp(data006[i].phi));
-      const Tp f0 = data006[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.90000000000000002, nu=0.59999999999999998.
-testcase_ellint_3<double> data007[] = {
-  { -0.0000000000000000, -0.90000000000000002, 0.59999999999999998,
-          0.0000000000000000 },
-  { 0.17420100334657815, -0.90000000000000002, 0.59999999999999998,
-          0.17453292519943295 },
-  { 0.34671975876122157, -0.90000000000000002, 0.59999999999999998,
-          0.34906585039886590 },
-  { 0.51724631570707968, -0.90000000000000002, 0.59999999999999998,
-          0.52359877559829882 },
-  { 0.68760879113743056, -0.90000000000000002, 0.59999999999999998,
-          0.69813170079773179 },
-  { 0.86192157779698364, -0.90000000000000002, 0.59999999999999998,
-          0.87266462599716477 },
-  { 1.0464279696166354, -0.90000000000000002, 0.59999999999999998,
-          1.0471975511965976 },
-  { 1.2488156247094004, -0.90000000000000002, 0.59999999999999998,
-          1.2217304763960306 },
-  { 1.4750988777188474, -0.90000000000000002, 0.59999999999999998,
-          1.3962634015954636 },
-  { 1.7211781128919523, -0.90000000000000002, 0.59999999999999998,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.90000000000000002, nu=0.59999999999999998.
-template <typename Tp>
-void test007()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data007)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data007[i].k), Tp(data007[i].nu),
-                   Tp(data007[i].phi));
-      const Tp f0 = data007[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.90000000000000002, nu=0.69999999999999996.
-testcase_ellint_3<double> data008[] = {
-  { -0.0000000000000000, -0.90000000000000002, 0.69999999999999996,
-          0.0000000000000000 },
-  { 0.17402765093102210, -0.90000000000000002, 0.69999999999999996,
-          0.17453292519943295 },
-  { 0.34541608382635131, -0.90000000000000002, 0.69999999999999996,
-          0.34906585039886590 },
-  { 0.51322715827061705, -0.90000000000000002, 0.69999999999999996,
-          0.52359877559829882 },
-  { 0.67903717872440306, -0.90000000000000002, 0.69999999999999996,
-          0.69813170079773179 },
-  { 0.84690113601682671, -0.90000000000000002, 0.69999999999999996,
-          0.87266462599716477 },
-  { 1.0229914311548418, -0.90000000000000002, 0.69999999999999996,
-          1.0471975511965976 },
-  { 1.2148329639709381, -0.90000000000000002, 0.69999999999999996,
-          1.2217304763960306 },
-  { 1.4283586501307806, -0.90000000000000002, 0.69999999999999996,
-          1.3962634015954636 },
-  { 1.6600480747670938, -0.90000000000000002, 0.69999999999999996,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.90000000000000002, nu=0.69999999999999996.
-template <typename Tp>
-void test008()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data008)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data008[i].k), Tp(data008[i].nu),
-                   Tp(data008[i].phi));
-      const Tp f0 = data008[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 6
+// max(|f - f_Boost| / |f_Boost|): 3.8944086593755267e-16
+// mean(f - f_Boost): 6.9388939039072284e-17
+// variance(f - f_Boost): 1.7333369499485123e-32
+// stddev(f - f_Boost): 1.3165625507162629e-16
+const testcase_ellint_3<double>
+data006[10] =
+{
+  { 0.0000000000000000, -0.90000000000000002, 0.50000000000000000, 
+	  0.0000000000000000 },
+  { 0.17614967734498183, -0.90000000000000002, 0.50000000000000000, 
+	  0.17453292519943295 },
+  { 0.36231594750319435, -0.90000000000000002, 0.50000000000000000, 
+	  0.34906585039886590 },
+  { 0.57016256984349567, -0.90000000000000002, 0.50000000000000000, 
+	  0.52359877559829882 },
+  { 0.81494025918293422, -0.90000000000000002, 0.50000000000000000, 
+	  0.69813170079773179 },
+  { 1.1178482279283477, -0.90000000000000002, 0.50000000000000000, 
+	  0.87266462599716477 },
+  { 1.5081455873012106, -0.90000000000000002, 0.50000000000000000, 
+	  1.0471975511965976 },
+  { 2.0213599730863998, -0.90000000000000002, 0.50000000000000000, 
+	  1.2217304763960306 },
+  { 2.6822467012926827, -0.90000000000000002, 0.50000000000000000, 
+	  1.3962634015954636 },
+  { 3.4591069002104677, -0.90000000000000002, 0.50000000000000000, 
+	  1.5707963267948966 },
+};
+const double toler006 = 2.5000000000000020e-13;
+
+// Test data for k=-0.90000000000000002, nu=0.60000000000000009.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 4.0602096790645418e-16
+// mean(f - f_Boost): 1.0269562977782698e-16
+// variance(f - f_Boost): 1.4388836606733082e-32
+// stddev(f - f_Boost): 1.1995347684303728e-16
+const testcase_ellint_3<double>
+data007[10] =
+{
+  { 0.0000000000000000, -0.90000000000000002, 0.60000000000000009, 
+	  0.0000000000000000 },
+  { 0.17633073723493825, -0.90000000000000002, 0.60000000000000009, 
+	  0.17453292519943295 },
+  { 0.36386108723492810, -0.90000000000000002, 0.60000000000000009, 
+	  0.34906585039886590 },
+  { 0.57597424744716241, -0.90000000000000002, 0.60000000000000009, 
+	  0.52359877559829882 },
+  { 0.83098051948501150, -0.90000000000000002, 0.60000000000000009, 
+	  0.69813170079773179 },
+  { 1.1558706545698916, -0.90000000000000002, 0.60000000000000009, 
+	  0.87266462599716477 },
+  { 1.5905576379415669, -0.90000000000000002, 0.60000000000000009, 
+	  1.0471975511965976 },
+  { 2.1875186010215080, -0.90000000000000002, 0.60000000000000009, 
+	  1.2217304763960306 },
+  { 2.9885767771316849, -0.90000000000000002, 0.60000000000000009, 
+	  1.3962634015954636 },
+  { 3.9549939883570224, -0.90000000000000002, 0.60000000000000009, 
+	  1.5707963267948966 },
+};
+const double toler007 = 2.5000000000000020e-13;
+
+// Test data for k=-0.90000000000000002, nu=0.70000000000000007.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 5.1938610791060186e-16
+// mean(f - f_Boost): 3.0253577421035517e-16
+// variance(f - f_Boost): 4.2342877557562532e-32
+// stddev(f - f_Boost): 2.0577385051935665e-16
+const testcase_ellint_3<double>
+data008[10] =
+{
+  { 0.0000000000000000, -0.90000000000000002, 0.70000000000000007, 
+	  0.0000000000000000 },
+  { 0.17651246700160939, -0.90000000000000002, 0.70000000000000007, 
+	  0.17453292519943295 },
+  { 0.36542993547358982, -0.90000000000000002, 0.70000000000000007, 
+	  0.34906585039886590 },
+  { 0.58199897877674867, -0.90000000000000002, 0.70000000000000007, 
+	  0.52359877559829882 },
+  { 0.84815633587352857, -0.90000000000000002, 0.70000000000000007, 
+	  0.69813170079773179 },
+  { 1.1985495623872375, -0.90000000000000002, 0.70000000000000007, 
+	  0.87266462599716477 },
+  { 1.6892158134027688, -0.90000000000000002, 0.70000000000000007, 
+	  1.0471975511965976 },
+  { 2.4029722191094236, -0.90000000000000002, 0.70000000000000007, 
+	  1.2217304763960306 },
+  { 3.4201084941340052, -0.90000000000000002, 0.70000000000000007, 
+	  1.3962634015954636 },
+  { 4.6985482312992435, -0.90000000000000002, 0.70000000000000007, 
+	  1.5707963267948966 },
+};
+const double toler008 = 2.5000000000000020e-13;
 
 // Test data for k=-0.90000000000000002, nu=0.80000000000000004.
-testcase_ellint_3<double> data009[] = {
-  { -0.0000000000000000, -0.90000000000000002, 0.80000000000000004,
-          0.0000000000000000 },
-  { 0.17385491439925149, -0.90000000000000002, 0.80000000000000004,
-          0.17453292519943295 },
-  { 0.34412950523113928, -0.90000000000000002, 0.80000000000000004,
-          0.34906585039886590 },
-  { 0.50931321668729612, -0.90000000000000002, 0.80000000000000004,
-          0.52359877559829882 },
-  { 0.67081081392296349, -0.90000000000000002, 0.80000000000000004,
-          0.69813170079773179 },
-  { 0.83268846097293259, -0.90000000000000002, 0.80000000000000004,
-          0.87266462599716477 },
-  { 1.0010985015814027, -0.90000000000000002, 0.80000000000000004,
-          1.0471975511965976 },
-  { 1.1834394045489678, -0.90000000000000002, 0.80000000000000004,
-          1.2217304763960306 },
-  { 1.3855695891683188, -0.90000000000000002, 0.80000000000000004,
-          1.3962634015954636 },
-  { 1.6044591960982204, -0.90000000000000002, 0.80000000000000004,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.90000000000000002, nu=0.80000000000000004.
-template <typename Tp>
-void test009()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data009)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data009[i].k), Tp(data009[i].nu),
-                   Tp(data009[i].phi));
-      const Tp f0 = data009[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 2.6645352591003757e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 6.5091520146032660e-16
+// mean(f - f_Boost): 2.8310687127941490e-16
+// variance(f - f_Boost): 9.8950000698295322e-33
+// stddev(f - f_Boost): 9.9473614943006532e-17
+const testcase_ellint_3<double>
+data009[10] =
+{
+  { 0.0000000000000000, -0.90000000000000002, 0.80000000000000004, 
+	  0.0000000000000000 },
+  { 0.17669487107954862, -0.90000000000000002, 0.80000000000000004, 
+	  0.17453292519943295 },
+  { 0.36702314729628421, -0.90000000000000002, 0.80000000000000004, 
+	  0.34906585039886590 },
+  { 0.58825099711365492, -0.90000000000000002, 0.80000000000000004, 
+	  0.52359877559829882 },
+  { 0.86661711422209031, -0.90000000000000002, 0.80000000000000004, 
+	  0.69813170079773179 },
+  { 1.2469779109884802, -0.90000000000000002, 0.80000000000000004, 
+	  0.87266462599716477 },
+  { 1.8105469760531578, -0.90000000000000002, 0.80000000000000004, 
+	  1.0471975511965976 },
+  { 2.6989505165893752, -0.90000000000000002, 0.80000000000000004, 
+	  1.2217304763960306 },
+  { 4.0935213267757424, -0.90000000000000002, 0.80000000000000004, 
+	  1.3962634015954636 },
+  { 5.9820740813645710, -0.90000000000000002, 0.80000000000000004, 
+	  1.5707963267948966 },
+};
+const double toler009 = 2.5000000000000020e-13;
 
 // Test data for k=-0.90000000000000002, nu=0.90000000000000002.
-testcase_ellint_3<double> data010[] = {
-  { -0.0000000000000000, -0.90000000000000002, 0.90000000000000002,
-          0.0000000000000000 },
-  { 0.17368278986240138, -0.90000000000000002, 0.90000000000000002,
-          0.17453292519943295 },
-  { 0.34285962963961397, -0.90000000000000002, 0.90000000000000002,
-          0.34906585039886590 },
-  { 0.50549974644993323, -0.90000000000000002, 0.90000000000000002,
-          0.52359877559829882 },
-  { 0.66290623857720898, -0.90000000000000002, 0.90000000000000002,
-          0.69813170079773179 },
-  { 0.81921183128847164, -0.90000000000000002, 0.90000000000000002,
-          0.87266462599716477 },
-  { 0.98058481956066390, -0.90000000000000002, 0.90000000000000002,
-          1.0471975511965976 },
-  { 1.1543223520473567, -0.90000000000000002, 0.90000000000000002,
-          1.2217304763960306 },
-  { 1.3462119782292938, -0.90000000000000002, 0.90000000000000002,
-          1.3962634015954636 },
-  { 1.5536420236310946, -0.90000000000000002, 0.90000000000000002,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.90000000000000002, nu=0.90000000000000002.
-template <typename Tp>
-void test010()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data010)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data010[i].k), Tp(data010[i].nu),
-                   Tp(data010[i].phi));
-      const Tp f0 = data010[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 4.4408920985006262e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 8.2628580104449673e-16
+// mean(f - f_Boost): 8.5764728652293339e-16
+// variance(f - f_Boost): 8.9671393318321280e-31
+// stddev(f - f_Boost): 9.4694980499666013e-16
+const testcase_ellint_3<double>
+data010[10] =
+{
+  { 0.0000000000000000, -0.90000000000000002, 0.90000000000000002, 
+	  0.0000000000000000 },
+  { 0.17687795394604169, -0.90000000000000002, 0.90000000000000002, 
+	  0.17453292519943295 },
+  { 0.36864140434751286, -0.90000000000000002, 0.90000000000000002, 
+	  0.34906585039886590 },
+  { 0.59474595366817051, -0.90000000000000002, 0.90000000000000002, 
+	  0.52359877559829882 },
+  { 0.88654237226056665, -0.90000000000000002, 0.90000000000000002, 
+	  0.69813170079773179 },
+  { 1.3026595810616726, -0.90000000000000002, 0.90000000000000002, 
+	  0.87266462599716477 },
+  { 1.9653635459278078, -0.90000000000000002, 0.90000000000000002, 
+	  1.0471975511965976 },
+  { 3.1451407527189463, -0.90000000000000002, 0.90000000000000002, 
+	  1.2217304763960306 },
+  { 5.3745230680316114, -0.90000000000000002, 0.90000000000000002, 
+	  1.3962634015954636 },
+  { 8.9942562031858682, -0.90000000000000002, 0.90000000000000002, 
+	  1.5707963267948966 },
+};
+const double toler010 = 2.5000000000000020e-13;
 
 // Test data for k=-0.80000000000000004, nu=0.0000000000000000.
-testcase_ellint_3<double> data011[] = {
-  { -0.0000000000000000, -0.80000000000000004, 0.0000000000000000,
-          0.0000000000000000 },
-  { 0.17510154241338902, -0.80000000000000004, 0.0000000000000000,
-          0.17453292519943295 },
-  { 0.35365068839779390, -0.80000000000000004, 0.0000000000000000,
-          0.34906585039886590 },
-  { 0.53926804409084561, -0.80000000000000004, 0.0000000000000000,
-          0.52359877559829882 },
-  { 0.73587926028070383, -0.80000000000000004, 0.0000000000000000,
-          0.69813170079773179 },
-  { 0.94770942970071170, -0.80000000000000004, 0.0000000000000000,
-          0.87266462599716477 },
-  { 1.1789022995388239, -0.80000000000000004, 0.0000000000000000,
-          1.0471975511965976 },
-  { 1.4323027881876009, -0.80000000000000004, 0.0000000000000000,
-          1.2217304763960306 },
-  { 1.7069629739121674, -0.80000000000000004, 0.0000000000000000,
-          1.3962634015954636 },
-  { 1.9953027776647296, -0.80000000000000004, 0.0000000000000000,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.80000000000000004, nu=0.0000000000000000.
-template <typename Tp>
-void test011()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data011)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data011[i].k), Tp(data011[i].nu),
-                   Tp(data011[i].phi));
-      const Tp f0 = data011[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 1.5543122344752192e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 7.7898565163847540e-16
+// mean(f - f_Boost): 2.3869795029440865e-16
+// variance(f - f_Boost): 2.1368406725192426e-31
+// stddev(f - f_Boost): 4.6225974002926564e-16
+const testcase_ellint_3<double>
+data011[10] =
+{
+  { 0.0000000000000000, -0.80000000000000004, 0.0000000000000000, 
+	  0.0000000000000000 },
+  { 0.17510154241338899, -0.80000000000000004, 0.0000000000000000, 
+	  0.17453292519943295 },
+  { 0.35365068839779396, -0.80000000000000004, 0.0000000000000000, 
+	  0.34906585039886590 },
+  { 0.53926804409084550, -0.80000000000000004, 0.0000000000000000, 
+	  0.52359877559829882 },
+  { 0.73587926028070372, -0.80000000000000004, 0.0000000000000000, 
+	  0.69813170079773179 },
+  { 0.94770942970071170, -0.80000000000000004, 0.0000000000000000, 
+	  0.87266462599716477 },
+  { 1.1789022995388236, -0.80000000000000004, 0.0000000000000000, 
+	  1.0471975511965976 },
+  { 1.4323027881876012, -0.80000000000000004, 0.0000000000000000, 
+	  1.2217304763960306 },
+  { 1.7069629739121677, -0.80000000000000004, 0.0000000000000000, 
+	  1.3962634015954636 },
+  { 1.9953027776647294, -0.80000000000000004, 0.0000000000000000, 
+	  1.5707963267948966 },
+};
+const double toler011 = 2.5000000000000020e-13;
 
 // Test data for k=-0.80000000000000004, nu=0.10000000000000001.
-testcase_ellint_3<double> data012[] = {
-  { -0.0000000000000000, -0.80000000000000004, 0.10000000000000001,
-          0.0000000000000000 },
-  { 0.17492468824017166, -0.80000000000000004, 0.10000000000000001,
-          0.17453292519943295 },
-  { 0.35224443521476911, -0.80000000000000004, 0.10000000000000001,
-          0.34906585039886590 },
-  { 0.53456851853226961, -0.80000000000000004, 0.10000000000000001,
-          0.52359877559829882 },
-  { 0.72488875602364944, -0.80000000000000004, 0.10000000000000001,
-          0.69813170079773179 },
-  { 0.92661354274638952, -0.80000000000000004, 0.10000000000000001,
-          0.87266462599716477 },
-  { 1.1432651144499077, -0.80000000000000004, 0.10000000000000001,
-          1.0471975511965976 },
-  { 1.3774479927211429, -0.80000000000000004, 0.10000000000000001,
-          1.2217304763960306 },
-  { 1.6287092337196041, -0.80000000000000004, 0.10000000000000001,
-          1.3962634015954636 },
-  { 1.8910755418379521, -0.80000000000000004, 0.10000000000000001,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.80000000000000004, nu=0.10000000000000001.
-template <typename Tp>
-void test012()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data012)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data012[i].k), Tp(data012[i].nu),
-                   Tp(data012[i].phi));
-      const Tp f0 = data012[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 8.3898786942190374e-16
+// mean(f - f_Boost): 2.3869795029440865e-16
+// variance(f - f_Boost): 2.9190059990693968e-31
+// stddev(f - f_Boost): 5.4027826155319237e-16
+const testcase_ellint_3<double>
+data012[10] =
+{
+  { 0.0000000000000000, -0.80000000000000004, 0.10000000000000001, 
+	  0.0000000000000000 },
+  { 0.17527903952342144, -0.80000000000000004, 0.10000000000000001, 
+	  0.17453292519943295 },
+  { 0.35507705313548549, -0.80000000000000004, 0.10000000000000001, 
+	  0.34906585039886590 },
+  { 0.54411455987643553, -0.80000000000000004, 0.10000000000000001, 
+	  0.52359877559829882 },
+  { 0.74745625666804383, -0.80000000000000004, 0.10000000000000001, 
+	  0.69813170079773179 },
+  { 0.97046953684238557, -0.80000000000000004, 0.10000000000000001, 
+	  0.87266462599716477 },
+  { 1.2183080025184605, -0.80000000000000004, 0.10000000000000001, 
+	  1.0471975511965976 },
+  { 1.4943711151994405, -0.80000000000000004, 0.10000000000000001, 
+	  1.2217304763960306 },
+  { 1.7972401309544201, -0.80000000000000004, 0.10000000000000001, 
+	  1.3962634015954636 },
+  { 2.1172616484005085, -0.80000000000000004, 0.10000000000000001, 
+	  1.5707963267948966 },
+};
+const double toler012 = 2.5000000000000020e-13;
 
 // Test data for k=-0.80000000000000004, nu=0.20000000000000001.
-testcase_ellint_3<double> data013[] = {
-  { -0.0000000000000000, -0.80000000000000004, 0.20000000000000001,
-          0.0000000000000000 },
-  { 0.17474847286224943, -0.80000000000000004, 0.20000000000000001,
-          0.17453292519943295 },
-  { 0.35085779529084682, -0.80000000000000004, 0.20000000000000001,
-          0.34906585039886590 },
-  { 0.53000829263059157, -0.80000000000000004, 0.20000000000000001,
-          0.52359877559829882 },
-  { 0.71443466027453406, -0.80000000000000004, 0.20000000000000001,
-          0.69813170079773179 },
-  { 0.90698196872715420, -0.80000000000000004, 0.20000000000000001,
-          0.87266462599716477 },
-  { 1.1108198200558581, -0.80000000000000004, 0.20000000000000001,
-          1.0471975511965976 },
-  { 1.3284988909963957, -0.80000000000000004, 0.20000000000000001,
-          1.2217304763960306 },
-  { 1.5600369318140328, -0.80000000000000004, 0.20000000000000001,
-          1.3962634015954636 },
-  { 1.8007226661734588, -0.80000000000000004, 0.20000000000000001,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.80000000000000004, nu=0.20000000000000001.
-template <typename Tp>
-void test013()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data013)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data013[i].k), Tp(data013[i].nu),
-                   Tp(data013[i].phi));
-      const Tp f0 = data013[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.80000000000000004, nu=0.29999999999999999.
-testcase_ellint_3<double> data014[] = {
-  { -0.0000000000000000, -0.80000000000000004, 0.29999999999999999,
-          0.0000000000000000 },
-  { 0.17457289217669891, -0.80000000000000004, 0.29999999999999999,
-          0.17453292519943295 },
-  { 0.34949028801501258, -0.80000000000000004, 0.29999999999999999,
-          0.34906585039886590 },
-  { 0.52558024362769318, -0.80000000000000004, 0.29999999999999999,
-          0.52359877559829882 },
-  { 0.70447281740094914, -0.80000000000000004, 0.29999999999999999,
-          0.69813170079773179 },
-  { 0.88864745641528986, -0.80000000000000004, 0.29999999999999999,
-          0.87266462599716477 },
-  { 1.0811075819341465, -0.80000000000000004, 0.29999999999999999,
-          1.0471975511965976 },
-  { 1.2844589654082377, -0.80000000000000004, 0.29999999999999999,
-          1.2217304763960306 },
-  { 1.4991461361277849, -0.80000000000000004, 0.29999999999999999,
-          1.3962634015954636 },
-  { 1.7214611048717301, -0.80000000000000004, 0.29999999999999999,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.80000000000000004, nu=0.29999999999999999.
-template <typename Tp>
-void test014()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data014)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data014[i].k), Tp(data014[i].nu),
-                   Tp(data014[i].phi));
-      const Tp f0 = data014[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 7.8513740186068518e-16
+// mean(f - f_Boost): 2.8310687127941490e-16
+// variance(f - f_Boost): 2.7528339102381189e-31
+// stddev(f - f_Boost): 5.2467455724840699e-16
+const testcase_ellint_3<double>
+data013[10] =
+{
+  { 0.0000000000000000, -0.80000000000000004, 0.20000000000000001, 
+	  0.0000000000000000 },
+  { 0.17545718375086419, -0.80000000000000004, 0.20000000000000001, 
+	  0.17453292519943295 },
+  { 0.35652404627248163, -0.80000000000000004, 0.20000000000000001, 
+	  0.34906585039886590 },
+  { 0.54911638512920913, -0.80000000000000004, 0.20000000000000001, 
+	  0.52359877559829882 },
+  { 0.75967684282131176, -0.80000000000000004, 0.20000000000000001, 
+	  0.69813170079773179 },
+  { 0.99513526893543769, -0.80000000000000004, 0.20000000000000001, 
+	  0.87266462599716477 },
+  { 1.2622192109995993, -0.80000000000000004, 0.20000000000000001, 
+	  1.0471975511965976 },
+  { 1.5654106676347741, -0.80000000000000004, 0.20000000000000001, 
+	  1.2217304763960306 },
+  { 1.9029531718534984, -0.80000000000000004, 0.20000000000000001, 
+	  1.3962634015954636 },
+  { 2.2624789434186798, -0.80000000000000004, 0.20000000000000001, 
+	  1.5707963267948966 },
+};
+const double toler013 = 2.5000000000000020e-13;
+
+// Test data for k=-0.80000000000000004, nu=0.30000000000000004.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 7.2825261583337354e-16
+// mean(f - f_Boost): 2.6367796834847468e-16
+// variance(f - f_Boost): 2.8249350208968825e-31
+// stddev(f - f_Boost): 5.3150117788175054e-16
+const testcase_ellint_3<double>
+data014[10] =
+{
+  { 0.0000000000000000, -0.80000000000000004, 0.30000000000000004, 
+	  0.0000000000000000 },
+  { 0.17563597931587369, -0.80000000000000004, 0.30000000000000004, 
+	  0.17453292519943295 },
+  { 0.35799220412005128, -0.80000000000000004, 0.30000000000000004, 
+	  0.34906585039886590 },
+  { 0.55428253691111318, -0.80000000000000004, 0.30000000000000004, 
+	  0.52359877559829882 },
+  { 0.77260647376977365, -0.80000000000000004, 0.30000000000000004, 
+	  0.69813170079773179 },
+  { 1.0220015271210958, -0.80000000000000004, 0.30000000000000004, 
+	  0.87266462599716477 },
+  { 1.3115965312302671, -0.80000000000000004, 0.30000000000000004, 
+	  1.0471975511965976 },
+  { 1.6478518468813512, -0.80000000000000004, 0.30000000000000004, 
+	  1.2217304763960306 },
+  { 2.0290458414203481, -0.80000000000000004, 0.30000000000000004, 
+	  1.3962634015954636 },
+  { 2.4392042002725693, -0.80000000000000004, 0.30000000000000004, 
+	  1.5707963267948966 },
+};
+const double toler014 = 2.5000000000000020e-13;
 
 // Test data for k=-0.80000000000000004, nu=0.40000000000000002.
-testcase_ellint_3<double> data015[] = {
-  { -0.0000000000000000, -0.80000000000000004, 0.40000000000000002,
-          0.0000000000000000 },
-  { 0.17439794211872178, -0.80000000000000004, 0.40000000000000002,
-          0.17453292519943295 },
-  { 0.34814144964568972, -0.80000000000000004, 0.40000000000000002,
-          0.34906585039886590 },
-  { 0.52127776285273075, -0.80000000000000004, 0.40000000000000002,
-          0.52359877559829882 },
-  { 0.69496411438966599, -0.80000000000000004, 0.40000000000000002,
-          0.69813170079773179 },
-  { 0.87146878427509589, -0.80000000000000004, 0.40000000000000002,
-          0.87266462599716477 },
-  { 1.0537579024937762, -0.80000000000000004, 0.40000000000000002,
-          1.0471975511965976 },
-  { 1.2445534387922637, -0.80000000000000004, 0.40000000000000002,
-          1.2217304763960306 },
-  { 1.4446769766361993, -0.80000000000000004, 0.40000000000000002,
-          1.3962634015954636 },
-  { 1.6512267838651289, -0.80000000000000004, 0.40000000000000002,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.80000000000000004, nu=0.40000000000000002.
-template <typename Tp>
-void test015()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data015)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data015[i].k), Tp(data015[i].nu),
-                   Tp(data015[i].phi));
-      const Tp f0 = data015[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 2.2204460492503131e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 8.3462748389836647e-16
+// mean(f - f_Boost): 3.3861802251067273e-16
+// variance(f - f_Boost): 4.3719465706454422e-31
+// stddev(f - f_Boost): 6.6120696991527871e-16
+const testcase_ellint_3<double>
+data015[10] =
+{
+  { 0.0000000000000000, -0.80000000000000004, 0.40000000000000002, 
+	  0.0000000000000000 },
+  { 0.17581543047866136, -0.80000000000000004, 0.40000000000000002, 
+	  0.17453292519943295 },
+  { 0.35948208343061633, -0.80000000000000004, 0.40000000000000002, 
+	  0.34906585039886590 },
+  { 0.55962280893702021, -0.80000000000000004, 0.40000000000000002, 
+	  0.52359877559829882 },
+  { 0.78632063889234116, -0.80000000000000004, 0.40000000000000002, 
+	  0.69813170079773179 },
+  { 1.0514333069550323, -0.80000000000000004, 0.40000000000000002, 
+	  0.87266462599716477 },
+  { 1.3677213138838757, -0.80000000000000004, 0.40000000000000002, 
+	  1.0471975511965976 },
+  { 1.7451736773665165, -0.80000000000000004, 0.40000000000000002, 
+	  1.2217304763960306 },
+  { 2.1830100424586831, -0.80000000000000004, 0.40000000000000002, 
+	  1.3962634015954636 },
+  { 2.6604037035529724, -0.80000000000000004, 0.40000000000000002, 
+	  1.5707963267948966 },
+};
+const double toler015 = 2.5000000000000020e-13;
 
 // Test data for k=-0.80000000000000004, nu=0.50000000000000000.
-testcase_ellint_3<double> data016[] = {
-  { -0.0000000000000000, -0.80000000000000004, 0.50000000000000000,
-          0.0000000000000000 },
-  { 0.17422361866118047, -0.80000000000000004, 0.50000000000000000,
-          0.17453292519943295 },
-  { 0.34681083254170475, -0.80000000000000004, 0.50000000000000000,
-          0.34906585039886590 },
-  { 0.51709470815494440, -0.80000000000000004, 0.50000000000000000,
-          0.52359877559829882 },
-  { 0.68587375344080259, -0.80000000000000004, 0.50000000000000000,
-          0.69813170079773179 },
-  { 0.85532571852810624, -0.80000000000000004, 0.50000000000000000,
-          0.87266462599716477 },
-  { 1.0284677391874906, -0.80000000000000004, 0.50000000000000000,
-          1.0471975511965976 },
-  { 1.2081693942686225, -0.80000000000000004, 0.50000000000000000,
-          1.2217304763960306 },
-  { 1.3955803006426311, -0.80000000000000004, 0.50000000000000000,
-          1.3962634015954636 },
-  { 1.5884528947755532, -0.80000000000000004, 0.50000000000000000,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.80000000000000004, nu=0.50000000000000000.
-template <typename Tp>
-void test016()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data016)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data016[i].k), Tp(data016[i].nu),
-                   Tp(data016[i].phi));
-      const Tp f0 = data016[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.80000000000000004, nu=0.59999999999999998.
-testcase_ellint_3<double> data017[] = {
-  { -0.0000000000000000, -0.80000000000000004, 0.59999999999999998,
-          0.0000000000000000 },
-  { 0.17404991781414092, -0.80000000000000004, 0.59999999999999998,
-          0.17453292519943295 },
-  { 0.34549800443625167, -0.80000000000000004, 0.59999999999999998,
-          0.34906585039886590 },
-  { 0.51302536167001556, -0.80000000000000004, 0.59999999999999998,
-          0.52359877559829882 },
-  { 0.67717065003912258, -0.80000000000000004, 0.59999999999999998,
-          0.69813170079773179 },
-  { 0.84011512421134416, -0.80000000000000004, 0.59999999999999998,
-          0.87266462599716477 },
-  { 1.0049863847088742, -0.80000000000000004, 0.59999999999999998,
-          1.0471975511965976 },
-  { 1.1748145941898918, -0.80000000000000004, 0.59999999999999998,
-          1.2217304763960306 },
-  { 1.3510319699755071, -0.80000000000000004, 0.59999999999999998,
-          1.3962634015954636 },
-  { 1.5319262547427865, -0.80000000000000004, 0.59999999999999998,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.80000000000000004, nu=0.59999999999999998.
-template <typename Tp>
-void test017()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data017)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data017[i].k), Tp(data017[i].nu),
-                   Tp(data017[i].phi));
-      const Tp f0 = data017[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.80000000000000004, nu=0.69999999999999996.
-testcase_ellint_3<double> data018[] = {
-  { -0.0000000000000000, -0.80000000000000004, 0.69999999999999996,
-          0.0000000000000000 },
-  { 0.17387683562442202, -0.80000000000000004, 0.69999999999999996,
-          0.17453292519943295 },
-  { 0.34420254775101611, -0.80000000000000004, 0.69999999999999996,
-          0.34906585039886590 },
-  { 0.50906439222143685, -0.80000000000000004, 0.69999999999999996,
-          0.52359877559829882 },
-  { 0.66882693152688433, -0.80000000000000004, 0.69999999999999996,
-          0.69813170079773179 },
-  { 0.82574792844091316, -0.80000000000000004, 0.69999999999999996,
-          0.87266462599716477 },
-  { 0.98310431309490953, -0.80000000000000004, 0.69999999999999996,
-          1.0471975511965976 },
-  { 1.1440884535113258, -0.80000000000000004, 0.69999999999999996,
-          1.2217304763960306 },
-  { 1.3103743938952537, -0.80000000000000004, 0.69999999999999996,
-          1.3962634015954636 },
-  { 1.4806912324625332, -0.80000000000000004, 0.69999999999999996,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.80000000000000004, nu=0.69999999999999996.
-template <typename Tp>
-void test018()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data018)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data018[i].k), Tp(data018[i].nu),
-                   Tp(data018[i].phi));
-      const Tp f0 = data018[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 2.6645352591003757e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 9.0388243828581744e-16
+// mean(f - f_Boost): 3.8580250105724191e-16
+// variance(f - f_Boost): 6.4106456575047741e-31
+// stddev(f - f_Boost): 8.0066507713929764e-16
+const testcase_ellint_3<double>
+data016[10] =
+{
+  { 0.0000000000000000, -0.80000000000000004, 0.50000000000000000, 
+	  0.0000000000000000 },
+  { 0.17599554153999472, -0.80000000000000004, 0.50000000000000000, 
+	  0.17453292519943295 },
+  { 0.36099426243351540, -0.80000000000000004, 0.50000000000000000, 
+	  0.34906585039886590 },
+  { 0.56514786174780673, -0.80000000000000004, 0.50000000000000000, 
+	  0.52359877559829882 },
+  { 0.80090697622371010, -0.80000000000000004, 0.50000000000000000, 
+	  0.69813170079773179 },
+  { 1.0838891627679339, -0.80000000000000004, 0.50000000000000000, 
+	  0.87266462599716477 },
+  { 1.4323506654466280, -0.80000000000000004, 0.50000000000000000, 
+	  1.0471975511965976 },
+  { 1.8625761085390575, -0.80000000000000004, 0.50000000000000000, 
+	  1.2217304763960306 },
+  { 2.3768757305654766, -0.80000000000000004, 0.50000000000000000, 
+	  1.3962634015954636 },
+  { 2.9478781158239746, -0.80000000000000004, 0.50000000000000000, 
+	  1.5707963267948966 },
+};
+const double toler016 = 2.5000000000000020e-13;
+
+// Test data for k=-0.80000000000000004, nu=0.60000000000000009.
+// max(|f - f_Boost|): 3.5527136788005009e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 1.0631099169042069e-15
+// mean(f - f_Boost): 4.8294701571194306e-16
+// variance(f - f_Boost): 1.1633910328160319e-30
+// stddev(f - f_Boost): 1.0786060600682865e-15
+const testcase_ellint_3<double>
+data017[10] =
+{
+  { 0.0000000000000000, -0.80000000000000004, 0.60000000000000009, 
+	  0.0000000000000000 },
+  { 0.17617631684170665, -0.80000000000000004, 0.60000000000000009, 
+	  0.17453292519943295 },
+  { 0.36252934193666231, -0.80000000000000004, 0.60000000000000009, 
+	  0.34906585039886590 },
+  { 0.57086932622945163, -0.80000000000000004, 0.60000000000000009, 
+	  0.52359877559829882 },
+  { 0.81646796740150973, -0.80000000000000004, 0.60000000000000009, 
+	  0.69813170079773179 },
+  { 1.1199552158519064, -0.80000000000000004, 0.60000000000000009, 
+	  0.87266462599716477 },
+  { 1.5079766673336394, -0.80000000000000004, 0.60000000000000009, 
+	  1.0471975511965976 },
+  { 2.0082747447038165, -0.80000000000000004, 0.60000000000000009, 
+	  1.2217304763960306 },
+  { 2.6315146066775523, -0.80000000000000004, 0.60000000000000009, 
+	  1.3962634015954636 },
+  { 3.3418121892288051, -0.80000000000000004, 0.60000000000000009, 
+	  1.5707963267948966 },
+};
+const double toler017 = 2.5000000000000020e-13;
+
+// Test data for k=-0.80000000000000004, nu=0.70000000000000007.
+// max(|f - f_Boost|): 2.2204460492503131e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 5.6544679145741375e-16
+// mean(f - f_Boost): 3.2751579226442120e-16
+// variance(f - f_Boost): 4.4236851331020672e-31
+// stddev(f - f_Boost): 6.6510789599147505e-16
+const testcase_ellint_3<double>
+data018[10] =
+{
+  { 0.0000000000000000, -0.80000000000000004, 0.70000000000000007, 
+	  0.0000000000000000 },
+  { 0.17635776076721221, -0.80000000000000004, 0.70000000000000007, 
+	  0.17453292519943295 },
+  { 0.36408794649916976, -0.80000000000000004, 0.70000000000000007, 
+	  0.34906585039886590 },
+  { 0.57679992290624138, -0.80000000000000004, 0.70000000000000007, 
+	  0.52359877559829882 },
+  { 0.83312441418142813, -0.80000000000000004, 0.70000000000000007, 
+	  0.69813170079773179 },
+  { 1.1603958891464856, -0.80000000000000004, 0.70000000000000007, 
+	  0.87266462599716477 },
+  { 1.5982855143796213, -0.80000000000000004, 0.70000000000000007, 
+	  1.0471975511965976 },
+  { 2.1962484408371821, -0.80000000000000004, 0.70000000000000007, 
+	  1.2217304763960306 },
+  { 2.9873281786111869, -0.80000000000000004, 0.70000000000000007, 
+	  1.3962634015954636 },
+  { 3.9268876980046397, -0.80000000000000004, 0.70000000000000007, 
+	  1.5707963267948966 },
+};
+const double toler018 = 2.5000000000000020e-13;
 
 // Test data for k=-0.80000000000000004, nu=0.80000000000000004.
-testcase_ellint_3<double> data019[] = {
-  { -0.0000000000000000, -0.80000000000000004, 0.80000000000000004,
-          0.0000000000000000 },
-  { 0.17370436817515206, -0.80000000000000004, 0.80000000000000004,
-          0.17453292519943295 },
-  { 0.34292405894783395, -0.80000000000000004, 0.80000000000000004,
-          0.34906585039886590 },
-  { 0.50520682176250087, -0.80000000000000004, 0.80000000000000004,
-          0.52359877559829882 },
-  { 0.66081751679736189, -0.80000000000000004, 0.80000000000000004,
-          0.69813170079773179 },
-  { 0.81214672249355102, -0.80000000000000004, 0.80000000000000004,
-          0.87266462599716477 },
-  { 0.96264481387685574, -0.80000000000000004, 0.80000000000000004,
-          1.0471975511965976 },
-  { 1.1156611352656258, -0.80000000000000004, 0.80000000000000004,
-          1.2217304763960306 },
-  { 1.2730756225143889, -0.80000000000000004, 0.80000000000000004,
-          1.3962634015954636 },
-  { 1.4339837018309474, -0.80000000000000004, 0.80000000000000004,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.80000000000000004, nu=0.80000000000000004.
-template <typename Tp>
-void test019()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data019)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data019[i].k), Tp(data019[i].nu),
-                   Tp(data019[i].phi));
-      const Tp f0 = data019[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 4.4408920985006262e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 9.0176949165011079e-16
+// mean(f - f_Boost): 7.0499162063697436e-16
+// variance(f - f_Boost): 1.7230805408026989e-30
+// stddev(f - f_Boost): 1.3126616246400665e-15
+const testcase_ellint_3<double>
+data019[10] =
+{
+  { 0.0000000000000000, -0.80000000000000004, 0.80000000000000004, 
+	  0.0000000000000000 },
+  { 0.17653987774203392, -0.80000000000000004, 0.80000000000000004, 
+	  0.17453292519943295 },
+  { 0.36567072568046877, -0.80000000000000004, 0.80000000000000004, 
+	  0.34906585039886590 },
+  { 0.58295359996558616, -0.80000000000000004, 0.80000000000000004, 
+	  0.52359877559829882 },
+  { 0.85101998309176108, -0.80000000000000004, 0.80000000000000004, 
+	  0.69813170079773179 },
+  { 1.2062322059736537, -0.80000000000000004, 0.80000000000000004, 
+	  0.87266462599716477 },
+  { 1.7090321420917429, -0.80000000000000004, 0.80000000000000004, 
+	  1.0471975511965976 },
+  { 2.4529058049405066, -0.80000000000000004, 0.80000000000000004, 
+	  1.2217304763960306 },
+  { 3.5368893360106948, -0.80000000000000004, 0.80000000000000004, 
+	  1.3962634015954636 },
+  { 4.9246422058196062, -0.80000000000000004, 0.80000000000000004, 
+	  1.5707963267948966 },
+};
+const double toler019 = 2.5000000000000020e-13;
 
 // Test data for k=-0.80000000000000004, nu=0.90000000000000002.
-testcase_ellint_3<double> data020[] = {
-  { -0.0000000000000000, -0.80000000000000004, 0.90000000000000002,
-          0.0000000000000000 },
-  { 0.17353251158533153, -0.80000000000000004, 0.90000000000000002,
-          0.17453292519943295 },
-  { 0.34166214791545768, -0.80000000000000004, 0.90000000000000002,
-          0.34906585039886590 },
-  { 0.50144799535130580, -0.80000000000000004, 0.90000000000000002,
-          0.52359877559829882 },
-  { 0.65311976193814447, -0.80000000000000004, 0.90000000000000002,
-          0.69813170079773179 },
-  { 0.79924384892320866, -0.80000000000000004, 0.90000000000000002,
-          0.87266462599716477 },
-  { 0.94345762353365625, -0.80000000000000004, 0.90000000000000002,
-          1.0471975511965976 },
-  { 1.0892582069219159, -0.80000000000000004, 0.90000000000000002,
-          1.2217304763960306 },
-  { 1.2387000876610268, -0.80000000000000004, 0.90000000000000002,
-          1.3962634015954636 },
-  { 1.3911845406776222, -0.80000000000000004, 0.90000000000000002,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.80000000000000004, nu=0.90000000000000002.
-template <typename Tp>
-void test020()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data020)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data020[i].k), Tp(data020[i].nu),
-                   Tp(data020[i].phi));
-      const Tp f0 = data020[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 4.4408920985006262e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 7.7782721357365268e-16
+// mean(f - f_Boost): 8.9928064994637676e-16
+// variance(f - f_Boost): 1.5485199571025344e-30
+// stddev(f - f_Boost): 1.2443954183066307e-15
+const testcase_ellint_3<double>
+data020[10] =
+{
+  { 0.0000000000000000, -0.80000000000000004, 0.90000000000000002, 
+	  0.0000000000000000 },
+  { 0.17672267223433513, -0.80000000000000004, 0.90000000000000002, 
+	  0.17453292519943295 },
+  { 0.36727835537196063, -0.80000000000000004, 0.90000000000000002, 
+	  0.34906585039886590 },
+  { 0.58934569363716649, -0.80000000000000004, 0.90000000000000002, 
+	  0.52359877559829882 },
+  { 0.87032723471138851, -0.80000000000000004, 0.90000000000000002, 
+	  0.69813170079773179 },
+  { 1.2588676111323349, -0.80000000000000004, 0.90000000000000002, 
+	  0.87266462599716477 },
+  { 1.8498731900660019, -0.80000000000000004, 0.90000000000000002, 
+	  1.0471975511965976 },
+  { 2.8368381299300420, -0.80000000000000004, 0.90000000000000002, 
+	  1.2217304763960306 },
+  { 4.5674844191654058, -0.80000000000000004, 0.90000000000000002, 
+	  1.3962634015954636 },
+  { 7.2263259298637115, -0.80000000000000004, 0.90000000000000002, 
+	  1.5707963267948966 },
+};
+const double toler020 = 2.5000000000000020e-13;
 
 // Test data for k=-0.69999999999999996, nu=0.0000000000000000.
-testcase_ellint_3<double> data021[] = {
-  { -0.0000000000000000, -0.69999999999999996, 0.0000000000000000,
-          0.0000000000000000 },
-  { 0.17496737466916720, -0.69999999999999996, 0.0000000000000000,
-          0.17453292519943295 },
-  { 0.35254687535677925, -0.69999999999999996, 0.0000000000000000,
-          0.34906585039886590 },
-  { 0.53536740275997130, -0.69999999999999996, 0.0000000000000000,
-          0.52359877559829882 },
-  { 0.72603797651684465, -0.69999999999999996, 0.0000000000000000,
-          0.69813170079773179 },
-  { 0.92698296348313458, -0.69999999999999996, 0.0000000000000000,
-          0.87266462599716477 },
-  { 1.1400447527693316, -0.69999999999999996, 0.0000000000000000,
-          1.0471975511965976 },
-  { 1.3657668117194071, -0.69999999999999996, 0.0000000000000000,
-          1.2217304763960306 },
-  { 1.6024686895959159, -0.69999999999999996, 0.0000000000000000,
-          1.3962634015954636 },
-  { 1.8456939983747236, -0.69999999999999996, 0.0000000000000000,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.69999999999999996, nu=0.0000000000000000.
-template <typename Tp>
-void test021()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data021)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data021[i].k), Tp(data021[i].nu),
-                   Tp(data021[i].phi));
-      const Tp f0 = data021[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 5.5425633303580569e-16
+// mean(f - f_Boost): 7.7715611723760953e-17
+// variance(f - f_Boost): 7.4564398834547797e-34
+// stddev(f - f_Boost): 2.7306482533374340e-17
+const testcase_ellint_3<double>
+data021[10] =
+{
+  { 0.0000000000000000, -0.69999999999999996, 0.0000000000000000, 
+	  0.0000000000000000 },
+  { 0.17496737466916723, -0.69999999999999996, 0.0000000000000000, 
+	  0.17453292519943295 },
+  { 0.35254687535677931, -0.69999999999999996, 0.0000000000000000, 
+	  0.34906585039886590 },
+  { 0.53536740275997130, -0.69999999999999996, 0.0000000000000000, 
+	  0.52359877559829882 },
+  { 0.72603797651684454, -0.69999999999999996, 0.0000000000000000, 
+	  0.69813170079773179 },
+  { 0.92698296348313447, -0.69999999999999996, 0.0000000000000000, 
+	  0.87266462599716477 },
+  { 1.1400447527693316, -0.69999999999999996, 0.0000000000000000, 
+	  1.0471975511965976 },
+  { 1.3657668117194071, -0.69999999999999996, 0.0000000000000000, 
+	  1.2217304763960306 },
+  { 1.6024686895959162, -0.69999999999999996, 0.0000000000000000, 
+	  1.3962634015954636 },
+  { 1.8456939983747234, -0.69999999999999996, 0.0000000000000000, 
+	  1.5707963267948966 },
+};
+const double toler021 = 2.5000000000000020e-13;
 
 // Test data for k=-0.69999999999999996, nu=0.10000000000000001.
-testcase_ellint_3<double> data022[] = {
-  { -0.0000000000000000, -0.69999999999999996, 0.10000000000000001,
-          0.0000000000000000 },
-  { 0.17479076384884681, -0.69999999999999996, 0.10000000000000001,
-          0.17453292519943295 },
-  { 0.35114844900396364, -0.69999999999999996, 0.10000000000000001,
-          0.34906585039886590 },
-  { 0.53072776947527012, -0.69999999999999996, 0.10000000000000001,
-          0.52359877559829882 },
-  { 0.71530198262386246, -0.69999999999999996, 0.10000000000000001,
-          0.69813170079773179 },
-  { 0.90666760677828306, -0.69999999999999996, 0.10000000000000001,
-          0.87266462599716477 },
-  { 1.1063366517438080, -0.69999999999999996, 0.10000000000000001,
-          1.0471975511965976 },
-  { 1.3149477243092147, -0.69999999999999996, 0.10000000000000001,
-          1.2217304763960306 },
-  { 1.5314886725038925, -0.69999999999999996, 0.10000000000000001,
-          1.3962634015954636 },
-  { 1.7528050171757608, -0.69999999999999996, 0.10000000000000001,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.69999999999999996, nu=0.10000000000000001.
-template <typename Tp>
-void test022()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data022)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data022[i].k), Tp(data022[i].nu),
-                   Tp(data022[i].phi));
-      const Tp f0 = data022[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 5.2736371663370261e-16
+// mean(f - f_Boost): 8.8817841970012528e-17
+// variance(f - f_Boost): 9.7390235212470591e-34
+// stddev(f - f_Boost): 3.1207408609570677e-17
+const testcase_ellint_3<double>
+data022[10] =
+{
+  { 0.0000000000000000, -0.69999999999999996, 0.10000000000000001, 
+	  0.0000000000000000 },
+  { 0.17514462737300920, -0.69999999999999996, 0.10000000000000001, 
+	  0.17453292519943295 },
+  { 0.35396527997470451, -0.69999999999999996, 0.10000000000000001, 
+	  0.34906585039886590 },
+  { 0.54015179589433981, -0.69999999999999996, 0.10000000000000001, 
+	  0.52359877559829882 },
+  { 0.73734430854477728, -0.69999999999999996, 0.10000000000000001, 
+	  0.69813170079773179 },
+  { 0.94888950796697047, -0.69999999999999996, 0.10000000000000001, 
+	  0.87266462599716477 },
+  { 1.1772807959736322, -0.69999999999999996, 0.10000000000000001, 
+	  1.0471975511965976 },
+  { 1.4231796401075831, -0.69999999999999996, 0.10000000000000001, 
+	  1.2217304763960306 },
+  { 1.6841856799887469, -0.69999999999999996, 0.10000000000000001, 
+	  1.3962634015954636 },
+  { 1.9541347343119562, -0.69999999999999996, 0.10000000000000001, 
+	  1.5707963267948966 },
+};
+const double toler022 = 2.5000000000000020e-13;
 
 // Test data for k=-0.69999999999999996, nu=0.20000000000000001.
-testcase_ellint_3<double> data023[] = {
-  { -0.0000000000000000, -0.69999999999999996, 0.20000000000000001,
-          0.0000000000000000 },
-  { 0.17461479077791472, -0.69999999999999996, 0.20000000000000001,
-          0.17453292519943295 },
-  { 0.34976950621407538, -0.69999999999999996, 0.20000000000000001,
-          0.34906585039886590 },
-  { 0.52622533231350188, -0.69999999999999996, 0.20000000000000001,
-          0.52359877559829882 },
-  { 0.70508774017895226, -0.69999999999999996, 0.20000000000000001,
-          0.69813170079773179 },
-  { 0.88775302531730294, -0.69999999999999996, 0.20000000000000001,
-          0.87266462599716477 },
-  { 1.0756195476149006, -0.69999999999999996, 0.20000000000000001,
-          1.0471975511965976 },
-  { 1.2695349716654372, -0.69999999999999996, 0.20000000000000001,
-          1.2217304763960306 },
-  { 1.4690814617070540, -0.69999999999999996, 0.20000000000000001,
-          1.3962634015954636 },
-  { 1.6721098780092147, -0.69999999999999996, 0.20000000000000001,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.69999999999999996, nu=0.20000000000000001.
-template <typename Tp>
-void test023()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data023)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data023[i].k), Tp(data023[i].nu),
-                   Tp(data023[i].phi));
-      const Tp f0 = data023[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.69999999999999996, nu=0.29999999999999999.
-testcase_ellint_3<double> data024[] = {
-  { -0.0000000000000000, -0.69999999999999996, 0.29999999999999999,
-          0.0000000000000000 },
-  { 0.17443945136076172, -0.69999999999999996, 0.29999999999999999,
-          0.17453292519943295 },
-  { 0.34840956983535287, -0.69999999999999996, 0.29999999999999999,
-          0.34906585039886590 },
-  { 0.52185308551329179, -0.69999999999999996, 0.29999999999999999,
-          0.52359877559829882 },
-  { 0.69535240431168266, -0.69999999999999996, 0.29999999999999999,
-          0.69813170079773179 },
-  { 0.87007983473964923, -0.69999999999999996, 0.29999999999999999,
-          0.87266462599716477 },
-  { 1.0474657975577066, -0.69999999999999996, 0.29999999999999999,
-          1.0471975511965976 },
-  { 1.2286225419931889, -0.69999999999999996, 0.29999999999999999,
-          1.2217304763960306 },
-  { 1.4136490671013271, -0.69999999999999996, 0.29999999999999999,
-          1.3962634015954636 },
-  { 1.6011813647733213, -0.69999999999999996, 0.29999999999999999,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.69999999999999996, nu=0.29999999999999999.
-template <typename Tp>
-void test024()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data024)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data024[i].k), Tp(data024[i].nu),
-                   Tp(data024[i].phi));
-      const Tp f0 = data024[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 4.9907249355047774e-16
+// mean(f - f_Boost): 3.3306690738754695e-17
+// variance(f - f_Boost): 1.3695501826753678e-34
+// stddev(f - f_Boost): 1.1702778228589003e-17
+const testcase_ellint_3<double>
+data023[10] =
+{
+  { 0.0000000000000000, -0.69999999999999996, 0.20000000000000001, 
+	  0.0000000000000000 },
+  { 0.17532252613350796, -0.69999999999999996, 0.20000000000000001, 
+	  0.17453292519943295 },
+  { 0.35540417596807522, -0.69999999999999996, 0.20000000000000001, 
+	  0.34906585039886590 },
+  { 0.54508913033361928, -0.69999999999999996, 0.20000000000000001, 
+	  0.52359877559829882 },
+  { 0.74927635777718415, -0.69999999999999996, 0.20000000000000001, 
+	  0.69813170079773179 },
+  { 0.97261706337936338, -0.69999999999999996, 0.20000000000000001, 
+	  0.87266462599716477 },
+  { 1.2187303976209327, -0.69999999999999996, 0.20000000000000001, 
+	  1.0471975511965976 },
+  { 1.4887796709222487, -0.69999999999999996, 0.20000000000000001, 
+	  1.2217304763960306 },
+  { 1.7796581281839212, -0.69999999999999996, 0.20000000000000001, 
+	  1.3962634015954636 },
+  { 2.0829290325820202, -0.69999999999999996, 0.20000000000000001, 
+	  1.5707963267948966 },
+};
+const double toler023 = 2.5000000000000020e-13;
+
+// Test data for k=-0.69999999999999996, nu=0.30000000000000004.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 4.6912897610535316e-16
+// mean(f - f_Boost): 1.6653345369377347e-17
+// variance(f - f_Boost): 2.6207864467918357e-32
+// stddev(f - f_Boost): 1.6188843216214787e-16
+const testcase_ellint_3<double>
+data024[10] =
+{
+  { 0.0000000000000000, -0.69999999999999996, 0.30000000000000004, 
+	  0.0000000000000000 },
+  { 0.17550107516328570, -0.69999999999999996, 0.30000000000000004, 
+	  0.17453292519943295 },
+  { 0.35686409576571959, -0.69999999999999996, 0.30000000000000004, 
+	  0.34906585039886590 },
+  { 0.55018827316513352, -0.69999999999999996, 0.30000000000000004, 
+	  0.52359877559829882 },
+  { 0.76189759494390275, -0.69999999999999996, 0.30000000000000004, 
+	  0.69813170079773179 },
+  { 0.99844623430885615, -0.69999999999999996, 0.30000000000000004, 
+	  0.87266462599716477 },
+  { 1.2652862989039833, -0.69999999999999996, 0.30000000000000004, 
+	  1.0471975511965976 },
+  { 1.5647666808691361, -0.69999999999999996, 0.30000000000000004, 
+	  1.2217304763960306 },
+  { 1.8932499694938163, -0.69999999999999996, 0.30000000000000004, 
+	  1.3962634015954636 },
+  { 2.2392290510988535, -0.69999999999999996, 0.30000000000000004, 
+	  1.5707963267948966 },
+};
+const double toler024 = 2.5000000000000020e-13;
 
 // Test data for k=-0.69999999999999996, nu=0.40000000000000002.
-testcase_ellint_3<double> data025[] = {
-  { -0.0000000000000000, -0.69999999999999996, 0.40000000000000002,
-          0.0000000000000000 },
-  { 0.17426474153983226, -0.69999999999999996, 0.40000000000000002,
-          0.17453292519943295 },
-  { 0.34706817945773732, -0.69999999999999996, 0.40000000000000002,
-          0.34906585039886590 },
-  { 0.51760452851738159, -0.69999999999999996, 0.40000000000000002,
-          0.52359877559829882 },
-  { 0.68605801534722766, -0.69999999999999996, 0.40000000000000002,
-          0.69813170079773179 },
-  { 0.85351339387296532, -0.69999999999999996, 0.40000000000000002,
-          0.87266462599716477 },
-  { 1.0215297967969537, -0.69999999999999996, 0.40000000000000002,
-          1.0471975511965976 },
-  { 1.1915051074460528, -0.69999999999999996, 0.40000000000000002,
-          1.2217304763960306 },
-  { 1.3639821911744707, -0.69999999999999996, 0.40000000000000002,
-          1.3962634015954636 },
-  { 1.5382162002954762, -0.69999999999999996, 0.40000000000000002,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.69999999999999996, nu=0.40000000000000002.
-template <typename Tp>
-void test025()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data025)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data025[i].k), Tp(data025[i].nu),
-                   Tp(data025[i].phi));
-      const Tp f0 = data025[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 6.5578567644745380e-16
+// mean(f - f_Boost): 1.4710455076283324e-16
+// variance(f - f_Boost): 2.6715739327327140e-33
+// stddev(f - f_Boost): 5.1687270509601433e-17
+const testcase_ellint_3<double>
+data025[10] =
+{
+  { 0.0000000000000000, -0.69999999999999996, 0.40000000000000002, 
+	  0.0000000000000000 },
+  { 0.17568027871494424, -0.69999999999999996, 0.40000000000000002, 
+	  0.17453292519943295 },
+  { 0.35834559208180261, -0.69999999999999996, 0.40000000000000002, 
+	  0.34906585039886590 },
+  { 0.55545885451190613, -0.69999999999999996, 0.40000000000000002, 
+	  0.52359877559829882 },
+  { 0.77528120402568101, -0.69999999999999996, 0.40000000000000002, 
+	  0.69813170079773179 },
+  { 1.0267241287600319, -0.69999999999999996, 0.40000000000000002, 
+	  0.87266462599716477 },
+  { 1.3181380338980246, -0.69999999999999996, 0.40000000000000002, 
+	  1.0471975511965976 },
+  { 1.6542840785132085, -0.69999999999999996, 0.40000000000000002, 
+	  1.2217304763960306 },
+  { 2.0315595131131818, -0.69999999999999996, 0.40000000000000002, 
+	  1.3962634015954636 },
+  { 2.4342502915307875, -0.69999999999999996, 0.40000000000000002, 
+	  1.5707963267948966 },
+};
+const double toler025 = 2.5000000000000020e-13;
 
 // Test data for k=-0.69999999999999996, nu=0.50000000000000000.
-testcase_ellint_3<double> data026[] = {
-  { -0.0000000000000000, -0.69999999999999996, 0.50000000000000000,
-          0.0000000000000000 },
-  { 0.17409065729516093, -0.69999999999999996, 0.50000000000000000,
-          0.17453292519943295 },
-  { 0.34574489064986091, -0.69999999999999996, 0.50000000000000000,
-          0.34906585039886590 },
-  { 0.51347361925579793, -0.69999999999999996, 0.50000000000000000,
-          0.52359877559829882 },
-  { 0.67717079489579290, -0.69999999999999996, 0.50000000000000000,
-          0.69813170079773179 },
-  { 0.83793902055292280, -0.69999999999999996, 0.50000000000000000,
-          0.87266462599716477 },
-  { 0.99752863545289705, -0.69999999999999996, 0.50000000000000000,
-          1.0471975511965976 },
-  { 1.1576240080401499, -0.69999999999999996, 0.50000000000000000,
-          1.2217304763960306 },
-  { 1.3191464023923762, -0.69999999999999996, 0.50000000000000000,
-          1.3962634015954636 },
-  { 1.4818433192178544, -0.69999999999999996, 0.50000000000000000,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.69999999999999996, nu=0.50000000000000000.
-template <typename Tp>
-void test026()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data026)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data026[i].k), Tp(data026[i].nu),
-                   Tp(data026[i].phi));
-      const Tp f0 = data026[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.69999999999999996, nu=0.59999999999999998.
-testcase_ellint_3<double> data027[] = {
-  { -0.0000000000000000, -0.69999999999999996, 0.59999999999999998,
-          0.0000000000000000 },
-  { 0.17391719464391611, -0.69999999999999996, 0.59999999999999998,
-          0.17453292519943295 },
-  { 0.34443927423869031, -0.69999999999999996, 0.59999999999999998,
-          0.34906585039886590 },
-  { 0.50945473266486074, -0.69999999999999996, 0.59999999999999998,
-          0.52359877559829882 },
-  { 0.66866056326513823, -0.69999999999999996, 0.59999999999999998,
-          0.69813170079773179 },
-  { 0.82325830002337352, -0.69999999999999996, 0.59999999999999998,
-          0.87266462599716477 },
-  { 0.97522808245669357, -0.69999999999999996, 0.59999999999999998,
-          1.0471975511965976 },
-  { 1.1265300613705282, -0.69999999999999996, 0.59999999999999998,
-          1.2217304763960306 },
-  { 1.2784066076152003, -0.69999999999999996, 0.59999999999999998,
-          1.3962634015954636 },
-  { 1.4309994736080540, -0.69999999999999996, 0.59999999999999998,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.69999999999999996, nu=0.59999999999999998.
-template <typename Tp>
-void test027()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data027)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data027[i].k), Tp(data027[i].nu),
-                   Tp(data027[i].phi));
-      const Tp f0 = data027[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.69999999999999996, nu=0.69999999999999996.
-testcase_ellint_3<double> data028[] = {
-  { -0.0000000000000000, -0.69999999999999996, 0.69999999999999996,
-          0.0000000000000000 },
-  { 0.17374434963995028, -0.69999999999999996, 0.69999999999999996,
-          0.17453292519943295 },
-  { 0.34315091562900674, -0.69999999999999996, 0.69999999999999996,
-          0.34906585039886590 },
-  { 0.50554262375653358, -0.69999999999999996, 0.69999999999999996,
-          0.52359877559829882 },
-  { 0.66050025406305812, -0.69999999999999996, 0.69999999999999996,
-          0.69813170079773179 },
-  { 0.80938620118847404, -0.69999999999999996, 0.69999999999999996,
-          0.87266462599716477 },
-  { 0.95443223855852144, -0.69999999999999996, 0.69999999999999996,
-          1.0471975511965976 },
-  { 1.0978573207128302, -0.69999999999999996, 0.69999999999999996,
-          1.2217304763960306 },
-  { 1.2411754575007123, -0.69999999999999996, 0.69999999999999996,
-          1.3962634015954636 },
-  { 1.3848459188329196, -0.69999999999999996, 0.69999999999999996,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.69999999999999996, nu=0.69999999999999996.
-template <typename Tp>
-void test028()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data028)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data028[i].k), Tp(data028[i].nu),
-                   Tp(data028[i].phi));
-      const Tp f0 = data028[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 6.0416041815443256e-16
+// mean(f - f_Boost): 1.9151347174783951e-16
+// variance(f - f_Boost): 7.8758646268991113e-33
+// stddev(f - f_Boost): 8.8746068233466605e-17
+const testcase_ellint_3<double>
+data026[10] =
+{
+  { 0.0000000000000000, -0.69999999999999996, 0.50000000000000000, 
+	  0.0000000000000000 },
+  { 0.17586014108156545, -0.69999999999999996, 0.50000000000000000, 
+	  0.17453292519943295 },
+  { 0.35984923894341653, -0.69999999999999996, 0.50000000000000000, 
+	  0.34906585039886590 },
+  { 0.56091135606739995, -0.69999999999999996, 0.50000000000000000, 
+	  0.52359877559829882 },
+  { 0.78951212635197054, -0.69999999999999996, 0.50000000000000000, 
+	  0.69813170079773179 },
+  { 1.0578865732938729, -0.69999999999999996, 0.50000000000000000, 
+	  0.87266462599716477 },
+  { 1.3789149005151722, -0.69999999999999996, 0.50000000000000000, 
+	  1.0471975511965976 },
+  { 1.7620212286086225, -0.69999999999999996, 0.50000000000000000, 
+	  1.2217304763960306 },
+  { 2.2051554347435585, -0.69999999999999996, 0.50000000000000000, 
+	  1.3962634015954636 },
+  { 2.6868019968236991, -0.69999999999999996, 0.50000000000000000, 
+	  1.5707963267948966 },
+};
+const double toler026 = 2.5000000000000020e-13;
+
+// Test data for k=-0.69999999999999996, nu=0.60000000000000009.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 3.6515644573247170e-16
+// mean(f - f_Boost): 9.9920072216264091e-17
+// variance(f - f_Boost): 1.2325951644078310e-33
+// stddev(f - f_Boost): 3.5108334685767011e-17
+const testcase_ellint_3<double>
+data027[10] =
+{
+  { 0.0000000000000000, -0.69999999999999996, 0.60000000000000009, 
+	  0.0000000000000000 },
+  { 0.17604066659721918, -0.69999999999999996, 0.60000000000000009, 
+	  0.17453292519943295 },
+  { 0.36137563278353424, -0.69999999999999996, 0.60000000000000009, 
+	  0.34906585039886590 },
+  { 0.56655721272747606, -0.69999999999999996, 0.60000000000000009, 
+	  0.52359877559829882 },
+  { 0.80468966552978305, -0.69999999999999996, 0.60000000000000009, 
+	  0.69813170079773179 },
+  { 1.0924902943683852, -0.69999999999999996, 0.60000000000000009, 
+	  0.87266462599716477 },
+  { 1.4499247992499797, -0.69999999999999996, 0.60000000000000009, 
+	  1.0471975511965976 },
+  { 1.8953714382113815, -0.69999999999999996, 0.60000000000000009, 
+	  1.2217304763960306 },
+  { 2.4323229949248670, -0.69999999999999996, 0.60000000000000009, 
+	  1.3962634015954636 },
+  { 3.0314573496746742, -0.69999999999999996, 0.60000000000000009, 
+	  1.5707963267948966 },
+};
+const double toler027 = 2.5000000000000020e-13;
+
+// Test data for k=-0.69999999999999996, nu=0.70000000000000007.
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 4.8475278552871384e-16
+// mean(f - f_Boost): 9.9920072216264091e-17
+// variance(f - f_Boost): 1.2325951644078310e-33
+// stddev(f - f_Boost): 3.5108334685767011e-17
+const testcase_ellint_3<double>
+data028[10] =
+{
+  { 0.0000000000000000, -0.69999999999999996, 0.70000000000000007, 
+	  0.0000000000000000 },
+  { 0.17622185963747933, -0.69999999999999996, 0.70000000000000007, 
+	  0.17453292519943295 },
+  { 0.36292539360435261, -0.69999999999999996, 0.70000000000000007, 
+	  0.34906585039886590 },
+  { 0.57240892970150015, -0.69999999999999996, 0.70000000000000007, 
+	  0.52359877559829882 },
+  { 0.82093084713182629, -0.69999999999999996, 0.70000000000000007, 
+	  0.69813170079773179 },
+  { 1.1312609022179871, -0.69999999999999996, 0.70000000000000007, 
+	  0.87266462599716477 },
+  { 1.5345768067715795, -0.69999999999999996, 0.70000000000000007, 
+	  1.0471975511965976 },
+  { 2.0668847445934420, -0.69999999999999996, 0.70000000000000007, 
+	  1.2217304763960306 },
+  { 2.7483444537551240, -0.69999999999999996, 0.70000000000000007, 
+	  1.3962634015954636 },
+  { 3.5408408771788560, -0.69999999999999996, 0.70000000000000007, 
+	  1.5707963267948966 },
+};
+const double toler028 = 2.5000000000000020e-13;
 
 // Test data for k=-0.69999999999999996, nu=0.80000000000000004.
-testcase_ellint_3<double> data029[] = {
-  { -0.0000000000000000, -0.69999999999999996, 0.80000000000000004,
-          0.0000000000000000 },
-  { 0.17357211837335737, -0.69999999999999996, 0.80000000000000004,
-          0.17453292519943295 },
-  { 0.34187941416012108, -0.69999999999999996, 0.80000000000000004,
-          0.34906585039886590 },
-  { 0.50173239465478270, -0.69999999999999996, 0.80000000000000004,
-          0.52359877559829882 },
-  { 0.65266550725988315, -0.69999999999999996, 0.80000000000000004,
-          0.69813170079773179 },
-  { 0.79624879865249298, -0.69999999999999996, 0.80000000000000004,
-          0.87266462599716477 },
-  { 0.93497577043296920, -0.69999999999999996, 0.80000000000000004,
-          1.0471975511965976 },
-  { 1.0713041566930748, -0.69999999999999996, 0.80000000000000004,
-          1.2217304763960306 },
-  { 1.2069772023255652, -0.69999999999999996, 0.80000000000000004,
-          1.3962634015954636 },
-  { 1.3427110650397533, -0.69999999999999996, 0.80000000000000004,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.69999999999999996, nu=0.80000000000000004.
-template <typename Tp>
-void test029()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data029)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data029[i].k), Tp(data029[i].nu),
-                   Tp(data029[i].phi));
-      const Tp f0 = data029[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 2.2204460492503131e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 6.8664526853112274e-16
+// mean(f - f_Boost): 1.6930901125533636e-16
+// variance(f - f_Boost): 3.5389557150937801e-33
+// stddev(f - f_Boost): 5.9489122661994095e-17
+const testcase_ellint_3<double>
+data029[10] =
+{
+  { 0.0000000000000000, -0.69999999999999996, 0.80000000000000004, 
+	  0.0000000000000000 },
+  { 0.17640372461994805, -0.69999999999999996, 0.80000000000000004, 
+	  0.17453292519943295 },
+  { 0.36449916621651091, -0.69999999999999996, 0.80000000000000004, 
+	  0.34906585039886590 },
+  { 0.57848021800372573, -0.69999999999999996, 0.80000000000000004, 
+	  0.52359877559829882 },
+  { 0.83837480968392586, -0.69999999999999996, 0.80000000000000004, 
+	  0.69813170079773179 },
+  { 1.1751669030061143, -0.69999999999999996, 0.80000000000000004, 
+	  0.87266462599716477 },
+  { 1.6381851899173601, -0.69999999999999996, 0.80000000000000004, 
+	  1.0471975511965976 },
+  { 2.3002065924302197, -0.69999999999999996, 0.80000000000000004, 
+	  1.2217304763960306 },
+  { 3.2337600665337862, -0.69999999999999996, 0.80000000000000004, 
+	  1.3962634015954636 },
+  { 4.4042405729076961, -0.69999999999999996, 0.80000000000000004, 
+	  1.5707963267948966 },
+};
+const double toler029 = 2.5000000000000020e-13;
 
 // Test data for k=-0.69999999999999996, nu=0.90000000000000002.
-testcase_ellint_3<double> data030[] = {
-  { -0.0000000000000000, -0.69999999999999996, 0.90000000000000002,
-          0.0000000000000000 },
-  { 0.17340049697003634, -0.69999999999999996, 0.90000000000000002,
-          0.17453292519943295 },
-  { 0.34062438249741556, -0.69999999999999996, 0.90000000000000002,
-          0.34906585039886590 },
-  { 0.49801946510076878, -0.69999999999999996, 0.90000000000000002,
-          0.52359877559829882 },
-  { 0.64513432604750487, -0.69999999999999996, 0.90000000000000002,
-          0.69813170079773179 },
-  { 0.78378145487573758, -0.69999999999999996, 0.90000000000000002,
-          0.87266462599716477 },
-  { 0.91671799500854634, -0.69999999999999996, 0.90000000000000002,
-          1.0471975511965976 },
-  { 1.0466193579463123, -0.69999999999999996, 0.90000000000000002,
-          1.2217304763960306 },
-  { 1.1754218079199146, -0.69999999999999996, 0.90000000000000002,
-          1.3962634015954636 },
-  { 1.3040500499695911, -0.69999999999999996, 0.90000000000000002,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.69999999999999996, nu=0.90000000000000002.
-template <typename Tp>
-void test030()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data030)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data030[i].k), Tp(data030[i].nu),
-                   Tp(data030[i].phi));
-      const Tp f0 = data030[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 3.5527136788005009e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 8.5869439826269878e-16
+// mean(f - f_Boost): 6.7723604502134545e-16
+// variance(f - f_Boost): 4.8757508225668289e-31
+// stddev(f - f_Boost): 6.9826576763914390e-16
+const testcase_ellint_3<double>
+data030[10] =
+{
+  { 0.0000000000000000, -0.69999999999999996, 0.90000000000000002, 
+	  0.0000000000000000 },
+  { 0.17658626600478800, -0.69999999999999996, 0.90000000000000002, 
+	  0.17453292519943295 },
+  { 0.36609762156017206, -0.69999999999999996, 0.90000000000000002, 
+	  0.34906585039886590 },
+  { 0.58478615187842409, -0.69999999999999996, 0.90000000000000002, 
+	  0.52359877559829882 },
+  { 0.85718862878291846, -0.69999999999999996, 0.90000000000000002, 
+	  0.69813170079773179 },
+  { 1.2255385617397643, -0.69999999999999996, 0.90000000000000002, 
+	  0.87266462599716477 },
+  { 1.7696521899992939, -0.69999999999999996, 0.90000000000000002, 
+	  1.0471975511965976 },
+  { 2.6476314987883502, -0.69999999999999996, 0.90000000000000002, 
+	  1.2217304763960306 },
+  { 4.1373434902898083, -0.69999999999999996, 0.90000000000000002, 
+	  1.3962634015954636 },
+  { 6.3796094177887746, -0.69999999999999996, 0.90000000000000002, 
+	  1.5707963267948966 },
+};
+const double toler030 = 2.5000000000000020e-13;
 
 // Test data for k=-0.59999999999999998, nu=0.0000000000000000.
-testcase_ellint_3<double> data031[] = {
-  { -0.0000000000000000, -0.59999999999999998, 0.0000000000000000,
-          0.0000000000000000 },
-  { 0.17485154362988362, -0.59999999999999998, 0.0000000000000000,
-          0.17453292519943295 },
-  { 0.35160509865544326, -0.59999999999999998, 0.0000000000000000,
-          0.34906585039886590 },
-  { 0.53210652578446160, -0.59999999999999998, 0.0000000000000000,
-          0.52359877559829882 },
-  { 0.71805304664485670, -0.59999999999999998, 0.0000000000000000,
-          0.69813170079773179 },
-  { 0.91082759030195970, -0.59999999999999998, 0.0000000000000000,
-          0.87266462599716477 },
-  { 1.1112333229323361, -0.59999999999999998, 0.0000000000000000,
-          1.0471975511965976 },
-  { 1.3191461190365270, -0.59999999999999998, 0.0000000000000000,
-          1.2217304763960306 },
-  { 1.5332022105084773, -0.59999999999999998, 0.0000000000000000,
-          1.3962634015954636 },
-  { 1.7507538029157526, -0.59999999999999998, 0.0000000000000000,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.59999999999999998, nu=0.0000000000000000.
-template <typename Tp>
-void test031()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data031)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data031[i].k), Tp(data031[i].nu),
-                   Tp(data031[i].phi));
-      const Tp f0 = data031[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.3664899092028927e-16
+// mean(f - f_Boost): 5.2735593669694933e-17
+// variance(f - f_Boost): 3.4333862218458872e-34
+// stddev(f - f_Boost): 1.8529398861932589e-17
+const testcase_ellint_3<double>
+data031[10] =
+{
+  { 0.0000000000000000, -0.59999999999999998, 0.0000000000000000, 
+	  0.0000000000000000 },
+  { 0.17485154362988359, -0.59999999999999998, 0.0000000000000000, 
+	  0.17453292519943295 },
+  { 0.35160509865544320, -0.59999999999999998, 0.0000000000000000, 
+	  0.34906585039886590 },
+  { 0.53210652578446138, -0.59999999999999998, 0.0000000000000000, 
+	  0.52359877559829882 },
+  { 0.71805304664485659, -0.59999999999999998, 0.0000000000000000, 
+	  0.69813170079773179 },
+  { 0.91082759030195981, -0.59999999999999998, 0.0000000000000000, 
+	  0.87266462599716477 },
+  { 1.1112333229323361, -0.59999999999999998, 0.0000000000000000, 
+	  1.0471975511965976 },
+  { 1.3191461190365270, -0.59999999999999998, 0.0000000000000000, 
+	  1.2217304763960306 },
+  { 1.5332022105084779, -0.59999999999999998, 0.0000000000000000, 
+	  1.3962634015954636 },
+  { 1.7507538029157523, -0.59999999999999998, 0.0000000000000000, 
+	  1.5707963267948966 },
+};
+const double toler031 = 2.5000000000000020e-13;
 
 // Test data for k=-0.59999999999999998, nu=0.10000000000000001.
-testcase_ellint_3<double> data032[] = {
-  { -0.0000000000000000, -0.59999999999999998, 0.10000000000000001,
-          0.0000000000000000 },
-  { 0.17467514275022014, -0.59999999999999998, 0.10000000000000001,
-          0.17453292519943295 },
-  { 0.35021333086258255, -0.59999999999999998, 0.10000000000000001,
-          0.34906585039886590 },
-  { 0.52751664092962713, -0.59999999999999998, 0.10000000000000001,
-          0.52359877559829882 },
-  { 0.70752126971957885, -0.59999999999999998, 0.10000000000000001,
-          0.69813170079773179 },
-  { 0.89111058756112871, -0.59999999999999998, 0.10000000000000001,
-          0.87266462599716477 },
-  { 1.0789241202877768, -0.59999999999999998, 0.10000000000000001,
-          1.0471975511965976 },
-  { 1.2710800210399946, -0.59999999999999998, 0.10000000000000001,
-          1.2217304763960306 },
-  { 1.4669060574440276, -0.59999999999999998, 0.10000000000000001,
-          1.3962634015954636 },
-  { 1.6648615773343014, -0.59999999999999998, 0.10000000000000001,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.59999999999999998, nu=0.10000000000000001.
-template <typename Tp>
-void test032()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data032)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data032[i].k), Tp(data032[i].nu),
-                   Tp(data032[i].phi));
-      const Tp f0 = data032[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.2335247010355137e-16
+// mean(f - f_Boost): 8.6042284408449634e-17
+// variance(f - f_Boost): 2.2835347143080263e-33
+// stddev(f - f_Boost): 4.7786344433405099e-17
+const testcase_ellint_3<double>
+data032[10] =
+{
+  { 0.0000000000000000, -0.59999999999999998, 0.10000000000000001, 
+	  0.0000000000000000 },
+  { 0.17502858548476194, -0.59999999999999998, 0.10000000000000001, 
+	  0.17453292519943295 },
+  { 0.35301673150537388, -0.59999999999999998, 0.10000000000000001, 
+	  0.34906585039886590 },
+  { 0.53683932476326812, -0.59999999999999998, 0.10000000000000001, 
+	  0.52359877559829882 },
+  { 0.72914228589586771, -0.59999999999999998, 0.10000000000000001, 
+	  0.69813170079773179 },
+  { 0.93208036718354692, -0.59999999999999998, 0.10000000000000001, 
+	  0.87266462599716477 },
+  { 1.1468984688863377, -0.59999999999999998, 0.10000000000000001, 
+	  1.0471975511965976 },
+  { 1.3733904977062528, -0.59999999999999998, 0.10000000000000001, 
+	  1.2217304763960306 },
+  { 1.6094225663372157, -0.59999999999999998, 0.10000000000000001, 
+	  1.3962634015954636 },
+  { 1.8508766487100685, -0.59999999999999998, 0.10000000000000001, 
+	  1.5707963267948966 },
+};
+const double toler032 = 2.5000000000000020e-13;
 
 // Test data for k=-0.59999999999999998, nu=0.20000000000000001.
-testcase_ellint_3<double> data033[] = {
-  { -0.0000000000000000, -0.59999999999999998, 0.20000000000000001,
-          0.0000000000000000 },
-  { 0.17449937871800653, -0.59999999999999998, 0.20000000000000001,
-          0.17453292519943295 },
-  { 0.34884093647346553, -0.59999999999999998, 0.20000000000000001,
-          0.34906585039886590 },
-  { 0.52306221119844110, -0.59999999999999998, 0.20000000000000001,
-          0.52359877559829882 },
-  { 0.69749955678982223, -0.59999999999999998, 0.20000000000000001,
-          0.69813170079773179 },
-  { 0.87274610682416853, -0.59999999999999998, 0.20000000000000001,
-          0.87266462599716477 },
-  { 1.0494620540750792, -0.59999999999999998, 0.20000000000000001,
-          1.0471975511965976 },
-  { 1.2280847305507339, -0.59999999999999998, 0.20000000000000001,
-          1.2217304763960306 },
-  { 1.4085436279696886, -0.59999999999999998, 0.20000000000000001,
-          1.3962634015954636 },
-  { 1.5901418016279374, -0.59999999999999998, 0.20000000000000001,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.59999999999999998, nu=0.20000000000000001.
-template <typename Tp>
-void test033()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data033)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data033[i].k), Tp(data033[i].nu),
-                   Tp(data033[i].phi));
-      const Tp f0 = data033[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.59999999999999998, nu=0.29999999999999999.
-testcase_ellint_3<double> data034[] = {
-  { -0.0000000000000000, -0.59999999999999998, 0.29999999999999999,
-          0.0000000000000000 },
-  { 0.17432424744393935, -0.59999999999999998, 0.29999999999999999,
-          0.17453292519943295 },
-  { 0.34748744127146447, -0.59999999999999998, 0.29999999999999999,
-          0.34906585039886590 },
-  { 0.51873632743924847, -0.59999999999999998, 0.29999999999999999,
-          0.52359877559829882 },
-  { 0.68794610396313127, -0.59999999999999998, 0.29999999999999999,
-          0.69813170079773179 },
-  { 0.85558070175468726, -0.59999999999999998, 0.29999999999999999,
-          0.87266462599716477 },
-  { 1.0224416343605653, -0.59999999999999998, 0.29999999999999999,
-          1.0471975511965976 },
-  { 1.1893144457936788, -0.59999999999999998, 0.29999999999999999,
-          1.2217304763960306 },
-  { 1.3566435377982575, -0.59999999999999998, 0.29999999999999999,
-          1.3962634015954636 },
-  { 1.5243814243493585, -0.59999999999999998, 0.29999999999999999,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.59999999999999998, nu=0.29999999999999999.
-template <typename Tp>
-void test034()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data034)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data034[i].k), Tp(data034[i].nu),
-                   Tp(data034[i].phi));
-      const Tp f0 = data034[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.0940560416437693e-16
+// mean(f - f_Boost): 4.1633363423443370e-17
+// variance(f - f_Boost): 8.5834655546147173e-33
+// stddev(f - f_Boost): 9.2646994309662939e-17
+const testcase_ellint_3<double>
+data033[10] =
+{
+  { 0.0000000000000000, -0.59999999999999998, 0.20000000000000001, 
+	  0.0000000000000000 },
+  { 0.17520627248155893, -0.59999999999999998, 0.20000000000000001, 
+	  0.17453292519943295 },
+  { 0.35444873935437748, -0.59999999999999998, 0.20000000000000001, 
+	  0.34906585039886590 },
+  { 0.54172310557682524, -0.59999999999999998, 0.20000000000000001, 
+	  0.52359877559829882 },
+  { 0.74084300280734672, -0.59999999999999998, 0.20000000000000001, 
+	  0.69813170079773179 },
+  { 0.95509001527006121, -0.59999999999999998, 0.20000000000000001, 
+	  0.87266462599716477 },
+  { 1.1865688084431796, -0.59999999999999998, 0.20000000000000001, 
+	  1.0471975511965976 },
+  { 1.4352978868932598, -0.59999999999999998, 0.20000000000000001, 
+	  1.2217304763960306 },
+  { 1.6983400371331816, -0.59999999999999998, 0.20000000000000001, 
+	  1.3962634015954636 },
+  { 1.9695980282802215, -0.59999999999999998, 0.20000000000000001, 
+	  1.5707963267948966 },
+};
+const double toler033 = 2.5000000000000020e-13;
+
+// Test data for k=-0.59999999999999998, nu=0.30000000000000004.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 2.9470074709717020e-16
+// mean(f - f_Boost): 7.4940054162198071e-17
+// variance(f - f_Boost): 1.6823592487044846e-32
+// stddev(f - f_Boost): 1.2970579203352812e-16
+const testcase_ellint_3<double>
+data034[10] =
+{
+  { 0.0000000000000000, -0.59999999999999998, 0.30000000000000004, 
+	  0.0000000000000000 },
+  { 0.17538460882640122, -0.59999999999999998, 0.30000000000000004, 
+	  0.17453292519943295 },
+  { 0.35590165133735557, -0.59999999999999998, 0.30000000000000004, 
+	  0.34906585039886590 },
+  { 0.54676661152254535, -0.59999999999999998, 0.30000000000000004, 
+	  0.52359877559829882 },
+  { 0.75321709418305305, -0.59999999999999998, 0.30000000000000004, 
+	  0.69813170079773179 },
+  { 0.98012637808992920, -0.59999999999999998, 0.30000000000000004, 
+	  0.87266462599716477 },
+  { 1.2310891277158875, -0.59999999999999998, 0.30000000000000004, 
+	  1.0471975511965976 },
+  { 1.5069157924585623, -0.59999999999999998, 0.30000000000000004, 
+	  1.2217304763960306 },
+  { 1.8039583598337940, -0.59999999999999998, 0.30000000000000004, 
+	  1.3962634015954636 },
+  { 2.1134154405060599, -0.59999999999999998, 0.30000000000000004, 
+	  1.5707963267948966 },
+};
+const double toler034 = 2.5000000000000020e-13;
 
 // Test data for k=-0.59999999999999998, nu=0.40000000000000002.
-testcase_ellint_3<double> data035[] = {
-  { -0.0000000000000000, -0.59999999999999998, 0.40000000000000002,
-          0.0000000000000000 },
-  { 0.17414974487670720, -0.59999999999999998, 0.40000000000000002,
-          0.17453292519943295 },
-  { 0.34615238767335027, -0.59999999999999998, 0.40000000000000002,
-          0.34906585039886590 },
-  { 0.51453257838108579, -0.59999999999999998, 0.40000000000000002,
-          0.52359877559829882 },
-  { 0.67882386787534410, -0.59999999999999998, 0.40000000000000002,
-          0.69813170079773179 },
-  { 0.83948470233173578, -0.59999999999999998, 0.40000000000000002,
-          0.87266462599716477 },
-  { 0.99753496200073977, -0.59999999999999998, 0.40000000000000002,
-          1.0471975511965976 },
-  { 1.1541101404388487, -0.59999999999999998, 0.40000000000000002,
-          1.2217304763960306 },
-  { 1.3100911323398814, -0.59999999999999998, 0.40000000000000002,
-          1.3962634015954636 },
-  { 1.4659345278069984, -0.59999999999999998, 0.40000000000000002,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.59999999999999998, nu=0.40000000000000002.
-template <typename Tp>
-void test035()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data035)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data035[i].k), Tp(data035[i].nu),
-                   Tp(data035[i].phi));
-      const Tp f0 = data035[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 2.7909659715991921e-16
+// mean(f - f_Boost): -2.7755575615628915e-18
+// variance(f - f_Boost): 2.4044165394594425e-32
+// stddev(f - f_Boost): 1.5506181152880429e-16
+const testcase_ellint_3<double>
+data035[10] =
+{
+  { 0.0000000000000000, -0.59999999999999998, 0.40000000000000002, 
+	  0.0000000000000000 },
+  { 0.17556359876533037, -0.59999999999999998, 0.40000000000000002, 
+	  0.17453292519943295 },
+  { 0.35737601674244679, -0.59999999999999998, 0.40000000000000002, 
+	  0.34906585039886590 },
+  { 0.55197933771320218, -0.59999999999999998, 0.40000000000000002, 
+	  0.52359877559829882 },
+  { 0.76633591620002894, -0.59999999999999998, 0.40000000000000002, 
+	  0.69813170079773179 },
+  { 1.0075231136019616, -0.59999999999999998, 0.40000000000000002, 
+	  0.87266462599716477 },
+  { 1.2815842073813450, -0.59999999999999998, 0.40000000000000002, 
+	  1.0471975511965976 },
+  { 1.5911666941449827, -0.59999999999999998, 0.40000000000000002, 
+	  1.2217304763960306 },
+  { 1.9323227566025762, -0.59999999999999998, 0.40000000000000002, 
+	  1.3962634015954636 },
+  { 2.2925036420985130, -0.59999999999999998, 0.40000000000000002, 
+	  1.5707963267948966 },
+};
+const double toler035 = 2.5000000000000020e-13;
 
 // Test data for k=-0.59999999999999998, nu=0.50000000000000000.
-testcase_ellint_3<double> data036[] = {
-  { -0.0000000000000000, -0.59999999999999998, 0.50000000000000000,
-          0.0000000000000000 },
-  { 0.17397586700252810, -0.59999999999999998, 0.50000000000000000,
-          0.17453292519943295 },
-  { 0.34483533397138516, -0.59999999999999998, 0.50000000000000000,
-          0.34906585039886590 },
-  { 0.51044500461706499, -0.59999999999999998, 0.50000000000000000,
-          0.52359877559829882 },
-  { 0.67009988034712675, -0.59999999999999998, 0.50000000000000000,
-          0.69813170079773179 },
-  { 0.82434762375735193, -0.59999999999999998, 0.50000000000000000,
-          0.87266462599716477 },
-  { 0.97447346702798998, -0.59999999999999998, 0.50000000000000000,
-          1.0471975511965976 },
-  { 1.1219494000522143, -0.59999999999999998, 0.50000000000000000,
-          1.2217304763960306 },
-  { 1.2680242605954486, -0.59999999999999998, 0.50000000000000000,
-          1.3962634015954636 },
-  { 1.4135484285693078, -0.59999999999999998, 0.50000000000000000,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.59999999999999998, nu=0.50000000000000000.
-template <typename Tp>
-void test036()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data036)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data036[i].k), Tp(data036[i].nu),
-                   Tp(data036[i].phi));
-      const Tp f0 = data036[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.59999999999999998, nu=0.59999999999999998.
-testcase_ellint_3<double> data037[] = {
-  { -0.0000000000000000, -0.59999999999999998, 0.59999999999999998,
-          0.0000000000000000 },
-  { 0.17380260984469356, -0.59999999999999998, 0.59999999999999998,
-          0.17453292519943295 },
-  { 0.34353585361777839, -0.59999999999999998, 0.59999999999999998,
-          0.34906585039886590 },
-  { 0.50646805774321402, -0.59999999999999998, 0.59999999999999998,
-          0.52359877559829882 },
-  { 0.66174468108625517, -0.59999999999999998, 0.59999999999999998,
-          0.69813170079773179 },
-  { 0.81007462280278408, -0.59999999999999998, 0.59999999999999998,
-          0.87266462599716477 },
-  { 0.95303466945718729, -0.59999999999999998, 0.59999999999999998,
-          1.0471975511965976 },
-  { 1.0924118588677503, -0.59999999999999998, 0.59999999999999998,
-          1.2217304763960306 },
-  { 1.2297640574847937, -0.59999999999999998, 0.59999999999999998,
-          1.3962634015954636 },
-  { 1.3662507535812816, -0.59999999999999998, 0.59999999999999998,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.59999999999999998, nu=0.59999999999999998.
-template <typename Tp>
-void test037()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data037)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data037[i].k), Tp(data037[i].nu),
-                   Tp(data037[i].phi));
-      const Tp f0 = data037[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.59999999999999998, nu=0.69999999999999996.
-testcase_ellint_3<double> data038[] = {
-  { -0.0000000000000000, -0.59999999999999998, 0.69999999999999996,
-          0.0000000000000000 },
-  { 0.17362996946312009, -0.59999999999999998, 0.69999999999999996,
-          0.17453292519943295 },
-  { 0.34225353454870588, -0.59999999999999998, 0.69999999999999996,
-          0.34906585039886590 },
-  { 0.50259656397799546, -0.59999999999999998, 0.69999999999999996,
-          0.52359877559829882 },
-  { 0.65373184496628944, -0.59999999999999998, 0.69999999999999996,
-          0.69813170079773179 },
-  { 0.79658372884056439, -0.59999999999999998, 0.69999999999999996,
-          0.87266462599716477 },
-  { 0.93303240100245421, -0.59999999999999998, 0.69999999999999996,
-          1.0471975511965976 },
-  { 1.0651547944716557, -0.59999999999999998, 0.69999999999999996,
-          1.2217304763960306 },
-  { 1.1947676204853441, -0.59999999999999998, 0.69999999999999996,
-          1.3962634015954636 },
-  { 1.3232737468822811, -0.59999999999999998, 0.69999999999999996,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.59999999999999998, nu=0.69999999999999996.
-template <typename Tp>
-void test038()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data038)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data038[i].k), Tp(data038[i].nu),
-                   Tp(data038[i].phi));
-      const Tp f0 = data038[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 2.6240126899196213e-16
+// mean(f - f_Boost): 9.1593399531575410e-17
+// variance(f - f_Boost): 1.0357223256482469e-33
+// stddev(f - f_Boost): 3.2182640128619758e-17
+const testcase_ellint_3<double>
+data036[10] =
+{
+  { 0.0000000000000000, -0.59999999999999998, 0.50000000000000000, 
+	  0.0000000000000000 },
+  { 0.17574324658480217, -0.59999999999999998, 0.50000000000000000, 
+	  0.17453292519943295 },
+  { 0.35887240603169313, -0.59999999999999998, 0.50000000000000000, 
+	  0.34906585039886590 },
+  { 0.55737161826345261, -0.59999999999999998, 0.50000000000000000, 
+	  0.52359877559829882 },
+  { 0.78028227313077458, -0.59999999999999998, 0.50000000000000000, 
+	  0.69813170079773179 },
+  { 1.0376989776486290, -0.59999999999999998, 0.50000000000000000, 
+	  0.87266462599716477 },
+  { 1.3395933991042925, -0.59999999999999998, 0.50000000000000000, 
+	  1.0471975511965976 },
+  { 1.6924049626591782, -0.59999999999999998, 0.50000000000000000, 
+	  1.2217304763960306 },
+  { 2.0931011856518920, -0.59999999999999998, 0.50000000000000000, 
+	  1.3962634015954636 },
+  { 2.5239007084492706, -0.59999999999999998, 0.50000000000000000, 
+	  1.5707963267948966 },
+};
+const double toler036 = 2.5000000000000020e-13;
+
+// Test data for k=-0.59999999999999998, nu=0.60000000000000009.
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.6651378277398083e-16
+// mean(f - f_Boost): 1.1934897514720432e-16
+// variance(f - f_Boost): 1.7585404776158019e-33
+// stddev(f - f_Boost): 4.1934955319110598e-17
+const testcase_ellint_3<double>
+data037[10] =
+{
+  { 0.0000000000000000, -0.59999999999999998, 0.60000000000000009, 
+	  0.0000000000000000 },
+  { 0.17592355661219386, -0.59999999999999998, 0.60000000000000009, 
+	  0.17453292519943295 },
+  { 0.36039141192661606, -0.59999999999999998, 0.60000000000000009, 
+	  0.34906585039886590 },
+  { 0.56295472636903854, -0.59999999999999998, 0.60000000000000009, 
+	  0.52359877559829882 },
+  { 0.79515295130165986, -0.59999999999999998, 0.60000000000000009, 
+	  0.69813170079773179 },
+  { 1.0711886441942242, -0.59999999999999998, 0.60000000000000009, 
+	  0.87266462599716477 },
+  { 1.4072952835139891, -0.59999999999999998, 0.60000000000000009, 
+	  1.0471975511965976 },
+  { 1.8174863977376825, -0.59999999999999998, 0.60000000000000009, 
+	  1.2217304763960306 },
+  { 2.3029921578542232, -0.59999999999999998, 0.60000000000000009, 
+	  1.3962634015954636 },
+  { 2.8388723099514972, -0.59999999999999998, 0.60000000000000009, 
+	  1.5707963267948966 },
+};
+const double toler037 = 2.5000000000000020e-13;
+
+// Test data for k=-0.59999999999999998, nu=0.70000000000000007.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 2.2451074234797436e-16
+// mean(f - f_Boost): 5.2735593669694933e-17
+// variance(f - f_Boost): 3.4333862218458872e-34
+// stddev(f - f_Boost): 1.8529398861932589e-17
+const testcase_ellint_3<double>
+data038[10] =
+{
+  { 0.0000000000000000, -0.59999999999999998, 0.70000000000000007, 
+	  0.0000000000000000 },
+  { 0.17610453321631936, -0.59999999999999998, 0.70000000000000007, 
+	  0.17453292519943295 },
+  { 0.36193365056369764, -0.59999999999999998, 0.70000000000000007, 
+	  0.34906585039886590 },
+  { 0.56874098962268527, -0.59999999999999998, 0.70000000000000007, 
+	  0.52359877559829882 },
+  { 0.81106198671477181, -0.59999999999999998, 0.70000000000000007, 
+	  0.69813170079773179 },
+  { 1.1086886419010082, -0.59999999999999998, 0.70000000000000007, 
+	  0.87266462599716477 },
+  { 1.4879048567239257, -0.59999999999999998, 0.70000000000000007, 
+	  1.0471975511965976 },
+  { 1.9780310073615923, -0.59999999999999998, 0.70000000000000007, 
+	  1.2217304763960306 },
+  { 2.5941545586772712, -0.59999999999999998, 0.70000000000000007, 
+	  1.3962634015954636 },
+  { 3.3029735898397155, -0.59999999999999998, 0.70000000000000007, 
+	  1.5707963267948966 },
+};
+const double toler038 = 2.5000000000000020e-13;
 
 // Test data for k=-0.59999999999999998, nu=0.80000000000000004.
-testcase_ellint_3<double> data039[] = {
-  { -0.0000000000000000, -0.59999999999999998, 0.80000000000000004,
-          0.0000000000000000 },
-  { 0.17345794195390687, -0.59999999999999998, 0.80000000000000004,
-          0.17453292519943295 },
-  { 0.34098797854531027, -0.59999999999999998, 0.80000000000000004,
-          0.34906585039886590 },
-  { 0.49882569168826230, -0.59999999999999998, 0.80000000000000004,
-          0.52359877559829882 },
-  { 0.64603758566475511, -0.59999999999999998, 0.80000000000000004,
-          0.69813170079773179 },
-  { 0.78380365594769730, -0.59999999999999998, 0.80000000000000004,
-          0.87266462599716477 },
-  { 0.91430946255611190, -0.59999999999999998, 0.80000000000000004,
-          1.0471975511965976 },
-  { 1.0398955217270607, -0.59999999999999998, 0.80000000000000004,
-          1.2217304763960306 },
-  { 1.1625948314277676, -0.59999999999999998, 0.80000000000000004,
-          1.3962634015954636 },
-  { 1.2840021261752192, -0.59999999999999998, 0.80000000000000004,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.59999999999999998, nu=0.80000000000000004.
-template <typename Tp>
-void test039()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data039)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data039[i].k), Tp(data039[i].nu),
-                   Tp(data039[i].phi));
-      const Tp f0 = data039[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 4.3826960061025914e-16
+// mean(f - f_Boost): 2.7478019859472625e-16
+// variance(f - f_Boost): 4.6451528105588637e-32
+// stddev(f - f_Boost): 2.1552616570984749e-16
+const testcase_ellint_3<double>
+data039[10] =
+{
+  { 0.0000000000000000, -0.59999999999999998, 0.80000000000000004, 
+	  0.0000000000000000 },
+  { 0.17628618080795252, -0.59999999999999998, 0.80000000000000004, 
+	  0.17453292519943295 },
+  { 0.36349976272521012, -0.59999999999999998, 0.80000000000000004, 
+	  0.34906585039886590 },
+  { 0.57474392342151914, -0.59999999999999998, 0.80000000000000004, 
+	  0.52359877559829882 },
+  { 0.82814493499158159, -0.59999999999999998, 0.80000000000000004, 
+	  0.69813170079773179 },
+  { 1.1511281795998280, -0.59999999999999998, 0.80000000000000004, 
+	  0.87266462599716477 },
+  { 1.5864286332503075, -0.59999999999999998, 0.80000000000000004, 
+	  1.0471975511965976 },
+  { 2.1958944866494527, -0.59999999999999998, 0.80000000000000004, 
+	  1.2217304763960306 },
+  { 3.0398358172574604, -0.59999999999999998, 0.80000000000000004, 
+	  1.3962634015954636 },
+  { 4.0867036409261832, -0.59999999999999998, 0.80000000000000004, 
+	  1.5707963267948966 },
+};
+const double toler039 = 2.5000000000000020e-13;
 
 // Test data for k=-0.59999999999999998, nu=0.90000000000000002.
-testcase_ellint_3<double> data040[] = {
-  { -0.0000000000000000, -0.59999999999999998, 0.90000000000000002,
-          0.0000000000000000 },
-  { 0.17328652344890033, -0.59999999999999998, 0.90000000000000002,
-          0.17453292519943295 },
-  { 0.33973880062929018, -0.59999999999999998, 0.90000000000000002,
-          0.34906585039886590 },
-  { 0.49515092233122765, -0.59999999999999998, 0.90000000000000002,
-          0.52359877559829882 },
-  { 0.63864042139737043, -0.59999999999999998, 0.90000000000000002,
-          0.69813170079773179 },
-  { 0.77167205646538850, -0.59999999999999998, 0.90000000000000002,
-          0.87266462599716477 },
-  { 0.89673202848034383, -0.59999999999999998, 0.90000000000000002,
-          1.0471975511965976 },
-  { 1.0163984492661304, -0.59999999999999998, 0.90000000000000002,
-          1.2217304763960306 },
-  { 1.1328845785162431, -0.59999999999999998, 0.90000000000000002,
-          1.3962634015954636 },
-  { 1.2479362973851875, -0.59999999999999998, 0.90000000000000002,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.59999999999999998, nu=0.90000000000000002.
-template <typename Tp>
-void test040()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data040)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data040[i].k), Tp(data040[i].nu),
-                   Tp(data040[i].phi));
-      const Tp f0 = data040[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 2.2204460492503131e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 5.7440178400898422e-16
+// mean(f - f_Boost): 5.0792703376600914e-16
+// variance(f - f_Boost): 1.9863137923719990e-31
+// stddev(f - f_Boost): 4.4568080420543122e-16
+const testcase_ellint_3<double>
+data040[10] =
+{
+  { 0.0000000000000000, -0.59999999999999998, 0.90000000000000002, 
+	  0.0000000000000000 },
+  { 0.17646850384035848, -0.59999999999999998, 0.90000000000000002, 
+	  0.17453292519943295 },
+  { 0.36509041515134105, -0.59999999999999998, 0.90000000000000002, 
+	  0.34906585039886590 },
+  { 0.58097838596260631, -0.59999999999999998, 0.90000000000000002, 
+	  0.52359877559829882 },
+  { 0.84656453396163722, -0.59999999999999998, 0.90000000000000002, 
+	  0.69813170079773179 },
+  { 1.1997828426963724, -0.59999999999999998, 0.90000000000000002, 
+	  0.87266462599716477 },
+  { 1.7112436789225605, -0.59999999999999998, 0.90000000000000002, 
+	  1.0471975511965976 },
+  { 2.5193168553672312, -0.59999999999999998, 0.90000000000000002, 
+	  1.2217304763960306 },
+  { 3.8656670488606686, -0.59999999999999998, 0.90000000000000002, 
+	  1.3962634015954636 },
+  { 5.8709993116265595, -0.59999999999999998, 0.90000000000000002, 
+	  1.5707963267948966 },
+};
+const double toler040 = 2.5000000000000020e-13;
 
 // Test data for k=-0.50000000000000000, nu=0.0000000000000000.
-testcase_ellint_3<double> data041[] = {
-  { -0.0000000000000000, -0.50000000000000000, 0.0000000000000000,
-          0.0000000000000000 },
-  { 0.17475385514035785, -0.50000000000000000, 0.0000000000000000,
-          0.17453292519943295 },
-  { 0.35081868470101585, -0.50000000000000000, 0.0000000000000000,
-          0.34906585039886590 },
-  { 0.52942862705190585, -0.50000000000000000, 0.0000000000000000,
-          0.52359877559829882 },
-  { 0.71164727562630326, -0.50000000000000000, 0.0000000000000000,
-          0.69813170079773179 },
-  { 0.89824523594227768, -0.50000000000000000, 0.0000000000000000,
-          0.87266462599716477 },
-  { 1.0895506700518851, -0.50000000000000000, 0.0000000000000000,
-          1.0471975511965976 },
-  { 1.2853005857432933, -0.50000000000000000, 0.0000000000000000,
-          1.2217304763960306 },
-  { 1.4845545520549484, -0.50000000000000000, 0.0000000000000000,
-          1.3962634015954636 },
-  { 1.6857503548125963, -0.50000000000000000, 0.0000000000000000,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.50000000000000000, nu=0.0000000000000000.
-template <typename Tp>
-void test041()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data041)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data041[i].k), Tp(data041[i].nu),
-                   Tp(data041[i].phi));
-      const Tp f0 = data041[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.4551389361831220e-16
+// mean(f - f_Boost): -1.3877787807814457e-17
+// variance(f - f_Boost): 2.5893058141206173e-32
+// stddev(f - f_Boost): 1.6091320064309879e-16
+const testcase_ellint_3<double>
+data041[10] =
+{
+  { 0.0000000000000000, -0.50000000000000000, 0.0000000000000000, 
+	  0.0000000000000000 },
+  { 0.17475385514035785, -0.50000000000000000, 0.0000000000000000, 
+	  0.17453292519943295 },
+  { 0.35081868470101579, -0.50000000000000000, 0.0000000000000000, 
+	  0.34906585039886590 },
+  { 0.52942862705190574, -0.50000000000000000, 0.0000000000000000, 
+	  0.52359877559829882 },
+  { 0.71164727562630326, -0.50000000000000000, 0.0000000000000000, 
+	  0.69813170079773179 },
+  { 0.89824523594227768, -0.50000000000000000, 0.0000000000000000, 
+	  0.87266462599716477 },
+  { 1.0895506700518853, -0.50000000000000000, 0.0000000000000000, 
+	  1.0471975511965976 },
+  { 1.2853005857432933, -0.50000000000000000, 0.0000000000000000, 
+	  1.2217304763960306 },
+  { 1.4845545520549488, -0.50000000000000000, 0.0000000000000000, 
+	  1.3962634015954636 },
+  { 1.6857503548125961, -0.50000000000000000, 0.0000000000000000, 
+	  1.5707963267948966 },
+};
+const double toler041 = 2.5000000000000020e-13;
 
 // Test data for k=-0.50000000000000000, nu=0.10000000000000001.
-testcase_ellint_3<double> data042[] = {
-  { -0.0000000000000000, -0.50000000000000000, 0.10000000000000001,
-          0.0000000000000000 },
-  { 0.17457763120814676, -0.50000000000000000, 0.10000000000000001,
-          0.17453292519943295 },
-  { 0.34943246340849154, -0.50000000000000000, 0.10000000000000001,
-          0.34906585039886590 },
-  { 0.52487937869610801, -0.50000000000000000, 0.10000000000000001,
-          0.52359877559829882 },
-  { 0.70127785096388395, -0.50000000000000000, 0.10000000000000001,
-          0.69813170079773179 },
-  { 0.87898815988624479, -0.50000000000000000, 0.10000000000000001,
-          0.87266462599716477 },
-  { 1.0582764576094172, -0.50000000000000000, 0.10000000000000001,
-          1.0471975511965976 },
-  { 1.2391936844060207, -0.50000000000000000, 0.10000000000000001,
-          1.2217304763960306 },
-  { 1.4214793542995841, -0.50000000000000000, 0.10000000000000001,
-          1.3962634015954636 },
-  { 1.6045524936084892, -0.50000000000000000, 0.10000000000000001,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.50000000000000000, nu=0.10000000000000001.
-template <typename Tp>
-void test042()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data042)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data042[i].k), Tp(data042[i].nu),
-                   Tp(data042[i].phi));
-      const Tp f0 = data042[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.7416868347177582e-16
+// mean(f - f_Boost): 2.7755575615628915e-18
+// variance(f - f_Boost): 5.4326441655972001e-32
+// stddev(f - f_Boost): 2.3308033305273100e-16
+const testcase_ellint_3<double>
+data042[10] =
+{
+  { 0.0000000000000000, -0.50000000000000000, 0.10000000000000001, 
+	  0.0000000000000000 },
+  { 0.17493071928248824, -0.50000000000000000, 0.10000000000000001, 
+	  0.17453292519943295 },
+  { 0.35222467688034798, -0.50000000000000000, 0.10000000000000001, 
+	  0.34906585039886590 },
+  { 0.53411928652008112, -0.50000000000000000, 0.10000000000000001, 
+	  0.52359877559829882 },
+  { 0.72256398117177589, -0.50000000000000000, 0.10000000000000001, 
+	  0.69813170079773179 },
+  { 0.91899583232771009, -0.50000000000000000, 0.10000000000000001, 
+	  0.87266462599716477 },
+  { 1.1240549163055360, -0.50000000000000000, 0.10000000000000001, 
+	  1.0471975511965976 },
+  { 1.3372938086286021, -0.50000000000000000, 0.10000000000000001, 
+	  1.2217304763960306 },
+  { 1.5570024469132429, -0.50000000000000000, 0.10000000000000001, 
+	  1.3962634015954636 },
+  { 1.7803034946545480, -0.50000000000000000, 0.10000000000000001, 
+	  1.5707963267948966 },
+};
+const double toler042 = 2.5000000000000020e-13;
 
 // Test data for k=-0.50000000000000000, nu=0.20000000000000001.
-testcase_ellint_3<double> data043[] = {
-  { -0.0000000000000000, -0.50000000000000000, 0.20000000000000001,
-          0.0000000000000000 },
-  { 0.17440204336345433, -0.50000000000000000, 0.20000000000000001,
-          0.17453292519943295 },
-  { 0.34806552388338824, -0.50000000000000000, 0.20000000000000001,
-          0.34906585039886590 },
-  { 0.52046416757129821, -0.50000000000000000, 0.20000000000000001,
-          0.52359877559829882 },
-  { 0.69140924550993876, -0.50000000000000000, 0.20000000000000001,
-          0.69813170079773179 },
-  { 0.86104678636125520, -0.50000000000000000, 0.20000000000000001,
-          0.87266462599716477 },
-  { 1.0297439459053981, -0.50000000000000000, 0.20000000000000001,
-          1.0471975511965976 },
-  { 1.1979214112912036, -0.50000000000000000, 0.20000000000000001,
-          1.2217304763960306 },
-  { 1.3659033858648930, -0.50000000000000000, 0.20000000000000001,
-          1.3962634015954636 },
-  { 1.5338490483665983, -0.50000000000000000, 0.20000000000000001,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.50000000000000000, nu=0.20000000000000001.
-template <typename Tp>
-void test043()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data043)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data043[i].k), Tp(data043[i].nu),
-                   Tp(data043[i].phi));
-      const Tp f0 = data043[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.50000000000000000, nu=0.29999999999999999.
-testcase_ellint_3<double> data044[] = {
-  { -0.0000000000000000, -0.50000000000000000, 0.29999999999999999,
-          0.0000000000000000 },
-  { 0.17422708752228896, -0.50000000000000000, 0.29999999999999999,
-          0.17453292519943295 },
-  { 0.34671739434855858, -0.50000000000000000, 0.29999999999999999,
-          0.34906585039886590 },
-  { 0.51617616305641889, -0.50000000000000000, 0.29999999999999999,
-          0.52359877559829882 },
-  { 0.68200047612545178, -0.50000000000000000, 0.29999999999999999,
-          0.69813170079773179 },
-  { 0.84427217869498372, -0.50000000000000000, 0.29999999999999999,
-          0.87266462599716477 },
-  { 1.0035637821389782, -0.50000000000000000, 0.29999999999999999,
-          1.0471975511965976 },
-  { 1.1606800483933113, -0.50000000000000000, 0.29999999999999999,
-          1.2217304763960306 },
-  { 1.3164407134643459, -0.50000000000000000, 0.29999999999999999,
-          1.3962634015954636 },
-  { 1.4715681939859637, -0.50000000000000000, 0.29999999999999999,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.50000000000000000, nu=0.29999999999999999.
-template <typename Tp>
-void test044()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data044)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data044[i].k), Tp(data044[i].nu),
-                   Tp(data044[i].phi));
-      const Tp f0 = data044[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.1198767993730867e-16
+// mean(f - f_Boost): 2.7755575615628914e-17
+// variance(f - f_Boost): 5.0311947683004831e-32
+// stddev(f - f_Boost): 2.2430324938128922e-16
+const testcase_ellint_3<double>
+data043[10] =
+{
+  { 0.0000000000000000, -0.50000000000000000, 0.20000000000000001, 
+	  0.0000000000000000 },
+  { 0.17510822779582402, -0.50000000000000000, 0.20000000000000001, 
+	  0.17453292519943295 },
+  { 0.35365094725531487, -0.50000000000000000, 0.20000000000000001, 
+	  0.34906585039886590 },
+  { 0.53895933237328697, -0.50000000000000000, 0.20000000000000001, 
+	  0.52359877559829882 },
+  { 0.73408090840070794, -0.50000000000000000, 0.20000000000000001, 
+	  0.69813170079773179 },
+  { 0.94145442818535396, -0.50000000000000000, 0.20000000000000001, 
+	  0.87266462599716477 },
+  { 1.1624120186296487, -0.50000000000000000, 0.20000000000000001, 
+	  1.0471975511965976 },
+  { 1.3965823372867114, -0.50000000000000000, 0.20000000000000001, 
+	  1.2217304763960306 },
+  { 1.6414308440430099, -0.50000000000000000, 0.20000000000000001, 
+	  1.3962634015954636 },
+  { 1.8922947612264018, -0.50000000000000000, 0.20000000000000001, 
+	  1.5707963267948966 },
+};
+const double toler043 = 2.5000000000000020e-13;
+
+// Test data for k=-0.50000000000000000, nu=0.30000000000000004.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.3800262770228813e-16
+// mean(f - f_Boost): 5.8286708792820721e-17
+// variance(f - f_Boost): 8.5027191584278157e-32
+// stddev(f - f_Boost): 2.9159422419567599e-16
+const testcase_ellint_3<double>
+data044[10] =
+{
+  { 0.0000000000000000, -0.50000000000000000, 0.30000000000000004, 
+	  0.0000000000000000 },
+  { 0.17528638488102041, -0.50000000000000000, 0.30000000000000004, 
+	  0.17453292519943295 },
+  { 0.35509802222332720, -0.50000000000000000, 0.30000000000000004, 
+	  0.34906585039886590 },
+  { 0.54395740731866193, -0.50000000000000000, 0.30000000000000004, 
+	  0.52359877559829882 },
+  { 0.74625871438752667, -0.50000000000000000, 0.30000000000000004, 
+	  0.69813170079773179 },
+  { 0.96588271186092023, -0.50000000000000000, 0.30000000000000004, 
+	  0.87266462599716477 },
+  { 1.2054319584357329, -0.50000000000000000, 0.30000000000000004, 
+	  1.0471975511965976 },
+  { 1.4651077994832871, -0.50000000000000000, 0.30000000000000004, 
+	  1.2217304763960306 },
+  { 1.7416018368052644, -0.50000000000000000, 0.30000000000000004, 
+	  1.3962634015954636 },
+  { 2.0277924458111314, -0.50000000000000000, 0.30000000000000004, 
+	  1.5707963267948966 },
+};
+const double toler044 = 2.5000000000000020e-13;
 
 // Test data for k=-0.50000000000000000, nu=0.40000000000000002.
-testcase_ellint_3<double> data045[] = {
-  { -0.0000000000000000, -0.50000000000000000, 0.40000000000000002,
-          0.0000000000000000 },
-  { 0.17405275963859917, -0.50000000000000000, 0.40000000000000002,
-          0.17453292519943295 },
-  { 0.34538761957029329, -0.50000000000000000, 0.40000000000000002,
-          0.34906585039886590 },
-  { 0.51200902646603919, -0.50000000000000000, 0.40000000000000002,
-          0.52359877559829882 },
-  { 0.67301522212868792, -0.50000000000000000, 0.40000000000000002,
-          0.69813170079773179 },
-  { 0.82853844466313320, -0.50000000000000000, 0.40000000000000002,
-          0.87266462599716477 },
-  { 0.97942097862681488, -0.50000000000000000, 0.40000000000000002,
-          1.0471975511965976 },
-  { 1.1268429801220616, -0.50000000000000000, 0.40000000000000002,
-          1.2217304763960306 },
-  { 1.2720406704533922, -0.50000000000000000, 0.40000000000000002,
-          1.3962634015954636 },
-  { 1.4161679518465340, -0.50000000000000000, 0.40000000000000002,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.50000000000000000, nu=0.40000000000000002.
-template <typename Tp>
-void test045()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data045)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data045[i].k), Tp(data045[i].nu),
-                   Tp(data045[i].phi));
-      const Tp f0 = data045[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.0439932918341581e-16
+// mean(f - f_Boost): 3.0531133177191807e-17
+// variance(f - f_Boost): 9.0809736800018602e-32
+// stddev(f - f_Boost): 3.0134653938616686e-16
+const testcase_ellint_3<double>
+data045[10] =
+{
+  { 0.0000000000000000, -0.50000000000000000, 0.40000000000000002, 
+	  0.0000000000000000 },
+  { 0.17546519477859268, -0.50000000000000000, 0.40000000000000002, 
+	  0.17453292519943295 },
+  { 0.35656644822531680, -0.50000000000000000, 0.40000000000000002, 
+	  0.34906585039886590 },
+  { 0.54912289677411319, -0.50000000000000000, 0.40000000000000002, 
+	  0.52359877559829882 },
+  { 0.75916731611690047, -0.50000000000000000, 0.40000000000000002, 
+	  0.69813170079773179 },
+  { 0.99260415631328214, -0.50000000000000000, 0.40000000000000002, 
+	  0.87266462599716477 },
+  { 1.2541925856918670, -0.50000000000000000, 0.40000000000000002, 
+	  1.0471975511965976 },
+  { 1.5456393705347609, -0.50000000000000000, 0.40000000000000002, 
+	  1.2217304763960306 },
+  { 1.8631904972952076, -0.50000000000000000, 0.40000000000000002, 
+	  1.3962634015954636 },
+  { 2.1962905366178065, -0.50000000000000000, 0.40000000000000002, 
+	  1.5707963267948966 },
+};
+const double toler045 = 2.5000000000000020e-13;
 
 // Test data for k=-0.50000000000000000, nu=0.50000000000000000.
-testcase_ellint_3<double> data046[] = {
-  { -0.0000000000000000, -0.50000000000000000, 0.50000000000000000,
-          0.0000000000000000 },
-  { 0.17387905570381157, -0.50000000000000000, 0.50000000000000000,
-          0.17453292519943295 },
-  { 0.34407576010465207, -0.50000000000000000, 0.50000000000000000,
-          0.34906585039886590 },
-  { 0.50795686560160835, -0.50000000000000000, 0.50000000000000000,
-          0.52359877559829882 },
-  { 0.66442115453330175, -0.50000000000000000, 0.50000000000000000,
-          0.69813170079773179 },
-  { 0.81373829119355345, -0.50000000000000000, 0.50000000000000000,
-          0.87266462599716477 },
-  { 0.95705743313235825, -0.50000000000000000, 0.50000000000000000,
-          1.0471975511965976 },
-  { 1.0959131991362556, -0.50000000000000000, 0.50000000000000000,
-          1.2217304763960306 },
-  { 1.2318900529754597, -0.50000000000000000, 0.50000000000000000,
-          1.3962634015954636 },
-  { 1.3664739530045971, -0.50000000000000000, 0.50000000000000000,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.50000000000000000, nu=0.50000000000000000.
-template <typename Tp>
-void test046()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data046)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data046[i].k), Tp(data046[i].nu),
-                   Tp(data046[i].phi));
-      const Tp f0 = data046[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.50000000000000000, nu=0.59999999999999998.
-testcase_ellint_3<double> data047[] = {
-  { -0.0000000000000000, -0.50000000000000000, 0.59999999999999998,
-          0.0000000000000000 },
-  { 0.17370597174637581, -0.50000000000000000, 0.59999999999999998,
-          0.17453292519943295 },
-  { 0.34278139158591414, -0.50000000000000000, 0.59999999999999998,
-          0.34906585039886590 },
-  { 0.50401419439302719, -0.50000000000000000, 0.59999999999999998,
-          0.52359877559829882 },
-  { 0.65618938076167221, -0.50000000000000000, 0.59999999999999998,
-          0.69813170079773179 },
-  { 0.79977959248855424, -0.50000000000000000, 0.59999999999999998,
-          0.87266462599716477 },
-  { 0.93625925190753545, -0.50000000000000000, 0.59999999999999998,
-          1.0471975511965976 },
-  { 1.0674905658379710, -0.50000000000000000, 0.59999999999999998,
-          1.2217304763960306 },
-  { 1.1953481298023048, -0.50000000000000000, 0.59999999999999998,
-          1.3962634015954636 },
-  { 1.3215740290190876, -0.50000000000000000, 0.59999999999999998,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.50000000000000000, nu=0.59999999999999998.
-template <typename Tp>
-void test047()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data047)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data047[i].k), Tp(data047[i].nu),
-                   Tp(data047[i].phi));
-      const Tp f0 = data047[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.50000000000000000, nu=0.69999999999999996.
-testcase_ellint_3<double> data048[] = {
-  { -0.0000000000000000, -0.50000000000000000, 0.69999999999999996,
-          0.0000000000000000 },
-  { 0.17353350383131641, -0.50000000000000000, 0.69999999999999996,
-          0.17453292519943295 },
-  { 0.34150410405436771, -0.50000000000000000, 0.69999999999999996,
-          0.34906585039886590 },
-  { 0.50017589696443487, -0.50000000000000000, 0.69999999999999996,
-          0.52359877559829882 },
-  { 0.64829398188419962, -0.50000000000000000, 0.69999999999999996,
-          0.69813170079773179 },
-  { 0.78658270782402073, -0.50000000000000000, 0.69999999999999996,
-          0.87266462599716477 },
-  { 0.91684738336675053, -0.50000000000000000, 0.69999999999999996,
-          1.0471975511965976 },
-  { 1.0412486789555937, -0.50000000000000000, 0.69999999999999996,
-          1.2217304763960306 },
-  { 1.1619021847612001, -0.50000000000000000, 0.69999999999999996,
-          1.3962634015954636 },
-  { 1.2807475181182502, -0.50000000000000000, 0.69999999999999996,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.50000000000000000, nu=0.69999999999999996.
-template <typename Tp>
-void test048()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data048)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data048[i].k), Tp(data048[i].nu),
-                   Tp(data048[i].phi));
-      const Tp f0 = data048[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.6797816859260978e-16
+// mean(f - f_Boost): 9.4368957093138303e-17
+// variance(f - f_Boost): 7.7794254682023874e-32
+// stddev(f - f_Boost): 2.7891621444803792e-16
+const testcase_ellint_3<double>
+data046[10] =
+{
+  { 0.0000000000000000, -0.50000000000000000, 0.50000000000000000, 
+	  0.0000000000000000 },
+  { 0.17564466176941509, -0.50000000000000000, 0.50000000000000000, 
+	  0.17453292519943295 },
+  { 0.35805679276065394, -0.50000000000000000, 0.50000000000000000, 
+	  0.34906585039886590 },
+  { 0.55446601496200032, -0.50000000000000000, 0.50000000000000000, 
+	  0.52359877559829882 },
+  { 0.77288783578259013, -0.50000000000000000, 0.50000000000000000, 
+	  0.69813170079773179 },
+  { 1.0220246013918972, -0.50000000000000000, 0.50000000000000000, 
+	  0.87266462599716477 },
+  { 1.3101681612463965, -0.50000000000000000, 0.50000000000000000, 
+	  1.0471975511965976 },
+  { 1.6422994881851025, -0.50000000000000000, 0.50000000000000000, 
+	  1.2217304763960306 },
+  { 2.0152636030998816, -0.50000000000000000, 0.50000000000000000, 
+	  1.3962634015954636 },
+  { 2.4136715042011945, -0.50000000000000000, 0.50000000000000000, 
+	  1.5707963267948966 },
+};
+const double toler046 = 2.5000000000000020e-13;
+
+// Test data for k=-0.50000000000000000, nu=0.60000000000000009.
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.9178421578645735e-16
+// mean(f - f_Boost): 1.3322676295501878e-16
+// variance(f - f_Boost): 1.7749370367472766e-31
+// stddev(f - f_Boost): 4.2130001622920411e-16
+const testcase_ellint_3<double>
+data047[10] =
+{
+  { 0.0000000000000000, -0.50000000000000000, 0.60000000000000009, 
+	  0.0000000000000000 },
+  { 0.17582479017522740, -0.50000000000000000, 0.60000000000000009, 
+	  0.17453292519943295 },
+  { 0.35956964546660036, -0.50000000000000000, 0.60000000000000009, 
+	  0.34906585039886590 },
+  { 0.55999790372984193, -0.50000000000000000, 0.60000000000000009, 
+	  0.52359877559829882 },
+  { 0.78751507911209895, -0.50000000000000000, 0.60000000000000009, 
+	  0.69813170079773179 },
+  { 1.0546620505035220, -0.50000000000000000, 0.60000000000000009, 
+	  0.87266462599716477 },
+  { 1.3754438357425935, -0.50000000000000000, 0.60000000000000009, 
+	  1.0471975511965976 },
+  { 1.7615727400820127, -0.50000000000000000, 0.60000000000000009, 
+	  1.2217304763960306 },
+  { 2.2134638067565242, -0.50000000000000000, 0.60000000000000009, 
+	  1.3962634015954636 },
+  { 2.7090491861753558, -0.50000000000000000, 0.60000000000000009, 
+	  1.5707963267948966 },
+};
+const double toler047 = 2.5000000000000020e-13;
+
+// Test data for k=-0.50000000000000000, nu=0.70000000000000007.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.0745105182189226e-16
+// mean(f - f_Boost): 4.1633363423443370e-17
+// variance(f - f_Boost): 1.9996383743576116e-32
+// stddev(f - f_Boost): 1.4140857026211713e-16
+const testcase_ellint_3<double>
+data048[10] =
+{
+  { 0.0000000000000000, -0.50000000000000000, 0.70000000000000007, 
+	  0.0000000000000000 },
+  { 0.17600558435914915, -0.50000000000000000, 0.70000000000000007, 
+	  0.17453292519943295 },
+  { 0.36110561926726259, -0.50000000000000000, 0.70000000000000007, 
+	  0.34906585039886590 },
+  { 0.56573074641137111, -0.50000000000000000, 0.70000000000000007, 
+	  0.52359877559829882 },
+  { 0.80316073084237205, -0.50000000000000000, 0.70000000000000007, 
+	  0.69813170079773179 },
+  { 1.0911910688131461, -0.50000000000000000, 0.70000000000000007, 
+	  0.87266462599716477 },
+  { 1.4530946406380640, -0.50000000000000000, 0.70000000000000007, 
+	  1.0471975511965976 },
+  { 1.9144386536785372, -0.50000000000000000, 0.70000000000000007, 
+	  1.2217304763960306 },
+  { 2.4878788958234970, -0.50000000000000000, 0.70000000000000007, 
+	  1.3962634015954636 },
+  { 3.1433945297859225, -0.50000000000000000, 0.70000000000000007, 
+	  1.5707963267948966 },
+};
+const double toler048 = 2.5000000000000020e-13;
 
 // Test data for k=-0.50000000000000000, nu=0.80000000000000004.
-testcase_ellint_3<double> data049[] = {
-  { -0.0000000000000000, -0.50000000000000000, 0.80000000000000004,
-          0.0000000000000000 },
-  { 0.17336164805979126, -0.50000000000000000, 0.80000000000000004,
-          0.17453292519943295 },
-  { 0.34024350132086773, -0.50000000000000000, 0.80000000000000004,
-          0.34906585039886590 },
-  { 0.49643719555734084, -0.50000000000000000, 0.80000000000000004,
-          0.52359877559829882 },
-  { 0.64071162456976150, -0.50000000000000000, 0.80000000000000004,
-          0.69813170079773179 },
-  { 0.77407836177211908, -0.50000000000000000, 0.80000000000000004,
-          0.87266462599716477 },
-  { 0.89867058251905652, -0.50000000000000000, 0.80000000000000004,
-          1.0471975511965976 },
-  { 1.0169181822134912, -0.50000000000000000, 0.80000000000000004,
-          1.2217304763960306 },
-  { 1.1311363312779448, -0.50000000000000000, 0.80000000000000004,
-          1.3962634015954636 },
-  { 1.2434165408189539, -0.50000000000000000, 0.80000000000000004,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.50000000000000000, nu=0.80000000000000004.
-template <typename Tp>
-void test049()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data049)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data049[i].k), Tp(data049[i].nu),
-                   Tp(data049[i].phi));
-      const Tp f0 = data049[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.4380477375534667e-16
+// mean(f - f_Boost): 2.3037127760972000e-16
+// variance(f - f_Boost): 1.4989821857033475e-31
+// stddev(f - f_Boost): 3.8716691306248618e-16
+const testcase_ellint_3<double>
+data049[10] =
+{
+  { 0.0000000000000000, -0.50000000000000000, 0.80000000000000004, 
+	  0.0000000000000000 },
+  { 0.17618704872620228, -0.50000000000000000, 0.80000000000000004, 
+	  0.17453292519943295 },
+  { 0.36266535159745827, -0.50000000000000000, 0.80000000000000004, 
+	  0.34906585039886590 },
+  { 0.57167789954529158, -0.50000000000000000, 0.80000000000000004, 
+	  0.52359877559829882 },
+  { 0.81995752984315018, -0.50000000000000000, 0.80000000000000004, 
+	  0.69813170079773179 },
+  { 1.1325112162158122, -0.50000000000000000, 0.80000000000000004, 
+	  0.87266462599716477 },
+  { 1.5479055930718042, -0.50000000000000000, 0.80000000000000004, 
+	  1.0471975511965976 },
+  { 2.1215243941010486, -0.50000000000000000, 0.80000000000000004, 
+	  1.2217304763960306 },
+  { 2.9069405767650132, -0.50000000000000000, 0.80000000000000004, 
+	  1.3962634015954636 },
+  { 3.8750701888108066, -0.50000000000000000, 0.80000000000000004, 
+	  1.5707963267948966 },
+};
+const double toler049 = 2.5000000000000020e-13;
 
 // Test data for k=-0.50000000000000000, nu=0.90000000000000002.
-testcase_ellint_3<double> data050[] = {
-  { -0.0000000000000000, -0.50000000000000000, 0.90000000000000002,
-          0.0000000000000000 },
-  { 0.17319040056865681, -0.50000000000000000, 0.90000000000000002,
-          0.17453292519943295 },
-  { 0.33899920036578557, -0.50000000000000000, 0.90000000000000002,
-          0.34906585039886590 },
-  { 0.49279362182695186, -0.50000000000000000, 0.90000000000000002,
-          0.52359877559829882 },
-  { 0.63342123379746151, -0.50000000000000000, 0.90000000000000002,
-          0.69813170079773179 },
-  { 0.76220595179550321, -0.50000000000000000, 0.90000000000000002,
-          0.87266462599716477 },
-  { 0.88160004743532294, -0.50000000000000000, 0.90000000000000002,
-          1.0471975511965976 },
-  { 0.99427448642310134, -0.50000000000000000, 0.90000000000000002,
-          1.2217304763960306 },
-  { 1.1027091512470093, -0.50000000000000000, 0.90000000000000002,
-          1.3962634015954636 },
-  { 1.2091116095504744, -0.50000000000000000, 0.90000000000000002,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.50000000000000000, nu=0.90000000000000002.
-template <typename Tp>
-void test050()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data050)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data050[i].k), Tp(data050[i].nu),
-                   Tp(data050[i].phi));
-      const Tp f0 = data050[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.40000000000000002, nu=0.0000000000000000.
-testcase_ellint_3<double> data051[] = {
-  { -0.0000000000000000, -0.40000000000000002, 0.0000000000000000,
-          0.0000000000000000 },
-  { 0.17467414669441531, -0.40000000000000002, 0.0000000000000000,
-          0.17453292519943295 },
-  { 0.35018222772483443, -0.40000000000000002, 0.0000000000000000,
-          0.34906585039886590 },
-  { 0.52729015917508748, -0.40000000000000002, 0.0000000000000000,
-          0.52359877559829882 },
-  { 0.70662374407341255, -0.40000000000000002, 0.0000000000000000,
-          0.69813170079773179 },
-  { 0.88859210497602170, -0.40000000000000002, 0.0000000000000000,
-          0.87266462599716477 },
-  { 1.0733136290471379, -0.40000000000000002, 0.0000000000000000,
-          1.0471975511965976 },
-  { 1.2605612170157061, -0.40000000000000002, 0.0000000000000000,
-          1.2217304763960306 },
-  { 1.4497513956433437, -0.40000000000000002, 0.0000000000000000,
-          1.3962634015954636 },
-  { 1.6399998658645112, -0.40000000000000002, 0.0000000000000000,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.40000000000000002, nu=0.0000000000000000.
-template <typename Tp>
-void test051()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data051)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data051[i].k), Tp(data051[i].nu),
-                   Tp(data051[i].phi));
-      const Tp f0 = data051[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.40000000000000002, nu=0.10000000000000001.
-testcase_ellint_3<double> data052[] = {
-  { -0.0000000000000000, -0.40000000000000002, 0.10000000000000001,
-          0.0000000000000000 },
-  { 0.17449806706684673, -0.40000000000000002, 0.10000000000000001,
-          0.17453292519943295 },
-  { 0.34880048623856075, -0.40000000000000002, 0.10000000000000001,
-          0.34906585039886590 },
-  { 0.52277322065757403, -0.40000000000000002, 0.10000000000000001,
-          0.52359877559829882 },
-  { 0.69638072056918376, -0.40000000000000002, 0.10000000000000001,
-          0.69813170079773179 },
-  { 0.86968426619831540, -0.40000000000000002, 0.10000000000000001,
-          0.87266462599716477 },
-  { 1.0428044206578095, -0.40000000000000002, 0.10000000000000001,
-          1.0471975511965976 },
-  { 1.2158651158274378, -0.40000000000000002, 0.10000000000000001,
-          1.2217304763960306 },
-  { 1.3889447129893322, -0.40000000000000002, 0.10000000000000001,
-          1.3962634015954636 },
-  { 1.5620566886683604, -0.40000000000000002, 0.10000000000000001,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.40000000000000002, nu=0.10000000000000001.
-template <typename Tp>
-void test052()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data052)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data052[i].k), Tp(data052[i].nu),
-                   Tp(data052[i].phi));
-      const Tp f0 = data052[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.40000000000000002, nu=0.20000000000000001.
-testcase_ellint_3<double> data053[] = {
-  { -0.0000000000000000, -0.40000000000000002, 0.20000000000000001,
-          0.0000000000000000 },
-  { 0.17432262290723399, -0.40000000000000002, 0.20000000000000001,
-          0.17453292519943295 },
-  { 0.34743795258968596, -0.40000000000000002, 0.20000000000000001,
-          0.34906585039886590 },
-  { 0.51838919472805123, -0.40000000000000002, 0.20000000000000001,
-          0.52359877559829882 },
-  { 0.68663134739057918, -0.40000000000000002, 0.20000000000000001,
-          0.69813170079773179 },
-  { 0.85206432981833979, -0.40000000000000002, 0.20000000000000001,
-          0.87266462599716477 },
-  { 1.0149595349004430, -0.40000000000000002, 0.20000000000000001,
-          1.0471975511965976 },
-  { 1.1758349405464676, -0.40000000000000002, 0.20000000000000001,
-          1.2217304763960306 },
-  { 1.3353337673882635, -0.40000000000000002, 0.20000000000000001,
-          1.3962634015954636 },
-  { 1.4941414344266770, -0.40000000000000002, 0.20000000000000001,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.40000000000000002, nu=0.20000000000000001.
-template <typename Tp>
-void test053()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data053)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data053[i].k), Tp(data053[i].nu),
-                   Tp(data053[i].phi));
-      const Tp f0 = data053[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.40000000000000002, nu=0.29999999999999999.
-testcase_ellint_3<double> data054[] = {
-  { -0.0000000000000000, -0.40000000000000002, 0.29999999999999999,
-          0.0000000000000000 },
-  { 0.17414781013591543, -0.40000000000000002, 0.29999999999999999,
-          0.17453292519943295 },
-  { 0.34609415696777285, -0.40000000000000002, 0.29999999999999999,
-          0.34906585039886590 },
-  { 0.51413131295862546, -0.40000000000000002, 0.29999999999999999,
-          0.52359877559829882 },
-  { 0.67733527622935630, -0.40000000000000002, 0.29999999999999999,
-          0.69813170079773179 },
-  { 0.83558675182733266, -0.40000000000000002, 0.29999999999999999,
-          0.87266462599716477 },
-  { 0.98940140808865906, -0.40000000000000002, 0.29999999999999999,
-          1.0471975511965976 },
-  { 1.1396968797728058, -0.40000000000000002, 0.29999999999999999,
-          1.2217304763960306 },
-  { 1.2875920037865087, -0.40000000000000002, 0.29999999999999999,
-          1.3962634015954636 },
-  { 1.4342789859950078, -0.40000000000000002, 0.29999999999999999,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.40000000000000002, nu=0.29999999999999999.
-template <typename Tp>
-void test054()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data054)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data054[i].k), Tp(data054[i].nu),
-                   Tp(data054[i].phi));
-      const Tp f0 = data054[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.40000000000000002, nu=0.40000000000000002.
-testcase_ellint_3<double> data055[] = {
-  { -0.0000000000000000, -0.40000000000000002, 0.40000000000000002,
-          0.0000000000000000 },
-  { 0.17397362471112710, -0.40000000000000002, 0.40000000000000002,
-          0.17453292519943295 },
-  { 0.34476864603333196, -0.40000000000000002, 0.40000000000000002,
-          0.34906585039886590 },
-  { 0.50999329415379357, -0.40000000000000002, 0.40000000000000002,
-          0.52359877559829882 },
-  { 0.66845674551396017, -0.40000000000000002, 0.40000000000000002,
-          0.69813170079773179 },
-  { 0.82012848346231748, -0.40000000000000002, 0.40000000000000002,
-          0.87266462599716477 },
-  { 0.96582449258349057, -0.40000000000000002, 0.40000000000000002,
-          1.0471975511965976 },
-  { 1.1068473749476286, -0.40000000000000002, 0.40000000000000002,
-          1.2217304763960306 },
-  { 1.2447132729159986, -0.40000000000000002, 0.40000000000000002,
-          1.3962634015954636 },
-  { 1.3809986210732901, -0.40000000000000002, 0.40000000000000002,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.40000000000000002, nu=0.40000000000000002.
-template <typename Tp>
-void test055()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data055)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data055[i].k), Tp(data055[i].nu),
-                   Tp(data055[i].phi));
-      const Tp f0 = data055[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.40000000000000002, nu=0.50000000000000000.
-testcase_ellint_3<double> data056[] = {
-  { -0.0000000000000000, -0.40000000000000002, 0.50000000000000000,
-          0.0000000000000000 },
-  { 0.17380006262854139, -0.40000000000000002, 0.50000000000000000,
-          0.17453292519943295 },
-  { 0.34346098216756610, -0.40000000000000002, 0.50000000000000000,
-          0.34906585039886590 },
-  { 0.50596929935059420, -0.40000000000000002, 0.50000000000000000,
-          0.52359877559829882 },
-  { 0.65996392089131262, -0.40000000000000002, 0.50000000000000000,
-          0.69813170079773179 },
-  { 0.80558463511364786, -0.40000000000000002, 0.50000000000000000,
-          0.87266462599716477 },
-  { 0.94397834522857704, -0.40000000000000002, 0.50000000000000000,
-          1.0471975511965976 },
-  { 1.0768075114108115, -0.40000000000000002, 0.50000000000000000,
-          1.2217304763960306 },
-  { 1.2059184624251329, -0.40000000000000002, 0.50000000000000000,
-          1.3962634015954636 },
-  { 1.3331797176377398, -0.40000000000000002, 0.50000000000000000,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.40000000000000002, nu=0.50000000000000000.
-template <typename Tp>
-void test056()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data056)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data056[i].k), Tp(data056[i].nu),
-                   Tp(data056[i].phi));
-      const Tp f0 = data056[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.40000000000000002, nu=0.59999999999999998.
-testcase_ellint_3<double> data057[] = {
-  { -0.0000000000000000, -0.40000000000000002, 0.59999999999999998,
-          0.0000000000000000 },
-  { 0.17362711992081248, -0.40000000000000002, 0.59999999999999998,
-          0.17453292519943295 },
-  { 0.34217074276403953, -0.40000000000000002, 0.59999999999999998,
-          0.34906585039886590 },
-  { 0.50205389185761617, -0.40000000000000002, 0.59999999999999998,
-          0.52359877559829882 },
-  { 0.65182834920372745, -0.40000000000000002, 0.59999999999999998,
-          0.69813170079773179 },
-  { 0.79186512820565136, -0.40000000000000002, 0.59999999999999998,
-          0.87266462599716477 },
-  { 0.92365535916287134, -0.40000000000000002, 0.59999999999999998,
-          1.0471975511965976 },
-  { 1.0491915663957907, -0.40000000000000002, 0.59999999999999998,
-          1.2217304763960306 },
-  { 1.1705934291745104, -0.40000000000000002, 0.59999999999999998,
-          1.3962634015954636 },
-  { 1.2899514672527024, -0.40000000000000002, 0.59999999999999998,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.40000000000000002, nu=0.59999999999999998.
-template <typename Tp>
-void test057()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data057)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data057[i].k), Tp(data057[i].nu),
-                   Tp(data057[i].phi));
-      const Tp f0 = data057[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.40000000000000002, nu=0.69999999999999996.
-testcase_ellint_3<double> data058[] = {
-  { -0.0000000000000000, -0.40000000000000002, 0.69999999999999996,
-          0.0000000000000000 },
-  { 0.17345479265712871, -0.40000000000000002, 0.69999999999999996,
-          0.17453292519943295 },
-  { 0.34089751955950354, -0.40000000000000002, 0.69999999999999996,
-          0.34906585039886590 },
-  { 0.49824200167361343, -0.40000000000000002, 0.69999999999999996,
-          0.52359877559829882 },
-  { 0.64402450341199413, -0.40000000000000002, 0.69999999999999996,
-          0.69813170079773179 },
-  { 0.77889207804122873, -0.40000000000000002, 0.69999999999999996,
-          0.87266462599716477 },
-  { 0.90468169720957992, -0.40000000000000002, 0.69999999999999996,
-          1.0471975511965976 },
-  { 1.0236847823692916, -0.40000000000000002, 0.69999999999999996,
-          1.2217304763960306 },
-  { 1.1382465247425164, -0.40000000000000002, 0.69999999999999996,
-          1.3962634015954636 },
-  { 1.2506255923253344, -0.40000000000000002, 0.69999999999999996,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.40000000000000002, nu=0.69999999999999996.
-template <typename Tp>
-void test058()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data058)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data058[i].k), Tp(data058[i].nu),
-                   Tp(data058[i].phi));
-      const Tp f0 = data058[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.40000000000000002, nu=0.80000000000000004.
-testcase_ellint_3<double> data059[] = {
-  { -0.0000000000000000, -0.40000000000000002, 0.80000000000000004,
-          0.0000000000000000 },
-  { 0.17328307694277156, -0.40000000000000002, 0.80000000000000004,
-          0.17453292519943295 },
-  { 0.33964091800132007, -0.40000000000000002, 0.80000000000000004,
-          0.34906585039886590 },
-  { 0.49452889372467451, -0.40000000000000002, 0.80000000000000004,
-          0.52359877559829882 },
-  { 0.63652940095937327, -0.40000000000000002, 0.80000000000000004,
-          0.69813170079773179 },
-  { 0.76659772511159097, -0.40000000000000002, 0.80000000000000004,
-          0.87266462599716477 },
-  { 0.88691047977338111, -0.40000000000000002, 0.80000000000000004,
-          1.0471975511965976 },
-  { 1.0000273200611638, -0.40000000000000002, 0.80000000000000004,
-          1.2217304763960306 },
-  { 1.1084787902188007, -0.40000000000000002, 0.80000000000000004,
-          1.3962634015954636 },
-  { 1.2146499565727209, -0.40000000000000002, 0.80000000000000004,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.40000000000000002, nu=0.80000000000000004.
-template <typename Tp>
-void test059()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data059)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data059[i].k), Tp(data059[i].nu),
-                   Tp(data059[i].phi));
-      const Tp f0 = data059[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.40000000000000002, nu=0.90000000000000002.
-testcase_ellint_3<double> data060[] = {
-  { -0.0000000000000000, -0.40000000000000002, 0.90000000000000002,
-          0.0000000000000000 },
-  { 0.17311196891868130, -0.40000000000000002, 0.90000000000000002,
-          0.17453292519943295 },
-  { 0.33840055664911906, -0.40000000000000002, 0.90000000000000002,
-          0.34906585039886590 },
-  { 0.49091013944075340, -0.40000000000000002, 0.90000000000000002,
-          0.52359877559829882 },
-  { 0.62932228186809591, -0.40000000000000002, 0.90000000000000002,
-          0.69813170079773179 },
-  { 0.75492278323019801, -0.40000000000000002, 0.90000000000000002,
-          0.87266462599716477 },
-  { 0.87021659043854294, -0.40000000000000002, 0.90000000000000002,
-          1.0471975511965976 },
-  { 0.97800245228239246, -0.40000000000000002, 0.90000000000000002,
-          1.2217304763960306 },
-  { 1.0809625773173694, -0.40000000000000002, 0.90000000000000002,
-          1.3962634015954636 },
-  { 1.1815758115929846, -0.40000000000000002, 0.90000000000000002,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.40000000000000002, nu=0.90000000000000002.
-template <typename Tp>
-void test060()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data060)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data060[i].k), Tp(data060[i].nu),
-                   Tp(data060[i].phi));
-      const Tp f0 = data060[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.30000000000000004, nu=0.0000000000000000.
-testcase_ellint_3<double> data061[] = {
-  { -0.0000000000000000, -0.30000000000000004, 0.0000000000000000,
-          0.0000000000000000 },
-  { 0.17461228653000102, -0.30000000000000004, 0.0000000000000000,
-          0.17453292519943295 },
-  { 0.34969146102798415, -0.30000000000000004, 0.0000000000000000,
-          0.34906585039886590 },
-  { 0.52565822873726320, -0.30000000000000004, 0.0000000000000000,
-          0.52359877559829882 },
-  { 0.70284226512408532, -0.30000000000000004, 0.0000000000000000,
-          0.69813170079773179 },
-  { 0.88144139195111182, -0.30000000000000004, 0.0000000000000000,
-          0.87266462599716477 },
-  { 1.0614897067260523, -0.30000000000000004, 0.0000000000000000,
-          1.0471975511965976 },
-  { 1.2428416824174218, -0.30000000000000004, 0.0000000000000000,
-          1.2217304763960306 },
-  { 1.4251795877015925, -0.30000000000000004, 0.0000000000000000,
-          1.3962634015954636 },
-  { 1.6080486199305126, -0.30000000000000004, 0.0000000000000000,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.30000000000000004, nu=0.0000000000000000.
-template <typename Tp>
-void test061()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data061)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data061[i].k), Tp(data061[i].nu),
-                   Tp(data061[i].phi));
-      const Tp f0 = data061[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.30000000000000004, nu=0.10000000000000001.
-testcase_ellint_3<double> data062[] = {
-  { -0.0000000000000000, -0.30000000000000004, 0.10000000000000001,
-          0.0000000000000000 },
-  { 0.17443631884814378, -0.30000000000000004, 0.10000000000000001,
-          0.17453292519943295 },
-  { 0.34831316835124926, -0.30000000000000004, 0.10000000000000001,
-          0.34906585039886590 },
-  { 0.52116586276523857, -0.30000000000000004, 0.10000000000000001,
-          0.52359877559829882 },
-  { 0.69269385837910036, -0.30000000000000004, 0.10000000000000001,
-          0.69813170079773179 },
-  { 0.86279023163070856, -0.30000000000000004, 0.10000000000000001,
-          0.87266462599716477 },
-  { 1.0315321461438265, -0.30000000000000004, 0.10000000000000001,
-          1.0471975511965976 },
-  { 1.1991449111869024, -0.30000000000000004, 0.10000000000000001,
-          1.2217304763960306 },
-  { 1.3659561780923211, -0.30000000000000004, 0.10000000000000001,
-          1.3962634015954636 },
-  { 1.5323534693557526, -0.30000000000000004, 0.10000000000000001,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.30000000000000004, nu=0.10000000000000001.
-template <typename Tp>
-void test062()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data062)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data062[i].k), Tp(data062[i].nu),
-                   Tp(data062[i].phi));
-      const Tp f0 = data062[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.30000000000000004, nu=0.20000000000000001.
-testcase_ellint_3<double> data063[] = {
-  { -0.0000000000000000, -0.30000000000000004, 0.20000000000000001,
-          0.0000000000000000 },
-  { 0.17426098615372090, -0.30000000000000004, 0.20000000000000001,
-          0.17453292519943295 },
-  { 0.34695402664689923, -0.30000000000000004, 0.20000000000000001,
-          0.34906585039886590 },
-  { 0.51680555567038933, -0.30000000000000004, 0.20000000000000001,
-          0.52359877559829882 },
-  { 0.68303375225260210, -0.30000000000000004, 0.20000000000000001,
-          0.69813170079773179 },
-  { 0.84540662891295026, -0.30000000000000004, 0.20000000000000001,
-          0.87266462599716477 },
-  { 1.0041834051646927, -0.30000000000000004, 0.20000000000000001,
-          1.0471975511965976 },
-  { 1.1599952702345711, -0.30000000000000004, 0.20000000000000001,
-          1.2217304763960306 },
-  { 1.3137179520499163, -0.30000000000000004, 0.20000000000000001,
-          1.3962634015954636 },
-  { 1.4663658145259875, -0.30000000000000004, 0.20000000000000001,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.30000000000000004, nu=0.20000000000000001.
-template <typename Tp>
-void test063()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data063)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data063[i].k), Tp(data063[i].nu),
-                   Tp(data063[i].phi));
-      const Tp f0 = data063[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.30000000000000004, nu=0.29999999999999999.
-testcase_ellint_3<double> data064[] = {
-  { -0.0000000000000000, -0.30000000000000004, 0.29999999999999999,
-          0.0000000000000000 },
-  { 0.17408628437042845, -0.30000000000000004, 0.29999999999999999,
-          0.17453292519943295 },
-  { 0.34561356761638401, -0.30000000000000004, 0.29999999999999999,
-          0.34906585039886590 },
-  { 0.51257058617875850, -0.30000000000000004, 0.29999999999999999,
-          0.52359877559829882 },
-  { 0.67382207124602866, -0.30000000000000004, 0.29999999999999999,
-          0.69813170079773179 },
-  { 0.82914751587825131, -0.30000000000000004, 0.29999999999999999,
-          0.87266462599716477 },
-  { 0.97907434814374950, -0.30000000000000004, 0.29999999999999999,
-          1.0471975511965976 },
-  { 1.1246399297351584, -0.30000000000000004, 0.29999999999999999,
-          1.2217304763960306 },
-  { 1.2671793970398146, -0.30000000000000004, 0.29999999999999999,
-          1.3962634015954636 },
-  { 1.4081767433479089, -0.30000000000000004, 0.29999999999999999,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.30000000000000004, nu=0.29999999999999999.
-template <typename Tp>
-void test064()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data064)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data064[i].k), Tp(data064[i].nu),
-                   Tp(data064[i].phi));
-      const Tp f0 = data064[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.30000000000000004, nu=0.40000000000000002.
-testcase_ellint_3<double> data065[] = {
-  { -0.0000000000000000, -0.30000000000000004, 0.40000000000000002,
-          0.0000000000000000 },
-  { 0.17391220945982730, -0.30000000000000004, 0.40000000000000002,
-          0.17453292519943295 },
-  { 0.34429133937639689, -0.30000000000000004, 0.40000000000000002,
-          0.34906585039886590 },
-  { 0.50845471668581632, -0.30000000000000004, 0.40000000000000002,
-          0.52359877559829882 },
-  { 0.66502347027873854, -0.30000000000000004, 0.40000000000000002,
-          0.69813170079773179 },
-  { 0.81389191978012254, -0.30000000000000004, 0.40000000000000002,
-          0.87266462599716477 },
-  { 0.95590618002140593, -0.30000000000000004, 0.40000000000000002,
-          1.0471975511965976 },
-  { 1.0924915195213121, -0.30000000000000004, 0.40000000000000002,
-          1.2217304763960306 },
-  { 1.2253651604038058, -0.30000000000000004, 0.40000000000000002,
-          1.3962634015954636 },
-  { 1.3563643538969761, -0.30000000000000004, 0.40000000000000002,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.30000000000000004, nu=0.40000000000000002.
-template <typename Tp>
-void test065()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data065)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data065[i].k), Tp(data065[i].nu),
-                   Tp(data065[i].phi));
-      const Tp f0 = data065[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.30000000000000004, nu=0.50000000000000000.
-testcase_ellint_3<double> data066[] = {
-  { -0.0000000000000000, -0.30000000000000004, 0.50000000000000000,
-          0.0000000000000000 },
-  { 0.17373875742088235, -0.30000000000000004, 0.50000000000000000,
-          0.17453292519943295 },
-  { 0.34298690571124157, -0.30000000000000004, 0.50000000000000000,
-          0.34906585039886590 },
-  { 0.50445214859646936, -0.30000000000000004, 0.50000000000000000,
-          0.52359877559829882 },
-  { 0.65660648352418516, -0.30000000000000004, 0.50000000000000000,
-          0.69813170079773179 },
-  { 0.79953670639287289, -0.30000000000000004, 0.50000000000000000,
-          0.87266462599716477 },
-  { 0.93443393926588558, -0.30000000000000004, 0.50000000000000000,
-          1.0471975511965976 },
-  { 1.0630838369016911, -0.30000000000000004, 0.50000000000000000,
-          1.2217304763960306 },
-  { 1.1875197325653026, -0.30000000000000004, 0.50000000000000000,
-          1.3962634015954636 },
-  { 1.3098448759814960, -0.30000000000000004, 0.50000000000000000,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.30000000000000004, nu=0.50000000000000000.
-template <typename Tp>
-void test066()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data066)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data066[i].k), Tp(data066[i].nu),
-                   Tp(data066[i].phi));
-      const Tp f0 = data066[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.30000000000000004, nu=0.59999999999999998.
-testcase_ellint_3<double> data067[] = {
-  { -0.0000000000000000, -0.30000000000000004, 0.59999999999999998,
-          0.0000000000000000 },
-  { 0.17356592428950826, -0.30000000000000004, 0.59999999999999998,
-          0.17453292519943295 },
-  { 0.34169984536697379, -0.30000000000000004, 0.59999999999999998,
-          0.34906585039886590 },
-  { 0.50055748266498457, -0.30000000000000004, 0.59999999999999998,
-          0.52359877559829882 },
-  { 0.64854298527106768, -0.30000000000000004, 0.59999999999999998,
-          0.69813170079773179 },
-  { 0.78599329284207431, -0.30000000000000004, 0.59999999999999998,
-          0.87266462599716477 },
-  { 0.91445452089128221, -0.30000000000000004, 0.59999999999999998,
-          1.0471975511965976 },
-  { 1.0360412952290587, -0.30000000000000004, 0.59999999999999998,
-          1.2217304763960306 },
-  { 1.1530473919778639, -0.30000000000000004, 0.59999999999999998,
-          1.3962634015954636 },
-  { 1.2677758800420666, -0.30000000000000004, 0.59999999999999998,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.30000000000000004, nu=0.59999999999999998.
-template <typename Tp>
-void test067()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data067)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data067[i].k), Tp(data067[i].nu),
-                   Tp(data067[i].phi));
-      const Tp f0 = data067[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.30000000000000004, nu=0.69999999999999996.
-testcase_ellint_3<double> data068[] = {
-  { -0.0000000000000000, -0.30000000000000004, 0.69999999999999996,
-          0.0000000000000000 },
-  { 0.17339370613812227, -0.30000000000000004, 0.69999999999999996,
-          0.17453292519943295 },
-  { 0.34042975138455933, -0.30000000000000004, 0.69999999999999996,
-          0.34906585039886590 },
-  { 0.49676568368075985, -0.30000000000000004, 0.69999999999999996,
-          0.52359877559829882 },
-  { 0.64080774055753720, -0.30000000000000004, 0.69999999999999996,
-          0.69813170079773179 },
-  { 0.77318507779667278, -0.30000000000000004, 0.69999999999999996,
-          0.87266462599716477 },
-  { 0.89579782346548631, -0.30000000000000004, 0.69999999999999996,
-          1.0471975511965976 },
-  { 1.0110573286052202, -0.30000000000000004, 0.69999999999999996,
-          1.2217304763960306 },
-  { 1.1214710972949633, -0.30000000000000004, 0.69999999999999996,
-          1.3962634015954636 },
-  { 1.2294913236274980, -0.30000000000000004, 0.69999999999999996,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.30000000000000004, nu=0.69999999999999996.
-template <typename Tp>
-void test068()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data068)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data068[i].k), Tp(data068[i].nu),
-                   Tp(data068[i].phi));
-      const Tp f0 = data068[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.30000000000000004, nu=0.80000000000000004.
-testcase_ellint_3<double> data069[] = {
-  { -0.0000000000000000, -0.30000000000000004, 0.80000000000000004,
-          0.0000000000000000 },
-  { 0.17322209907520361, -0.30000000000000004, 0.80000000000000004,
-          0.17453292519943295 },
-  { 0.33917623046949996, -0.30000000000000004, 0.80000000000000004,
-          0.34906585039886590 },
-  { 0.49307204894329176, -0.30000000000000004, 0.80000000000000004,
-          0.52359877559829882 },
-  { 0.63337802830291723, -0.30000000000000004, 0.80000000000000004,
-          0.69813170079773179 },
-  { 0.76104540997689407, -0.30000000000000004, 0.80000000000000004,
-          0.87266462599716477 },
-  { 0.87832009635450736, -0.30000000000000004, 0.80000000000000004,
-          1.0471975511965976 },
-  { 0.98787879723171790, -0.30000000000000004, 0.80000000000000004,
-          1.2217304763960306 },
-  { 1.0924036340069336, -0.30000000000000004, 0.80000000000000004,
-          1.3962634015954636 },
-  { 1.1944567571590046, -0.30000000000000004, 0.80000000000000004,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.30000000000000004, nu=0.80000000000000004.
-template <typename Tp>
-void test069()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data069)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data069[i].k), Tp(data069[i].nu),
-                   Tp(data069[i].phi));
-      const Tp f0 = data069[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.30000000000000004, nu=0.90000000000000002.
-testcase_ellint_3<double> data070[] = {
-  { -0.0000000000000000, -0.30000000000000004, 0.90000000000000002,
-          0.0000000000000000 },
-  { 0.17305109924485948, -0.30000000000000004, 0.90000000000000002,
-          0.17453292519943295 },
-  { 0.33793890239556984, -0.30000000000000004, 0.90000000000000002,
-          0.34906585039886590 },
-  { 0.48947218005089738, -0.30000000000000004, 0.90000000000000002,
-          0.52359877559829882 },
-  { 0.62623332340775151, -0.30000000000000004, 0.90000000000000002,
-          0.69813170079773179 },
-  { 0.74951596581511148, -0.30000000000000004, 0.90000000000000002,
-          0.87266462599716477 },
-  { 0.86189886597756005, -0.30000000000000004, 0.90000000000000002,
-          1.0471975511965976 },
-  { 0.96629451153092005, -0.30000000000000004, 0.90000000000000002,
-          1.2217304763960306 },
-  { 1.0655269133492680, -0.30000000000000004, 0.90000000000000002,
-          1.3962634015954636 },
-  { 1.1622376896064912, -0.30000000000000004, 0.90000000000000002,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.30000000000000004, nu=0.90000000000000002.
-template <typename Tp>
-void test070()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data070)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data070[i].k), Tp(data070[i].nu),
-                   Tp(data070[i].phi));
-      const Tp f0 = data070[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.6192315188521289e-16
+// mean(f - f_Boost): 3.5249581031848718e-16
+// variance(f - f_Boost): 2.5029385557256515e-31
+// stddev(f - f_Boost): 5.0029376927217987e-16
+const testcase_ellint_3<double>
+data050[10] =
+{
+  { 0.0000000000000000, -0.50000000000000000, 0.90000000000000002, 
+	  0.0000000000000000 },
+  { 0.17636918772384180, -0.50000000000000000, 0.90000000000000002, 
+	  0.17453292519943295 },
+  { 0.36424950570740700, -0.50000000000000000, 0.90000000000000002, 
+	  0.34906585039886590 },
+  { 0.57785404590231426, -0.50000000000000000, 0.90000000000000002, 
+	  0.52359877559829882 },
+  { 0.83806480521716531, -0.50000000000000000, 0.90000000000000002, 
+	  0.69813170079773179 },
+  { 1.1798568683069752, -0.50000000000000000, 0.90000000000000002, 
+	  0.87266462599716477 },
+  { 1.6678766243739607, -0.50000000000000000, 0.90000000000000002, 
+	  1.0471975511965976 },
+  { 2.4282976450693483, -0.50000000000000000, 0.90000000000000002, 
+	  1.2217304763960306 },
+  { 3.6810787666126656, -0.50000000000000000, 0.90000000000000002, 
+	  1.3962634015954636 },
+  { 5.5355132096026454, -0.50000000000000000, 0.90000000000000002, 
+	  1.5707963267948966 },
+};
+const double toler050 = 2.5000000000000020e-13;
+
+// Test data for k=-0.39999999999999991, nu=0.0000000000000000.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.1423314994346225e-16
+// mean(f - f_Boost): 1.9428902930940238e-17
+// variance(f - f_Boost): 2.2263750157116445e-32
+// stddev(f - f_Boost): 1.4921042241450980e-16
+const testcase_ellint_3<double>
+data051[10] =
+{
+  { 0.0000000000000000, -0.39999999999999991, 0.0000000000000000, 
+	  0.0000000000000000 },
+  { 0.17467414669441528, -0.39999999999999991, 0.0000000000000000, 
+	  0.17453292519943295 },
+  { 0.35018222772483443, -0.39999999999999991, 0.0000000000000000, 
+	  0.34906585039886590 },
+  { 0.52729015917508748, -0.39999999999999991, 0.0000000000000000, 
+	  0.52359877559829882 },
+  { 0.70662374407341244, -0.39999999999999991, 0.0000000000000000, 
+	  0.69813170079773179 },
+  { 0.88859210497602159, -0.39999999999999991, 0.0000000000000000, 
+	  0.87266462599716477 },
+  { 1.0733136290471381, -0.39999999999999991, 0.0000000000000000, 
+	  1.0471975511965976 },
+  { 1.2605612170157066, -0.39999999999999991, 0.0000000000000000, 
+	  1.2217304763960306 },
+  { 1.4497513956433439, -0.39999999999999991, 0.0000000000000000, 
+	  1.3962634015954636 },
+  { 1.6399998658645112, -0.39999999999999991, 0.0000000000000000, 
+	  1.5707963267948966 },
+};
+const double toler051 = 2.5000000000000020e-13;
+
+// Test data for k=-0.39999999999999991, nu=0.10000000000000001.
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.8489340395463703e-16
+// mean(f - f_Boost): 6.3837823915946496e-17
+// variance(f - f_Boost): 4.4785242050000272e-32
+// stddev(f - f_Boost): 2.1162523963365114e-16
+const testcase_ellint_3<double>
+data052[10] =
+{
+  { 0.0000000000000000, -0.39999999999999991, 0.10000000000000001, 
+	  0.0000000000000000 },
+  { 0.17485086590796767, -0.39999999999999991, 0.10000000000000001, 
+	  0.17453292519943295 },
+  { 0.35158366412506992, -0.39999999999999991, 0.10000000000000001, 
+	  0.34906585039886590 },
+  { 0.53194731675711726, -0.39999999999999991, 0.10000000000000001, 
+	  0.52359877559829882 },
+  { 0.71740615528010931, -0.39999999999999991, 0.10000000000000001, 
+	  0.69813170079773179 },
+  { 0.90896157773487030, -0.39999999999999991, 0.10000000000000001, 
+	  0.87266462599716477 },
+  { 1.1069605483834348, -0.39999999999999991, 0.10000000000000001, 
+	  1.0471975511965976 },
+  { 1.3109353428823001, -0.39999999999999991, 0.10000000000000001, 
+	  1.2217304763960306 },
+  { 1.5195460789903448, -0.39999999999999991, 0.10000000000000001, 
+	  1.3962634015954636 },
+  { 1.7306968836847187, -0.39999999999999991, 0.10000000000000001, 
+	  1.5707963267948966 },
+};
+const double toler052 = 2.5000000000000020e-13;
+
+// Test data for k=-0.39999999999999991, nu=0.20000000000000001.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.0467985583872730e-16
+// mean(f - f_Boost): 8.6042284408449634e-17
+// variance(f - f_Boost): 1.5826864298542218e-32
+// stddev(f - f_Boost): 1.2580486595733180e-16
+const testcase_ellint_3<double>
+data053[10] =
+{
+  { 0.0000000000000000, -0.39999999999999991, 0.20000000000000001, 
+	  0.0000000000000000 },
+  { 0.17502822886437389, -0.39999999999999991, 0.20000000000000001, 
+	  0.17453292519943295 },
+  { 0.35300530062530805, -0.39999999999999991, 0.20000000000000001, 
+	  0.34906585039886590 },
+  { 0.53675259548210896, -0.39999999999999991, 0.20000000000000001, 
+	  0.52359877559829882 },
+  { 0.72878006428676934, -0.39999999999999991, 0.20000000000000001, 
+	  0.69813170079773179 },
+  { 0.93100219010583563, -0.39999999999999991, 0.20000000000000001, 
+	  0.87266462599716477 },
+  { 1.1443487271187609, -0.39999999999999991, 0.20000000000000001, 
+	  1.0471975511965976 },
+  { 1.3683427764108813, -0.39999999999999991, 0.20000000000000001, 
+	  1.2217304763960306 },
+  { 1.6008221459300933, -0.39999999999999991, 0.20000000000000001, 
+	  1.3962634015954636 },
+  { 1.8380358826317627, -0.39999999999999991, 0.20000000000000001, 
+	  1.5707963267948966 },
+};
+const double toler053 = 2.5000000000000020e-13;
+
+// Test data for k=-0.39999999999999991, nu=0.30000000000000004.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 2.9973414591826100e-16
+// mean(f - f_Boost): 8.6042284408449634e-17
+// variance(f - f_Boost): 1.5826864298542218e-32
+// stddev(f - f_Boost): 1.2580486595733180e-16
+const testcase_ellint_3<double>
+data054[10] =
+{
+  { 0.0000000000000000, -0.39999999999999991, 0.30000000000000004, 
+	  0.0000000000000000 },
+  { 0.17520623975982899, -0.39999999999999991, 0.30000000000000004, 
+	  0.17453292519943295 },
+  { 0.35444766141612105, -0.39999999999999991, 0.30000000000000004, 
+	  0.34906585039886590 },
+  { 0.54171455841536009, -0.39999999999999991, 0.30000000000000004, 
+	  0.52359877559829882 },
+  { 0.74080517001084012, -0.39999999999999991, 0.30000000000000004, 
+	  0.69813170079773179 },
+  { 0.95496950509296563, -0.39999999999999991, 0.30000000000000004, 
+	  0.87266462599716477 },
+  { 1.1862627879844718, -0.39999999999999991, 0.30000000000000004, 
+	  1.0471975511965976 },
+  { 1.4346501803799458, -0.39999999999999991, 0.30000000000000004, 
+	  1.2217304763960306 },
+  { 1.6971744798077697, -0.39999999999999991, 0.30000000000000004, 
+	  1.3962634015954636 },
+  { 1.9677924132520139, -0.39999999999999991, 0.30000000000000004, 
+	  1.5707963267948966 },
+};
+const double toler054 = 2.5000000000000020e-13;
+
+// Test data for k=-0.39999999999999991, nu=0.40000000000000002.
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 6.2577246923979600e-16
+// mean(f - f_Boost): 1.8596235662471373e-16
+// variance(f - f_Boost): 1.6222417021441306e-31
+// stddev(f - f_Boost): 4.0277061736727151e-16
+const testcase_ellint_3<double>
+data055[10] =
+{
+  { 0.0000000000000000, -0.39999999999999991, 0.40000000000000002, 
+	  0.0000000000000000 },
+  { 0.17538490283034375, -0.39999999999999991, 0.40000000000000002, 
+	  0.17453292519943295 },
+  { 0.35591129064319948, -0.39999999999999991, 0.40000000000000002, 
+	  0.34906585039886590 },
+  { 0.54684250413264535, -0.39999999999999991, 0.40000000000000002, 
+	  0.52359877559829882 },
+  { 0.75355027742668290, -0.39999999999999991, 0.40000000000000002, 
+	  0.69813170079773179 },
+  { 0.98117935026780634, -0.39999999999999991, 0.40000000000000002, 
+	  0.87266462599716477 },
+  { 1.2337464222030734, -0.39999999999999991, 0.40000000000000002, 
+	  1.0471975511965976 },
+  { 1.5125183419289221, -0.39999999999999991, 0.40000000000000002, 
+	  1.2217304763960306 },
+  { 1.8140224451130311, -0.39999999999999991, 0.40000000000000002, 
+	  1.3962634015954636 },
+  { 2.1289968719280026, -0.39999999999999991, 0.40000000000000002, 
+	  1.5707963267948966 },
+};
+const double toler055 = 2.5000000000000020e-13;
+
+// Test data for k=-0.39999999999999991, nu=0.50000000000000000.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.8009196014748294e-16
+// mean(f - f_Boost): 1.6375789613221060e-16
+// variance(f - f_Boost): 6.4788283329186610e-32
+// stddev(f - f_Boost): 2.5453542647181080e-16
+const testcase_ellint_3<double>
+data056[10] =
+{
+  { 0.0000000000000000, -0.39999999999999991, 0.50000000000000000, 
+	  0.0000000000000000 },
+  { 0.17556422235224273, -0.39999999999999991, 0.50000000000000000, 
+	  0.17453292519943295 },
+  { 0.35739675341763921, -0.39999999999999991, 0.50000000000000000, 
+	  0.34906585039886590 },
+  { 0.55214655195037188, -0.39999999999999991, 0.50000000000000000, 
+	  0.52359877559829882 },
+  { 0.76709520942047438, -0.39999999999999991, 0.50000000000000000, 
+	  0.69813170079773179 },
+  { 1.0100278761577499, -0.39999999999999991, 0.50000000000000000, 
+	  0.87266462599716477 },
+  { 1.2882265661384342, -0.39999999999999991, 0.50000000000000000, 
+	  1.0471975511965976 },
+  { 1.6059059780051874, -0.39999999999999991, 0.50000000000000000, 
+	  1.2217304763960306 },
+  { 1.9600182740224081, -0.39999999999999991, 0.50000000000000000, 
+	  1.3962634015954636 },
+  { 2.3367461373176508, -0.39999999999999991, 0.50000000000000000, 
+	  1.5707963267948966 },
+};
+const double toler056 = 2.5000000000000020e-13;
+
+// Test data for k=-0.39999999999999991, nu=0.60000000000000009.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 2.8411408870840790e-16
+// mean(f - f_Boost): 9.7144514654701197e-17
+// variance(f - f_Boost): 1.4860570558543486e-32
+// stddev(f - f_Boost): 1.2190393988113545e-16
+const testcase_ellint_3<double>
+data057[10] =
+{
+  { 0.0000000000000000, -0.39999999999999991, 0.60000000000000009, 
+	  0.0000000000000000 },
+  { 0.17574420264267029, -0.39999999999999991, 0.60000000000000009, 
+	  0.17453292519943295 },
+  { 0.35890463689046265, -0.39999999999999991, 0.60000000000000009, 
+	  0.34906585039886590 },
+  { 0.55763773975194486, -0.39999999999999991, 0.60000000000000009, 
+	  0.52359877559829882 },
+  { 0.78153324227761267, -0.39999999999999991, 0.60000000000000009, 
+	  0.69813170079773179 },
+  { 1.0420205885765887, -0.39999999999999991, 0.60000000000000009, 
+	  0.87266462599716477 },
+  { 1.3517205230381770, -0.39999999999999991, 0.60000000000000009, 
+	  1.0471975511965976 },
+  { 1.7210360970313896, -0.39999999999999991, 0.60000000000000009, 
+	  1.2217304763960306 },
+  { 2.1500780510169242, -0.39999999999999991, 0.60000000000000009, 
+	  1.3962634015954636 },
+  { 2.6186940209850191, -0.39999999999999991, 0.60000000000000009, 
+	  1.5707963267948966 },
+};
+const double toler057 = 2.5000000000000020e-13;
+
+// Test data for k=-0.39999999999999991, nu=0.70000000000000007.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.1553900340611668e-16
+// mean(f - f_Boost): 1.1657341758564144e-16
+// variance(f - f_Boost): 1.3242789405258207e-32
+// stddev(f - f_Boost): 1.1507731924779187e-16
+const testcase_ellint_3<double>
+data058[10] =
+{
+  { 0.0000000000000000, -0.39999999999999991, 0.70000000000000007, 
+	  0.0000000000000000 },
+  { 0.17592484806010436, -0.39999999999999991, 0.70000000000000007, 
+	  0.17453292519943295 },
+  { 0.36043555139631439, -0.39999999999999991, 0.70000000000000007, 
+	  0.34906585039886590 },
+  { 0.56332813669944881, -0.39999999999999991, 0.70000000000000007, 
+	  0.52359877559829882 },
+  { 0.79697424562157548, -0.39999999999999991, 0.70000000000000007, 
+	  0.69813170079773179 },
+  { 1.0778155987523672, -0.39999999999999991, 0.70000000000000007, 
+	  0.87266462599716477 },
+  { 1.4272018169896268, -0.39999999999999991, 0.70000000000000007, 
+	  1.0471975511965976 },
+  { 1.8684377907453380, -0.39999999999999991, 0.70000000000000007, 
+	  1.2217304763960306 },
+  { 2.4128677409207469, -0.39999999999999991, 0.70000000000000007, 
+	  1.3962634015954636 },
+  { 3.0327078743873241, -0.39999999999999991, 0.70000000000000007, 
+	  1.5707963267948966 },
+};
+const double toler058 = 2.5000000000000020e-13;
+
+// Test data for k=-0.39999999999999991, nu=0.80000000000000004.
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.5727642219519274e-16
+// mean(f - f_Boost): 2.1926904736346843e-16
+// variance(f - f_Boost): 1.5293405480859847e-31
+// stddev(f - f_Boost): 3.9106783913868252e-16
+const testcase_ellint_3<double>
+data059[10] =
+{
+  { 0.0000000000000000, -0.39999999999999991, 0.80000000000000004, 
+	  0.0000000000000000 },
+  { 0.17610616300487833, -0.39999999999999991, 0.80000000000000004, 
+	  0.17453292519943295 },
+  { 0.36199013167171978, -0.39999999999999991, 0.80000000000000004, 
+	  0.34906585039886590 },
+  { 0.56923097361842423, -0.39999999999999991, 0.80000000000000004, 
+	  0.52359877559829882 },
+  { 0.81354878456624347, -0.39999999999999991, 0.80000000000000004, 
+	  0.69813170079773179 },
+  { 1.1182902719261825, -0.39999999999999991, 0.80000000000000004, 
+	  0.87266462599716477 },
+  { 1.5192950589409022, -0.39999999999999991, 0.80000000000000004, 
+	  1.0471975511965976 },
+  { 2.0678761710223981, -0.39999999999999991, 0.80000000000000004, 
+	  1.2217304763960306 },
+  { 2.8135222249879783, -0.39999999999999991, 0.80000000000000004, 
+	  1.3962634015954636 },
+  { 3.7289548002199902, -0.39999999999999991, 0.80000000000000004, 
+	  1.5707963267948966 },
+};
+const double toler059 = 2.5000000000000020e-13;
+
+// Test data for k=-0.39999999999999991, nu=0.90000000000000002.
+// max(|f - f_Boost|): 2.6645352591003757e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 5.0221626338023938e-16
+// mean(f - f_Boost): 4.1910919179599658e-16
+// variance(f - f_Boost): 6.2246150910247033e-31
+// stddev(f - f_Boost): 7.8896229891070860e-16
+const testcase_ellint_3<double>
+data060[10] =
+{
+  { 0.0000000000000000, -0.39999999999999991, 0.90000000000000002, 
+	  0.0000000000000000 },
+  { 0.17628815191971123, -0.39999999999999991, 0.90000000000000002, 
+	  0.17453292519943295 },
+  { 0.36356903815378772, -0.39999999999999991, 0.90000000000000002, 
+	  0.34906585039886590 },
+  { 0.57536079447000310, -0.39999999999999991, 0.90000000000000002, 
+	  0.52359877559829882 },
+  { 0.83141355850172571, -0.39999999999999991, 0.90000000000000002, 
+	  0.69813170079773179 },
+  { 1.1646481598721361, -0.39999999999999991, 0.90000000000000002, 
+	  0.87266462599716477 },
+  { 1.6357275034001995, -0.39999999999999991, 0.90000000000000002, 
+	  1.0471975511965976 },
+  { 2.3628787566572398, -0.39999999999999991, 0.90000000000000002, 
+	  1.2217304763960306 },
+  { 3.5521010369134958, -0.39999999999999991, 0.90000000000000002, 
+	  1.3962634015954636 },
+  { 5.3055535102872513, -0.39999999999999991, 0.90000000000000002, 
+	  1.5707963267948966 },
+};
+const double toler060 = 2.5000000000000020e-13;
+
+// Test data for k=-0.29999999999999993, nu=0.0000000000000000.
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.2241249691539529e-16
+// mean(f - f_Boost): 4.9960036108132046e-17
+// variance(f - f_Boost): 4.6872855002064458e-32
+// stddev(f - f_Boost): 2.1650139722889657e-16
+const testcase_ellint_3<double>
+data061[10] =
+{
+  { 0.0000000000000000, -0.29999999999999993, 0.0000000000000000, 
+	  0.0000000000000000 },
+  { 0.17461228653000099, -0.29999999999999993, 0.0000000000000000, 
+	  0.17453292519943295 },
+  { 0.34969146102798421, -0.29999999999999993, 0.0000000000000000, 
+	  0.34906585039886590 },
+  { 0.52565822873726309, -0.29999999999999993, 0.0000000000000000, 
+	  0.52359877559829882 },
+  { 0.70284226512408543, -0.29999999999999993, 0.0000000000000000, 
+	  0.69813170079773179 },
+  { 0.88144139195111171, -0.29999999999999993, 0.0000000000000000, 
+	  0.87266462599716477 },
+  { 1.0614897067260520, -0.29999999999999993, 0.0000000000000000, 
+	  1.0471975511965976 },
+  { 1.2428416824174220, -0.29999999999999993, 0.0000000000000000, 
+	  1.2217304763960306 },
+  { 1.4251795877015929, -0.29999999999999993, 0.0000000000000000, 
+	  1.3962634015954636 },
+  { 1.6080486199305126, -0.29999999999999993, 0.0000000000000000, 
+	  1.5707963267948966 },
+};
+const double toler061 = 2.5000000000000020e-13;
+
+// Test data for k=-0.29999999999999993, nu=0.10000000000000001.
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.1872304407982844e-16
+// mean(f - f_Boost): 9.4368957093138303e-17
+// variance(f - f_Boost): 4.0359883022230488e-32
+// stddev(f - f_Boost): 2.0089769292411121e-16
+const testcase_ellint_3<double>
+data062[10] =
+{
+  { 0.0000000000000000, -0.29999999999999993, 0.10000000000000001, 
+	  0.0000000000000000 },
+  { 0.17478889331392972, -0.29999999999999993, 0.10000000000000001, 
+	  0.17453292519943295 },
+  { 0.35108939018329183, -0.29999999999999993, 0.10000000000000001, 
+	  0.34906585039886590 },
+  { 0.53028990896115835, -0.29999999999999993, 0.10000000000000001, 
+	  0.52359877559829882 },
+  { 0.71352417052371409, -0.29999999999999993, 0.10000000000000001, 
+	  0.69813170079773179 },
+  { 0.90153086032405894, -0.29999999999999993, 0.10000000000000001, 
+	  0.87266462599716477 },
+  { 1.0945187977283313, -0.29999999999999993, 0.10000000000000001, 
+	  1.0471975511965976 },
+  { 1.2920699268385680, -0.29999999999999993, 0.10000000000000001, 
+	  1.2217304763960306 },
+  { 1.4931243665896394, -0.29999999999999993, 0.10000000000000001, 
+	  1.3962634015954636 },
+  { 1.6960848815118226, -0.29999999999999993, 0.10000000000000001, 
+	  1.5707963267948966 },
+};
+const double toler062 = 2.5000000000000020e-13;
+
+// Test data for k=-0.29999999999999993, nu=0.20000000000000001.
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 6.2247497610332889e-16
+// mean(f - f_Boost): 1.1102230246251565e-16
+// variance(f - f_Boost): 3.8043060629871325e-32
+// stddev(f - f_Boost): 1.9504630380981672e-16
+const testcase_ellint_3<double>
+data063[10] =
+{
+  { 0.0000000000000000, -0.29999999999999993, 0.20000000000000001, 
+	  0.0000000000000000 },
+  { 0.17496614335337535, -0.29999999999999993, 0.20000000000000001, 
+	  0.17453292519943295 },
+  { 0.35250745937139372, -0.29999999999999993, 0.20000000000000001, 
+	  0.34906585039886590 },
+  { 0.53506875002836884, -0.29999999999999993, 0.20000000000000001, 
+	  0.52359877559829882 },
+  { 0.72479106622248191, -0.29999999999999993, 0.20000000000000001, 
+	  0.69813170079773179 },
+  { 0.92326451535891607, -0.29999999999999993, 0.20000000000000001, 
+	  0.87266462599716477 },
+  { 1.1312092060698349, -0.29999999999999993, 0.20000000000000001, 
+	  1.0471975511965976 },
+  { 1.3481473154592321, -0.29999999999999993, 0.20000000000000001, 
+	  1.2217304763960306 },
+  { 1.5722049569662748, -0.29999999999999993, 0.20000000000000001, 
+	  1.3962634015954636 },
+  { 1.8002173372290498, -0.29999999999999993, 0.20000000000000001, 
+	  1.5707963267948966 },
+};
+const double toler063 = 2.5000000000000020e-13;
+
+// Test data for k=-0.29999999999999993, nu=0.30000000000000004.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 6.1678685180047551e-16
+// mean(f - f_Boost): 1.0547118733938987e-16
+// variance(f - f_Boost): 7.5633408838247182e-32
+// stddev(f - f_Boost): 2.7501528837184157e-16
+const testcase_ellint_3<double>
+data064[10] =
+{
+  { 0.0000000000000000, -0.29999999999999993, 0.30000000000000004, 
+	  0.0000000000000000 },
+  { 0.17514404084107435, -0.29999999999999993, 0.30000000000000004, 
+	  0.17453292519943295 },
+  { 0.35394619108645647, -0.29999999999999993, 0.30000000000000004, 
+	  0.34906585039886590 },
+  { 0.54000325463372689, -0.29999999999999993, 0.30000000000000004, 
+	  0.52359877559829882 },
+  { 0.73670193794067651, -0.29999999999999993, 0.30000000000000004, 
+	  0.69813170079773179 },
+  { 0.94689345491722177, -0.29999999999999993, 0.30000000000000004, 
+	  0.87266462599716477 },
+  { 1.1723274608389140, -0.29999999999999993, 0.30000000000000004, 
+	  1.0471975511965976 },
+  { 1.4128880552936287, -0.29999999999999993, 0.30000000000000004, 
+	  1.2217304763960306 },
+  { 1.6659010047449661, -0.29999999999999993, 0.30000000000000004, 
+	  1.3962634015954636 },
+  { 1.9260216862473254, -0.29999999999999993, 0.30000000000000004, 
+	  1.5707963267948966 },
+};
+const double toler064 = 2.5000000000000020e-13;
+
+// Test data for k=-0.29999999999999993, nu=0.40000000000000002.
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 6.3983279132797385e-16
+// mean(f - f_Boost): 1.1657341758564144e-16
+// variance(f - f_Boost): 1.8245832308692586e-31
+// stddev(f - f_Boost): 4.2715140534349863e-16
+const testcase_ellint_3<double>
+data065[10] =
+{
+  { 0.0000000000000000, -0.29999999999999993, 0.40000000000000002, 
+	  0.0000000000000000 },
+  { 0.17532259000954434, -0.29999999999999993, 0.40000000000000002, 
+	  0.17453292519943295 },
+  { 0.35540612770983693, -0.29999999999999993, 0.40000000000000002, 
+	  0.34906585039886590 },
+  { 0.54510265552938919, -0.29999999999999993, 0.40000000000000002, 
+	  0.52359877559829882 },
+  { 0.74932476310965057, -0.29999999999999993, 0.40000000000000002, 
+	  0.69813170079773179 },
+  { 0.97272793583093109, -0.29999999999999993, 0.40000000000000002, 
+	  0.87266462599716477 },
+  { 1.2188928987074241, -0.29999999999999993, 0.40000000000000002, 
+	  1.0471975511965976 },
+  { 1.4888771674085941, -0.29999999999999993, 0.40000000000000002, 
+	  1.2217304763960306 },
+  { 1.7794558498219191, -0.29999999999999993, 0.40000000000000002, 
+	  1.3962634015954636 },
+  { 2.0822121773175528, -0.29999999999999993, 0.40000000000000002, 
+	  1.5707963267948966 },
+};
+const double toler065 = 2.5000000000000020e-13;
+
+// Test data for k=-0.29999999999999993, nu=0.50000000000000000.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 6.0516138451673425e-16
+// mean(f - f_Boost): 4.7184478546569152e-17
+// variance(f - f_Boost): 1.9448563670505968e-32
+// stddev(f - f_Boost): 1.3945810722401896e-16
+const testcase_ellint_3<double>
+data066[10] =
+{
+  { 0.0000000000000000, -0.29999999999999993, 0.50000000000000000, 
+	  0.0000000000000000 },
+  { 0.17550179513158179, -0.29999999999999993, 0.50000000000000000, 
+	  0.17453292519943295 },
+  { 0.35688783251681200, -0.29999999999999993, 0.50000000000000000, 
+	  0.34906585039886590 },
+  { 0.55037700010142798, -0.29999999999999993, 0.50000000000000000, 
+	  0.52359877559829882 },
+  { 0.76273839789895992, -0.29999999999999993, 0.50000000000000000, 
+	  0.69813170079773179 },
+  { 1.0011570518830419, -0.29999999999999993, 0.50000000000000000, 
+	  0.87266462599716477 },
+  { 1.2722987414055109, -0.29999999999999993, 0.50000000000000000, 
+	  1.0471975511965976 },
+  { 1.5799590511080066, -0.29999999999999993, 0.50000000000000000, 
+	  1.2217304763960306 },
+  { 1.9212367220124293, -0.29999999999999993, 0.50000000000000000, 
+	  1.3962634015954636 },
+  { 2.2833505881933971, -0.29999999999999993, 0.50000000000000000, 
+	  1.5707963267948966 },
+};
+const double toler066 = 2.5000000000000020e-13;
+
+// Test data for k=-0.29999999999999993, nu=0.60000000000000009.
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 5.2121157428443725e-16
+// mean(f - f_Boost): 1.9428902930940239e-16
+// variance(f - f_Boost): 1.5987596229703424e-31
+// stddev(f - f_Boost): 3.9984492281012430e-16
+const testcase_ellint_3<double>
+data067[10] =
+{
+  { 0.0000000000000000, -0.29999999999999993, 0.60000000000000009, 
+	  0.0000000000000000 },
+  { 0.17568166052076745, -0.29999999999999993, 0.60000000000000009, 
+	  0.17453292519943295 },
+  { 0.35839189074731181, -0.29999999999999993, 0.60000000000000009, 
+	  0.34906585039886590 },
+  { 0.55583724744367558, -0.29999999999999993, 0.60000000000000009, 
+	  0.52359877559829882 },
+  { 0.77703498090888223, -0.29999999999999993, 0.60000000000000009, 
+	  0.69813170079773179 },
+  { 1.0326772113675962, -0.29999999999999993, 0.60000000000000009, 
+	  0.87266462599716477 },
+  { 1.3345139983717369, -0.29999999999999993, 0.60000000000000009, 
+	  1.0471975511965976 },
+  { 1.6921742922838403, -0.29999999999999993, 0.60000000000000009, 
+	  1.2217304763960306 },
+  { 2.1056608968472186, -0.29999999999999993, 0.60000000000000009, 
+	  1.3962634015954636 },
+  { 2.5560975528589061, -0.29999999999999993, 0.60000000000000009, 
+	  1.5707963267948966 },
+};
+const double toler067 = 2.5000000000000020e-13;
+
+// Test data for k=-0.29999999999999993, nu=0.70000000000000007.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 6.0088945789059381e-16
+// mean(f - f_Boost): 1.6653345369377348e-16
+// variance(f - f_Boost): 3.1994213989721786e-31
+// stddev(f - f_Boost): 5.6563428104846852e-16
+const testcase_ellint_3<double>
+data068[10] =
+{
+  { 0.0000000000000000, -0.29999999999999993, 0.70000000000000007, 
+	  0.0000000000000000 },
+  { 0.17586219053197988, -0.29999999999999993, 0.70000000000000007, 
+	  0.17453292519943295 },
+  { 0.35991891074557669, -0.29999999999999993, 0.70000000000000007, 
+	  0.34906585039886590 },
+  { 0.56149538019961731, -0.29999999999999993, 0.70000000000000007, 
+	  0.52359877559829882 },
+  { 0.79232303189667685, -0.29999999999999993, 0.70000000000000007, 
+	  0.69813170079773179 },
+  { 1.0679345542878826, -0.29999999999999993, 0.70000000000000007, 
+	  0.87266462599716477 },
+  { 1.4084400085913955, -0.29999999999999993, 0.70000000000000007, 
+	  1.0471975511965976 },
+  { 1.8357382859296454, -0.29999999999999993, 0.70000000000000007, 
+	  1.2217304763960306 },
+  { 2.3604197996171519, -0.29999999999999993, 0.70000000000000007, 
+	  1.3962634015954636 },
+  { 2.9562123549913872, -0.29999999999999993, 0.70000000000000007, 
+	  1.5707963267948966 },
+};
+const double toler068 = 2.5000000000000020e-13;
+
+// Test data for k=-0.29999999999999993, nu=0.80000000000000004.
+// max(|f - f_Boost|): 2.2204460492503131e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 6.1197887707781618e-16
+// mean(f - f_Boost): 3.4416913763379854e-16
+// variance(f - f_Boost): 4.3461914185990199e-31
+// stddev(f - f_Boost): 6.5925650687718054e-16
+const testcase_ellint_3<double>
+data069[10] =
+{
+  { 0.0000000000000000, -0.29999999999999993, 0.80000000000000004, 
+	  0.0000000000000000 },
+  { 0.17604338956191670, -0.29999999999999993, 0.80000000000000004, 
+	  0.17453292519943295 },
+  { 0.36146952517410791, -0.29999999999999993, 0.80000000000000004, 
+	  0.34906585039886590 },
+  { 0.56736453393774644, -0.29999999999999993, 0.80000000000000004, 
+	  0.52359877559829882 },
+  { 0.80873149979001091, -0.29999999999999993, 0.80000000000000004, 
+	  0.69813170079773179 },
+  { 1.1077903069860620, -0.29999999999999993, 0.80000000000000004, 
+	  0.87266462599716477 },
+  { 1.4985874311132998, -0.29999999999999993, 0.80000000000000004, 
+	  1.0471975511965976 },
+  { 2.0298167266724954, -0.29999999999999993, 0.80000000000000004, 
+	  1.2217304763960306 },
+  { 2.7483929054985432, -0.29999999999999993, 0.80000000000000004, 
+	  1.3962634015954636 },
+  { 3.6283050484567170, -0.29999999999999993, 0.80000000000000004, 
+	  1.5707963267948966 },
+};
+const double toler069 = 2.5000000000000020e-13;
+
+// Test data for k=-0.29999999999999993, nu=0.90000000000000002.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 5.1301806687926828e-16
+// mean(f - f_Boost): 4.1633363423443370e-16
+// variance(f - f_Boost): 2.2835347143080263e-31
+// stddev(f - f_Boost): 4.7786344433405093e-16
+const testcase_ellint_3<double>
+data070[10] =
+{
+  { 0.0000000000000000, -0.29999999999999993, 0.90000000000000002, 
+	  0.0000000000000000 },
+  { 0.17622526204962433, -0.29999999999999993, 0.90000000000000002, 
+	  0.17453292519943295 },
+  { 0.36304439230777141, -0.29999999999999993, 0.90000000000000002, 
+	  0.34906585039886590 },
+  { 0.57345914744719195, -0.29999999999999993, 0.90000000000000002, 
+	  0.52359877559829882 },
+  { 0.82641512928845162, -0.29999999999999993, 0.90000000000000002, 
+	  0.69813170079773179 },
+  { 1.1534256210757743, -0.29999999999999993, 0.90000000000000002, 
+	  0.87266462599716477 },
+  { 1.6124900353411677, -0.29999999999999993, 0.90000000000000002, 
+	  1.0471975511965976 },
+  { 2.3165905514845089, -0.29999999999999993, 0.90000000000000002, 
+	  1.2217304763960306 },
+  { 3.4625619526539824, -0.29999999999999993, 0.90000000000000002, 
+	  1.3962634015954636 },
+  { 5.1479514944016787, -0.29999999999999993, 0.90000000000000002, 
+	  1.5707963267948966 },
+};
+const double toler070 = 2.5000000000000020e-13;
 
 // Test data for k=-0.19999999999999996, nu=0.0000000000000000.
-testcase_ellint_3<double> data071[] = {
-  { -0.0000000000000000, -0.19999999999999996, 0.0000000000000000,
-          0.0000000000000000 },
-  { 0.17456817290292811, -0.19999999999999996, 0.0000000000000000,
-          0.17453292519943295 },
-  { 0.34934315932086801, -0.19999999999999996, 0.0000000000000000,
-          0.34906585039886590 },
-  { 0.52450880529443988, -0.19999999999999996, 0.0000000000000000,
-          0.52359877559829882 },
-  { 0.70020491009844910, -0.19999999999999996, 0.0000000000000000,
-          0.69813170079773179 },
-  { 0.87651006649967955, -0.19999999999999996, 0.0000000000000000,
-          0.87266462599716477 },
-  { 1.0534305870298994, -0.19999999999999996, 0.0000000000000000,
-          1.0471975511965976 },
-  { 1.2308975521670784, -0.19999999999999996, 0.0000000000000000,
-          1.2217304763960306 },
-  { 1.4087733584990738, -0.19999999999999996, 0.0000000000000000,
-          1.3962634015954636 },
-  { 1.5868678474541664, -0.19999999999999996, 0.0000000000000000,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.19999999999999996, nu=0.0000000000000000.
-template <typename Tp>
-void test071()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data071)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data071[i].k), Tp(data071[i].nu),
-                   Tp(data071[i].phi));
-      const Tp f0 = data071[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 6
+// max(|f - f_Boost| / |f_Boost|): 4.2156475739151676e-16
+// mean(f - f_Boost): -5.2735593669694933e-17
+// variance(f - f_Boost): 3.0473442641042680e-32
+// stddev(f - f_Boost): 1.7456644190978597e-16
+const testcase_ellint_3<double>
+data071[10] =
+{
+  { 0.0000000000000000, -0.19999999999999996, 0.0000000000000000, 
+	  0.0000000000000000 },
+  { 0.17456817290292806, -0.19999999999999996, 0.0000000000000000, 
+	  0.17453292519943295 },
+  { 0.34934315932086796, -0.19999999999999996, 0.0000000000000000, 
+	  0.34906585039886590 },
+  { 0.52450880529443988, -0.19999999999999996, 0.0000000000000000, 
+	  0.52359877559829882 },
+  { 0.70020491009844887, -0.19999999999999996, 0.0000000000000000, 
+	  0.69813170079773179 },
+  { 0.87651006649967977, -0.19999999999999996, 0.0000000000000000, 
+	  0.87266462599716477 },
+  { 1.0534305870298994, -0.19999999999999996, 0.0000000000000000, 
+	  1.0471975511965976 },
+  { 1.2308975521670789, -0.19999999999999996, 0.0000000000000000, 
+	  1.2217304763960306 },
+  { 1.4087733584990738, -0.19999999999999996, 0.0000000000000000, 
+	  1.3962634015954636 },
+  { 1.5868678474541662, -0.19999999999999996, 0.0000000000000000, 
+	  1.5707963267948966 },
+};
+const double toler071 = 2.5000000000000020e-13;
 
 // Test data for k=-0.19999999999999996, nu=0.10000000000000001.
-testcase_ellint_3<double> data072[] = {
-  { -0.0000000000000000, -0.19999999999999996, 0.10000000000000001,
-          0.0000000000000000 },
-  { 0.17439228502691750, -0.19999999999999996, 0.10000000000000001,
-          0.17453292519943295 },
-  { 0.34796731137565740, -0.19999999999999996, 0.10000000000000001,
-          0.34906585039886590 },
-  { 0.52003370294544848, -0.19999999999999996, 0.10000000000000001,
-          0.52359877559829882 },
-  { 0.69012222258631495, -0.19999999999999996, 0.10000000000000001,
-          0.69813170079773179 },
-  { 0.85803491465566772, -0.19999999999999996, 0.10000000000000001,
-          0.87266462599716477 },
-  { 1.0238463961099364, -0.19999999999999996, 0.10000000000000001,
-          1.0471975511965976 },
-  { 1.1878691059202153, -0.19999999999999996, 0.10000000000000001,
-          1.2217304763960306 },
-  { 1.3505985031831940, -0.19999999999999996, 0.10000000000000001,
-          1.3962634015954636 },
-  { 1.5126513474261092, -0.19999999999999996, 0.10000000000000001,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.19999999999999996, nu=0.10000000000000001.
-template <typename Tp>
-void test072()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data072)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data072[i].k), Tp(data072[i].nu),
-                   Tp(data072[i].phi));
-      const Tp f0 = data072[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 6
+// max(|f - f_Boost| / |f_Boost|): 4.0890622182605400e-16
+// mean(f - f_Boost): -3.8857805861880476e-17
+// variance(f - f_Boost): 2.8794792590749608e-32
+// stddev(f - f_Boost): 1.6969028431454054e-16
+const testcase_ellint_3<double>
+data072[10] =
+{
+  { 0.0000000000000000, -0.19999999999999996, 0.10000000000000001, 
+	  0.0000000000000000 },
+  { 0.17474469953608965, -0.19999999999999996, 0.10000000000000001, 
+	  0.17453292519943295 },
+  { 0.35073860234984255, -0.19999999999999996, 0.10000000000000001, 
+	  0.34906585039886590 },
+  { 0.52912258712951521, -0.19999999999999996, 0.10000000000000001, 
+	  0.52359877559829882 },
+  { 0.71081701558898069, -0.19999999999999996, 0.10000000000000001, 
+	  0.69813170079773179 },
+  { 0.89640758521169384, -0.19999999999999996, 0.10000000000000001, 
+	  0.87266462599716477 },
+  { 1.0860417038089853, -0.19999999999999996, 0.10000000000000001, 
+	  1.0471975511965976 },
+  { 1.2793599255528623, -0.19999999999999996, 0.10000000000000001, 
+	  1.2217304763960306 },
+  { 1.4754938544089076, -0.19999999999999996, 0.10000000000000001, 
+	  1.3962634015954636 },
+  { 1.6731552050562593, -0.19999999999999996, 0.10000000000000001, 
+	  1.5707963267948966 },
+};
+const double toler072 = 2.5000000000000020e-13;
 
 // Test data for k=-0.19999999999999996, nu=0.20000000000000001.
-testcase_ellint_3<double> data073[] = {
-  { -0.0000000000000000, -0.19999999999999996, 0.20000000000000001,
-          0.0000000000000000 },
-  { 0.17421703179583750, -0.19999999999999996, 0.20000000000000001,
-          0.17453292519943295 },
-  { 0.34661057411998791, -0.19999999999999996, 0.20000000000000001,
-          0.34906585039886590 },
-  { 0.51569006052647393, -0.19999999999999996, 0.20000000000000001,
-          0.52359877559829882 },
-  { 0.68052412821107278, -0.19999999999999996, 0.20000000000000001,
-          0.69813170079773179 },
-  { 0.84081341263313825, -0.19999999999999996, 0.20000000000000001,
-          0.87266462599716477 },
-  { 0.99683359988842890, -0.19999999999999996, 0.20000000000000001,
-          1.0471975511965976 },
-  { 1.1493086715118852, -0.19999999999999996, 0.20000000000000001,
-          1.2217304763960306 },
-  { 1.2992699693957541, -0.19999999999999996, 0.20000000000000001,
-          1.3962634015954636 },
-  { 1.4479323932249568, -0.19999999999999996, 0.20000000000000001,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.19999999999999996, nu=0.20000000000000001.
-template <typename Tp>
-void test073()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data073)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data073[i].k), Tp(data073[i].nu),
-                   Tp(data073[i].phi));
-      const Tp f0 = data073[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.19999999999999996, nu=0.29999999999999999.
-testcase_ellint_3<double> data074[] = {
-  { -0.0000000000000000, -0.19999999999999996, 0.29999999999999999,
-          0.0000000000000000 },
-  { 0.17404240913577707, -0.19999999999999996, 0.29999999999999999,
-          0.17453292519943295 },
-  { 0.34527248032587193, -0.19999999999999996, 0.29999999999999999,
-          0.34906585039886590 },
-  { 0.51147118981668416, -0.19999999999999996, 0.29999999999999999,
-          0.52359877559829882 },
-  { 0.67137107867777635, -0.19999999999999996, 0.29999999999999999,
-          0.69813170079773179 },
-  { 0.82470418188668893, -0.19999999999999996, 0.29999999999999999,
-          0.87266462599716477 },
-  { 0.97202873223594299, -0.19999999999999996, 0.29999999999999999,
-          1.0471975511965976 },
-  { 1.1144773569375266, -0.19999999999999996, 0.29999999999999999,
-          1.2217304763960306 },
-  { 1.2535292433701000, -0.19999999999999996, 0.29999999999999999,
-          1.3962634015954636 },
-  { 1.3908453514752481, -0.19999999999999996, 0.29999999999999999,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.19999999999999996, nu=0.29999999999999999.
-template <typename Tp>
-void test074()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data074)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data074[i].k), Tp(data074[i].nu),
-                   Tp(data074[i].phi));
-      const Tp f0 = data074[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 6
+// max(|f - f_Boost| / |f_Boost|): 3.9570963716579749e-16
+// mean(f - f_Boost): -5.8286708792820721e-17
+// variance(f - f_Boost): 3.1158217732380362e-32
+// stddev(f - f_Boost): 1.7651690494788412e-16
+const testcase_ellint_3<double>
+data073[10] =
+{
+  { 0.0000000000000000, -0.19999999999999996, 0.20000000000000001, 
+	  0.0000000000000000 },
+  { 0.17492186907740698, -0.19999999999999996, 0.20000000000000001, 
+	  0.17453292519943295 },
+  { 0.35215414286134267, -0.19999999999999996, 0.20000000000000001, 
+	  0.34906585039886590 },
+  { 0.53388285615182440, -0.19999999999999996, 0.20000000000000001, 
+	  0.52359877559829882 },
+  { 0.72200960282688265, -0.19999999999999996, 0.20000000000000001, 
+	  0.69813170079773179 },
+  { 0.91793087614428526, -0.19999999999999996, 0.20000000000000001, 
+	  0.87266462599716477 },
+  { 1.1222602841587976, -0.19999999999999996, 0.20000000000000001, 
+	  1.0471975511965976 },
+  { 1.3345489407496247, -0.19999999999999996, 0.20000000000000001, 
+	  1.2217304763960306 },
+  { 1.5531225705475502, -0.19999999999999996, 0.20000000000000001, 
+	  1.3962634015954636 },
+  { 1.7751816279738935, -0.19999999999999996, 0.20000000000000001, 
+	  1.5707963267948966 },
+};
+const double toler073 = 2.5000000000000020e-13;
+
+// Test data for k=-0.19999999999999996, nu=0.30000000000000004.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.6785817924053817e-16
+// mean(f - f_Boost): -1.1102230246251566e-17
+// variance(f - f_Boost): 9.9840208317034302e-32
+// stddev(f - f_Boost): 3.1597501217190311e-16
+const testcase_ellint_3<double>
+data074[10] =
+{
+  { 0.0000000000000000, -0.19999999999999996, 0.30000000000000004, 
+	  0.0000000000000000 },
+  { 0.17509968571715159, -0.19999999999999996, 0.30000000000000004, 
+	  0.17453292519943295 },
+  { 0.35359030214835629, -0.19999999999999996, 0.30000000000000004, 
+	  0.34906585039886590 },
+  { 0.53879807274537084, -0.19999999999999996, 0.30000000000000004, 
+	  0.52359877559829882 },
+  { 0.73384116418059731, -0.19999999999999996, 0.30000000000000004, 
+	  0.69813170079773179 },
+  { 0.94132799329524031, -0.19999999999999996, 0.30000000000000004, 
+	  0.87266462599716477 },
+  { 1.1628407021801439, -0.19999999999999996, 0.30000000000000004, 
+	  1.0471975511965976 },
+  { 1.3982440216739438, -0.19999999999999996, 0.30000000000000004, 
+	  1.2217304763960306 },
+  { 1.6450634983653640, -0.19999999999999996, 0.30000000000000004, 
+	  1.3962634015954636 },
+  { 1.8983924169967099, -0.19999999999999996, 0.30000000000000004, 
+	  1.5707963267948966 },
+};
+const double toler074 = 2.5000000000000020e-13;
 
 // Test data for k=-0.19999999999999996, nu=0.40000000000000002.
-testcase_ellint_3<double> data075[] = {
-  { -0.0000000000000000, -0.19999999999999996, 0.40000000000000002,
-          0.0000000000000000 },
-  { 0.17386841301066677, -0.19999999999999996, 0.40000000000000002,
-          0.17453292519943295 },
-  { 0.34395257914113253, -0.19999999999999996, 0.40000000000000002,
-          0.34906585039886590 },
-  { 0.50737088376869466, -0.19999999999999996, 0.40000000000000002,
-          0.52359877559829882 },
-  { 0.66262801717277664, -0.19999999999999996, 0.40000000000000002,
-          0.69813170079773179 },
-  { 0.80958766645079094, -0.19999999999999996, 0.40000000000000002,
-          0.87266462599716477 },
-  { 0.94913754236162040, -0.19999999999999996, 0.40000000000000002,
-          1.0471975511965976 },
-  { 1.0827985514223000, -0.19999999999999996, 0.40000000000000002,
-          1.2217304763960306 },
-  { 1.2124212429050478, -0.19999999999999996, 0.40000000000000002,
-          1.3962634015954636 },
-  { 1.3400002519661010, -0.19999999999999996, 0.40000000000000002,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.19999999999999996, nu=0.40000000000000002.
-template <typename Tp>
-void test075()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data075)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data075[i].k), Tp(data075[i].nu),
-                   Tp(data075[i].phi));
-      const Tp f0 = data075[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.3298410018355870e-16
+// mean(f - f_Boost): 1.3877787807814457e-17
+// variance(f - f_Boost): 9.4370567274974557e-32
+// stddev(f - f_Boost): 3.0719792850046133e-16
+const testcase_ellint_3<double>
+data075[10] =
+{
+  { 0.0000000000000000, -0.19999999999999996, 0.40000000000000002, 
+	  0.0000000000000000 },
+  { 0.17527815368535152, -0.19999999999999996, 0.40000000000000002, 
+	  0.17453292519943295 },
+  { 0.35504762134297801, -0.19999999999999996, 0.40000000000000002, 
+	  0.34906585039886590 },
+  { 0.54387742353211344, -0.19999999999999996, 0.40000000000000002, 
+	  0.52359877559829882 },
+  { 0.74637910471804259, -0.19999999999999996, 0.40000000000000002, 
+	  0.69813170079773179 },
+  { 0.96690539714174639, -0.19999999999999996, 0.40000000000000002, 
+	  0.87266462599716477 },
+  { 1.2087859420184757, -0.19999999999999996, 0.40000000000000002, 
+	  1.0471975511965976 },
+  { 1.4729799844168852, -0.19999999999999996, 0.40000000000000002, 
+	  1.2217304763960306 },
+  { 1.7564445064596661, -0.19999999999999996, 0.40000000000000002, 
+	  1.3962634015954636 },
+  { 2.0512956926676802, -0.19999999999999996, 0.40000000000000002, 
+	  1.5707963267948966 },
+};
+const double toler075 = 2.5000000000000020e-13;
 
 // Test data for k=-0.19999999999999996, nu=0.50000000000000000.
-testcase_ellint_3<double> data076[] = {
-  { -0.0000000000000000, -0.19999999999999996, 0.50000000000000000,
-          0.0000000000000000 },
-  { 0.17369503942181802, -0.19999999999999996, 0.50000000000000000,
-          0.17453292519943295 },
-  { 0.34265043534362660, -0.19999999999999996, 0.50000000000000000,
-          0.34906585039886590 },
-  { 0.50338337208655415, -0.19999999999999996, 0.50000000000000000,
-          0.52359877559829882 },
-  { 0.65426373297163642, -0.19999999999999996, 0.50000000000000000,
-          0.69813170079773179 },
-  { 0.79536193036145808, -0.19999999999999996, 0.50000000000000000,
-          0.87266462599716477 },
-  { 0.92791875910061605, -0.19999999999999996, 0.50000000000000000,
-          1.0471975511965976 },
-  { 1.0538145052725829, -0.19999999999999996, 0.50000000000000000,
-          1.2217304763960306 },
-  { 1.1752060022875899, -0.19999999999999996, 0.50000000000000000,
-          1.3962634015954636 },
-  { 1.2943374404397376, -0.19999999999999996, 0.50000000000000000,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.19999999999999996, nu=0.50000000000000000.
-template <typename Tp>
-void test076()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data076)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data076[i].k), Tp(data076[i].nu),
-                   Tp(data076[i].phi));
-      const Tp f0 = data076[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.19999999999999996, nu=0.59999999999999998.
-testcase_ellint_3<double> data077[] = {
-  { -0.0000000000000000, -0.19999999999999996, 0.59999999999999998,
-          0.0000000000000000 },
-  { 0.17352228440746928, -0.19999999999999996, 0.59999999999999998,
-          0.17453292519943295 },
-  { 0.34136562863713626, -0.19999999999999996, 0.59999999999999998,
-          0.34906585039886590 },
-  { 0.49950328177638481, -0.19999999999999996, 0.59999999999999998,
-          0.52359877559829882 },
-  { 0.64625032705690832, -0.19999999999999996, 0.59999999999999998,
-          0.69813170079773179 },
-  { 0.78193941198403094, -0.19999999999999996, 0.59999999999999998,
-          0.87266462599716477 },
-  { 0.90817230934317128, -0.19999999999999996, 0.59999999999999998,
-          1.0471975511965976 },
-  { 1.0271563751276462, -0.19999999999999996, 0.59999999999999998,
-          1.2217304763960306 },
-  { 1.1412999379040518, -0.19999999999999996, 0.59999999999999998,
-          1.3962634015954636 },
-  { 1.2530330675914561, -0.19999999999999996, 0.59999999999999998,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.19999999999999996, nu=0.59999999999999998.
-template <typename Tp>
-void test077()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data077)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data077[i].k), Tp(data077[i].nu),
-                   Tp(data077[i].phi));
-      const Tp f0 = data077[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.19999999999999996, nu=0.69999999999999996.
-testcase_ellint_3<double> data078[] = {
-  { -0.0000000000000000, -0.19999999999999996, 0.69999999999999996,
-          0.0000000000000000 },
-  { 0.17335014404233898, -0.19999999999999996, 0.69999999999999996,
-          0.17453292519943295 },
-  { 0.34009775298617811, -0.19999999999999996, 0.69999999999999996,
-          0.34906585039886590 },
-  { 0.49572560201923810, -0.19999999999999996, 0.69999999999999996,
-          0.52359877559829882 },
-  { 0.63856276669886525, -0.19999999999999996, 0.69999999999999996,
-          0.69813170079773179 },
-  { 0.76924438644867565, -0.19999999999999996, 0.69999999999999996,
-          0.87266462599716477 },
-  { 0.88973060843856466, -0.19999999999999996, 0.69999999999999996,
-          1.0471975511965976 },
-  { 1.0025230471636377, -0.19999999999999996, 0.69999999999999996,
-          1.2217304763960306 },
-  { 1.1102356376093103, -0.19999999999999996, 0.69999999999999996,
-          1.3962634015954636 },
-  { 1.2154356555075867, -0.19999999999999996, 0.69999999999999996,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.19999999999999996, nu=0.69999999999999996.
-template <typename Tp>
-void test078()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data078)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data078[i].k), Tp(data078[i].nu),
-                   Tp(data078[i].phi));
-      const Tp f0 = data078[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.3841806057292116e-16
+// mean(f - f_Boost): 8.0491169285323847e-17
+// variance(f - f_Boost): 8.0538110429953348e-32
+// stddev(f - f_Boost): 2.8379237204328335e-16
+const testcase_ellint_3<double>
+data076[10] =
+{
+  { 0.0000000000000000, -0.19999999999999996, 0.50000000000000000, 
+	  0.0000000000000000 },
+  { 0.17545727725228877, -0.19999999999999996, 0.50000000000000000, 
+	  0.17453292519943295 },
+  { 0.35652666242062175, -0.19999999999999996, 0.50000000000000000, 
+	  0.34906585039886590 },
+  { 0.54913090549102406, -0.19999999999999996, 0.50000000000000000, 
+	  0.52359877559829882 },
+  { 0.75970161209211551, -0.19999999999999996, 0.50000000000000000, 
+	  0.69813170079773179 },
+  { 0.99504737401590326, -0.19999999999999996, 0.50000000000000000, 
+	  0.87266462599716477 },
+  { 1.2614666007124373, -0.19999999999999996, 0.50000000000000000, 
+	  1.0471975511965976 },
+  { 1.5625255355205496, -0.19999999999999996, 0.50000000000000000, 
+	  1.2217304763960306 },
+  { 1.8954460255613343, -0.19999999999999996, 0.50000000000000000, 
+	  1.3962634015954636 },
+  { 2.2481046259421302, -0.19999999999999996, 0.50000000000000000, 
+	  1.5707963267948966 },
+};
+const double toler076 = 2.5000000000000020e-13;
+
+// Test data for k=-0.19999999999999996, nu=0.60000000000000009.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.5317584994994743e-16
+// mean(f - f_Boost): -1.3877787807814457e-17
+// variance(f - f_Boost): 1.0045745697575397e-31
+// stddev(f - f_Boost): 3.1695024369095219e-16
+const testcase_ellint_3<double>
+data077[10] =
+{
+  { 0.0000000000000000, -0.19999999999999996, 0.60000000000000009, 
+	  0.0000000000000000 },
+  { 0.17563706072900442, -0.19999999999999996, 0.60000000000000009, 
+	  0.17453292519943295 },
+  { 0.35802800926807238, -0.19999999999999996, 0.60000000000000009, 
+	  0.34906585039886590 },
+  { 0.55456942250515051, -0.19999999999999996, 0.60000000000000009, 
+	  0.52359877559829882 },
+  { 0.77390003828438203, -0.19999999999999996, 0.60000000000000009, 
+	  0.69813170079773179 },
+  { 1.0262441366366397, -0.19999999999999996, 0.60000000000000009, 
+	  0.87266462599716477 },
+  { 1.3228192988439669, -0.19999999999999996, 0.60000000000000009, 
+	  1.0471975511965976 },
+  { 1.6728005754680795, -0.19999999999999996, 0.60000000000000009, 
+	  1.2217304763960306 },
+  { 2.0761587107468511, -0.19999999999999996, 0.60000000000000009, 
+	  1.3962634015954636 },
+  { 2.5148333891629315, -0.19999999999999996, 0.60000000000000009, 
+	  1.5707963267948966 },
+};
+const double toler077 = 2.5000000000000020e-13;
+
+// Test data for k=-0.19999999999999996, nu=0.70000000000000007.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.1818454249546518e-16
+// mean(f - f_Boost): 3.6082248300317589e-17
+// variance(f - f_Boost): 8.9638010532618564e-32
+// stddev(f - f_Boost): 2.9939607634806868e-16
+const testcase_ellint_3<double>
+data078[10] =
+{
+  { 0.0000000000000000, -0.19999999999999996, 0.70000000000000007, 
+	  0.0000000000000000 },
+  { 0.17581750846781172, -0.19999999999999996, 0.70000000000000007, 
+	  0.17453292519943295 },
+  { 0.35955226882028513, -0.19999999999999996, 0.70000000000000007, 
+	  0.34906585039886590 },
+  { 0.56020489659466499, -0.19999999999999996, 0.70000000000000007, 
+	  0.52359877559829882 },
+  { 0.78908196988531487, -0.19999999999999996, 0.70000000000000007, 
+	  0.69813170079773179 },
+  { 1.0611336754143517, -0.19999999999999996, 0.70000000000000007, 
+	  0.87266462599716477 },
+  { 1.3956969951058884, -0.19999999999999996, 0.70000000000000007, 
+	  1.0471975511965976 },
+  { 1.8138131612209609, -0.19999999999999996, 0.70000000000000007, 
+	  1.2217304763960306 },
+  { 2.3256365528879561, -0.19999999999999996, 0.70000000000000007, 
+	  1.3962634015954636 },
+  { 2.9058704854500963, -0.19999999999999996, 0.70000000000000007, 
+	  1.5707963267948966 },
+};
+const double toler078 = 2.5000000000000020e-13;
 
 // Test data for k=-0.19999999999999996, nu=0.80000000000000004.
-testcase_ellint_3<double> data079[] = {
-  { -0.0000000000000000, -0.19999999999999996, 0.80000000000000004,
-          0.0000000000000000 },
-  { 0.17317861443718541, -0.19999999999999996, 0.80000000000000004,
-          0.17453292519943295 },
-  { 0.33884641598718701, -0.19999999999999996, 0.80000000000000004,
-          0.34906585039886590 },
-  { 0.49204565281259494, -0.19999999999999996, 0.80000000000000004,
-          0.52359877559829882 },
-  { 0.63117851188220353, -0.19999999999999996, 0.80000000000000004,
-          0.69813170079773179 },
-  { 0.75721095949544170, -0.19999999999999996, 0.80000000000000004,
-          0.87266462599716477 },
-  { 0.87245201443919118, -0.19999999999999996, 0.80000000000000004,
-          1.0471975511965976 },
-  { 0.97966584238831089, -0.19999999999999996, 0.80000000000000004,
-          1.2217304763960306 },
-  { 1.0816336325174360, -0.19999999999999996, 0.80000000000000004,
-          1.3962634015954636 },
-  { 1.1810223448909913, -0.19999999999999996, 0.80000000000000004,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.19999999999999996, nu=0.80000000000000004.
-template <typename Tp>
-void test079()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data079)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data079[i].k), Tp(data079[i].nu),
-                   Tp(data079[i].phi));
-      const Tp f0 = data079[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.9866614515542431e-16
+// mean(f - f_Boost): 1.8318679906315082e-16
+// variance(f - f_Boost): 3.1335688610218711e-31
+// stddev(f - f_Boost): 5.5978289193417400e-16
+const testcase_ellint_3<double>
+data079[10] =
+{
+  { 0.0000000000000000, -0.19999999999999996, 0.80000000000000004, 
+	  0.0000000000000000 },
+  { 0.17599862486281712, -0.19999999999999996, 0.80000000000000004, 
+	  0.17453292519943295 },
+  { 0.36110007227128776, -0.19999999999999996, 0.80000000000000004, 
+	  0.34906585039886590 },
+  { 0.56605039658567224, -0.19999999999999996, 0.80000000000000004, 
+	  0.52359877559829882 },
+  { 0.80537523874517691, -0.19999999999999996, 0.80000000000000004, 
+	  0.69813170079773179 },
+  { 1.1005662342414086, -0.19999999999999996, 0.80000000000000004, 
+	  0.87266462599716477 },
+  { 1.4845340298105778, -0.19999999999999996, 0.80000000000000004, 
+	  1.0471975511965976 },
+  { 2.0043332244969392, -0.19999999999999996, 0.80000000000000004, 
+	  1.2217304763960306 },
+  { 2.7052856676744761, -0.19999999999999996, 0.80000000000000004, 
+	  1.3962634015954636 },
+  { 3.5622166386422629, -0.19999999999999996, 0.80000000000000004, 
+	  1.5707963267948966 },
+};
+const double toler079 = 2.5000000000000020e-13;
 
 // Test data for k=-0.19999999999999996, nu=0.90000000000000002.
-testcase_ellint_3<double> data080[] = {
-  { -0.0000000000000000, -0.19999999999999996, 0.90000000000000002,
-          0.0000000000000000 },
-  { 0.17300769173837280, -0.19999999999999996, 0.90000000000000002,
-          0.17453292519943295 },
-  { 0.33761123827372508, -0.19999999999999996, 0.90000000000000002,
-          0.34906585039886590 },
-  { 0.48845905690769426, -0.19999999999999996, 0.90000000000000002,
-          0.52359877559829882 },
-  { 0.62407720017324986, -0.19999999999999996, 0.90000000000000002,
-          0.69813170079773179 },
-  { 0.74578146525124289, -0.19999999999999996, 0.90000000000000002,
-          0.87266462599716477 },
-  { 0.85621583540073076, -0.19999999999999996, 0.90000000000000002,
-          1.0471975511965976 },
-  { 0.95837725988001199, -0.19999999999999996, 0.90000000000000002,
-          1.2217304763960306 },
-  { 1.0551821412633928, -0.19999999999999996, 0.90000000000000002,
-          1.3962634015954636 },
-  { 1.1493679916141863, -0.19999999999999996, 0.90000000000000002,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.19999999999999996, nu=0.90000000000000002.
-template <typename Tp>
-void test080()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data080)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data080[i].k), Tp(data080[i].nu),
-                   Tp(data080[i].phi));
-      const Tp f0 = data080[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 2.6645352591003757e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 5.2817178727913890e-16
+// mean(f - f_Boost): 3.4694469519536142e-16
+// variance(f - f_Boost): 6.6311432369155086e-31
+// stddev(f - f_Boost): 8.1431831840598485e-16
+const testcase_ellint_3<double>
+data080[10] =
+{
+  { 0.0000000000000000, -0.19999999999999996, 0.90000000000000002, 
+	  0.0000000000000000 },
+  { 0.17618041435044951, -0.19999999999999996, 0.90000000000000002, 
+	  0.17453292519943295 },
+  { 0.36267207636502929, -0.19999999999999996, 0.90000000000000002, 
+	  0.34906585039886590 },
+  { 0.57212028758237743, -0.19999999999999996, 0.90000000000000002, 
+	  0.52359877559829882 },
+  { 0.82293323876704483, -0.19999999999999996, 0.90000000000000002, 
+	  0.69813170079773179 },
+  { 1.1457077279880385, -0.19999999999999996, 0.90000000000000002, 
+	  0.87266462599716477 },
+  { 1.5967346899325681, -0.19999999999999996, 0.90000000000000002, 
+	  1.0471975511965976 },
+  { 2.2856537353421724, -0.19999999999999996, 0.90000000000000002, 
+	  1.2217304763960306 },
+  { 3.4034714304613902, -0.19999999999999996, 0.90000000000000002, 
+	  1.3962634015954636 },
+  { 5.0448269356200361, -0.19999999999999996, 0.90000000000000002, 
+	  1.5707963267948966 },
+};
+const double toler080 = 2.5000000000000020e-13;
 
 // Test data for k=-0.099999999999999978, nu=0.0000000000000000.
-testcase_ellint_3<double> data081[] = {
-  { -0.0000000000000000, -0.099999999999999978, 0.0000000000000000,
-          0.0000000000000000 },
-  { 0.17454173353063665, -0.099999999999999978, 0.0000000000000000,
-          0.17453292519943295 },
-  { 0.34913506721468085, -0.099999999999999978, 0.0000000000000000,
-          0.34906585039886590 },
-  { 0.52382550016538953, -0.099999999999999978, 0.0000000000000000,
-          0.52359877559829882 },
-  { 0.69864700854177031, -0.099999999999999978, 0.0000000000000000,
-          0.69813170079773179 },
-  { 0.87361792586964870, -0.099999999999999978, 0.0000000000000000,
-          0.87266462599716477 },
-  { 1.0487386319621685, -0.099999999999999978, 0.0000000000000000,
-          1.0471975511965976 },
-  { 1.2239913752078757, -0.099999999999999978, 0.0000000000000000,
-          1.2217304763960306 },
-  { 1.3993423113684049, -0.099999999999999978, 0.0000000000000000,
-          1.3962634015954636 },
-  { 1.5747455615173562, -0.099999999999999978, 0.0000000000000000,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.099999999999999978, nu=0.0000000000000000.
-template <typename Tp>
-void test081()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data081)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data081[i].k), Tp(data081[i].nu),
-                   Tp(data081[i].phi));
-      const Tp f0 = data081[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 3.1735566504509645e-16
+// mean(f - f_Boost): -3.6082248300317589e-17
+// variance(f - f_Boost): 8.2258607846939269e-33
+// stddev(f - f_Boost): 9.0696531271564778e-17
+const testcase_ellint_3<double>
+data081[10] =
+{
+  { 0.0000000000000000, -0.099999999999999978, 0.0000000000000000, 
+	  0.0000000000000000 },
+  { 0.17454173353063662, -0.099999999999999978, 0.0000000000000000, 
+	  0.17453292519943295 },
+  { 0.34913506721468096, -0.099999999999999978, 0.0000000000000000, 
+	  0.34906585039886590 },
+  { 0.52382550016538953, -0.099999999999999978, 0.0000000000000000, 
+	  0.52359877559829882 },
+  { 0.69864700854177020, -0.099999999999999978, 0.0000000000000000, 
+	  0.69813170079773179 },
+  { 0.87361792586964859, -0.099999999999999978, 0.0000000000000000, 
+	  0.87266462599716477 },
+  { 1.0487386319621685, -0.099999999999999978, 0.0000000000000000, 
+	  1.0471975511965976 },
+  { 1.2239913752078759, -0.099999999999999978, 0.0000000000000000, 
+	  1.2217304763960306 },
+  { 1.3993423113684051, -0.099999999999999978, 0.0000000000000000, 
+	  1.3962634015954636 },
+  { 1.5747455615173558, -0.099999999999999978, 0.0000000000000000, 
+	  1.5707963267948966 },
+};
+const double toler081 = 2.5000000000000020e-13;
 
 // Test data for k=-0.099999999999999978, nu=0.10000000000000001.
-testcase_ellint_3<double> data082[] = {
-  { -0.0000000000000000, -0.099999999999999978, 0.10000000000000001,
-          0.0000000000000000 },
-  { 0.17436589347616618, -0.099999999999999978, 0.10000000000000001,
-          0.17453292519943295 },
-  { 0.34776067871237354, -0.099999999999999978, 0.10000000000000001,
-          0.34906585039886590 },
-  { 0.51936064354727807, -0.099999999999999978, 0.10000000000000001,
-          0.52359877559829882 },
-  { 0.68860303749364360, -0.099999999999999978, 0.10000000000000001,
-          0.69813170079773179 },
-  { 0.85524561882332051, -0.099999999999999978, 0.10000000000000001,
-          0.87266462599716477 },
-  { 1.0193708301908337, -0.099999999999999978, 0.10000000000000001,
-          1.0471975511965976 },
-  { 1.1813474067123044, -0.099999999999999978, 0.10000000000000001,
-          1.2217304763960306 },
-  { 1.3417670770424983, -0.099999999999999978, 0.10000000000000001,
-          1.3962634015954636 },
-  { 1.5013711111199950, -0.099999999999999978, 0.10000000000000001,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.099999999999999978, nu=0.10000000000000001.
-template <typename Tp>
-void test082()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data082)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data082[i].k), Tp(data082[i].nu),
-                   Tp(data082[i].phi));
-      const Tp f0 = data082[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 3.0305747373482148e-16
+// mean(f - f_Boost): -3.0531133177191807e-17
+// variance(f - f_Boost): 1.1508025840536076e-34
+// stddev(f - f_Boost): 1.0727546709539920e-17
+const testcase_ellint_3<double>
+data082[10] =
+{
+  { 0.0000000000000000, -0.099999999999999978, 0.10000000000000001, 
+	  0.0000000000000000 },
+  { 0.17471821213559732, -0.099999999999999978, 0.10000000000000001, 
+	  0.17453292519943295 },
+  { 0.35052902610011138, -0.099999999999999978, 0.10000000000000001, 
+	  0.34906585039886590 },
+  { 0.52842865990255727, -0.099999999999999978, 0.10000000000000001, 
+	  0.52359877559829882 },
+  { 0.70921799731166713, -0.099999999999999978, 0.10000000000000001, 
+	  0.69813170079773179 },
+  { 0.89340330535868662, -0.099999999999999978, 0.10000000000000001, 
+	  0.87266462599716477 },
+  { 1.0811075784236857, -0.099999999999999978, 0.10000000000000001, 
+	  1.0471975511965976 },
+  { 1.2720133232666426, -0.099999999999999978, 0.10000000000000001, 
+	  1.2217304763960306 },
+  { 1.4653630031861395, -0.099999999999999978, 0.10000000000000001, 
+	  1.3962634015954636 },
+  { 1.6600374067558428, -0.099999999999999978, 0.10000000000000001, 
+	  1.5707963267948966 },
+};
+const double toler082 = 2.5000000000000020e-13;
 
 // Test data for k=-0.099999999999999978, nu=0.20000000000000001.
-testcase_ellint_3<double> data083[] = {
-  { -0.0000000000000000, -0.099999999999999978, 0.20000000000000001,
-          0.0000000000000000 },
-  { 0.17419068786141345, -0.099999999999999978, 0.20000000000000001,
-          0.17453292519943295 },
-  { 0.34640537686230127, -0.099999999999999978, 0.20000000000000001,
-          0.34906585039886590 },
-  { 0.51502689171753957, -0.099999999999999978, 0.20000000000000001,
-          0.52359877559829882 },
-  { 0.67904147863672726, -0.099999999999999978, 0.20000000000000001,
-          0.69813170079773179 },
-  { 0.83811885126105179, -0.099999999999999978, 0.20000000000000001,
-          0.87266462599716477 },
-  { 0.99255278555742810, -0.099999999999999978, 0.20000000000000001,
-          1.0471975511965976 },
-  { 1.1431260546194930, -0.099999999999999978, 0.20000000000000001,
-          1.2217304763960306 },
-  { 1.2909589656532101, -0.099999999999999978, 0.20000000000000001,
-          1.3962634015954636 },
-  { 1.4373749386463430, -0.099999999999999978, 0.20000000000000001,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.099999999999999978, nu=0.20000000000000001.
-template <typename Tp>
-void test083()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data083)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data083[i].k), Tp(data083[i].nu),
-                   Tp(data083[i].phi));
-      const Tp f0 = data083[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.099999999999999978, nu=0.29999999999999999.
-testcase_ellint_3<double> data084[] = {
-  { -0.0000000000000000, -0.099999999999999978, 0.29999999999999999,
-          0.0000000000000000 },
-  { 0.17401611261390110, -0.099999999999999978, 0.29999999999999999,
-          0.17453292519943295 },
-  { 0.34506869507511767, -0.099999999999999978, 0.29999999999999999,
-          0.34906585039886590 },
-  { 0.51081757604259870, -0.099999999999999978, 0.29999999999999999,
-          0.52359877559829882 },
-  { 0.66992297597712303, -0.099999999999999978, 0.29999999999999999,
-          0.69813170079773179 },
-  { 0.82209722856174228, -0.099999999999999978, 0.29999999999999999,
-          0.87266462599716477 },
-  { 0.96792430487669612, -0.099999999999999978, 0.29999999999999999,
-          1.0471975511965976 },
-  { 1.1085964108954092, -0.099999999999999978, 0.29999999999999999,
-          1.2217304763960306 },
-  { 1.2456748370836999, -0.099999999999999978, 0.29999999999999999,
-          1.3962634015954636 },
-  { 1.3809159606704959, -0.099999999999999978, 0.29999999999999999,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.099999999999999978, nu=0.29999999999999999.
-template <typename Tp>
-void test084()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data084)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data084[i].k), Tp(data084[i].nu),
-                   Tp(data084[i].phi));
-      const Tp f0 = data084[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 2.2204460492503131e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 1.6736714959992433e-16
+// mean(f - f_Boost): 5.5511151231257830e-18
+// variance(f - f_Boost): 3.8043060629871325e-36
+// stddev(f - f_Boost): 1.9504630380981673e-18
+const testcase_ellint_3<double>
+data083[10] =
+{
+  { 0.0000000000000000, -0.099999999999999978, 0.20000000000000001, 
+	  0.0000000000000000 },
+  { 0.17489533344059083, -0.099999999999999978, 0.20000000000000001, 
+	  0.17453292519943295 },
+  { 0.35194305707815038, -0.099999999999999978, 0.20000000000000001, 
+	  0.34906585039886590 },
+  { 0.53317790741512527, -0.099999999999999978, 0.20000000000000001, 
+	  0.52359877559829882 },
+  { 0.72036681615081222, -0.099999999999999978, 0.20000000000000001, 
+	  0.69813170079773179 },
+  { 0.91480372268244303, -0.099999999999999978, 0.20000000000000001, 
+	  0.87266462599716477 },
+  { 1.1170528708071514, -0.099999999999999978, 0.20000000000000001, 
+	  1.0471975511965976 },
+  { 1.3266916802718358, -0.099999999999999978, 0.20000000000000001, 
+	  1.2217304763960306 },
+  { 1.5421622241831547, -0.099999999999999978, 0.20000000000000001, 
+	  1.3962634015954636 },
+  { 1.7608656115083421, -0.099999999999999978, 0.20000000000000001, 
+	  1.5707963267948966 },
+};
+const double toler083 = 2.5000000000000020e-13;
+
+// Test data for k=-0.099999999999999978, nu=0.30000000000000004.
+// max(|f - f_Boost|): 2.2204460492503131e-16 at index 6
+// max(|f - f_Boost| / |f_Boost|): 1.9186071760326645e-16
+// mean(f - f_Boost): -1.6653345369377347e-17
+// variance(f - f_Boost): 3.4238754566884194e-35
+// stddev(f - f_Boost): 5.8513891142945016e-18
+const testcase_ellint_3<double>
+data084[10] =
+{
+  { 0.0000000000000000, -0.099999999999999978, 0.30000000000000004, 
+	  0.0000000000000000 },
+  { 0.17507310163441189, -0.099999999999999978, 0.30000000000000004, 
+	  0.17453292519943295 },
+  { 0.35337768072524217, -0.099999999999999978, 0.30000000000000004, 
+	  0.34906585039886590 },
+  { 0.53808167801629170, -0.099999999999999978, 0.30000000000000004, 
+	  0.52359877559829882 },
+  { 0.73215166755955019, -0.099999999999999978, 0.30000000000000004, 
+	  0.69813170079773179 },
+  { 0.93806546000201219, -0.099999999999999978, 0.30000000000000004, 
+	  0.87266462599716477 },
+  { 1.1573218723395986, -0.099999999999999978, 0.30000000000000004, 
+	  1.0471975511965976 },
+  { 1.3897859679542097, -0.099999999999999978, 0.30000000000000004, 
+	  1.2217304763960306 },
+  { 1.6331009404328622, -0.099999999999999978, 0.30000000000000004, 
+	  1.3962634015954636 },
+  { 1.8826015946315438, -0.099999999999999978, 0.30000000000000004, 
+	  1.5707963267948966 },
+};
+const double toler084 = 2.5000000000000020e-13;
 
 // Test data for k=-0.099999999999999978, nu=0.40000000000000002.
-testcase_ellint_3<double> data085[] = {
-  { -0.0000000000000000, -0.099999999999999978, 0.40000000000000002,
-          0.0000000000000000 },
-  { 0.17384216369897937, -0.099999999999999978, 0.40000000000000002,
-          0.17453292519943295 },
-  { 0.34375018311376782, -0.099999999999999978, 0.40000000000000002,
-          0.34906585039886590 },
-  { 0.50672650758380455, -0.099999999999999978, 0.40000000000000002,
-          0.52359877559829882 },
-  { 0.66121264213337616, -0.099999999999999978, 0.40000000000000002,
-          0.69813170079773179 },
-  { 0.80706202005774441, -0.099999999999999978, 0.40000000000000002,
-          0.87266462599716477 },
-  { 0.94519376138245892, -0.099999999999999978, 0.40000000000000002,
-          1.0471975511965976 },
-  { 1.0771880300759584, -0.099999999999999978, 0.40000000000000002,
-          1.2217304763960306 },
-  { 1.2049711557188272, -0.099999999999999978, 0.40000000000000002,
-          1.3962634015954636 },
-  { 1.3306223265207477, -0.099999999999999978, 0.40000000000000002,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.099999999999999978, nu=0.40000000000000002.
-template <typename Tp>
-void test085()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data085)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data085[i].k), Tp(data085[i].nu),
-                   Tp(data085[i].phi));
-      const Tp f0 = data085[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.0338059536914377e-16
+// mean(f - f_Boost): 2.7755575615628914e-17
+// variance(f - f_Boost): 9.5107651574678308e-35
+// stddev(f - f_Boost): 9.7523151904908362e-18
+const testcase_ellint_3<double>
+data085[10] =
+{
+  { 0.0000000000000000, -0.099999999999999978, 0.40000000000000002, 
+	  0.0000000000000000 },
+  { 0.17525152094559704, -0.099999999999999978, 0.40000000000000002, 
+	  0.17453292519943295 },
+  { 0.35483343742825979, -0.099999999999999978, 0.40000000000000002, 
+	  0.34906585039886590 },
+  { 0.54314913099505446, -0.099999999999999978, 0.40000000000000002, 
+	  0.52359877559829882 },
+  { 0.74463962034766862, -0.099999999999999978, 0.40000000000000002, 
+	  0.69813170079773179 },
+  { 0.96349276837570441, -0.099999999999999978, 0.40000000000000002, 
+	  0.87266462599716477 },
+  { 1.2029081382746343, -0.099999999999999978, 0.40000000000000002, 
+	  1.0471975511965976 },
+  { 1.4638022887050806, -0.099999999999999978, 0.40000000000000002, 
+	  1.2217304763960306 },
+  { 1.7432413830105224, -0.099999999999999978, 0.40000000000000002, 
+	  1.3962634015954636 },
+  { 2.0336367403076760, -0.099999999999999978, 0.40000000000000002, 
+	  1.5707963267948966 },
+};
+const double toler085 = 2.5000000000000020e-13;
 
 // Test data for k=-0.099999999999999978, nu=0.50000000000000000.
-testcase_ellint_3<double> data086[] = {
-  { -0.0000000000000000, -0.099999999999999978, 0.50000000000000000,
-          0.0000000000000000 },
-  { 0.17366883711936554, -0.099999999999999978, 0.50000000000000000,
-          0.17453292519943295 },
-  { 0.34244940634881876, -0.099999999999999978, 0.50000000000000000,
-          0.34906585039886590 },
-  { 0.50274793281634378, -0.099999999999999978, 0.50000000000000000,
-          0.52359877559829882 },
-  { 0.65287941633275093, -0.099999999999999978, 0.50000000000000000,
-          0.69813170079773179 },
-  { 0.79291198790315398, -0.099999999999999978, 0.50000000000000000,
-          0.87266462599716477 },
-  { 0.92412201537880345, -0.099999999999999978, 0.50000000000000000,
-          1.0471975511965976 },
-  { 1.0484480076799370, -0.099999999999999978, 0.50000000000000000,
-          1.2217304763960306 },
-  { 1.1681168130475206, -0.099999999999999978, 0.50000000000000000,
-          1.3962634015954636 },
-  { 1.2854480708580160, -0.099999999999999978, 0.50000000000000000,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.099999999999999978, nu=0.50000000000000000.
-template <typename Tp>
-void test086()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data086)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data086[i].k), Tp(data086[i].nu),
-                   Tp(data086[i].phi));
-      const Tp f0 = data086[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.099999999999999978, nu=0.59999999999999998.
-testcase_ellint_3<double> data087[] = {
-  { -0.0000000000000000, -0.099999999999999978, 0.59999999999999998,
-          0.0000000000000000 },
-  { 0.17349612891469018, -0.099999999999999978, 0.59999999999999998,
-          0.17453292519943295 },
-  { 0.34116594505539438, -0.099999999999999978, 0.59999999999999998,
-          0.34906585039886590 },
-  { 0.49887649430466685, -0.099999999999999978, 0.59999999999999998,
-          0.52359877559829882 },
-  { 0.64489553282165157, -0.099999999999999978, 0.59999999999999998,
-          0.69813170079773179 },
-  { 0.77956016553782437, -0.099999999999999978, 0.59999999999999998,
-          0.87266462599716477 },
-  { 0.90451074530096309, -0.099999999999999978, 0.59999999999999998,
-          1.0471975511965976 },
-  { 1.0220113666961632, -0.099999999999999978, 0.59999999999999998,
-          1.2217304763960306 },
-  { 1.1345351441065563, -0.099999999999999978, 0.59999999999999998,
-          1.3962634015954636 },
-  { 1.2445798942989255, -0.099999999999999978, 0.59999999999999998,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.099999999999999978, nu=0.59999999999999998.
-template <typename Tp>
-void test087()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data087)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data087[i].k), Tp(data087[i].nu),
-                   Tp(data087[i].phi));
-      const Tp f0 = data087[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.099999999999999978, nu=0.69999999999999996.
-testcase_ellint_3<double> data088[] = {
-  { -0.0000000000000000, -0.099999999999999978, 0.69999999999999996,
-          0.0000000000000000 },
-  { 0.17332403516105052, -0.099999999999999978, 0.69999999999999996,
-          0.17453292519943295 },
-  { 0.33989939374896877, -0.099999999999999978, 0.69999999999999996,
-          0.34906585039886590 },
-  { 0.49510719568614081, -0.099999999999999978, 0.69999999999999996,
-          0.52359877559829882 },
-  { 0.63723607776354974, -0.099999999999999978, 0.69999999999999996,
-          0.69813170079773179 },
-  { 0.76693133887935327, -0.099999999999999978, 0.69999999999999996,
-          0.87266462599716477 },
-  { 0.88619382078823827, -0.099999999999999978, 0.69999999999999996,
-          1.0471975511965976 },
-  { 0.99758012018676490, -0.099999999999999978, 0.69999999999999996,
-          1.2217304763960306 },
-  { 1.1037642270814410, -0.099999999999999978, 0.69999999999999996,
-          1.3962634015954636 },
-  { 1.2073745911083187, -0.099999999999999978, 0.69999999999999996,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.099999999999999978, nu=0.69999999999999996.
-template <typename Tp>
-void test088()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data088)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data088[i].k), Tp(data088[i].nu),
-                   Tp(data088[i].phi));
-      const Tp f0 = data088[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.9864616042835278e-16
+// mean(f - f_Boost): 1.0547118733938987e-16
+// variance(f - f_Boost): 7.5633408838247182e-32
+// stddev(f - f_Boost): 2.7501528837184157e-16
+const testcase_ellint_3<double>
+data086[10] =
+{
+  { 0.0000000000000000, -0.099999999999999978, 0.50000000000000000, 
+	  0.0000000000000000 },
+  { 0.17543059564292182, -0.099999999999999978, 0.50000000000000000, 
+	  0.17453292519943295 },
+  { 0.35631088838721664, -0.099999999999999978, 0.50000000000000000, 
+	  0.34906585039886590 },
+  { 0.54839023346436444, -0.099999999999999978, 0.50000000000000000, 
+	  0.52359877559829882 },
+  { 0.75790846946088830, -0.099999999999999978, 0.50000000000000000, 
+	  0.69813170079773179 },
+  { 0.99146713686720678, -0.099999999999999978, 0.50000000000000000, 
+	  0.87266462599716477 },
+  { 1.2551692247937198, -0.099999999999999978, 0.50000000000000000, 
+	  1.0471975511965976 },
+  { 1.5524660788146873, -0.099999999999999978, 0.50000000000000000, 
+	  1.2217304763960306 },
+  { 1.8806578570830670, -0.099999999999999978, 0.50000000000000000, 
+	  1.3962634015954636 },
+  { 2.2279868912966849, -0.099999999999999978, 0.50000000000000000, 
+	  1.5707963267948966 },
+};
+const double toler086 = 2.5000000000000020e-13;
+
+// Test data for k=-0.099999999999999978, nu=0.60000000000000009.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 2.6726146516228014e-16
+// mean(f - f_Boost): -3.6082248300317589e-17
+// variance(f - f_Boost): 1.6073193116120635e-34
+// stddev(f - f_Boost): 1.2678009747638087e-17
+const testcase_ellint_3<double>
+data087[10] =
+{
+  { 0.0000000000000000, -0.099999999999999978, 0.60000000000000009, 
+	  0.0000000000000000 },
+  { 0.17561033003590576, -0.099999999999999978, 0.60000000000000009, 
+	  0.17453292519943295 },
+  { 0.35781061668171932, -0.099999999999999978, 0.60000000000000009, 
+	  0.34906585039886590 },
+  { 0.55381585659629196, -0.099999999999999978, 0.60000000000000009, 
+	  0.52359877559829882 },
+  { 0.77204910484575640, -0.099999999999999978, 0.60000000000000009, 
+	  0.69813170079773179 },
+  { 1.0224751740393108, -0.099999999999999978, 0.60000000000000009, 
+	  0.87266462599716477 },
+  { 1.3160230906351114, -0.099999999999999978, 0.60000000000000009, 
+	  1.0471975511965976 },
+  { 1.6616282844233206, -0.099999999999999978, 0.60000000000000009, 
+	  1.2217304763960306 },
+  { 2.0592555664850392, -0.099999999999999978, 0.60000000000000009, 
+	  1.3962634015954636 },
+  { 2.4913004919173822, -0.099999999999999978, 0.60000000000000009, 
+	  1.5707963267948966 },
+};
+const double toler087 = 2.5000000000000020e-13;
+
+// Test data for k=-0.099999999999999978, nu=0.70000000000000007.
+// max(|f - f_Boost|): 2.2204460492503131e-16 at index 5
+// max(|f - f_Boost| / |f_Boost|): 2.1004074871280821e-16
+// mean(f - f_Boost): 3.3306690738754695e-17
+// variance(f - f_Boost): 1.3695501826753678e-34
+// stddev(f - f_Boost): 1.1702778228589003e-17
+const testcase_ellint_3<double>
+data088[10] =
+{
+  { 0.0000000000000000, -0.099999999999999978, 0.70000000000000007, 
+	  0.0000000000000000 },
+  { 0.17579072847532518, -0.099999999999999978, 0.70000000000000007, 
+	  0.17453292519943295 },
+  { 0.35933322840606297, -0.099999999999999978, 0.70000000000000007, 
+	  0.34906585039886590 },
+  { 0.55943788649460324, -0.099999999999999978, 0.70000000000000007, 
+	  0.52359877559829882 },
+  { 0.78716856504031707, -0.099999999999999978, 0.70000000000000007, 
+	  0.69813170079773179 },
+  { 1.0571501305617423, -0.099999999999999978, 0.70000000000000007, 
+	  0.87266462599716477 },
+  { 1.3882948301743525, -0.099999999999999978, 0.70000000000000007, 
+	  1.0471975511965976 },
+  { 1.8011785680114223, -0.099999999999999978, 0.70000000000000007, 
+	  1.2217304763960306 },
+  { 2.3057268183616464, -0.099999999999999978, 0.70000000000000007, 
+	  1.3962634015954636 },
+  { 2.8771910188009739, -0.099999999999999978, 0.70000000000000007, 
+	  1.5707963267948966 },
+};
+const double toler088 = 2.5000000000000020e-13;
 
 // Test data for k=-0.099999999999999978, nu=0.80000000000000004.
-testcase_ellint_3<double> data089[] = {
-  { -0.0000000000000000, -0.099999999999999978, 0.80000000000000004,
-          0.0000000000000000 },
-  { 0.17315255197057020, -0.099999999999999978, 0.80000000000000004,
-          0.17453292519943295 },
-  { 0.33864936055747985, -0.099999999999999978, 0.80000000000000004,
-          0.34906585039886590 },
-  { 0.49143537041117619, -0.099999999999999978, 0.80000000000000004,
-          0.52359877559829882 },
-  { 0.62987861760047492, -0.099999999999999978, 0.80000000000000004,
-          0.69813170079773179 },
-  { 0.75496005490917517, -0.099999999999999978, 0.80000000000000004,
-          0.87266462599716477 },
-  { 0.86903081862701903, -0.099999999999999978, 0.80000000000000004,
-          1.0471975511965976 },
-  { 0.97490814820725591, -0.099999999999999978, 0.80000000000000004,
-          1.2217304763960306 },
-  { 1.0754290107171083, -0.099999999999999978, 0.80000000000000004,
-          1.3962634015954636 },
-  { 1.1733158866987732, -0.099999999999999978, 0.80000000000000004,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.099999999999999978, nu=0.80000000000000004.
-template <typename Tp>
-void test089()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data089)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data089[i].k), Tp(data089[i].nu),
-                   Tp(data089[i].phi));
-      const Tp f0 = data089[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 3.3133043868392355e-16
+// mean(f - f_Boost): 1.8041124150158794e-16
+// variance(f - f_Boost): 6.1843750436434569e-32
+// stddev(f - f_Boost): 2.4868403735751633e-16
+const testcase_ellint_3<double>
+data089[10] =
+{
+  { 0.0000000000000000, -0.099999999999999978, 0.80000000000000004, 
+	  0.0000000000000000 },
+  { 0.17597179535373417, -0.099999999999999978, 0.80000000000000004, 
+	  0.17453292519943295 },
+  { 0.36087935387831499, -0.099999999999999978, 0.80000000000000004, 
+	  0.34906585039886590 },
+  { 0.56526935244526444, -0.099999999999999978, 0.80000000000000004, 
+	  0.52359877559829882 },
+  { 0.80339402590612397, -0.099999999999999978, 0.80000000000000004, 
+	  0.69813170079773179 },
+  { 1.0963358646374459, -0.099999999999999978, 0.80000000000000004, 
+	  0.87266462599716477 },
+  { 1.4763748483246868, -0.099999999999999978, 0.80000000000000004, 
+	  1.0471975511965976 },
+  { 1.9896610222794102, -0.099999999999999978, 0.80000000000000004, 
+	  1.2217304763960306 },
+  { 2.6806423920122024, -0.099999999999999978, 0.80000000000000004, 
+	  1.3962634015954636 },
+  { 3.5246199613295612, -0.099999999999999978, 0.80000000000000004, 
+	  1.5707963267948966 },
+};
+const double toler089 = 2.5000000000000020e-13;
 
 // Test data for k=-0.099999999999999978, nu=0.90000000000000002.
-testcase_ellint_3<double> data090[] = {
-  { -0.0000000000000000, -0.099999999999999978, 0.90000000000000002,
-          0.0000000000000000 },
-  { 0.17298167549096569, -0.099999999999999978, 0.90000000000000002,
-          0.17453292519943295 },
-  { 0.33741546662741584, -0.099999999999999978, 0.90000000000000002,
-          0.34906585039886590 },
-  { 0.48785665376856879, -0.099999999999999978, 0.90000000000000002,
-          0.52359877559829882 },
-  { 0.62280288554518959, -0.099999999999999978, 0.90000000000000002,
-          0.69813170079773179 },
-  { 0.74358903115455199, -0.099999999999999978, 0.90000000000000002,
-          0.87266462599716477 },
-  { 0.85290207679298358, -0.099999999999999978, 0.90000000000000002,
-          1.0471975511965976 },
-  { 0.95379006645397379, -0.099999999999999978, 0.90000000000000002,
-          1.2217304763960306 },
-  { 1.0492213119872327, -0.099999999999999978, 0.90000000000000002,
-          1.3962634015954636 },
-  { 1.1419839485283374, -0.099999999999999978, 0.90000000000000002,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.099999999999999978, nu=0.90000000000000002.
-template <typename Tp>
-void test090()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data090)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data090[i].k), Tp(data090[i].nu),
-                   Tp(data090[i].phi));
-      const Tp f0 = data090[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.5624826890976725e-16
+// mean(f - f_Boost): 2.3314683517128288e-16
+// variance(f - f_Boost): 2.9401198977189756e-31
+// stddev(f - f_Boost): 5.4222872459129045e-16
+const testcase_ellint_3<double>
+data090[10] =
+{
+  { 0.0000000000000000, -0.099999999999999978, 0.90000000000000002, 
+	  0.0000000000000000 },
+  { 0.17615353510599349, -0.099999999999999978, 0.90000000000000002, 
+	  0.17453292519943295 },
+  { 0.36244964892922371, -0.099999999999999978, 0.90000000000000002, 
+	  0.34906585039886590 },
+  { 0.57132457590110530, -0.099999999999999978, 0.90000000000000002, 
+	  0.52359877559829882 },
+  { 0.82087808820385000, -0.099999999999999978, 0.90000000000000002, 
+	  0.69813170079773179 },
+  { 1.1411894342144451, -0.099999999999999978, 0.90000000000000002, 
+	  0.87266462599716477 },
+  { 1.5875929286844597, -0.099999999999999978, 0.90000000000000002, 
+	  1.0471975511965976 },
+  { 2.2678622986596659, -0.099999999999999978, 0.90000000000000002, 
+	  1.2217304763960306 },
+  { 3.3697528941897903, -0.099999999999999978, 0.90000000000000002, 
+	  1.3962634015954636 },
+  { 4.9862890417305499, -0.099999999999999978, 0.90000000000000002, 
+	  1.5707963267948966 },
+};
+const double toler090 = 2.5000000000000020e-13;
 
 // Test data for k=0.0000000000000000, nu=0.0000000000000000.
-testcase_ellint_3<double> data091[] = {
-  { -0.0000000000000000, 0.0000000000000000, 0.0000000000000000,
-          0.0000000000000000 },
-  { 0.17453292519943295, 0.0000000000000000, 0.0000000000000000,
-          0.17453292519943295 },
-  { 0.34906585039886584, 0.0000000000000000, 0.0000000000000000,
-          0.34906585039886590 },
-  { 0.52359877559829882, 0.0000000000000000, 0.0000000000000000,
-          0.52359877559829882 },
-  { 0.69813170079773179, 0.0000000000000000, 0.0000000000000000,
-          0.69813170079773179 },
-  { 0.87266462599716477, 0.0000000000000000, 0.0000000000000000,
-          0.87266462599716477 },
-  { 1.0471975511965976, 0.0000000000000000, 0.0000000000000000,
-          1.0471975511965976 },
-  { 1.2217304763960304, 0.0000000000000000, 0.0000000000000000,
-          1.2217304763960306 },
-  { 1.3962634015954631, 0.0000000000000000, 0.0000000000000000,
-          1.3962634015954636 },
-  { 1.5707963267948966, 0.0000000000000000, 0.0000000000000000,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.0000000000000000, nu=0.0000000000000000.
-template <typename Tp>
-void test091()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data091)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data091[i].k), Tp(data091[i].nu),
-                   Tp(data091[i].phi));
-      const Tp f0 = data091[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 2.2204460492503131e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 2.1203697876423447e-16
+// mean(f - f_Boost): -1.9428902930940238e-17
+// variance(f - f_Boost): 4.6602749271592373e-35
+// stddev(f - f_Boost): 6.8266206333435850e-18
+const testcase_ellint_3<double>
+data091[10] =
+{
+  { 0.0000000000000000, 0.0000000000000000, 0.0000000000000000, 
+	  0.0000000000000000 },
+  { 0.17453292519943295, 0.0000000000000000, 0.0000000000000000, 
+	  0.17453292519943295 },
+  { 0.34906585039886590, 0.0000000000000000, 0.0000000000000000, 
+	  0.34906585039886590 },
+  { 0.52359877559829882, 0.0000000000000000, 0.0000000000000000, 
+	  0.52359877559829882 },
+  { 0.69813170079773179, 0.0000000000000000, 0.0000000000000000, 
+	  0.69813170079773179 },
+  { 0.87266462599716477, 0.0000000000000000, 0.0000000000000000, 
+	  0.87266462599716477 },
+  { 1.0471975511965976, 0.0000000000000000, 0.0000000000000000, 
+	  1.0471975511965976 },
+  { 1.2217304763960306, 0.0000000000000000, 0.0000000000000000, 
+	  1.2217304763960306 },
+  { 1.3962634015954636, 0.0000000000000000, 0.0000000000000000, 
+	  1.3962634015954636 },
+  { 1.5707963267948966, 0.0000000000000000, 0.0000000000000000, 
+	  1.5707963267948966 },
+};
+const double toler091 = 2.5000000000000020e-13;
 
 // Test data for k=0.0000000000000000, nu=0.10000000000000001.
-testcase_ellint_3<double> data092[] = {
-  { -0.0000000000000000, 0.0000000000000000, 0.10000000000000001,
-          0.0000000000000000 },
-  { 0.17435710107516608, 0.0000000000000000, 0.10000000000000001,
-          0.17453292519943295 },
-  { 0.34769194715329604, 0.0000000000000000, 0.10000000000000001,
-          0.34906585039886590 },
-  { 0.51913731575866118, 0.0000000000000000, 0.10000000000000001,
-          0.52359877559829882 },
-  { 0.68810051897078461, 0.0000000000000000, 0.10000000000000001,
-          0.69813170079773179 },
-  { 0.85432615661706823, 0.0000000000000000, 0.10000000000000001,
-          0.87266462599716477 },
-  { 1.0179006647340796, 0.0000000000000000, 0.10000000000000001,
-          1.0471975511965976 },
-  { 1.1792120640746322, 0.0000000000000000, 0.10000000000000001,
-          1.2217304763960306 },
-  { 1.3388834245070498, 0.0000000000000000, 0.10000000000000001,
-          1.3962634015954636 },
-  { 1.4976955329233277, 0.0000000000000000, 0.10000000000000001,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.0000000000000000, nu=0.10000000000000001.
-template <typename Tp>
-void test092()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data092)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data092[i].k), Tp(data092[i].nu),
-                   Tp(data092[i].phi));
-      const Tp f0 = data092[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 2.2204460492503131e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 2.1019052604815601e-16
+// mean(f - f_Boost): 2.7755575615628915e-18
+// variance(f - f_Boost): 9.5107651574678312e-37
+// stddev(f - f_Boost): 9.7523151904908366e-19
+const testcase_ellint_3<double>
+data092[10] =
+{
+  { 0.0000000000000000, 0.0000000000000000, 0.10000000000000001, 
+	  0.0000000000000000 },
+  { 0.17470938780535167, 0.0000000000000000, 0.10000000000000001, 
+	  0.17453292519943295 },
+  { 0.35045931581655582, 0.0000000000000000, 0.10000000000000001, 
+	  0.34906585039886590 },
+  { 0.52819841383849875, 0.0000000000000000, 0.10000000000000001, 
+	  0.52359877559829882 },
+  { 0.70868910807992958, 0.0000000000000000, 0.10000000000000001, 
+	  0.69813170079773179 },
+  { 0.89241311307249638, 0.0000000000000000, 0.10000000000000001, 
+	  0.87266462599716477 },
+  { 1.0794871444666669, 0.0000000000000000, 0.10000000000000001, 
+	  1.0471975511965976 },
+  { 1.2696086247356864, 0.0000000000000000, 0.10000000000000001, 
+	  1.2217304763960306 },
+  { 1.4620562617494721, 0.0000000000000000, 0.10000000000000001, 
+	  1.3962634015954636 },
+  { 1.6557647109660167, 0.0000000000000000, 0.10000000000000001, 
+	  1.5707963267948966 },
+};
+const double toler092 = 2.5000000000000020e-13;
 
 // Test data for k=0.0000000000000000, nu=0.20000000000000001.
-testcase_ellint_3<double> data093[] = {
-  { -0.0000000000000000, 0.0000000000000000, 0.20000000000000001,
-          0.0000000000000000 },
-  { 0.17418191132226077, 0.0000000000000000, 0.20000000000000001,
-          0.17453292519943295 },
-  { 0.34633712256943405, 0.0000000000000000, 0.20000000000000001,
-          0.34906585039886590 },
-  { 0.51480684302043711, 0.0000000000000000, 0.20000000000000001,
-          0.52359877559829882 },
-  { 0.67855102942481949, 0.0000000000000000, 0.20000000000000001,
-          0.69813170079773179 },
-  { 0.83723056090326253, 0.0000000000000000, 0.20000000000000001,
-          0.87266462599716477 },
-  { 0.99114645269578183, 0.0000000000000000, 0.20000000000000001,
-          1.0471975511965976 },
-  { 1.1411014627915537, 0.0000000000000000, 0.20000000000000001,
-          1.2217304763960306 },
-  { 1.2882448138013969, 0.0000000000000000, 0.20000000000000001,
-          1.3962634015954636 },
-  { 1.4339343023863691, 0.0000000000000000, 0.20000000000000001,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.0000000000000000, nu=0.20000000000000001.
-template <typename Tp>
-void test093()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data093)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data093[i].k), Tp(data093[i].nu),
-                   Tp(data093[i].phi));
-      const Tp f0 = data093[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.0000000000000000, nu=0.29999999999999999.
-testcase_ellint_3<double> data094[] = {
-  { -0.0000000000000000, 0.0000000000000000, 0.29999999999999999,
-          0.0000000000000000 },
-  { 0.17400735186871727, 0.0000000000000000, 0.29999999999999999,
-          0.17453292519943295 },
-  { 0.34500091027020219, 0.0000000000000000, 0.29999999999999999,
-          0.34906585039886590 },
-  { 0.51060069523901541, 0.0000000000000000, 0.29999999999999999,
-          0.52359877559829882 },
-  { 0.66944393961375459, 0.0000000000000000, 0.29999999999999999,
-          0.69813170079773179 },
-  { 0.82123776744538157, 0.0000000000000000, 0.29999999999999999,
-          0.87266462599716477 },
-  { 0.96657579245516523, 0.0000000000000000, 0.29999999999999999,
-          1.0471975511965976 },
-  { 1.1066703663542414, 0.0000000000000000, 0.29999999999999999,
-          1.2217304763960306 },
-  { 1.2431094251944901, 0.0000000000000000, 0.29999999999999999,
-          1.3962634015954636 },
-  { 1.3776795151134889, 0.0000000000000000, 0.29999999999999999,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.0000000000000000, nu=0.29999999999999999.
-template <typename Tp>
-void test094()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data094)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data094[i].k), Tp(data094[i].nu),
-                   Tp(data094[i].phi));
-      const Tp f0 = data094[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 2.2204460492503131e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 2.0831888697465320e-16
+// mean(f - f_Boost): -1.9428902930940238e-17
+// variance(f - f_Boost): 4.6602749271592373e-35
+// stddev(f - f_Boost): 6.8266206333435850e-18
+const testcase_ellint_3<double>
+data093[10] =
+{
+  { 0.0000000000000000, 0.0000000000000000, 0.20000000000000001, 
+	  0.0000000000000000 },
+  { 0.17488649304197776, 0.0000000000000000, 0.20000000000000001, 
+	  0.17453292519943295 },
+  { 0.35187284488675424, 0.0000000000000000, 0.20000000000000001, 
+	  0.34906585039886590 },
+  { 0.53294400750146131, 0.0000000000000000, 0.20000000000000001, 
+	  0.52359877559829882 },
+  { 0.71982347021822823, 0.0000000000000000, 0.20000000000000001, 
+	  0.69813170079773179 },
+  { 0.91377311030258745, 0.0000000000000000, 0.20000000000000001, 
+	  0.87266462599716477 },
+  { 1.1153429007215137, 0.0000000000000000, 0.20000000000000001, 
+	  1.0471975511965976 },
+  { 1.3241202847784086, 0.0000000000000000, 0.20000000000000001, 
+	  1.2217304763960306 },
+  { 1.5385854914338242, 0.0000000000000000, 0.20000000000000001, 
+	  1.3962634015954636 },
+  { 1.7562036827601815, 0.0000000000000000, 0.20000000000000001, 
+	  1.5707963267948966 },
+};
+const double toler093 = 2.5000000000000020e-13;
+
+// Test data for k=0.0000000000000000, nu=0.30000000000000004.
+// max(|f - f_Boost|): 2.2204460492503131e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 2.0642101770923591e-16
+// mean(f - f_Boost): -1.9428902930940238e-17
+// variance(f - f_Boost): 4.6602749271592373e-35
+// stddev(f - f_Boost): 6.8266206333435850e-18
+const testcase_ellint_3<double>
+data094[10] =
+{
+  { 0.0000000000000000, 0.0000000000000000, 0.30000000000000004, 
+	  0.0000000000000000 },
+  { 0.17506424509761404, 0.0000000000000000, 0.30000000000000004, 
+	  0.17453292519943295 },
+  { 0.35330695794774630, 0.0000000000000000, 0.30000000000000004, 
+	  0.34906585039886590 },
+  { 0.53784398359522367, 0.0000000000000000, 0.30000000000000004, 
+	  0.52359877559829882 },
+  { 0.73159289408687844, 0.0000000000000000, 0.30000000000000004, 
+	  0.69813170079773179 },
+  { 0.93699031797084975, 0.0000000000000000, 0.30000000000000004, 
+	  0.87266462599716477 },
+  { 1.1555098909390267, 0.0000000000000000, 0.30000000000000004, 
+	  1.0471975511965976 },
+  { 1.3870184960144325, 0.0000000000000000, 0.30000000000000004, 
+	  1.2217304763960306 },
+  { 1.6291980835772994, 0.0000000000000000, 0.30000000000000004, 
+	  1.3962634015954636 },
+  { 1.8774607092226381, 0.0000000000000000, 0.30000000000000004, 
+	  1.5707963267948966 },
+};
+const double toler094 = 2.5000000000000020e-13;
 
 // Test data for k=0.0000000000000000, nu=0.40000000000000002.
-testcase_ellint_3<double> data095[] = {
-  { -0.0000000000000000, 0.0000000000000000, 0.40000000000000002,
-          0.0000000000000000 },
-  { 0.17383341868035865, 0.0000000000000000, 0.40000000000000002,
-          0.17453292519943295 },
-  { 0.34368286022299821, 0.0000000000000000, 0.40000000000000002,
-          0.34906585039886590 },
-  { 0.50651268947499406, 0.0000000000000000, 0.40000000000000002,
-          0.52359877559829882 },
-  { 0.66074441806097550, 0.0000000000000000, 0.40000000000000002,
-          0.69813170079773179 },
-  { 0.80622931670113485, 0.0000000000000000, 0.40000000000000002,
-          0.87266462599716477 },
-  { 0.94389791565435233, 0.0000000000000000, 0.40000000000000002,
-          1.0471975511965976 },
-  { 1.0753503387899728, 0.0000000000000000, 0.40000000000000002,
-          1.2217304763960306 },
-  { 1.2025374759127518, 0.0000000000000000, 0.40000000000000002,
-          1.3962634015954636 },
-  { 1.3275651989026322, 0.0000000000000000, 0.40000000000000002,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.0000000000000000, nu=0.40000000000000002.
-template <typename Tp>
-void test095()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data095)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data095[i].k), Tp(data095[i].nu),
-                   Tp(data095[i].phi));
-      const Tp f0 = data095[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 2.2204460492503131e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 2.0449580089795878e-16
+// mean(f - f_Boost): -1.9428902930940238e-17
+// variance(f - f_Boost): 4.6602749271592373e-35
+// stddev(f - f_Boost): 6.8266206333435850e-18
+const testcase_ellint_3<double>
+data095[10] =
+{
+  { 0.0000000000000000, 0.0000000000000000, 0.40000000000000002, 
+	  0.0000000000000000 },
+  { 0.17524264820030025, 0.0000000000000000, 0.40000000000000002, 
+	  0.17453292519943295 },
+  { 0.35476219513871499, 0.0000000000000000, 0.40000000000000002, 
+	  0.34906585039886590 },
+  { 0.54290749235440094, 0.0000000000000000, 0.40000000000000002, 
+	  0.52359877559829882 },
+  { 0.74406433757109913, 0.0000000000000000, 0.40000000000000002, 
+	  0.69813170079773179 },
+  { 0.96236826162553313, 0.0000000000000000, 0.40000000000000002, 
+	  0.87266462599716477 },
+  { 1.2009785880262487, 0.0000000000000000, 0.40000000000000002, 
+	  1.0471975511965976 },
+  { 1.4608000106167567, 0.0000000000000000, 0.40000000000000002, 
+	  1.2217304763960306 },
+  { 1.7389349574753439, 0.0000000000000000, 0.40000000000000002, 
+	  1.3962634015954636 },
+  { 2.0278893379868057, 0.0000000000000000, 0.40000000000000002, 
+	  1.5707963267948966 },
+};
+const double toler095 = 2.5000000000000020e-13;
 
 // Test data for k=0.0000000000000000, nu=0.50000000000000000.
-testcase_ellint_3<double> data096[] = {
-  { -0.0000000000000000, 0.0000000000000000, 0.50000000000000000,
-          0.0000000000000000 },
-  { 0.17366010776037047, 0.0000000000000000, 0.50000000000000000,
-          0.17453292519943295 },
-  { 0.34238253799539309, 0.0000000000000000, 0.50000000000000000,
-          0.34906585039886590 },
-  { 0.50253707775976408, 0.0000000000000000, 0.50000000000000000,
-          0.52359877559829882 },
-  { 0.65242145347295766, 0.0000000000000000, 0.50000000000000000,
-          0.69813170079773179 },
-  { 0.79210420018698058, 0.0000000000000000, 0.50000000000000000,
-          0.87266462599716477 },
-  { 0.92287437995632193, 0.0000000000000000, 0.50000000000000000,
-          1.0471975511965976 },
-  { 1.0466900550798661, 0.0000000000000000, 0.50000000000000000,
-          1.2217304763960306 },
-  { 1.1658007366618623, 0.0000000000000000, 0.50000000000000000,
-          1.3962634015954636 },
-  { 1.2825498301618641, 0.0000000000000000, 0.50000000000000000,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.0000000000000000, nu=0.50000000000000000.
-template <typename Tp>
-void test096()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data096)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data096[i].k), Tp(data096[i].nu),
-                   Tp(data096[i].phi));
-      const Tp f0 = data096[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.0000000000000000, nu=0.59999999999999998.
-testcase_ellint_3<double> data097[] = {
-  { -0.0000000000000000, 0.0000000000000000, 0.59999999999999998,
-          0.0000000000000000 },
-  { 0.17348741514884702, 0.0000000000000000, 0.59999999999999998,
-          0.17453292519943295 },
-  { 0.34109952405241289, 0.0000000000000000, 0.59999999999999998,
-          0.34906585039886590 },
-  { 0.49866850781226296, 0.0000000000000000, 0.59999999999999998,
-          0.52359877559829882 },
-  { 0.64444732407062510, 0.0000000000000000, 0.59999999999999998,
-          0.69813170079773179 },
-  { 0.77877564686544720, 0.0000000000000000, 0.59999999999999998,
-          0.87266462599716477 },
-  { 0.90330743691883497, 0.0000000000000000, 0.59999999999999998,
-          1.0471975511965976 },
-  { 1.0203257987604104, 0.0000000000000000, 0.59999999999999998,
-          1.2217304763960306 },
-  { 1.1323247918768631, 0.0000000000000000, 0.59999999999999998,
-          1.3962634015954636 },
-  { 1.2418235332245127, 0.0000000000000000, 0.59999999999999998,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.0000000000000000, nu=0.59999999999999998.
-template <typename Tp>
-void test097()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data097)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data097[i].k), Tp(data097[i].nu),
-                   Tp(data097[i].phi));
-      const Tp f0 = data097[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.0000000000000000, nu=0.69999999999999996.
-testcase_ellint_3<double> data098[] = {
-  { -0.0000000000000000, 0.0000000000000000, 0.69999999999999996,
-          0.0000000000000000 },
-  { 0.17331533692234477, 0.0000000000000000, 0.69999999999999996,
-          0.17453292519943295 },
-  { 0.33983341309265941, 0.0000000000000000, 0.69999999999999996,
-          0.34906585039886590 },
-  { 0.49490198805931990, 0.0000000000000000, 0.69999999999999996,
-          0.52359877559829882 },
-  { 0.63679715525145308, 0.0000000000000000, 0.69999999999999996,
-          0.69813170079773179 },
-  { 0.76616861049481944, 0.0000000000000000, 0.69999999999999996,
-          0.87266462599716477 },
-  { 0.88503143209004220, 0.0000000000000000, 0.69999999999999996,
-          1.0471975511965976 },
-  { 0.99596060249112173, 0.0000000000000000, 0.69999999999999996,
-          1.2217304763960306 },
-  { 1.1016495050260424, 0.0000000000000000, 0.69999999999999996,
-          1.3962634015954636 },
-  { 1.2047457872617382, 0.0000000000000000, 0.69999999999999996,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.0000000000000000, nu=0.69999999999999996.
-template <typename Tp>
-void test098()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data098)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data098[i].k), Tp(data098[i].nu),
-                   Tp(data098[i].phi));
-      const Tp f0 = data098[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 2.2204460492503131e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 2.0254203825026289e-16
+// mean(f - f_Boost): -1.9428902930940238e-17
+// variance(f - f_Boost): 4.6602749271592373e-35
+// stddev(f - f_Boost): 6.8266206333435850e-18
+const testcase_ellint_3<double>
+data096[10] =
+{
+  { 0.0000000000000000, 0.0000000000000000, 0.50000000000000000, 
+	  0.0000000000000000 },
+  { 0.17542170661831016, 0.0000000000000000, 0.50000000000000000, 
+	  0.17453292519943295 },
+  { 0.35623911740195419, 0.0000000000000000, 0.50000000000000000, 
+	  0.34906585039886590 },
+  { 0.54814449099863127, 0.0000000000000000, 0.50000000000000000, 
+	  0.52359877559829882 },
+  { 0.75731546607718081, 0.0000000000000000, 0.50000000000000000, 
+	  0.69813170079773179 },
+  { 0.99028751188233310, 0.0000000000000000, 0.50000000000000000, 
+	  0.87266462599716477 },
+  { 1.2531022857760581, 0.0000000000000000, 0.50000000000000000, 
+	  1.0471975511965976 },
+  { 1.5491761777615785, 0.0000000000000000, 0.50000000000000000, 
+	  1.2217304763960306 },
+  { 1.8758359693666533, 0.0000000000000000, 0.50000000000000000, 
+	  1.3962634015954636 },
+  { 2.2214414690791831, 0.0000000000000000, 0.50000000000000000, 
+	  1.5707963267948966 },
+};
+const double toler096 = 2.5000000000000020e-13;
+
+// Test data for k=0.0000000000000000, nu=0.60000000000000009.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 2.1742785192400269e-16
+// mean(f - f_Boost): 1.3877787807814457e-17
+// variance(f - f_Boost): 2.3776912893669577e-35
+// stddev(f - f_Boost): 4.8761575952454181e-18
+const testcase_ellint_3<double>
+data097[10] =
+{
+  { 0.0000000000000000, 0.0000000000000000, 0.60000000000000009, 
+	  0.0000000000000000 },
+  { 0.17560142466065651, 0.0000000000000000, 0.60000000000000009, 
+	  0.17453292519943295 },
+  { 0.35773830754879005, 0.0000000000000000, 0.60000000000000009, 
+	  0.34906585039886590 },
+  { 0.55356583986445973, 0.0000000000000000, 0.60000000000000009, 
+	  0.52359877559829882 },
+  { 0.77143701715151514, 0.0000000000000000, 0.60000000000000009, 
+	  0.69813170079773179 },
+  { 1.0212334940541210, 0.0000000000000000, 0.60000000000000009, 
+	  0.87266462599716477 },
+  { 1.3137928444460387, 0.0000000000000000, 0.60000000000000009, 
+	  1.0471975511965976 },
+  { 1.6579755004159076, 0.0000000000000000, 0.60000000000000009, 
+	  1.2217304763960306 },
+  { 2.0537461418295506, 0.0000000000000000, 0.60000000000000009, 
+	  1.3962634015954636 },
+  { 2.4836470664490253, 0.0000000000000000, 0.60000000000000009, 
+	  1.5707963267948966 },
+};
+const double toler097 = 2.5000000000000020e-13;
+
+// Test data for k=0.0000000000000000, nu=0.70000000000000007.
+// max(|f - f_Boost|): 2.2204460492503131e-16 at index 4
+// max(|f - f_Boost| / |f_Boost|): 3.0903019454022601e-16
+// mean(f - f_Boost): -6.9388939039072284e-17
+// variance(f - f_Boost): 5.9442282234173945e-34
+// stddev(f - f_Boost): 2.4380787976227090e-17
+const testcase_ellint_3<double>
+data098[10] =
+{
+  { 0.0000000000000000, 0.0000000000000000, 0.70000000000000007, 
+	  0.0000000000000000 },
+  { 0.17578180667760368, 0.0000000000000000, 0.70000000000000007, 
+	  0.17453292519943295 },
+  { 0.35926037139410999, 0.0000000000000000, 0.70000000000000007, 
+	  0.34906585039886590 },
+  { 0.55918341315855080, 0.0000000000000000, 0.70000000000000007, 
+	  0.52359877559829882 },
+  { 0.78653584856932546, 0.0000000000000000, 0.70000000000000007, 
+	  0.69813170079773179 },
+  { 1.0558379029273324, 0.0000000000000000, 0.70000000000000007, 
+	  0.87266462599716477 },
+  { 1.3858662544850615, 0.0000000000000000, 0.70000000000000007, 
+	  1.0471975511965976 },
+  { 1.7970491170359040, 0.0000000000000000, 0.70000000000000007, 
+	  1.2217304763960306 },
+  { 2.2992404490153917, 0.0000000000000000, 0.70000000000000007, 
+	  1.3962634015954636 },
+  { 2.8678686047727382, 0.0000000000000000, 0.70000000000000007, 
+	  1.5707963267948966 },
+};
+const double toler098 = 2.5000000000000020e-13;
 
 // Test data for k=0.0000000000000000, nu=0.80000000000000004.
-testcase_ellint_3<double> data099[] = {
-  { -0.0000000000000000, 0.0000000000000000, 0.80000000000000004,
-          0.0000000000000000 },
-  { 0.17314386919344213, 0.0000000000000000, 0.80000000000000004,
-          0.17453292519943295 },
-  { 0.33858381342073240, 0.0000000000000000, 0.80000000000000004,
-          0.34906585039886590 },
-  { 0.49123285640844738, 0.0000000000000000, 0.80000000000000004,
-          0.52359877559829882 },
-  { 0.62944854858904520, 0.0000000000000000, 0.80000000000000004,
-          0.69813170079773179 },
-  { 0.75421778305499343, 0.0000000000000000, 0.80000000000000004,
-          0.87266462599716477 },
-  { 0.86790634112156639, 0.0000000000000000, 0.80000000000000004,
-          1.0471975511965976 },
-  { 0.97334918087427558, 0.0000000000000000, 0.80000000000000004,
-          1.2217304763960306 },
-  { 1.0734012615283985, 0.0000000000000000, 0.80000000000000004,
-          1.3962634015954636 },
-  { 1.1708024551734544, 0.0000000000000000, 0.80000000000000004,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.0000000000000000, nu=0.80000000000000004.
-template <typename Tp>
-void test099()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data099)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data099[i].k), Tp(data099[i].nu),
-                   Tp(data099[i].phi));
-      const Tp f0 = data099[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 2.2373744057922657e-16
+// mean(f - f_Boost): 1.0269562977782698e-16
+// variance(f - f_Boost): 1.4388836606733082e-32
+// stddev(f - f_Boost): 1.1995347684303728e-16
+const testcase_ellint_3<double>
+data099[10] =
+{
+  { 0.0000000000000000, 0.0000000000000000, 0.80000000000000004, 
+	  0.0000000000000000 },
+  { 0.17596285706118869, 0.0000000000000000, 0.80000000000000004, 
+	  0.17453292519943295 },
+  { 0.36080593896484231, 0.0000000000000000, 0.80000000000000004, 
+	  0.34906585039886590 },
+  { 0.56501022706967863, 0.0000000000000000, 0.80000000000000004, 
+	  0.52359877559829882 },
+  { 0.80273891984116930, 0.0000000000000000, 0.80000000000000004, 
+	  0.69813170079773179 },
+  { 1.0949425007763358, 0.0000000000000000, 0.80000000000000004, 
+	  0.87266462599716477 },
+  { 1.4736985692253419, 0.0000000000000000, 0.80000000000000004, 
+	  1.0471975511965976 },
+  { 1.9848676587180696, 0.0000000000000000, 0.80000000000000004, 
+	  1.2217304763960306 },
+  { 2.6726187823193546, 0.0000000000000000, 0.80000000000000004, 
+	  1.3962634015954636 },
+  { 3.5124073655203634, 0.0000000000000000, 0.80000000000000004, 
+	  1.5707963267948966 },
+};
+const double toler099 = 2.5000000000000020e-13;
 
 // Test data for k=0.0000000000000000, nu=0.90000000000000002.
-testcase_ellint_3<double> data100[] = {
-  { -0.0000000000000000, 0.0000000000000000, 0.90000000000000002,
-          0.0000000000000000 },
-  { 0.17297300811030600, 0.0000000000000000, 0.90000000000000002,
-          0.17453292519943295 },
-  { 0.33735034635360817, 0.0000000000000000, 0.90000000000000002,
-          0.34906585039886590 },
-  { 0.48765675230233141, 0.0000000000000000, 0.90000000000000002,
-          0.52359877559829882 },
-  { 0.62238126886123568, 0.0000000000000000, 0.90000000000000002,
-          0.69813170079773179 },
-  { 0.74286600807269243, 0.0000000000000000, 0.90000000000000002,
-          0.87266462599716477 },
-  { 0.85181283909264971, 0.0000000000000000, 0.90000000000000002,
-          1.0471975511965976 },
-  { 0.95228683995371122, 0.0000000000000000, 0.90000000000000002,
-          1.2217304763960306 },
-  { 1.0472730487412552, 0.0000000000000000, 0.90000000000000002,
-          1.3962634015954636 },
-  { 1.1395754288497419, 0.0000000000000000, 0.90000000000000002,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.0000000000000000, nu=0.90000000000000002.
-template <typename Tp>
-void test100()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data100)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data100[i].k), Tp(data100[i].nu),
-                   Tp(data100[i].phi));
-      const Tp f0 = data100[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 2.2204460492503131e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 6.6108624815885066e-16
+// mean(f - f_Boost): 2.1371793224034264e-16
+// variance(f - f_Boost): 5.6389326618626776e-33
+// stddev(f - f_Boost): 7.5092826966779442e-17
+const testcase_ellint_3<double>
+data100[10] =
+{
+  { 0.0000000000000000, 0.0000000000000000, 0.90000000000000002, 
+	  0.0000000000000000 },
+  { 0.17614458024574997, 0.0000000000000000, 0.90000000000000002, 
+	  0.17453292519943295 },
+  { 0.36237566578821978, 0.0000000000000000, 0.90000000000000002, 
+	  0.34906585039886590 },
+  { 0.57106058859196640, 0.0000000000000000, 0.90000000000000002, 
+	  0.52359877559829882 },
+  { 0.82019857015755915, 0.0000000000000000, 0.90000000000000002, 
+	  0.69813170079773179 },
+  { 1.1397014388908147, 0.0000000000000000, 0.90000000000000002, 
+	  0.87266462599716477 },
+  { 1.5845952415154960, 0.0000000000000000, 0.90000000000000002, 
+	  1.0471975511965976 },
+  { 2.2620531413370775, 0.0000000000000000, 0.90000000000000002, 
+	  1.2217304763960306 },
+  { 3.3587842061975066, 0.0000000000000000, 0.90000000000000002, 
+	  1.3962634015954636 },
+  { 4.9672941328980507, 0.0000000000000000, 0.90000000000000002, 
+	  1.5707963267948966 },
+};
+const double toler100 = 2.5000000000000020e-13;
 
 // Test data for k=0.10000000000000009, nu=0.0000000000000000.
-testcase_ellint_3<double> data101[] = {
-  { -0.0000000000000000, 0.10000000000000009, 0.0000000000000000,
-          0.0000000000000000 },
-  { 0.17454173353063665, 0.10000000000000009, 0.0000000000000000,
-          0.17453292519943295 },
-  { 0.34913506721468085, 0.10000000000000009, 0.0000000000000000,
-          0.34906585039886590 },
-  { 0.52382550016538953, 0.10000000000000009, 0.0000000000000000,
-          0.52359877559829882 },
-  { 0.69864700854177031, 0.10000000000000009, 0.0000000000000000,
-          0.69813170079773179 },
-  { 0.87361792586964870, 0.10000000000000009, 0.0000000000000000,
-          0.87266462599716477 },
-  { 1.0487386319621685, 0.10000000000000009, 0.0000000000000000,
-          1.0471975511965976 },
-  { 1.2239913752078757, 0.10000000000000009, 0.0000000000000000,
-          1.2217304763960306 },
-  { 1.3993423113684049, 0.10000000000000009, 0.0000000000000000,
-          1.3962634015954636 },
-  { 1.5747455615173562, 0.10000000000000009, 0.0000000000000000,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.10000000000000009, nu=0.0000000000000000.
-template <typename Tp>
-void test101()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data101)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data101[i].k), Tp(data101[i].nu),
-                   Tp(data101[i].phi));
-      const Tp f0 = data101[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 3.1735566504509645e-16
+// mean(f - f_Boost): -5.8286708792820721e-17
+// variance(f - f_Boost): 4.1942474344433133e-34
+// stddev(f - f_Boost): 2.0479861900030756e-17
+const testcase_ellint_3<double>
+data101[10] =
+{
+  { 0.0000000000000000, 0.10000000000000009, 0.0000000000000000, 
+	  0.0000000000000000 },
+  { 0.17454173353063662, 0.10000000000000009, 0.0000000000000000, 
+	  0.17453292519943295 },
+  { 0.34913506721468096, 0.10000000000000009, 0.0000000000000000, 
+	  0.34906585039886590 },
+  { 0.52382550016538953, 0.10000000000000009, 0.0000000000000000, 
+	  0.52359877559829882 },
+  { 0.69864700854177020, 0.10000000000000009, 0.0000000000000000, 
+	  0.69813170079773179 },
+  { 0.87361792586964859, 0.10000000000000009, 0.0000000000000000, 
+	  0.87266462599716477 },
+  { 1.0487386319621685, 0.10000000000000009, 0.0000000000000000, 
+	  1.0471975511965976 },
+  { 1.2239913752078759, 0.10000000000000009, 0.0000000000000000, 
+	  1.2217304763960306 },
+  { 1.3993423113684051, 0.10000000000000009, 0.0000000000000000, 
+	  1.3962634015954636 },
+  { 1.5747455615173560, 0.10000000000000009, 0.0000000000000000, 
+	  1.5707963267948966 },
+};
+const double toler101 = 2.5000000000000020e-13;
 
 // Test data for k=0.10000000000000009, nu=0.10000000000000001.
-testcase_ellint_3<double> data102[] = {
-  { -0.0000000000000000, 0.10000000000000009, 0.10000000000000001,
-          0.0000000000000000 },
-  { 0.17436589347616618, 0.10000000000000009, 0.10000000000000001,
-          0.17453292519943295 },
-  { 0.34776067871237354, 0.10000000000000009, 0.10000000000000001,
-          0.34906585039886590 },
-  { 0.51936064354727807, 0.10000000000000009, 0.10000000000000001,
-          0.52359877559829882 },
-  { 0.68860303749364360, 0.10000000000000009, 0.10000000000000001,
-          0.69813170079773179 },
-  { 0.85524561882332051, 0.10000000000000009, 0.10000000000000001,
-          0.87266462599716477 },
-  { 1.0193708301908337, 0.10000000000000009, 0.10000000000000001,
-          1.0471975511965976 },
-  { 1.1813474067123044, 0.10000000000000009, 0.10000000000000001,
-          1.2217304763960306 },
-  { 1.3417670770424983, 0.10000000000000009, 0.10000000000000001,
-          1.3962634015954636 },
-  { 1.5013711111199950, 0.10000000000000009, 0.10000000000000001,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.10000000000000009, nu=0.10000000000000001.
-template <typename Tp>
-void test102()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data102)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data102[i].k), Tp(data102[i].nu),
-                   Tp(data102[i].phi));
-      const Tp f0 = data102[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 3.0305747373482148e-16
+// mean(f - f_Boost): -3.0531133177191807e-17
+// variance(f - f_Boost): 1.1508025840536076e-34
+// stddev(f - f_Boost): 1.0727546709539920e-17
+const testcase_ellint_3<double>
+data102[10] =
+{
+  { 0.0000000000000000, 0.10000000000000009, 0.10000000000000001, 
+	  0.0000000000000000 },
+  { 0.17471821213559732, 0.10000000000000009, 0.10000000000000001, 
+	  0.17453292519943295 },
+  { 0.35052902610011138, 0.10000000000000009, 0.10000000000000001, 
+	  0.34906585039886590 },
+  { 0.52842865990255727, 0.10000000000000009, 0.10000000000000001, 
+	  0.52359877559829882 },
+  { 0.70921799731166713, 0.10000000000000009, 0.10000000000000001, 
+	  0.69813170079773179 },
+  { 0.89340330535868662, 0.10000000000000009, 0.10000000000000001, 
+	  0.87266462599716477 },
+  { 1.0811075784236857, 0.10000000000000009, 0.10000000000000001, 
+	  1.0471975511965976 },
+  { 1.2720133232666426, 0.10000000000000009, 0.10000000000000001, 
+	  1.2217304763960306 },
+  { 1.4653630031861395, 0.10000000000000009, 0.10000000000000001, 
+	  1.3962634015954636 },
+  { 1.6600374067558428, 0.10000000000000009, 0.10000000000000001, 
+	  1.5707963267948966 },
+};
+const double toler102 = 2.5000000000000020e-13;
 
 // Test data for k=0.10000000000000009, nu=0.20000000000000001.
-testcase_ellint_3<double> data103[] = {
-  { -0.0000000000000000, 0.10000000000000009, 0.20000000000000001,
-          0.0000000000000000 },
-  { 0.17419068786141345, 0.10000000000000009, 0.20000000000000001,
-          0.17453292519943295 },
-  { 0.34640537686230127, 0.10000000000000009, 0.20000000000000001,
-          0.34906585039886590 },
-  { 0.51502689171753957, 0.10000000000000009, 0.20000000000000001,
-          0.52359877559829882 },
-  { 0.67904147863672726, 0.10000000000000009, 0.20000000000000001,
-          0.69813170079773179 },
-  { 0.83811885126105179, 0.10000000000000009, 0.20000000000000001,
-          0.87266462599716477 },
-  { 0.99255278555742810, 0.10000000000000009, 0.20000000000000001,
-          1.0471975511965976 },
-  { 1.1431260546194930, 0.10000000000000009, 0.20000000000000001,
-          1.2217304763960306 },
-  { 1.2909589656532101, 0.10000000000000009, 0.20000000000000001,
-          1.3962634015954636 },
-  { 1.4373749386463430, 0.10000000000000009, 0.20000000000000001,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.10000000000000009, nu=0.20000000000000001.
-template <typename Tp>
-void test103()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data103)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data103[i].k), Tp(data103[i].nu),
-                   Tp(data103[i].phi));
-      const Tp f0 = data103[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.10000000000000009, nu=0.29999999999999999.
-testcase_ellint_3<double> data104[] = {
-  { -0.0000000000000000, 0.10000000000000009, 0.29999999999999999,
-          0.0000000000000000 },
-  { 0.17401611261390110, 0.10000000000000009, 0.29999999999999999,
-          0.17453292519943295 },
-  { 0.34506869507511767, 0.10000000000000009, 0.29999999999999999,
-          0.34906585039886590 },
-  { 0.51081757604259870, 0.10000000000000009, 0.29999999999999999,
-          0.52359877559829882 },
-  { 0.66992297597712303, 0.10000000000000009, 0.29999999999999999,
-          0.69813170079773179 },
-  { 0.82209722856174228, 0.10000000000000009, 0.29999999999999999,
-          0.87266462599716477 },
-  { 0.96792430487669612, 0.10000000000000009, 0.29999999999999999,
-          1.0471975511965976 },
-  { 1.1085964108954092, 0.10000000000000009, 0.29999999999999999,
-          1.2217304763960306 },
-  { 1.2456748370836999, 0.10000000000000009, 0.29999999999999999,
-          1.3962634015954636 },
-  { 1.3809159606704959, 0.10000000000000009, 0.29999999999999999,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.10000000000000009, nu=0.29999999999999999.
-template <typename Tp>
-void test104()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data104)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data104[i].k), Tp(data104[i].nu),
-                   Tp(data104[i].phi));
-      const Tp f0 = data104[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 2.2204460492503131e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 1.6736714959992433e-16
+// mean(f - f_Boost): 5.5511151231257830e-18
+// variance(f - f_Boost): 3.8043060629871325e-36
+// stddev(f - f_Boost): 1.9504630380981673e-18
+const testcase_ellint_3<double>
+data103[10] =
+{
+  { 0.0000000000000000, 0.10000000000000009, 0.20000000000000001, 
+	  0.0000000000000000 },
+  { 0.17489533344059083, 0.10000000000000009, 0.20000000000000001, 
+	  0.17453292519943295 },
+  { 0.35194305707815038, 0.10000000000000009, 0.20000000000000001, 
+	  0.34906585039886590 },
+  { 0.53317790741512527, 0.10000000000000009, 0.20000000000000001, 
+	  0.52359877559829882 },
+  { 0.72036681615081222, 0.10000000000000009, 0.20000000000000001, 
+	  0.69813170079773179 },
+  { 0.91480372268244303, 0.10000000000000009, 0.20000000000000001, 
+	  0.87266462599716477 },
+  { 1.1170528708071514, 0.10000000000000009, 0.20000000000000001, 
+	  1.0471975511965976 },
+  { 1.3266916802718358, 0.10000000000000009, 0.20000000000000001, 
+	  1.2217304763960306 },
+  { 1.5421622241831547, 0.10000000000000009, 0.20000000000000001, 
+	  1.3962634015954636 },
+  { 1.7608656115083421, 0.10000000000000009, 0.20000000000000001, 
+	  1.5707963267948966 },
+};
+const double toler103 = 2.5000000000000020e-13;
+
+// Test data for k=0.10000000000000009, nu=0.30000000000000004.
+// max(|f - f_Boost|): 2.2204460492503131e-16 at index 6
+// max(|f - f_Boost| / |f_Boost|): 1.9186071760326645e-16
+// mean(f - f_Boost): -1.6653345369377347e-17
+// variance(f - f_Boost): 3.4238754566884194e-35
+// stddev(f - f_Boost): 5.8513891142945016e-18
+const testcase_ellint_3<double>
+data104[10] =
+{
+  { 0.0000000000000000, 0.10000000000000009, 0.30000000000000004, 
+	  0.0000000000000000 },
+  { 0.17507310163441189, 0.10000000000000009, 0.30000000000000004, 
+	  0.17453292519943295 },
+  { 0.35337768072524217, 0.10000000000000009, 0.30000000000000004, 
+	  0.34906585039886590 },
+  { 0.53808167801629170, 0.10000000000000009, 0.30000000000000004, 
+	  0.52359877559829882 },
+  { 0.73215166755955019, 0.10000000000000009, 0.30000000000000004, 
+	  0.69813170079773179 },
+  { 0.93806546000201219, 0.10000000000000009, 0.30000000000000004, 
+	  0.87266462599716477 },
+  { 1.1573218723395986, 0.10000000000000009, 0.30000000000000004, 
+	  1.0471975511965976 },
+  { 1.3897859679542097, 0.10000000000000009, 0.30000000000000004, 
+	  1.2217304763960306 },
+  { 1.6331009404328622, 0.10000000000000009, 0.30000000000000004, 
+	  1.3962634015954636 },
+  { 1.8826015946315438, 0.10000000000000009, 0.30000000000000004, 
+	  1.5707963267948966 },
+};
+const double toler104 = 2.5000000000000020e-13;
 
 // Test data for k=0.10000000000000009, nu=0.40000000000000002.
-testcase_ellint_3<double> data105[] = {
-  { -0.0000000000000000, 0.10000000000000009, 0.40000000000000002,
-          0.0000000000000000 },
-  { 0.17384216369897937, 0.10000000000000009, 0.40000000000000002,
-          0.17453292519943295 },
-  { 0.34375018311376782, 0.10000000000000009, 0.40000000000000002,
-          0.34906585039886590 },
-  { 0.50672650758380455, 0.10000000000000009, 0.40000000000000002,
-          0.52359877559829882 },
-  { 0.66121264213337616, 0.10000000000000009, 0.40000000000000002,
-          0.69813170079773179 },
-  { 0.80706202005774441, 0.10000000000000009, 0.40000000000000002,
-          0.87266462599716477 },
-  { 0.94519376138245892, 0.10000000000000009, 0.40000000000000002,
-          1.0471975511965976 },
-  { 1.0771880300759584, 0.10000000000000009, 0.40000000000000002,
-          1.2217304763960306 },
-  { 1.2049711557188272, 0.10000000000000009, 0.40000000000000002,
-          1.3962634015954636 },
-  { 1.3306223265207477, 0.10000000000000009, 0.40000000000000002,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.10000000000000009, nu=0.40000000000000002.
-template <typename Tp>
-void test105()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data105)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data105[i].k), Tp(data105[i].nu),
-                   Tp(data105[i].phi));
-      const Tp f0 = data105[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.0338059536914377e-16
+// mean(f - f_Boost): 2.7755575615628914e-17
+// variance(f - f_Boost): 9.5107651574678308e-35
+// stddev(f - f_Boost): 9.7523151904908362e-18
+const testcase_ellint_3<double>
+data105[10] =
+{
+  { 0.0000000000000000, 0.10000000000000009, 0.40000000000000002, 
+	  0.0000000000000000 },
+  { 0.17525152094559704, 0.10000000000000009, 0.40000000000000002, 
+	  0.17453292519943295 },
+  { 0.35483343742825979, 0.10000000000000009, 0.40000000000000002, 
+	  0.34906585039886590 },
+  { 0.54314913099505446, 0.10000000000000009, 0.40000000000000002, 
+	  0.52359877559829882 },
+  { 0.74463962034766862, 0.10000000000000009, 0.40000000000000002, 
+	  0.69813170079773179 },
+  { 0.96349276837570441, 0.10000000000000009, 0.40000000000000002, 
+	  0.87266462599716477 },
+  { 1.2029081382746343, 0.10000000000000009, 0.40000000000000002, 
+	  1.0471975511965976 },
+  { 1.4638022887050806, 0.10000000000000009, 0.40000000000000002, 
+	  1.2217304763960306 },
+  { 1.7432413830105224, 0.10000000000000009, 0.40000000000000002, 
+	  1.3962634015954636 },
+  { 2.0336367403076760, 0.10000000000000009, 0.40000000000000002, 
+	  1.5707963267948966 },
+};
+const double toler105 = 2.5000000000000020e-13;
 
 // Test data for k=0.10000000000000009, nu=0.50000000000000000.
-testcase_ellint_3<double> data106[] = {
-  { -0.0000000000000000, 0.10000000000000009, 0.50000000000000000,
-          0.0000000000000000 },
-  { 0.17366883711936554, 0.10000000000000009, 0.50000000000000000,
-          0.17453292519943295 },
-  { 0.34244940634881876, 0.10000000000000009, 0.50000000000000000,
-          0.34906585039886590 },
-  { 0.50274793281634378, 0.10000000000000009, 0.50000000000000000,
-          0.52359877559829882 },
-  { 0.65287941633275093, 0.10000000000000009, 0.50000000000000000,
-          0.69813170079773179 },
-  { 0.79291198790315398, 0.10000000000000009, 0.50000000000000000,
-          0.87266462599716477 },
-  { 0.92412201537880345, 0.10000000000000009, 0.50000000000000000,
-          1.0471975511965976 },
-  { 1.0484480076799370, 0.10000000000000009, 0.50000000000000000,
-          1.2217304763960306 },
-  { 1.1681168130475206, 0.10000000000000009, 0.50000000000000000,
-          1.3962634015954636 },
-  { 1.2854480708580160, 0.10000000000000009, 0.50000000000000000,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.10000000000000009, nu=0.50000000000000000.
-template <typename Tp>
-void test106()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data106)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data106[i].k), Tp(data106[i].nu),
-                   Tp(data106[i].phi));
-      const Tp f0 = data106[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.10000000000000009, nu=0.59999999999999998.
-testcase_ellint_3<double> data107[] = {
-  { -0.0000000000000000, 0.10000000000000009, 0.59999999999999998,
-          0.0000000000000000 },
-  { 0.17349612891469018, 0.10000000000000009, 0.59999999999999998,
-          0.17453292519943295 },
-  { 0.34116594505539438, 0.10000000000000009, 0.59999999999999998,
-          0.34906585039886590 },
-  { 0.49887649430466685, 0.10000000000000009, 0.59999999999999998,
-          0.52359877559829882 },
-  { 0.64489553282165157, 0.10000000000000009, 0.59999999999999998,
-          0.69813170079773179 },
-  { 0.77956016553782437, 0.10000000000000009, 0.59999999999999998,
-          0.87266462599716477 },
-  { 0.90451074530096309, 0.10000000000000009, 0.59999999999999998,
-          1.0471975511965976 },
-  { 1.0220113666961632, 0.10000000000000009, 0.59999999999999998,
-          1.2217304763960306 },
-  { 1.1345351441065563, 0.10000000000000009, 0.59999999999999998,
-          1.3962634015954636 },
-  { 1.2445798942989255, 0.10000000000000009, 0.59999999999999998,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.10000000000000009, nu=0.59999999999999998.
-template <typename Tp>
-void test107()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data107)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data107[i].k), Tp(data107[i].nu),
-                   Tp(data107[i].phi));
-      const Tp f0 = data107[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.10000000000000009, nu=0.69999999999999996.
-testcase_ellint_3<double> data108[] = {
-  { -0.0000000000000000, 0.10000000000000009, 0.69999999999999996,
-          0.0000000000000000 },
-  { 0.17332403516105052, 0.10000000000000009, 0.69999999999999996,
-          0.17453292519943295 },
-  { 0.33989939374896877, 0.10000000000000009, 0.69999999999999996,
-          0.34906585039886590 },
-  { 0.49510719568614081, 0.10000000000000009, 0.69999999999999996,
-          0.52359877559829882 },
-  { 0.63723607776354974, 0.10000000000000009, 0.69999999999999996,
-          0.69813170079773179 },
-  { 0.76693133887935327, 0.10000000000000009, 0.69999999999999996,
-          0.87266462599716477 },
-  { 0.88619382078823827, 0.10000000000000009, 0.69999999999999996,
-          1.0471975511965976 },
-  { 0.99758012018676490, 0.10000000000000009, 0.69999999999999996,
-          1.2217304763960306 },
-  { 1.1037642270814410, 0.10000000000000009, 0.69999999999999996,
-          1.3962634015954636 },
-  { 1.2073745911083187, 0.10000000000000009, 0.69999999999999996,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.10000000000000009, nu=0.69999999999999996.
-template <typename Tp>
-void test108()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data108)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data108[i].k), Tp(data108[i].nu),
-                   Tp(data108[i].phi));
-      const Tp f0 = data108[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.9864616042835278e-16
+// mean(f - f_Boost): 9.4368957093138303e-17
+// variance(f - f_Boost): 7.7794254682023874e-32
+// stddev(f - f_Boost): 2.7891621444803792e-16
+const testcase_ellint_3<double>
+data106[10] =
+{
+  { 0.0000000000000000, 0.10000000000000009, 0.50000000000000000, 
+	  0.0000000000000000 },
+  { 0.17543059564292182, 0.10000000000000009, 0.50000000000000000, 
+	  0.17453292519943295 },
+  { 0.35631088838721664, 0.10000000000000009, 0.50000000000000000, 
+	  0.34906585039886590 },
+  { 0.54839023346436455, 0.10000000000000009, 0.50000000000000000, 
+	  0.52359877559829882 },
+  { 0.75790846946088830, 0.10000000000000009, 0.50000000000000000, 
+	  0.69813170079773179 },
+  { 0.99146713686720678, 0.10000000000000009, 0.50000000000000000, 
+	  0.87266462599716477 },
+  { 1.2551692247937198, 0.10000000000000009, 0.50000000000000000, 
+	  1.0471975511965976 },
+  { 1.5524660788146873, 0.10000000000000009, 0.50000000000000000, 
+	  1.2217304763960306 },
+  { 1.8806578570830670, 0.10000000000000009, 0.50000000000000000, 
+	  1.3962634015954636 },
+  { 2.2279868912966849, 0.10000000000000009, 0.50000000000000000, 
+	  1.5707963267948966 },
+};
+const double toler106 = 2.5000000000000020e-13;
+
+// Test data for k=0.10000000000000009, nu=0.60000000000000009.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 2.6726146516228014e-16
+// mean(f - f_Boost): -3.6082248300317589e-17
+// variance(f - f_Boost): 1.6073193116120635e-34
+// stddev(f - f_Boost): 1.2678009747638087e-17
+const testcase_ellint_3<double>
+data107[10] =
+{
+  { 0.0000000000000000, 0.10000000000000009, 0.60000000000000009, 
+	  0.0000000000000000 },
+  { 0.17561033003590576, 0.10000000000000009, 0.60000000000000009, 
+	  0.17453292519943295 },
+  { 0.35781061668171932, 0.10000000000000009, 0.60000000000000009, 
+	  0.34906585039886590 },
+  { 0.55381585659629196, 0.10000000000000009, 0.60000000000000009, 
+	  0.52359877559829882 },
+  { 0.77204910484575640, 0.10000000000000009, 0.60000000000000009, 
+	  0.69813170079773179 },
+  { 1.0224751740393108, 0.10000000000000009, 0.60000000000000009, 
+	  0.87266462599716477 },
+  { 1.3160230906351114, 0.10000000000000009, 0.60000000000000009, 
+	  1.0471975511965976 },
+  { 1.6616282844233206, 0.10000000000000009, 0.60000000000000009, 
+	  1.2217304763960306 },
+  { 2.0592555664850392, 0.10000000000000009, 0.60000000000000009, 
+	  1.3962634015954636 },
+  { 2.4913004919173822, 0.10000000000000009, 0.60000000000000009, 
+	  1.5707963267948966 },
+};
+const double toler107 = 2.5000000000000020e-13;
+
+// Test data for k=0.10000000000000009, nu=0.70000000000000007.
+// max(|f - f_Boost|): 2.2204460492503131e-16 at index 5
+// max(|f - f_Boost| / |f_Boost|): 2.1004074871280821e-16
+// mean(f - f_Boost): 3.3306690738754695e-17
+// variance(f - f_Boost): 1.3695501826753678e-34
+// stddev(f - f_Boost): 1.1702778228589003e-17
+const testcase_ellint_3<double>
+data108[10] =
+{
+  { 0.0000000000000000, 0.10000000000000009, 0.70000000000000007, 
+	  0.0000000000000000 },
+  { 0.17579072847532518, 0.10000000000000009, 0.70000000000000007, 
+	  0.17453292519943295 },
+  { 0.35933322840606297, 0.10000000000000009, 0.70000000000000007, 
+	  0.34906585039886590 },
+  { 0.55943788649460324, 0.10000000000000009, 0.70000000000000007, 
+	  0.52359877559829882 },
+  { 0.78716856504031707, 0.10000000000000009, 0.70000000000000007, 
+	  0.69813170079773179 },
+  { 1.0571501305617423, 0.10000000000000009, 0.70000000000000007, 
+	  0.87266462599716477 },
+  { 1.3882948301743525, 0.10000000000000009, 0.70000000000000007, 
+	  1.0471975511965976 },
+  { 1.8011785680114223, 0.10000000000000009, 0.70000000000000007, 
+	  1.2217304763960306 },
+  { 2.3057268183616464, 0.10000000000000009, 0.70000000000000007, 
+	  1.3962634015954636 },
+  { 2.8771910188009739, 0.10000000000000009, 0.70000000000000007, 
+	  1.5707963267948966 },
+};
+const double toler108 = 2.5000000000000020e-13;
 
 // Test data for k=0.10000000000000009, nu=0.80000000000000004.
-testcase_ellint_3<double> data109[] = {
-  { -0.0000000000000000, 0.10000000000000009, 0.80000000000000004,
-          0.0000000000000000 },
-  { 0.17315255197057020, 0.10000000000000009, 0.80000000000000004,
-          0.17453292519943295 },
-  { 0.33864936055747985, 0.10000000000000009, 0.80000000000000004,
-          0.34906585039886590 },
-  { 0.49143537041117619, 0.10000000000000009, 0.80000000000000004,
-          0.52359877559829882 },
-  { 0.62987861760047492, 0.10000000000000009, 0.80000000000000004,
-          0.69813170079773179 },
-  { 0.75496005490917517, 0.10000000000000009, 0.80000000000000004,
-          0.87266462599716477 },
-  { 0.86903081862701903, 0.10000000000000009, 0.80000000000000004,
-          1.0471975511965976 },
-  { 0.97490814820725591, 0.10000000000000009, 0.80000000000000004,
-          1.2217304763960306 },
-  { 1.0754290107171083, 0.10000000000000009, 0.80000000000000004,
-          1.3962634015954636 },
-  { 1.1733158866987732, 0.10000000000000009, 0.80000000000000004,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.10000000000000009, nu=0.80000000000000004.
-template <typename Tp>
-void test109()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data109)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data109[i].k), Tp(data109[i].nu),
-                   Tp(data109[i].phi));
-      const Tp f0 = data109[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 3.3133043868392355e-16
+// mean(f - f_Boost): 1.8041124150158794e-16
+// variance(f - f_Boost): 6.1843750436434569e-32
+// stddev(f - f_Boost): 2.4868403735751633e-16
+const testcase_ellint_3<double>
+data109[10] =
+{
+  { 0.0000000000000000, 0.10000000000000009, 0.80000000000000004, 
+	  0.0000000000000000 },
+  { 0.17597179535373417, 0.10000000000000009, 0.80000000000000004, 
+	  0.17453292519943295 },
+  { 0.36087935387831499, 0.10000000000000009, 0.80000000000000004, 
+	  0.34906585039886590 },
+  { 0.56526935244526444, 0.10000000000000009, 0.80000000000000004, 
+	  0.52359877559829882 },
+  { 0.80339402590612397, 0.10000000000000009, 0.80000000000000004, 
+	  0.69813170079773179 },
+  { 1.0963358646374459, 0.10000000000000009, 0.80000000000000004, 
+	  0.87266462599716477 },
+  { 1.4763748483246868, 0.10000000000000009, 0.80000000000000004, 
+	  1.0471975511965976 },
+  { 1.9896610222794102, 0.10000000000000009, 0.80000000000000004, 
+	  1.2217304763960306 },
+  { 2.6806423920122024, 0.10000000000000009, 0.80000000000000004, 
+	  1.3962634015954636 },
+  { 3.5246199613295612, 0.10000000000000009, 0.80000000000000004, 
+	  1.5707963267948966 },
+};
+const double toler109 = 2.5000000000000020e-13;
 
 // Test data for k=0.10000000000000009, nu=0.90000000000000002.
-testcase_ellint_3<double> data110[] = {
-  { -0.0000000000000000, 0.10000000000000009, 0.90000000000000002,
-          0.0000000000000000 },
-  { 0.17298167549096569, 0.10000000000000009, 0.90000000000000002,
-          0.17453292519943295 },
-  { 0.33741546662741584, 0.10000000000000009, 0.90000000000000002,
-          0.34906585039886590 },
-  { 0.48785665376856879, 0.10000000000000009, 0.90000000000000002,
-          0.52359877559829882 },
-  { 0.62280288554518959, 0.10000000000000009, 0.90000000000000002,
-          0.69813170079773179 },
-  { 0.74358903115455199, 0.10000000000000009, 0.90000000000000002,
-          0.87266462599716477 },
-  { 0.85290207679298358, 0.10000000000000009, 0.90000000000000002,
-          1.0471975511965976 },
-  { 0.95379006645397379, 0.10000000000000009, 0.90000000000000002,
-          1.2217304763960306 },
-  { 1.0492213119872327, 0.10000000000000009, 0.90000000000000002,
-          1.3962634015954636 },
-  { 1.1419839485283374, 0.10000000000000009, 0.90000000000000002,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.10000000000000009, nu=0.90000000000000002.
-template <typename Tp>
-void test110()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data110)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data110[i].k), Tp(data110[i].nu),
-                   Tp(data110[i].phi));
-      const Tp f0 = data110[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.19999999999999996, nu=0.0000000000000000.
-testcase_ellint_3<double> data111[] = {
-  { -0.0000000000000000, 0.19999999999999996, 0.0000000000000000,
-          0.0000000000000000 },
-  { 0.17456817290292811, 0.19999999999999996, 0.0000000000000000,
-          0.17453292519943295 },
-  { 0.34934315932086801, 0.19999999999999996, 0.0000000000000000,
-          0.34906585039886590 },
-  { 0.52450880529443988, 0.19999999999999996, 0.0000000000000000,
-          0.52359877559829882 },
-  { 0.70020491009844910, 0.19999999999999996, 0.0000000000000000,
-          0.69813170079773179 },
-  { 0.87651006649967955, 0.19999999999999996, 0.0000000000000000,
-          0.87266462599716477 },
-  { 1.0534305870298994, 0.19999999999999996, 0.0000000000000000,
-          1.0471975511965976 },
-  { 1.2308975521670784, 0.19999999999999996, 0.0000000000000000,
-          1.2217304763960306 },
-  { 1.4087733584990738, 0.19999999999999996, 0.0000000000000000,
-          1.3962634015954636 },
-  { 1.5868678474541664, 0.19999999999999996, 0.0000000000000000,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.19999999999999996, nu=0.0000000000000000.
-template <typename Tp>
-void test111()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data111)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data111[i].k), Tp(data111[i].nu),
-                   Tp(data111[i].phi));
-      const Tp f0 = data111[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.19999999999999996, nu=0.10000000000000001.
-testcase_ellint_3<double> data112[] = {
-  { -0.0000000000000000, 0.19999999999999996, 0.10000000000000001,
-          0.0000000000000000 },
-  { 0.17439228502691750, 0.19999999999999996, 0.10000000000000001,
-          0.17453292519943295 },
-  { 0.34796731137565740, 0.19999999999999996, 0.10000000000000001,
-          0.34906585039886590 },
-  { 0.52003370294544848, 0.19999999999999996, 0.10000000000000001,
-          0.52359877559829882 },
-  { 0.69012222258631495, 0.19999999999999996, 0.10000000000000001,
-          0.69813170079773179 },
-  { 0.85803491465566772, 0.19999999999999996, 0.10000000000000001,
-          0.87266462599716477 },
-  { 1.0238463961099364, 0.19999999999999996, 0.10000000000000001,
-          1.0471975511965976 },
-  { 1.1878691059202153, 0.19999999999999996, 0.10000000000000001,
-          1.2217304763960306 },
-  { 1.3505985031831940, 0.19999999999999996, 0.10000000000000001,
-          1.3962634015954636 },
-  { 1.5126513474261092, 0.19999999999999996, 0.10000000000000001,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.19999999999999996, nu=0.10000000000000001.
-template <typename Tp>
-void test112()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data112)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data112[i].k), Tp(data112[i].nu),
-                   Tp(data112[i].phi));
-      const Tp f0 = data112[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.19999999999999996, nu=0.20000000000000001.
-testcase_ellint_3<double> data113[] = {
-  { -0.0000000000000000, 0.19999999999999996, 0.20000000000000001,
-          0.0000000000000000 },
-  { 0.17421703179583750, 0.19999999999999996, 0.20000000000000001,
-          0.17453292519943295 },
-  { 0.34661057411998791, 0.19999999999999996, 0.20000000000000001,
-          0.34906585039886590 },
-  { 0.51569006052647393, 0.19999999999999996, 0.20000000000000001,
-          0.52359877559829882 },
-  { 0.68052412821107278, 0.19999999999999996, 0.20000000000000001,
-          0.69813170079773179 },
-  { 0.84081341263313825, 0.19999999999999996, 0.20000000000000001,
-          0.87266462599716477 },
-  { 0.99683359988842890, 0.19999999999999996, 0.20000000000000001,
-          1.0471975511965976 },
-  { 1.1493086715118852, 0.19999999999999996, 0.20000000000000001,
-          1.2217304763960306 },
-  { 1.2992699693957541, 0.19999999999999996, 0.20000000000000001,
-          1.3962634015954636 },
-  { 1.4479323932249568, 0.19999999999999996, 0.20000000000000001,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.19999999999999996, nu=0.20000000000000001.
-template <typename Tp>
-void test113()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data113)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data113[i].k), Tp(data113[i].nu),
-                   Tp(data113[i].phi));
-      const Tp f0 = data113[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.19999999999999996, nu=0.29999999999999999.
-testcase_ellint_3<double> data114[] = {
-  { -0.0000000000000000, 0.19999999999999996, 0.29999999999999999,
-          0.0000000000000000 },
-  { 0.17404240913577707, 0.19999999999999996, 0.29999999999999999,
-          0.17453292519943295 },
-  { 0.34527248032587193, 0.19999999999999996, 0.29999999999999999,
-          0.34906585039886590 },
-  { 0.51147118981668416, 0.19999999999999996, 0.29999999999999999,
-          0.52359877559829882 },
-  { 0.67137107867777635, 0.19999999999999996, 0.29999999999999999,
-          0.69813170079773179 },
-  { 0.82470418188668893, 0.19999999999999996, 0.29999999999999999,
-          0.87266462599716477 },
-  { 0.97202873223594299, 0.19999999999999996, 0.29999999999999999,
-          1.0471975511965976 },
-  { 1.1144773569375266, 0.19999999999999996, 0.29999999999999999,
-          1.2217304763960306 },
-  { 1.2535292433701000, 0.19999999999999996, 0.29999999999999999,
-          1.3962634015954636 },
-  { 1.3908453514752481, 0.19999999999999996, 0.29999999999999999,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.19999999999999996, nu=0.29999999999999999.
-template <typename Tp>
-void test114()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data114)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data114[i].k), Tp(data114[i].nu),
-                   Tp(data114[i].phi));
-      const Tp f0 = data114[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.19999999999999996, nu=0.40000000000000002.
-testcase_ellint_3<double> data115[] = {
-  { -0.0000000000000000, 0.19999999999999996, 0.40000000000000002,
-          0.0000000000000000 },
-  { 0.17386841301066677, 0.19999999999999996, 0.40000000000000002,
-          0.17453292519943295 },
-  { 0.34395257914113253, 0.19999999999999996, 0.40000000000000002,
-          0.34906585039886590 },
-  { 0.50737088376869466, 0.19999999999999996, 0.40000000000000002,
-          0.52359877559829882 },
-  { 0.66262801717277664, 0.19999999999999996, 0.40000000000000002,
-          0.69813170079773179 },
-  { 0.80958766645079094, 0.19999999999999996, 0.40000000000000002,
-          0.87266462599716477 },
-  { 0.94913754236162040, 0.19999999999999996, 0.40000000000000002,
-          1.0471975511965976 },
-  { 1.0827985514223000, 0.19999999999999996, 0.40000000000000002,
-          1.2217304763960306 },
-  { 1.2124212429050478, 0.19999999999999996, 0.40000000000000002,
-          1.3962634015954636 },
-  { 1.3400002519661010, 0.19999999999999996, 0.40000000000000002,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.19999999999999996, nu=0.40000000000000002.
-template <typename Tp>
-void test115()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data115)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data115[i].k), Tp(data115[i].nu),
-                   Tp(data115[i].phi));
-      const Tp f0 = data115[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.19999999999999996, nu=0.50000000000000000.
-testcase_ellint_3<double> data116[] = {
-  { -0.0000000000000000, 0.19999999999999996, 0.50000000000000000,
-          0.0000000000000000 },
-  { 0.17369503942181802, 0.19999999999999996, 0.50000000000000000,
-          0.17453292519943295 },
-  { 0.34265043534362660, 0.19999999999999996, 0.50000000000000000,
-          0.34906585039886590 },
-  { 0.50338337208655415, 0.19999999999999996, 0.50000000000000000,
-          0.52359877559829882 },
-  { 0.65426373297163642, 0.19999999999999996, 0.50000000000000000,
-          0.69813170079773179 },
-  { 0.79536193036145808, 0.19999999999999996, 0.50000000000000000,
-          0.87266462599716477 },
-  { 0.92791875910061605, 0.19999999999999996, 0.50000000000000000,
-          1.0471975511965976 },
-  { 1.0538145052725829, 0.19999999999999996, 0.50000000000000000,
-          1.2217304763960306 },
-  { 1.1752060022875899, 0.19999999999999996, 0.50000000000000000,
-          1.3962634015954636 },
-  { 1.2943374404397376, 0.19999999999999996, 0.50000000000000000,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.19999999999999996, nu=0.50000000000000000.
-template <typename Tp>
-void test116()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data116)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data116[i].k), Tp(data116[i].nu),
-                   Tp(data116[i].phi));
-      const Tp f0 = data116[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.19999999999999996, nu=0.59999999999999998.
-testcase_ellint_3<double> data117[] = {
-  { -0.0000000000000000, 0.19999999999999996, 0.59999999999999998,
-          0.0000000000000000 },
-  { 0.17352228440746928, 0.19999999999999996, 0.59999999999999998,
-          0.17453292519943295 },
-  { 0.34136562863713626, 0.19999999999999996, 0.59999999999999998,
-          0.34906585039886590 },
-  { 0.49950328177638481, 0.19999999999999996, 0.59999999999999998,
-          0.52359877559829882 },
-  { 0.64625032705690832, 0.19999999999999996, 0.59999999999999998,
-          0.69813170079773179 },
-  { 0.78193941198403094, 0.19999999999999996, 0.59999999999999998,
-          0.87266462599716477 },
-  { 0.90817230934317128, 0.19999999999999996, 0.59999999999999998,
-          1.0471975511965976 },
-  { 1.0271563751276462, 0.19999999999999996, 0.59999999999999998,
-          1.2217304763960306 },
-  { 1.1412999379040518, 0.19999999999999996, 0.59999999999999998,
-          1.3962634015954636 },
-  { 1.2530330675914561, 0.19999999999999996, 0.59999999999999998,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.19999999999999996, nu=0.59999999999999998.
-template <typename Tp>
-void test117()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data117)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data117[i].k), Tp(data117[i].nu),
-                   Tp(data117[i].phi));
-      const Tp f0 = data117[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.19999999999999996, nu=0.69999999999999996.
-testcase_ellint_3<double> data118[] = {
-  { -0.0000000000000000, 0.19999999999999996, 0.69999999999999996,
-          0.0000000000000000 },
-  { 0.17335014404233898, 0.19999999999999996, 0.69999999999999996,
-          0.17453292519943295 },
-  { 0.34009775298617811, 0.19999999999999996, 0.69999999999999996,
-          0.34906585039886590 },
-  { 0.49572560201923810, 0.19999999999999996, 0.69999999999999996,
-          0.52359877559829882 },
-  { 0.63856276669886525, 0.19999999999999996, 0.69999999999999996,
-          0.69813170079773179 },
-  { 0.76924438644867565, 0.19999999999999996, 0.69999999999999996,
-          0.87266462599716477 },
-  { 0.88973060843856466, 0.19999999999999996, 0.69999999999999996,
-          1.0471975511965976 },
-  { 1.0025230471636377, 0.19999999999999996, 0.69999999999999996,
-          1.2217304763960306 },
-  { 1.1102356376093103, 0.19999999999999996, 0.69999999999999996,
-          1.3962634015954636 },
-  { 1.2154356555075867, 0.19999999999999996, 0.69999999999999996,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.19999999999999996, nu=0.69999999999999996.
-template <typename Tp>
-void test118()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data118)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data118[i].k), Tp(data118[i].nu),
-                   Tp(data118[i].phi));
-      const Tp f0 = data118[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.19999999999999996, nu=0.80000000000000004.
-testcase_ellint_3<double> data119[] = {
-  { -0.0000000000000000, 0.19999999999999996, 0.80000000000000004,
-          0.0000000000000000 },
-  { 0.17317861443718541, 0.19999999999999996, 0.80000000000000004,
-          0.17453292519943295 },
-  { 0.33884641598718701, 0.19999999999999996, 0.80000000000000004,
-          0.34906585039886590 },
-  { 0.49204565281259494, 0.19999999999999996, 0.80000000000000004,
-          0.52359877559829882 },
-  { 0.63117851188220353, 0.19999999999999996, 0.80000000000000004,
-          0.69813170079773179 },
-  { 0.75721095949544170, 0.19999999999999996, 0.80000000000000004,
-          0.87266462599716477 },
-  { 0.87245201443919118, 0.19999999999999996, 0.80000000000000004,
-          1.0471975511965976 },
-  { 0.97966584238831089, 0.19999999999999996, 0.80000000000000004,
-          1.2217304763960306 },
-  { 1.0816336325174360, 0.19999999999999996, 0.80000000000000004,
-          1.3962634015954636 },
-  { 1.1810223448909913, 0.19999999999999996, 0.80000000000000004,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.19999999999999996, nu=0.80000000000000004.
-template <typename Tp>
-void test119()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data119)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data119[i].k), Tp(data119[i].nu),
-                   Tp(data119[i].phi));
-      const Tp f0 = data119[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.19999999999999996, nu=0.90000000000000002.
-testcase_ellint_3<double> data120[] = {
-  { -0.0000000000000000, 0.19999999999999996, 0.90000000000000002,
-          0.0000000000000000 },
-  { 0.17300769173837280, 0.19999999999999996, 0.90000000000000002,
-          0.17453292519943295 },
-  { 0.33761123827372508, 0.19999999999999996, 0.90000000000000002,
-          0.34906585039886590 },
-  { 0.48845905690769426, 0.19999999999999996, 0.90000000000000002,
-          0.52359877559829882 },
-  { 0.62407720017324986, 0.19999999999999996, 0.90000000000000002,
-          0.69813170079773179 },
-  { 0.74578146525124289, 0.19999999999999996, 0.90000000000000002,
-          0.87266462599716477 },
-  { 0.85621583540073076, 0.19999999999999996, 0.90000000000000002,
-          1.0471975511965976 },
-  { 0.95837725988001199, 0.19999999999999996, 0.90000000000000002,
-          1.2217304763960306 },
-  { 1.0551821412633928, 0.19999999999999996, 0.90000000000000002,
-          1.3962634015954636 },
-  { 1.1493679916141863, 0.19999999999999996, 0.90000000000000002,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.19999999999999996, nu=0.90000000000000002.
-template <typename Tp>
-void test120()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data120)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data120[i].k), Tp(data120[i].nu),
-                   Tp(data120[i].phi));
-      const Tp f0 = data120[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.5624826890976725e-16
+// mean(f - f_Boost): 2.3314683517128288e-16
+// variance(f - f_Boost): 2.9401198977189756e-31
+// stddev(f - f_Boost): 5.4222872459129045e-16
+const testcase_ellint_3<double>
+data110[10] =
+{
+  { 0.0000000000000000, 0.10000000000000009, 0.90000000000000002, 
+	  0.0000000000000000 },
+  { 0.17615353510599349, 0.10000000000000009, 0.90000000000000002, 
+	  0.17453292519943295 },
+  { 0.36244964892922371, 0.10000000000000009, 0.90000000000000002, 
+	  0.34906585039886590 },
+  { 0.57132457590110530, 0.10000000000000009, 0.90000000000000002, 
+	  0.52359877559829882 },
+  { 0.82087808820385000, 0.10000000000000009, 0.90000000000000002, 
+	  0.69813170079773179 },
+  { 1.1411894342144451, 0.10000000000000009, 0.90000000000000002, 
+	  0.87266462599716477 },
+  { 1.5875929286844597, 0.10000000000000009, 0.90000000000000002, 
+	  1.0471975511965976 },
+  { 2.2678622986596659, 0.10000000000000009, 0.90000000000000002, 
+	  1.2217304763960306 },
+  { 3.3697528941897903, 0.10000000000000009, 0.90000000000000002, 
+	  1.3962634015954636 },
+  { 4.9862890417305499, 0.10000000000000009, 0.90000000000000002, 
+	  1.5707963267948966 },
+};
+const double toler110 = 2.5000000000000020e-13;
+
+// Test data for k=0.20000000000000018, nu=0.0000000000000000.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 6
+// max(|f - f_Boost| / |f_Boost|): 4.2156475739151676e-16
+// mean(f - f_Boost): -5.2735593669694933e-17
+// variance(f - f_Boost): 3.0473442641042680e-32
+// stddev(f - f_Boost): 1.7456644190978597e-16
+const testcase_ellint_3<double>
+data111[10] =
+{
+  { 0.0000000000000000, 0.20000000000000018, 0.0000000000000000, 
+	  0.0000000000000000 },
+  { 0.17456817290292806, 0.20000000000000018, 0.0000000000000000, 
+	  0.17453292519943295 },
+  { 0.34934315932086796, 0.20000000000000018, 0.0000000000000000, 
+	  0.34906585039886590 },
+  { 0.52450880529443988, 0.20000000000000018, 0.0000000000000000, 
+	  0.52359877559829882 },
+  { 0.70020491009844887, 0.20000000000000018, 0.0000000000000000, 
+	  0.69813170079773179 },
+  { 0.87651006649967977, 0.20000000000000018, 0.0000000000000000, 
+	  0.87266462599716477 },
+  { 1.0534305870298994, 0.20000000000000018, 0.0000000000000000, 
+	  1.0471975511965976 },
+  { 1.2308975521670789, 0.20000000000000018, 0.0000000000000000, 
+	  1.2217304763960306 },
+  { 1.4087733584990738, 0.20000000000000018, 0.0000000000000000, 
+	  1.3962634015954636 },
+  { 1.5868678474541662, 0.20000000000000018, 0.0000000000000000, 
+	  1.5707963267948966 },
+};
+const double toler111 = 2.5000000000000020e-13;
+
+// Test data for k=0.20000000000000018, nu=0.10000000000000001.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 6
+// max(|f - f_Boost| / |f_Boost|): 4.0890622182605400e-16
+// mean(f - f_Boost): -3.8857805861880476e-17
+// variance(f - f_Boost): 2.8794792590749608e-32
+// stddev(f - f_Boost): 1.6969028431454054e-16
+const testcase_ellint_3<double>
+data112[10] =
+{
+  { 0.0000000000000000, 0.20000000000000018, 0.10000000000000001, 
+	  0.0000000000000000 },
+  { 0.17474469953608965, 0.20000000000000018, 0.10000000000000001, 
+	  0.17453292519943295 },
+  { 0.35073860234984255, 0.20000000000000018, 0.10000000000000001, 
+	  0.34906585039886590 },
+  { 0.52912258712951521, 0.20000000000000018, 0.10000000000000001, 
+	  0.52359877559829882 },
+  { 0.71081701558898069, 0.20000000000000018, 0.10000000000000001, 
+	  0.69813170079773179 },
+  { 0.89640758521169384, 0.20000000000000018, 0.10000000000000001, 
+	  0.87266462599716477 },
+  { 1.0860417038089853, 0.20000000000000018, 0.10000000000000001, 
+	  1.0471975511965976 },
+  { 1.2793599255528623, 0.20000000000000018, 0.10000000000000001, 
+	  1.2217304763960306 },
+  { 1.4754938544089076, 0.20000000000000018, 0.10000000000000001, 
+	  1.3962634015954636 },
+  { 1.6731552050562593, 0.20000000000000018, 0.10000000000000001, 
+	  1.5707963267948966 },
+};
+const double toler112 = 2.5000000000000020e-13;
+
+// Test data for k=0.20000000000000018, nu=0.20000000000000001.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 6
+// max(|f - f_Boost| / |f_Boost|): 3.9570963716579749e-16
+// mean(f - f_Boost): -5.8286708792820721e-17
+// variance(f - f_Boost): 3.1158217732380362e-32
+// stddev(f - f_Boost): 1.7651690494788412e-16
+const testcase_ellint_3<double>
+data113[10] =
+{
+  { 0.0000000000000000, 0.20000000000000018, 0.20000000000000001, 
+	  0.0000000000000000 },
+  { 0.17492186907740698, 0.20000000000000018, 0.20000000000000001, 
+	  0.17453292519943295 },
+  { 0.35215414286134267, 0.20000000000000018, 0.20000000000000001, 
+	  0.34906585039886590 },
+  { 0.53388285615182440, 0.20000000000000018, 0.20000000000000001, 
+	  0.52359877559829882 },
+  { 0.72200960282688265, 0.20000000000000018, 0.20000000000000001, 
+	  0.69813170079773179 },
+  { 0.91793087614428526, 0.20000000000000018, 0.20000000000000001, 
+	  0.87266462599716477 },
+  { 1.1222602841587976, 0.20000000000000018, 0.20000000000000001, 
+	  1.0471975511965976 },
+  { 1.3345489407496247, 0.20000000000000018, 0.20000000000000001, 
+	  1.2217304763960306 },
+  { 1.5531225705475502, 0.20000000000000018, 0.20000000000000001, 
+	  1.3962634015954636 },
+  { 1.7751816279738935, 0.20000000000000018, 0.20000000000000001, 
+	  1.5707963267948966 },
+};
+const double toler113 = 2.5000000000000020e-13;
+
+// Test data for k=0.20000000000000018, nu=0.30000000000000004.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.6785817924053817e-16
+// mean(f - f_Boost): -1.1102230246251566e-17
+// variance(f - f_Boost): 9.9840208317034302e-32
+// stddev(f - f_Boost): 3.1597501217190311e-16
+const testcase_ellint_3<double>
+data114[10] =
+{
+  { 0.0000000000000000, 0.20000000000000018, 0.30000000000000004, 
+	  0.0000000000000000 },
+  { 0.17509968571715159, 0.20000000000000018, 0.30000000000000004, 
+	  0.17453292519943295 },
+  { 0.35359030214835629, 0.20000000000000018, 0.30000000000000004, 
+	  0.34906585039886590 },
+  { 0.53879807274537084, 0.20000000000000018, 0.30000000000000004, 
+	  0.52359877559829882 },
+  { 0.73384116418059731, 0.20000000000000018, 0.30000000000000004, 
+	  0.69813170079773179 },
+  { 0.94132799329524031, 0.20000000000000018, 0.30000000000000004, 
+	  0.87266462599716477 },
+  { 1.1628407021801439, 0.20000000000000018, 0.30000000000000004, 
+	  1.0471975511965976 },
+  { 1.3982440216739438, 0.20000000000000018, 0.30000000000000004, 
+	  1.2217304763960306 },
+  { 1.6450634983653640, 0.20000000000000018, 0.30000000000000004, 
+	  1.3962634015954636 },
+  { 1.8983924169967099, 0.20000000000000018, 0.30000000000000004, 
+	  1.5707963267948966 },
+};
+const double toler114 = 2.5000000000000020e-13;
+
+// Test data for k=0.20000000000000018, nu=0.40000000000000002.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 6
+// max(|f - f_Boost| / |f_Boost|): 3.6738449250038925e-16
+// mean(f - f_Boost): -3.0531133177191807e-17
+// variance(f - f_Boost): 2.7810428396951687e-32
+// stddev(f - f_Boost): 1.6676458975739331e-16
+const testcase_ellint_3<double>
+data115[10] =
+{
+  { 0.0000000000000000, 0.20000000000000018, 0.40000000000000002, 
+	  0.0000000000000000 },
+  { 0.17527815368535152, 0.20000000000000018, 0.40000000000000002, 
+	  0.17453292519943295 },
+  { 0.35504762134297801, 0.20000000000000018, 0.40000000000000002, 
+	  0.34906585039886590 },
+  { 0.54387742353211344, 0.20000000000000018, 0.40000000000000002, 
+	  0.52359877559829882 },
+  { 0.74637910471804259, 0.20000000000000018, 0.40000000000000002, 
+	  0.69813170079773179 },
+  { 0.96690539714174639, 0.20000000000000018, 0.40000000000000002, 
+	  0.87266462599716477 },
+  { 1.2087859420184757, 0.20000000000000018, 0.40000000000000002, 
+	  1.0471975511965976 },
+  { 1.4729799844168852, 0.20000000000000018, 0.40000000000000002, 
+	  1.2217304763960306 },
+  { 1.7564445064596661, 0.20000000000000018, 0.40000000000000002, 
+	  1.3962634015954636 },
+  { 2.0512956926676806, 0.20000000000000018, 0.40000000000000002, 
+	  1.5707963267948966 },
+};
+const double toler115 = 2.5000000000000020e-13;
+
+// Test data for k=0.20000000000000018, nu=0.50000000000000000.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.3841806057292116e-16
+// mean(f - f_Boost): 3.6082248300317589e-17
+// variance(f - f_Boost): 8.9638010532618564e-32
+// stddev(f - f_Boost): 2.9939607634806868e-16
+const testcase_ellint_3<double>
+data116[10] =
+{
+  { 0.0000000000000000, 0.20000000000000018, 0.50000000000000000, 
+	  0.0000000000000000 },
+  { 0.17545727725228877, 0.20000000000000018, 0.50000000000000000, 
+	  0.17453292519943295 },
+  { 0.35652666242062175, 0.20000000000000018, 0.50000000000000000, 
+	  0.34906585039886590 },
+  { 0.54913090549102406, 0.20000000000000018, 0.50000000000000000, 
+	  0.52359877559829882 },
+  { 0.75970161209211551, 0.20000000000000018, 0.50000000000000000, 
+	  0.69813170079773179 },
+  { 0.99504737401590326, 0.20000000000000018, 0.50000000000000000, 
+	  0.87266462599716477 },
+  { 1.2614666007124373, 0.20000000000000018, 0.50000000000000000, 
+	  1.0471975511965976 },
+  { 1.5625255355205498, 0.20000000000000018, 0.50000000000000000, 
+	  1.2217304763960306 },
+  { 1.8954460255613346, 0.20000000000000018, 0.50000000000000000, 
+	  1.3962634015954636 },
+  { 2.2481046259421302, 0.20000000000000018, 0.50000000000000000, 
+	  1.5707963267948966 },
+};
+const double toler116 = 2.5000000000000020e-13;
+
+// Test data for k=0.20000000000000018, nu=0.60000000000000009.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.5317584994994743e-16
+// mean(f - f_Boost): -1.3877787807814457e-17
+// variance(f - f_Boost): 1.0045745697575397e-31
+// stddev(f - f_Boost): 3.1695024369095219e-16
+const testcase_ellint_3<double>
+data117[10] =
+{
+  { 0.0000000000000000, 0.20000000000000018, 0.60000000000000009, 
+	  0.0000000000000000 },
+  { 0.17563706072900442, 0.20000000000000018, 0.60000000000000009, 
+	  0.17453292519943295 },
+  { 0.35802800926807238, 0.20000000000000018, 0.60000000000000009, 
+	  0.34906585039886590 },
+  { 0.55456942250515051, 0.20000000000000018, 0.60000000000000009, 
+	  0.52359877559829882 },
+  { 0.77390003828438203, 0.20000000000000018, 0.60000000000000009, 
+	  0.69813170079773179 },
+  { 1.0262441366366397, 0.20000000000000018, 0.60000000000000009, 
+	  0.87266462599716477 },
+  { 1.3228192988439669, 0.20000000000000018, 0.60000000000000009, 
+	  1.0471975511965976 },
+  { 1.6728005754680795, 0.20000000000000018, 0.60000000000000009, 
+	  1.2217304763960306 },
+  { 2.0761587107468511, 0.20000000000000018, 0.60000000000000009, 
+	  1.3962634015954636 },
+  { 2.5148333891629315, 0.20000000000000018, 0.60000000000000009, 
+	  1.5707963267948966 },
+};
+const double toler117 = 2.5000000000000020e-13;
+
+// Test data for k=0.20000000000000018, nu=0.70000000000000007.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.2209418045118284e-16
+// mean(f - f_Boost): 2.4980018054066023e-17
+// variance(f - f_Boost): 9.1989071679544611e-32
+// stddev(f - f_Boost): 3.0329700242426498e-16
+const testcase_ellint_3<double>
+data118[10] =
+{
+  { 0.0000000000000000, 0.20000000000000018, 0.70000000000000007, 
+	  0.0000000000000000 },
+  { 0.17581750846781172, 0.20000000000000018, 0.70000000000000007, 
+	  0.17453292519943295 },
+  { 0.35955226882028513, 0.20000000000000018, 0.70000000000000007, 
+	  0.34906585039886590 },
+  { 0.56020489659466499, 0.20000000000000018, 0.70000000000000007, 
+	  0.52359877559829882 },
+  { 0.78908196988531498, 0.20000000000000018, 0.70000000000000007, 
+	  0.69813170079773179 },
+  { 1.0611336754143517, 0.20000000000000018, 0.70000000000000007, 
+	  0.87266462599716477 },
+  { 1.3956969951058884, 0.20000000000000018, 0.70000000000000007, 
+	  1.0471975511965976 },
+  { 1.8138131612209609, 0.20000000000000018, 0.70000000000000007, 
+	  1.2217304763960306 },
+  { 2.3256365528879561, 0.20000000000000018, 0.70000000000000007, 
+	  1.3962634015954636 },
+  { 2.9058704854500963, 0.20000000000000018, 0.70000000000000007, 
+	  1.5707963267948966 },
+};
+const double toler118 = 2.5000000000000020e-13;
+
+// Test data for k=0.20000000000000018, nu=0.80000000000000004.
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.7399960886656824e-16
+// mean(f - f_Boost): 1.3877787807814457e-16
+// variance(f - f_Boost): 1.7585404776158019e-31
+// stddev(f - f_Boost): 4.1934955319110593e-16
+const testcase_ellint_3<double>
+data119[10] =
+{
+  { 0.0000000000000000, 0.20000000000000018, 0.80000000000000004, 
+	  0.0000000000000000 },
+  { 0.17599862486281712, 0.20000000000000018, 0.80000000000000004, 
+	  0.17453292519943295 },
+  { 0.36110007227128776, 0.20000000000000018, 0.80000000000000004, 
+	  0.34906585039886590 },
+  { 0.56605039658567224, 0.20000000000000018, 0.80000000000000004, 
+	  0.52359877559829882 },
+  { 0.80537523874517691, 0.20000000000000018, 0.80000000000000004, 
+	  0.69813170079773179 },
+  { 1.1005662342414086, 0.20000000000000018, 0.80000000000000004, 
+	  0.87266462599716477 },
+  { 1.4845340298105778, 0.20000000000000018, 0.80000000000000004, 
+	  1.0471975511965976 },
+  { 2.0043332244969392, 0.20000000000000018, 0.80000000000000004, 
+	  1.2217304763960306 },
+  { 2.7052856676744761, 0.20000000000000018, 0.80000000000000004, 
+	  1.3962634015954636 },
+  { 3.5622166386422633, 0.20000000000000018, 0.80000000000000004, 
+	  1.5707963267948966 },
+};
+const double toler119 = 2.5000000000000020e-13;
+
+// Test data for k=0.20000000000000018, nu=0.90000000000000002.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.1718503329017390e-16
+// mean(f - f_Boost): 2.3592239273284576e-16
+// variance(f - f_Boost): 2.9295534376290287e-31
+// stddev(f - f_Boost): 5.4125349307224141e-16
+const testcase_ellint_3<double>
+data120[10] =
+{
+  { 0.0000000000000000, 0.20000000000000018, 0.90000000000000002, 
+	  0.0000000000000000 },
+  { 0.17618041435044951, 0.20000000000000018, 0.90000000000000002, 
+	  0.17453292519943295 },
+  { 0.36267207636502929, 0.20000000000000018, 0.90000000000000002, 
+	  0.34906585039886590 },
+  { 0.57212028758237743, 0.20000000000000018, 0.90000000000000002, 
+	  0.52359877559829882 },
+  { 0.82293323876704483, 0.20000000000000018, 0.90000000000000002, 
+	  0.69813170079773179 },
+  { 1.1457077279880388, 0.20000000000000018, 0.90000000000000002, 
+	  0.87266462599716477 },
+  { 1.5967346899325681, 0.20000000000000018, 0.90000000000000002, 
+	  1.0471975511965976 },
+  { 2.2856537353421724, 0.20000000000000018, 0.90000000000000002, 
+	  1.2217304763960306 },
+  { 3.4034714304613902, 0.20000000000000018, 0.90000000000000002, 
+	  1.3962634015954636 },
+  { 5.0448269356200370, 0.20000000000000018, 0.90000000000000002, 
+	  1.5707963267948966 },
+};
+const double toler120 = 2.5000000000000020e-13;
 
 // Test data for k=0.30000000000000004, nu=0.0000000000000000.
-testcase_ellint_3<double> data121[] = {
-  { -0.0000000000000000, 0.30000000000000004, 0.0000000000000000,
-          0.0000000000000000 },
-  { 0.17461228653000102, 0.30000000000000004, 0.0000000000000000,
-          0.17453292519943295 },
-  { 0.34969146102798415, 0.30000000000000004, 0.0000000000000000,
-          0.34906585039886590 },
-  { 0.52565822873726320, 0.30000000000000004, 0.0000000000000000,
-          0.52359877559829882 },
-  { 0.70284226512408532, 0.30000000000000004, 0.0000000000000000,
-          0.69813170079773179 },
-  { 0.88144139195111182, 0.30000000000000004, 0.0000000000000000,
-          0.87266462599716477 },
-  { 1.0614897067260523, 0.30000000000000004, 0.0000000000000000,
-          1.0471975511965976 },
-  { 1.2428416824174218, 0.30000000000000004, 0.0000000000000000,
-          1.2217304763960306 },
-  { 1.4251795877015925, 0.30000000000000004, 0.0000000000000000,
-          1.3962634015954636 },
-  { 1.6080486199305126, 0.30000000000000004, 0.0000000000000000,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.30000000000000004, nu=0.0000000000000000.
-template <typename Tp>
-void test121()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data121)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data121[i].k), Tp(data121[i].nu),
-                   Tp(data121[i].phi));
-      const Tp f0 = data121[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.2241249691539529e-16
+// mean(f - f_Boost): 2.7755575615628914e-17
+// variance(f - f_Boost): 2.1399221604302621e-32
+// stddev(f - f_Boost): 1.4628472785736254e-16
+const testcase_ellint_3<double>
+data121[10] =
+{
+  { 0.0000000000000000, 0.30000000000000004, 0.0000000000000000, 
+	  0.0000000000000000 },
+  { 0.17461228653000099, 0.30000000000000004, 0.0000000000000000, 
+	  0.17453292519943295 },
+  { 0.34969146102798421, 0.30000000000000004, 0.0000000000000000, 
+	  0.34906585039886590 },
+  { 0.52565822873726309, 0.30000000000000004, 0.0000000000000000, 
+	  0.52359877559829882 },
+  { 0.70284226512408543, 0.30000000000000004, 0.0000000000000000, 
+	  0.69813170079773179 },
+  { 0.88144139195111171, 0.30000000000000004, 0.0000000000000000, 
+	  0.87266462599716477 },
+  { 1.0614897067260520, 0.30000000000000004, 0.0000000000000000, 
+	  1.0471975511965976 },
+  { 1.2428416824174220, 0.30000000000000004, 0.0000000000000000, 
+	  1.2217304763960306 },
+  { 1.4251795877015929, 0.30000000000000004, 0.0000000000000000, 
+	  1.3962634015954636 },
+  { 1.6080486199305128, 0.30000000000000004, 0.0000000000000000, 
+	  1.5707963267948966 },
+};
+const double toler121 = 2.5000000000000020e-13;
 
 // Test data for k=0.30000000000000004, nu=0.10000000000000001.
-testcase_ellint_3<double> data122[] = {
-  { -0.0000000000000000, 0.30000000000000004, 0.10000000000000001,
-          0.0000000000000000 },
-  { 0.17443631884814378, 0.30000000000000004, 0.10000000000000001,
-          0.17453292519943295 },
-  { 0.34831316835124926, 0.30000000000000004, 0.10000000000000001,
-          0.34906585039886590 },
-  { 0.52116586276523857, 0.30000000000000004, 0.10000000000000001,
-          0.52359877559829882 },
-  { 0.69269385837910036, 0.30000000000000004, 0.10000000000000001,
-          0.69813170079773179 },
-  { 0.86279023163070856, 0.30000000000000004, 0.10000000000000001,
-          0.87266462599716477 },
-  { 1.0315321461438265, 0.30000000000000004, 0.10000000000000001,
-          1.0471975511965976 },
-  { 1.1991449111869024, 0.30000000000000004, 0.10000000000000001,
-          1.2217304763960306 },
-  { 1.3659561780923211, 0.30000000000000004, 0.10000000000000001,
-          1.3962634015954636 },
-  { 1.5323534693557526, 0.30000000000000004, 0.10000000000000001,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.30000000000000004, nu=0.10000000000000001.
-template <typename Tp>
-void test122()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data122)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data122[i].k), Tp(data122[i].nu),
-                   Tp(data122[i].phi));
-      const Tp f0 = data122[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.1872304407982844e-16
+// mean(f - f_Boost): 7.2164496600635178e-17
+// variance(f - f_Boost): 4.3555500115139682e-32
+// stddev(f - f_Boost): 2.0869954507650391e-16
+const testcase_ellint_3<double>
+data122[10] =
+{
+  { 0.0000000000000000, 0.30000000000000004, 0.10000000000000001, 
+	  0.0000000000000000 },
+  { 0.17478889331392972, 0.30000000000000004, 0.10000000000000001, 
+	  0.17453292519943295 },
+  { 0.35108939018329183, 0.30000000000000004, 0.10000000000000001, 
+	  0.34906585039886590 },
+  { 0.53028990896115835, 0.30000000000000004, 0.10000000000000001, 
+	  0.52359877559829882 },
+  { 0.71352417052371409, 0.30000000000000004, 0.10000000000000001, 
+	  0.69813170079773179 },
+  { 0.90153086032405894, 0.30000000000000004, 0.10000000000000001, 
+	  0.87266462599716477 },
+  { 1.0945187977283313, 0.30000000000000004, 0.10000000000000001, 
+	  1.0471975511965976 },
+  { 1.2920699268385683, 0.30000000000000004, 0.10000000000000001, 
+	  1.2217304763960306 },
+  { 1.4931243665896394, 0.30000000000000004, 0.10000000000000001, 
+	  1.3962634015954636 },
+  { 1.6960848815118226, 0.30000000000000004, 0.10000000000000001, 
+	  1.5707963267948966 },
+};
+const double toler122 = 2.5000000000000020e-13;
 
 // Test data for k=0.30000000000000004, nu=0.20000000000000001.
-testcase_ellint_3<double> data123[] = {
-  { -0.0000000000000000, 0.30000000000000004, 0.20000000000000001,
-          0.0000000000000000 },
-  { 0.17426098615372090, 0.30000000000000004, 0.20000000000000001,
-          0.17453292519943295 },
-  { 0.34695402664689923, 0.30000000000000004, 0.20000000000000001,
-          0.34906585039886590 },
-  { 0.51680555567038933, 0.30000000000000004, 0.20000000000000001,
-          0.52359877559829882 },
-  { 0.68303375225260210, 0.30000000000000004, 0.20000000000000001,
-          0.69813170079773179 },
-  { 0.84540662891295026, 0.30000000000000004, 0.20000000000000001,
-          0.87266462599716477 },
-  { 1.0041834051646927, 0.30000000000000004, 0.20000000000000001,
-          1.0471975511965976 },
-  { 1.1599952702345711, 0.30000000000000004, 0.20000000000000001,
-          1.2217304763960306 },
-  { 1.3137179520499163, 0.30000000000000004, 0.20000000000000001,
-          1.3962634015954636 },
-  { 1.4663658145259875, 0.30000000000000004, 0.20000000000000001,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.30000000000000004, nu=0.20000000000000001.
-template <typename Tp>
-void test123()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data123)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data123[i].k), Tp(data123[i].nu),
-                   Tp(data123[i].phi));
-      const Tp f0 = data123[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.30000000000000004, nu=0.29999999999999999.
-testcase_ellint_3<double> data124[] = {
-  { -0.0000000000000000, 0.30000000000000004, 0.29999999999999999,
-          0.0000000000000000 },
-  { 0.17408628437042845, 0.30000000000000004, 0.29999999999999999,
-          0.17453292519943295 },
-  { 0.34561356761638401, 0.30000000000000004, 0.29999999999999999,
-          0.34906585039886590 },
-  { 0.51257058617875850, 0.30000000000000004, 0.29999999999999999,
-          0.52359877559829882 },
-  { 0.67382207124602866, 0.30000000000000004, 0.29999999999999999,
-          0.69813170079773179 },
-  { 0.82914751587825131, 0.30000000000000004, 0.29999999999999999,
-          0.87266462599716477 },
-  { 0.97907434814374950, 0.30000000000000004, 0.29999999999999999,
-          1.0471975511965976 },
-  { 1.1246399297351584, 0.30000000000000004, 0.29999999999999999,
-          1.2217304763960306 },
-  { 1.2671793970398146, 0.30000000000000004, 0.29999999999999999,
-          1.3962634015954636 },
-  { 1.4081767433479089, 0.30000000000000004, 0.29999999999999999,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.30000000000000004, nu=0.29999999999999999.
-template <typename Tp>
-void test124()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data124)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data124[i].k), Tp(data124[i].nu),
-                   Tp(data124[i].phi));
-      const Tp f0 = data124[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 6.2247497610332889e-16
+// mean(f - f_Boost): 6.6613381477509390e-17
+// variance(f - f_Boost): 1.7591111235252501e-32
+// stddev(f - f_Boost): 1.3263148659067538e-16
+const testcase_ellint_3<double>
+data123[10] =
+{
+  { 0.0000000000000000, 0.30000000000000004, 0.20000000000000001, 
+	  0.0000000000000000 },
+  { 0.17496614335337535, 0.30000000000000004, 0.20000000000000001, 
+	  0.17453292519943295 },
+  { 0.35250745937139372, 0.30000000000000004, 0.20000000000000001, 
+	  0.34906585039886590 },
+  { 0.53506875002836884, 0.30000000000000004, 0.20000000000000001, 
+	  0.52359877559829882 },
+  { 0.72479106622248191, 0.30000000000000004, 0.20000000000000001, 
+	  0.69813170079773179 },
+  { 0.92326451535891607, 0.30000000000000004, 0.20000000000000001, 
+	  0.87266462599716477 },
+  { 1.1312092060698349, 0.30000000000000004, 0.20000000000000001, 
+	  1.0471975511965976 },
+  { 1.3481473154592321, 0.30000000000000004, 0.20000000000000001, 
+	  1.2217304763960306 },
+  { 1.5722049569662750, 0.30000000000000004, 0.20000000000000001, 
+	  1.3962634015954636 },
+  { 1.8002173372290500, 0.30000000000000004, 0.20000000000000001, 
+	  1.5707963267948966 },
+};
+const double toler123 = 2.5000000000000020e-13;
+
+// Test data for k=0.30000000000000004, nu=0.30000000000000004.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 6.1678685180047551e-16
+// mean(f - f_Boost): 1.0547118733938987e-16
+// variance(f - f_Boost): 7.5633408838247182e-32
+// stddev(f - f_Boost): 2.7501528837184157e-16
+const testcase_ellint_3<double>
+data124[10] =
+{
+  { 0.0000000000000000, 0.30000000000000004, 0.30000000000000004, 
+	  0.0000000000000000 },
+  { 0.17514404084107435, 0.30000000000000004, 0.30000000000000004, 
+	  0.17453292519943295 },
+  { 0.35394619108645647, 0.30000000000000004, 0.30000000000000004, 
+	  0.34906585039886590 },
+  { 0.54000325463372689, 0.30000000000000004, 0.30000000000000004, 
+	  0.52359877559829882 },
+  { 0.73670193794067651, 0.30000000000000004, 0.30000000000000004, 
+	  0.69813170079773179 },
+  { 0.94689345491722177, 0.30000000000000004, 0.30000000000000004, 
+	  0.87266462599716477 },
+  { 1.1723274608389140, 0.30000000000000004, 0.30000000000000004, 
+	  1.0471975511965976 },
+  { 1.4128880552936287, 0.30000000000000004, 0.30000000000000004, 
+	  1.2217304763960306 },
+  { 1.6659010047449661, 0.30000000000000004, 0.30000000000000004, 
+	  1.3962634015954636 },
+  { 1.9260216862473254, 0.30000000000000004, 0.30000000000000004, 
+	  1.5707963267948966 },
+};
+const double toler124 = 2.5000000000000020e-13;
 
 // Test data for k=0.30000000000000004, nu=0.40000000000000002.
-testcase_ellint_3<double> data125[] = {
-  { -0.0000000000000000, 0.30000000000000004, 0.40000000000000002,
-          0.0000000000000000 },
-  { 0.17391220945982730, 0.30000000000000004, 0.40000000000000002,
-          0.17453292519943295 },
-  { 0.34429133937639689, 0.30000000000000004, 0.40000000000000002,
-          0.34906585039886590 },
-  { 0.50845471668581632, 0.30000000000000004, 0.40000000000000002,
-          0.52359877559829882 },
-  { 0.66502347027873854, 0.30000000000000004, 0.40000000000000002,
-          0.69813170079773179 },
-  { 0.81389191978012254, 0.30000000000000004, 0.40000000000000002,
-          0.87266462599716477 },
-  { 0.95590618002140593, 0.30000000000000004, 0.40000000000000002,
-          1.0471975511965976 },
-  { 1.0924915195213121, 0.30000000000000004, 0.40000000000000002,
-          1.2217304763960306 },
-  { 1.2253651604038058, 0.30000000000000004, 0.40000000000000002,
-          1.3962634015954636 },
-  { 1.3563643538969761, 0.30000000000000004, 0.40000000000000002,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.30000000000000004, nu=0.40000000000000002.
-template <typename Tp>
-void test125()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data125)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data125[i].k), Tp(data125[i].nu),
-                   Tp(data125[i].phi));
-      const Tp f0 = data125[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 6.3983279132797385e-16
+// mean(f - f_Boost): 1.1657341758564144e-16
+// variance(f - f_Boost): 1.8245832308692586e-31
+// stddev(f - f_Boost): 4.2715140534349863e-16
+const testcase_ellint_3<double>
+data125[10] =
+{
+  { 0.0000000000000000, 0.30000000000000004, 0.40000000000000002, 
+	  0.0000000000000000 },
+  { 0.17532259000954434, 0.30000000000000004, 0.40000000000000002, 
+	  0.17453292519943295 },
+  { 0.35540612770983693, 0.30000000000000004, 0.40000000000000002, 
+	  0.34906585039886590 },
+  { 0.54510265552938919, 0.30000000000000004, 0.40000000000000002, 
+	  0.52359877559829882 },
+  { 0.74932476310965057, 0.30000000000000004, 0.40000000000000002, 
+	  0.69813170079773179 },
+  { 0.97272793583093109, 0.30000000000000004, 0.40000000000000002, 
+	  0.87266462599716477 },
+  { 1.2188928987074241, 0.30000000000000004, 0.40000000000000002, 
+	  1.0471975511965976 },
+  { 1.4888771674085941, 0.30000000000000004, 0.40000000000000002, 
+	  1.2217304763960306 },
+  { 1.7794558498219191, 0.30000000000000004, 0.40000000000000002, 
+	  1.3962634015954636 },
+  { 2.0822121773175528, 0.30000000000000004, 0.40000000000000002, 
+	  1.5707963267948966 },
+};
+const double toler125 = 2.5000000000000020e-13;
 
 // Test data for k=0.30000000000000004, nu=0.50000000000000000.
-testcase_ellint_3<double> data126[] = {
-  { -0.0000000000000000, 0.30000000000000004, 0.50000000000000000,
-          0.0000000000000000 },
-  { 0.17373875742088235, 0.30000000000000004, 0.50000000000000000,
-          0.17453292519943295 },
-  { 0.34298690571124157, 0.30000000000000004, 0.50000000000000000,
-          0.34906585039886590 },
-  { 0.50445214859646936, 0.30000000000000004, 0.50000000000000000,
-          0.52359877559829882 },
-  { 0.65660648352418516, 0.30000000000000004, 0.50000000000000000,
-          0.69813170079773179 },
-  { 0.79953670639287289, 0.30000000000000004, 0.50000000000000000,
-          0.87266462599716477 },
-  { 0.93443393926588558, 0.30000000000000004, 0.50000000000000000,
-          1.0471975511965976 },
-  { 1.0630838369016911, 0.30000000000000004, 0.50000000000000000,
-          1.2217304763960306 },
-  { 1.1875197325653026, 0.30000000000000004, 0.50000000000000000,
-          1.3962634015954636 },
-  { 1.3098448759814960, 0.30000000000000004, 0.50000000000000000,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.30000000000000004, nu=0.50000000000000000.
-template <typename Tp>
-void test126()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data126)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data126[i].k), Tp(data126[i].nu),
-                   Tp(data126[i].phi));
-      const Tp f0 = data126[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.30000000000000004, nu=0.59999999999999998.
-testcase_ellint_3<double> data127[] = {
-  { -0.0000000000000000, 0.30000000000000004, 0.59999999999999998,
-          0.0000000000000000 },
-  { 0.17356592428950826, 0.30000000000000004, 0.59999999999999998,
-          0.17453292519943295 },
-  { 0.34169984536697379, 0.30000000000000004, 0.59999999999999998,
-          0.34906585039886590 },
-  { 0.50055748266498457, 0.30000000000000004, 0.59999999999999998,
-          0.52359877559829882 },
-  { 0.64854298527106768, 0.30000000000000004, 0.59999999999999998,
-          0.69813170079773179 },
-  { 0.78599329284207431, 0.30000000000000004, 0.59999999999999998,
-          0.87266462599716477 },
-  { 0.91445452089128221, 0.30000000000000004, 0.59999999999999998,
-          1.0471975511965976 },
-  { 1.0360412952290587, 0.30000000000000004, 0.59999999999999998,
-          1.2217304763960306 },
-  { 1.1530473919778639, 0.30000000000000004, 0.59999999999999998,
-          1.3962634015954636 },
-  { 1.2677758800420666, 0.30000000000000004, 0.59999999999999998,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.30000000000000004, nu=0.59999999999999998.
-template <typename Tp>
-void test127()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data127)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data127[i].k), Tp(data127[i].nu),
-                   Tp(data127[i].phi));
-      const Tp f0 = data127[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.30000000000000004, nu=0.69999999999999996.
-testcase_ellint_3<double> data128[] = {
-  { -0.0000000000000000, 0.30000000000000004, 0.69999999999999996,
-          0.0000000000000000 },
-  { 0.17339370613812227, 0.30000000000000004, 0.69999999999999996,
-          0.17453292519943295 },
-  { 0.34042975138455933, 0.30000000000000004, 0.69999999999999996,
-          0.34906585039886590 },
-  { 0.49676568368075985, 0.30000000000000004, 0.69999999999999996,
-          0.52359877559829882 },
-  { 0.64080774055753720, 0.30000000000000004, 0.69999999999999996,
-          0.69813170079773179 },
-  { 0.77318507779667278, 0.30000000000000004, 0.69999999999999996,
-          0.87266462599716477 },
-  { 0.89579782346548631, 0.30000000000000004, 0.69999999999999996,
-          1.0471975511965976 },
-  { 1.0110573286052202, 0.30000000000000004, 0.69999999999999996,
-          1.2217304763960306 },
-  { 1.1214710972949633, 0.30000000000000004, 0.69999999999999996,
-          1.3962634015954636 },
-  { 1.2294913236274980, 0.30000000000000004, 0.69999999999999996,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.30000000000000004, nu=0.69999999999999996.
-template <typename Tp>
-void test128()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data128)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data128[i].k), Tp(data128[i].nu),
-                   Tp(data128[i].phi));
-      const Tp f0 = data128[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 6.0516138451673425e-16
+// mean(f - f_Boost): 4.7184478546569152e-17
+// variance(f - f_Boost): 1.9448563670505968e-32
+// stddev(f - f_Boost): 1.3945810722401896e-16
+const testcase_ellint_3<double>
+data126[10] =
+{
+  { 0.0000000000000000, 0.30000000000000004, 0.50000000000000000, 
+	  0.0000000000000000 },
+  { 0.17550179513158179, 0.30000000000000004, 0.50000000000000000, 
+	  0.17453292519943295 },
+  { 0.35688783251681200, 0.30000000000000004, 0.50000000000000000, 
+	  0.34906585039886590 },
+  { 0.55037700010142798, 0.30000000000000004, 0.50000000000000000, 
+	  0.52359877559829882 },
+  { 0.76273839789895992, 0.30000000000000004, 0.50000000000000000, 
+	  0.69813170079773179 },
+  { 1.0011570518830419, 0.30000000000000004, 0.50000000000000000, 
+	  0.87266462599716477 },
+  { 1.2722987414055109, 0.30000000000000004, 0.50000000000000000, 
+	  1.0471975511965976 },
+  { 1.5799590511080066, 0.30000000000000004, 0.50000000000000000, 
+	  1.2217304763960306 },
+  { 1.9212367220124293, 0.30000000000000004, 0.50000000000000000, 
+	  1.3962634015954636 },
+  { 2.2833505881933971, 0.30000000000000004, 0.50000000000000000, 
+	  1.5707963267948966 },
+};
+const double toler126 = 2.5000000000000020e-13;
+
+// Test data for k=0.30000000000000004, nu=0.60000000000000009.
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 5.2121157428443725e-16
+// mean(f - f_Boost): 1.9428902930940239e-16
+// variance(f - f_Boost): 1.5987596229703424e-31
+// stddev(f - f_Boost): 3.9984492281012430e-16
+const testcase_ellint_3<double>
+data127[10] =
+{
+  { 0.0000000000000000, 0.30000000000000004, 0.60000000000000009, 
+	  0.0000000000000000 },
+  { 0.17568166052076745, 0.30000000000000004, 0.60000000000000009, 
+	  0.17453292519943295 },
+  { 0.35839189074731181, 0.30000000000000004, 0.60000000000000009, 
+	  0.34906585039886590 },
+  { 0.55583724744367558, 0.30000000000000004, 0.60000000000000009, 
+	  0.52359877559829882 },
+  { 0.77703498090888223, 0.30000000000000004, 0.60000000000000009, 
+	  0.69813170079773179 },
+  { 1.0326772113675962, 0.30000000000000004, 0.60000000000000009, 
+	  0.87266462599716477 },
+  { 1.3345139983717369, 0.30000000000000004, 0.60000000000000009, 
+	  1.0471975511965976 },
+  { 1.6921742922838403, 0.30000000000000004, 0.60000000000000009, 
+	  1.2217304763960306 },
+  { 2.1056608968472186, 0.30000000000000004, 0.60000000000000009, 
+	  1.3962634015954636 },
+  { 2.5560975528589061, 0.30000000000000004, 0.60000000000000009, 
+	  1.5707963267948966 },
+};
+const double toler127 = 2.5000000000000020e-13;
+
+// Test data for k=0.30000000000000004, nu=0.70000000000000007.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 6.0088945789059381e-16
+// mean(f - f_Boost): 2.1094237467877973e-16
+// variance(f - f_Boost): 3.0253363535298873e-31
+// stddev(f - f_Boost): 5.5003057674368314e-16
+const testcase_ellint_3<double>
+data128[10] =
+{
+  { 0.0000000000000000, 0.30000000000000004, 0.70000000000000007, 
+	  0.0000000000000000 },
+  { 0.17586219053197988, 0.30000000000000004, 0.70000000000000007, 
+	  0.17453292519943295 },
+  { 0.35991891074557669, 0.30000000000000004, 0.70000000000000007, 
+	  0.34906585039886590 },
+  { 0.56149538019961731, 0.30000000000000004, 0.70000000000000007, 
+	  0.52359877559829882 },
+  { 0.79232303189667685, 0.30000000000000004, 0.70000000000000007, 
+	  0.69813170079773179 },
+  { 1.0679345542878826, 0.30000000000000004, 0.70000000000000007, 
+	  0.87266462599716477 },
+  { 1.4084400085913955, 0.30000000000000004, 0.70000000000000007, 
+	  1.0471975511965976 },
+  { 1.8357382859296454, 0.30000000000000004, 0.70000000000000007, 
+	  1.2217304763960306 },
+  { 2.3604197996171519, 0.30000000000000004, 0.70000000000000007, 
+	  1.3962634015954636 },
+  { 2.9562123549913872, 0.30000000000000004, 0.70000000000000007, 
+	  1.5707963267948966 },
+};
+const double toler128 = 2.5000000000000020e-13;
 
 // Test data for k=0.30000000000000004, nu=0.80000000000000004.
-testcase_ellint_3<double> data129[] = {
-  { -0.0000000000000000, 0.30000000000000004, 0.80000000000000004,
-          0.0000000000000000 },
-  { 0.17322209907520361, 0.30000000000000004, 0.80000000000000004,
-          0.17453292519943295 },
-  { 0.33917623046949996, 0.30000000000000004, 0.80000000000000004,
-          0.34906585039886590 },
-  { 0.49307204894329176, 0.30000000000000004, 0.80000000000000004,
-          0.52359877559829882 },
-  { 0.63337802830291723, 0.30000000000000004, 0.80000000000000004,
-          0.69813170079773179 },
-  { 0.76104540997689407, 0.30000000000000004, 0.80000000000000004,
-          0.87266462599716477 },
-  { 0.87832009635450736, 0.30000000000000004, 0.80000000000000004,
-          1.0471975511965976 },
-  { 0.98787879723171790, 0.30000000000000004, 0.80000000000000004,
-          1.2217304763960306 },
-  { 1.0924036340069336, 0.30000000000000004, 0.80000000000000004,
-          1.3962634015954636 },
-  { 1.1944567571590046, 0.30000000000000004, 0.80000000000000004,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.30000000000000004, nu=0.80000000000000004.
-template <typename Tp>
-void test129()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data129)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data129[i].k), Tp(data129[i].nu),
-                   Tp(data129[i].phi));
-      const Tp f0 = data129[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 2.2204460492503131e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 6.1197887707781618e-16
+// mean(f - f_Boost): 3.4416913763379854e-16
+// variance(f - f_Boost): 4.3461914185990199e-31
+// stddev(f - f_Boost): 6.5925650687718054e-16
+const testcase_ellint_3<double>
+data129[10] =
+{
+  { 0.0000000000000000, 0.30000000000000004, 0.80000000000000004, 
+	  0.0000000000000000 },
+  { 0.17604338956191670, 0.30000000000000004, 0.80000000000000004, 
+	  0.17453292519943295 },
+  { 0.36146952517410791, 0.30000000000000004, 0.80000000000000004, 
+	  0.34906585039886590 },
+  { 0.56736453393774644, 0.30000000000000004, 0.80000000000000004, 
+	  0.52359877559829882 },
+  { 0.80873149979001091, 0.30000000000000004, 0.80000000000000004, 
+	  0.69813170079773179 },
+  { 1.1077903069860620, 0.30000000000000004, 0.80000000000000004, 
+	  0.87266462599716477 },
+  { 1.4985874311132998, 0.30000000000000004, 0.80000000000000004, 
+	  1.0471975511965976 },
+  { 2.0298167266724954, 0.30000000000000004, 0.80000000000000004, 
+	  1.2217304763960306 },
+  { 2.7483929054985432, 0.30000000000000004, 0.80000000000000004, 
+	  1.3962634015954636 },
+  { 3.6283050484567170, 0.30000000000000004, 0.80000000000000004, 
+	  1.5707963267948966 },
+};
+const double toler129 = 2.5000000000000020e-13;
 
 // Test data for k=0.30000000000000004, nu=0.90000000000000002.
-testcase_ellint_3<double> data130[] = {
-  { -0.0000000000000000, 0.30000000000000004, 0.90000000000000002,
-          0.0000000000000000 },
-  { 0.17305109924485948, 0.30000000000000004, 0.90000000000000002,
-          0.17453292519943295 },
-  { 0.33793890239556984, 0.30000000000000004, 0.90000000000000002,
-          0.34906585039886590 },
-  { 0.48947218005089738, 0.30000000000000004, 0.90000000000000002,
-          0.52359877559829882 },
-  { 0.62623332340775151, 0.30000000000000004, 0.90000000000000002,
-          0.69813170079773179 },
-  { 0.74951596581511148, 0.30000000000000004, 0.90000000000000002,
-          0.87266462599716477 },
-  { 0.86189886597756005, 0.30000000000000004, 0.90000000000000002,
-          1.0471975511965976 },
-  { 0.96629451153092005, 0.30000000000000004, 0.90000000000000002,
-          1.2217304763960306 },
-  { 1.0655269133492680, 0.30000000000000004, 0.90000000000000002,
-          1.3962634015954636 },
-  { 1.1622376896064912, 0.30000000000000004, 0.90000000000000002,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.30000000000000004, nu=0.90000000000000002.
-template <typename Tp>
-void test130()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data130)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data130[i].k), Tp(data130[i].nu),
-                   Tp(data130[i].phi));
-      const Tp f0 = data130[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.39999999999999991, nu=0.0000000000000000.
-testcase_ellint_3<double> data131[] = {
-  { -0.0000000000000000, 0.39999999999999991, 0.0000000000000000,
-          0.0000000000000000 },
-  { 0.17467414669441531, 0.39999999999999991, 0.0000000000000000,
-          0.17453292519943295 },
-  { 0.35018222772483443, 0.39999999999999991, 0.0000000000000000,
-          0.34906585039886590 },
-  { 0.52729015917508748, 0.39999999999999991, 0.0000000000000000,
-          0.52359877559829882 },
-  { 0.70662374407341255, 0.39999999999999991, 0.0000000000000000,
-          0.69813170079773179 },
-  { 0.88859210497602170, 0.39999999999999991, 0.0000000000000000,
-          0.87266462599716477 },
-  { 1.0733136290471379, 0.39999999999999991, 0.0000000000000000,
-          1.0471975511965976 },
-  { 1.2605612170157061, 0.39999999999999991, 0.0000000000000000,
-          1.2217304763960306 },
-  { 1.4497513956433437, 0.39999999999999991, 0.0000000000000000,
-          1.3962634015954636 },
-  { 1.6399998658645112, 0.39999999999999991, 0.0000000000000000,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.39999999999999991, nu=0.0000000000000000.
-template <typename Tp>
-void test131()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data131)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data131[i].k), Tp(data131[i].nu),
-                   Tp(data131[i].phi));
-      const Tp f0 = data131[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.39999999999999991, nu=0.10000000000000001.
-testcase_ellint_3<double> data132[] = {
-  { -0.0000000000000000, 0.39999999999999991, 0.10000000000000001,
-          0.0000000000000000 },
-  { 0.17449806706684673, 0.39999999999999991, 0.10000000000000001,
-          0.17453292519943295 },
-  { 0.34880048623856075, 0.39999999999999991, 0.10000000000000001,
-          0.34906585039886590 },
-  { 0.52277322065757403, 0.39999999999999991, 0.10000000000000001,
-          0.52359877559829882 },
-  { 0.69638072056918376, 0.39999999999999991, 0.10000000000000001,
-          0.69813170079773179 },
-  { 0.86968426619831540, 0.39999999999999991, 0.10000000000000001,
-          0.87266462599716477 },
-  { 1.0428044206578095, 0.39999999999999991, 0.10000000000000001,
-          1.0471975511965976 },
-  { 1.2158651158274378, 0.39999999999999991, 0.10000000000000001,
-          1.2217304763960306 },
-  { 1.3889447129893322, 0.39999999999999991, 0.10000000000000001,
-          1.3962634015954636 },
-  { 1.5620566886683604, 0.39999999999999991, 0.10000000000000001,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.39999999999999991, nu=0.10000000000000001.
-template <typename Tp>
-void test132()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data132)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data132[i].k), Tp(data132[i].nu),
-                   Tp(data132[i].phi));
-      const Tp f0 = data132[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.39999999999999991, nu=0.20000000000000001.
-testcase_ellint_3<double> data133[] = {
-  { -0.0000000000000000, 0.39999999999999991, 0.20000000000000001,
-          0.0000000000000000 },
-  { 0.17432262290723399, 0.39999999999999991, 0.20000000000000001,
-          0.17453292519943295 },
-  { 0.34743795258968596, 0.39999999999999991, 0.20000000000000001,
-          0.34906585039886590 },
-  { 0.51838919472805123, 0.39999999999999991, 0.20000000000000001,
-          0.52359877559829882 },
-  { 0.68663134739057918, 0.39999999999999991, 0.20000000000000001,
-          0.69813170079773179 },
-  { 0.85206432981833979, 0.39999999999999991, 0.20000000000000001,
-          0.87266462599716477 },
-  { 1.0149595349004430, 0.39999999999999991, 0.20000000000000001,
-          1.0471975511965976 },
-  { 1.1758349405464676, 0.39999999999999991, 0.20000000000000001,
-          1.2217304763960306 },
-  { 1.3353337673882635, 0.39999999999999991, 0.20000000000000001,
-          1.3962634015954636 },
-  { 1.4941414344266770, 0.39999999999999991, 0.20000000000000001,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.39999999999999991, nu=0.20000000000000001.
-template <typename Tp>
-void test133()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data133)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data133[i].k), Tp(data133[i].nu),
-                   Tp(data133[i].phi));
-      const Tp f0 = data133[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.39999999999999991, nu=0.29999999999999999.
-testcase_ellint_3<double> data134[] = {
-  { -0.0000000000000000, 0.39999999999999991, 0.29999999999999999,
-          0.0000000000000000 },
-  { 0.17414781013591543, 0.39999999999999991, 0.29999999999999999,
-          0.17453292519943295 },
-  { 0.34609415696777285, 0.39999999999999991, 0.29999999999999999,
-          0.34906585039886590 },
-  { 0.51413131295862546, 0.39999999999999991, 0.29999999999999999,
-          0.52359877559829882 },
-  { 0.67733527622935630, 0.39999999999999991, 0.29999999999999999,
-          0.69813170079773179 },
-  { 0.83558675182733266, 0.39999999999999991, 0.29999999999999999,
-          0.87266462599716477 },
-  { 0.98940140808865906, 0.39999999999999991, 0.29999999999999999,
-          1.0471975511965976 },
-  { 1.1396968797728058, 0.39999999999999991, 0.29999999999999999,
-          1.2217304763960306 },
-  { 1.2875920037865087, 0.39999999999999991, 0.29999999999999999,
-          1.3962634015954636 },
-  { 1.4342789859950078, 0.39999999999999991, 0.29999999999999999,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.39999999999999991, nu=0.29999999999999999.
-template <typename Tp>
-void test134()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data134)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data134[i].k), Tp(data134[i].nu),
-                   Tp(data134[i].phi));
-      const Tp f0 = data134[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.39999999999999991, nu=0.40000000000000002.
-testcase_ellint_3<double> data135[] = {
-  { -0.0000000000000000, 0.39999999999999991, 0.40000000000000002,
-          0.0000000000000000 },
-  { 0.17397362471112710, 0.39999999999999991, 0.40000000000000002,
-          0.17453292519943295 },
-  { 0.34476864603333196, 0.39999999999999991, 0.40000000000000002,
-          0.34906585039886590 },
-  { 0.50999329415379357, 0.39999999999999991, 0.40000000000000002,
-          0.52359877559829882 },
-  { 0.66845674551396017, 0.39999999999999991, 0.40000000000000002,
-          0.69813170079773179 },
-  { 0.82012848346231748, 0.39999999999999991, 0.40000000000000002,
-          0.87266462599716477 },
-  { 0.96582449258349057, 0.39999999999999991, 0.40000000000000002,
-          1.0471975511965976 },
-  { 1.1068473749476286, 0.39999999999999991, 0.40000000000000002,
-          1.2217304763960306 },
-  { 1.2447132729159986, 0.39999999999999991, 0.40000000000000002,
-          1.3962634015954636 },
-  { 1.3809986210732901, 0.39999999999999991, 0.40000000000000002,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.39999999999999991, nu=0.40000000000000002.
-template <typename Tp>
-void test135()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data135)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data135[i].k), Tp(data135[i].nu),
-                   Tp(data135[i].phi));
-      const Tp f0 = data135[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.39999999999999991, nu=0.50000000000000000.
-testcase_ellint_3<double> data136[] = {
-  { -0.0000000000000000, 0.39999999999999991, 0.50000000000000000,
-          0.0000000000000000 },
-  { 0.17380006262854139, 0.39999999999999991, 0.50000000000000000,
-          0.17453292519943295 },
-  { 0.34346098216756610, 0.39999999999999991, 0.50000000000000000,
-          0.34906585039886590 },
-  { 0.50596929935059420, 0.39999999999999991, 0.50000000000000000,
-          0.52359877559829882 },
-  { 0.65996392089131262, 0.39999999999999991, 0.50000000000000000,
-          0.69813170079773179 },
-  { 0.80558463511364786, 0.39999999999999991, 0.50000000000000000,
-          0.87266462599716477 },
-  { 0.94397834522857704, 0.39999999999999991, 0.50000000000000000,
-          1.0471975511965976 },
-  { 1.0768075114108115, 0.39999999999999991, 0.50000000000000000,
-          1.2217304763960306 },
-  { 1.2059184624251329, 0.39999999999999991, 0.50000000000000000,
-          1.3962634015954636 },
-  { 1.3331797176377398, 0.39999999999999991, 0.50000000000000000,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.39999999999999991, nu=0.50000000000000000.
-template <typename Tp>
-void test136()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data136)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data136[i].k), Tp(data136[i].nu),
-                   Tp(data136[i].phi));
-      const Tp f0 = data136[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.39999999999999991, nu=0.59999999999999998.
-testcase_ellint_3<double> data137[] = {
-  { -0.0000000000000000, 0.39999999999999991, 0.59999999999999998,
-          0.0000000000000000 },
-  { 0.17362711992081248, 0.39999999999999991, 0.59999999999999998,
-          0.17453292519943295 },
-  { 0.34217074276403953, 0.39999999999999991, 0.59999999999999998,
-          0.34906585039886590 },
-  { 0.50205389185761617, 0.39999999999999991, 0.59999999999999998,
-          0.52359877559829882 },
-  { 0.65182834920372745, 0.39999999999999991, 0.59999999999999998,
-          0.69813170079773179 },
-  { 0.79186512820565136, 0.39999999999999991, 0.59999999999999998,
-          0.87266462599716477 },
-  { 0.92365535916287134, 0.39999999999999991, 0.59999999999999998,
-          1.0471975511965976 },
-  { 1.0491915663957907, 0.39999999999999991, 0.59999999999999998,
-          1.2217304763960306 },
-  { 1.1705934291745104, 0.39999999999999991, 0.59999999999999998,
-          1.3962634015954636 },
-  { 1.2899514672527024, 0.39999999999999991, 0.59999999999999998,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.39999999999999991, nu=0.59999999999999998.
-template <typename Tp>
-void test137()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data137)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data137[i].k), Tp(data137[i].nu),
-                   Tp(data137[i].phi));
-      const Tp f0 = data137[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.39999999999999991, nu=0.69999999999999996.
-testcase_ellint_3<double> data138[] = {
-  { -0.0000000000000000, 0.39999999999999991, 0.69999999999999996,
-          0.0000000000000000 },
-  { 0.17345479265712871, 0.39999999999999991, 0.69999999999999996,
-          0.17453292519943295 },
-  { 0.34089751955950354, 0.39999999999999991, 0.69999999999999996,
-          0.34906585039886590 },
-  { 0.49824200167361343, 0.39999999999999991, 0.69999999999999996,
-          0.52359877559829882 },
-  { 0.64402450341199413, 0.39999999999999991, 0.69999999999999996,
-          0.69813170079773179 },
-  { 0.77889207804122873, 0.39999999999999991, 0.69999999999999996,
-          0.87266462599716477 },
-  { 0.90468169720957992, 0.39999999999999991, 0.69999999999999996,
-          1.0471975511965976 },
-  { 1.0236847823692916, 0.39999999999999991, 0.69999999999999996,
-          1.2217304763960306 },
-  { 1.1382465247425164, 0.39999999999999991, 0.69999999999999996,
-          1.3962634015954636 },
-  { 1.2506255923253344, 0.39999999999999991, 0.69999999999999996,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.39999999999999991, nu=0.69999999999999996.
-template <typename Tp>
-void test138()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data138)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data138[i].k), Tp(data138[i].nu),
-                   Tp(data138[i].phi));
-      const Tp f0 = data138[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.39999999999999991, nu=0.80000000000000004.
-testcase_ellint_3<double> data139[] = {
-  { -0.0000000000000000, 0.39999999999999991, 0.80000000000000004,
-          0.0000000000000000 },
-  { 0.17328307694277156, 0.39999999999999991, 0.80000000000000004,
-          0.17453292519943295 },
-  { 0.33964091800132007, 0.39999999999999991, 0.80000000000000004,
-          0.34906585039886590 },
-  { 0.49452889372467451, 0.39999999999999991, 0.80000000000000004,
-          0.52359877559829882 },
-  { 0.63652940095937327, 0.39999999999999991, 0.80000000000000004,
-          0.69813170079773179 },
-  { 0.76659772511159097, 0.39999999999999991, 0.80000000000000004,
-          0.87266462599716477 },
-  { 0.88691047977338111, 0.39999999999999991, 0.80000000000000004,
-          1.0471975511965976 },
-  { 1.0000273200611640, 0.39999999999999991, 0.80000000000000004,
-          1.2217304763960306 },
-  { 1.1084787902188007, 0.39999999999999991, 0.80000000000000004,
-          1.3962634015954636 },
-  { 1.2146499565727209, 0.39999999999999991, 0.80000000000000004,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.39999999999999991, nu=0.80000000000000004.
-template <typename Tp>
-void test139()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data139)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data139[i].k), Tp(data139[i].nu),
-                   Tp(data139[i].phi));
-      const Tp f0 = data139[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.39999999999999991, nu=0.90000000000000002.
-testcase_ellint_3<double> data140[] = {
-  { -0.0000000000000000, 0.39999999999999991, 0.90000000000000002,
-          0.0000000000000000 },
-  { 0.17311196891868130, 0.39999999999999991, 0.90000000000000002,
-          0.17453292519943295 },
-  { 0.33840055664911906, 0.39999999999999991, 0.90000000000000002,
-          0.34906585039886590 },
-  { 0.49091013944075340, 0.39999999999999991, 0.90000000000000002,
-          0.52359877559829882 },
-  { 0.62932228186809591, 0.39999999999999991, 0.90000000000000002,
-          0.69813170079773179 },
-  { 0.75492278323019801, 0.39999999999999991, 0.90000000000000002,
-          0.87266462599716477 },
-  { 0.87021659043854294, 0.39999999999999991, 0.90000000000000002,
-          1.0471975511965976 },
-  { 0.97800245228239246, 0.39999999999999991, 0.90000000000000002,
-          1.2217304763960306 },
-  { 1.0809625773173694, 0.39999999999999991, 0.90000000000000002,
-          1.3962634015954636 },
-  { 1.1815758115929846, 0.39999999999999991, 0.90000000000000002,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.39999999999999991, nu=0.90000000000000002.
-template <typename Tp>
-void test140()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data140)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data140[i].k), Tp(data140[i].nu),
-                   Tp(data140[i].phi));
-      const Tp f0 = data140[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 5.1301806687926828e-16
+// mean(f - f_Boost): 4.1633363423443370e-16
+// variance(f - f_Boost): 2.2835347143080263e-31
+// stddev(f - f_Boost): 4.7786344433405093e-16
+const testcase_ellint_3<double>
+data130[10] =
+{
+  { 0.0000000000000000, 0.30000000000000004, 0.90000000000000002, 
+	  0.0000000000000000 },
+  { 0.17622526204962433, 0.30000000000000004, 0.90000000000000002, 
+	  0.17453292519943295 },
+  { 0.36304439230777141, 0.30000000000000004, 0.90000000000000002, 
+	  0.34906585039886590 },
+  { 0.57345914744719195, 0.30000000000000004, 0.90000000000000002, 
+	  0.52359877559829882 },
+  { 0.82641512928845162, 0.30000000000000004, 0.90000000000000002, 
+	  0.69813170079773179 },
+  { 1.1534256210757743, 0.30000000000000004, 0.90000000000000002, 
+	  0.87266462599716477 },
+  { 1.6124900353411677, 0.30000000000000004, 0.90000000000000002, 
+	  1.0471975511965976 },
+  { 2.3165905514845089, 0.30000000000000004, 0.90000000000000002, 
+	  1.2217304763960306 },
+  { 3.4625619526539824, 0.30000000000000004, 0.90000000000000002, 
+	  1.3962634015954636 },
+  { 5.1479514944016787, 0.30000000000000004, 0.90000000000000002, 
+	  1.5707963267948966 },
+};
+const double toler130 = 2.5000000000000020e-13;
+
+// Test data for k=0.40000000000000013, nu=0.0000000000000000.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 1.0831445028587608e-15
+// mean(f - f_Boost): 1.7486012637846215e-16
+// variance(f - f_Boost): 3.1664095331106078e-31
+// stddev(f - f_Boost): 5.6270858649132121e-16
+const testcase_ellint_3<double>
+data131[10] =
+{
+  { 0.0000000000000000, 0.40000000000000013, 0.0000000000000000, 
+	  0.0000000000000000 },
+  { 0.17467414669441528, 0.40000000000000013, 0.0000000000000000, 
+	  0.17453292519943295 },
+  { 0.35018222772483443, 0.40000000000000013, 0.0000000000000000, 
+	  0.34906585039886590 },
+  { 0.52729015917508748, 0.40000000000000013, 0.0000000000000000, 
+	  0.52359877559829882 },
+  { 0.70662374407341244, 0.40000000000000013, 0.0000000000000000, 
+	  0.69813170079773179 },
+  { 0.88859210497602159, 0.40000000000000013, 0.0000000000000000, 
+	  0.87266462599716477 },
+  { 1.0733136290471381, 0.40000000000000013, 0.0000000000000000, 
+	  1.0471975511965976 },
+  { 1.2605612170157066, 0.40000000000000013, 0.0000000000000000, 
+	  1.2217304763960306 },
+  { 1.4497513956433439, 0.40000000000000013, 0.0000000000000000, 
+	  1.3962634015954636 },
+  { 1.6399998658645112, 0.40000000000000013, 0.0000000000000000, 
+	  1.5707963267948966 },
+};
+const double toler131 = 2.5000000000000020e-13;
+
+// Test data for k=0.40000000000000013, nu=0.10000000000000001.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 1.0263824105456986e-15
+// mean(f - f_Boost): 1.7486012637846215e-16
+// variance(f - f_Boost): 3.1664095331106078e-31
+// stddev(f - f_Boost): 5.6270858649132121e-16
+const testcase_ellint_3<double>
+data132[10] =
+{
+  { 0.0000000000000000, 0.40000000000000013, 0.10000000000000001, 
+	  0.0000000000000000 },
+  { 0.17485086590796767, 0.40000000000000013, 0.10000000000000001, 
+	  0.17453292519943295 },
+  { 0.35158366412506992, 0.40000000000000013, 0.10000000000000001, 
+	  0.34906585039886590 },
+  { 0.53194731675711726, 0.40000000000000013, 0.10000000000000001, 
+	  0.52359877559829882 },
+  { 0.71740615528010931, 0.40000000000000013, 0.10000000000000001, 
+	  0.69813170079773179 },
+  { 0.90896157773487030, 0.40000000000000013, 0.10000000000000001, 
+	  0.87266462599716477 },
+  { 1.1069605483834348, 0.40000000000000013, 0.10000000000000001, 
+	  1.0471975511965976 },
+  { 1.3109353428823001, 0.40000000000000013, 0.10000000000000001, 
+	  1.2217304763960306 },
+  { 1.5195460789903450, 0.40000000000000013, 0.10000000000000001, 
+	  1.3962634015954636 },
+  { 1.7306968836847190, 0.40000000000000013, 0.10000000000000001, 
+	  1.5707963267948966 },
+};
+const double toler132 = 2.5000000000000020e-13;
+
+// Test data for k=0.40000000000000013, nu=0.20000000000000001.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 9.6644296021947179e-16
+// mean(f - f_Boost): 2.0816681711721685e-16
+// variance(f - f_Boost): 3.0360740073926687e-31
+// stddev(f - f_Boost): 5.5100580826273227e-16
+const testcase_ellint_3<double>
+data133[10] =
+{
+  { 0.0000000000000000, 0.40000000000000013, 0.20000000000000001, 
+	  0.0000000000000000 },
+  { 0.17502822886437389, 0.40000000000000013, 0.20000000000000001, 
+	  0.17453292519943295 },
+  { 0.35300530062530805, 0.40000000000000013, 0.20000000000000001, 
+	  0.34906585039886590 },
+  { 0.53675259548210896, 0.40000000000000013, 0.20000000000000001, 
+	  0.52359877559829882 },
+  { 0.72878006428676934, 0.40000000000000013, 0.20000000000000001, 
+	  0.69813170079773179 },
+  { 0.93100219010583574, 0.40000000000000013, 0.20000000000000001, 
+	  0.87266462599716477 },
+  { 1.1443487271187611, 0.40000000000000013, 0.20000000000000001, 
+	  1.0471975511965976 },
+  { 1.3683427764108813, 0.40000000000000013, 0.20000000000000001, 
+	  1.2217304763960306 },
+  { 1.6008221459300933, 0.40000000000000013, 0.20000000000000001, 
+	  1.3962634015954636 },
+  { 1.8380358826317627, 0.40000000000000013, 0.20000000000000001, 
+	  1.5707963267948966 },
+};
+const double toler133 = 2.5000000000000020e-13;
+
+// Test data for k=0.40000000000000013, nu=0.30000000000000004.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 9.0271556462838835e-16
+// mean(f - f_Boost): 2.0816681711721685e-16
+// variance(f - f_Boost): 3.0360740073926687e-31
+// stddev(f - f_Boost): 5.5100580826273227e-16
+const testcase_ellint_3<double>
+data134[10] =
+{
+  { 0.0000000000000000, 0.40000000000000013, 0.30000000000000004, 
+	  0.0000000000000000 },
+  { 0.17520623975982899, 0.40000000000000013, 0.30000000000000004, 
+	  0.17453292519943295 },
+  { 0.35444766141612105, 0.40000000000000013, 0.30000000000000004, 
+	  0.34906585039886590 },
+  { 0.54171455841536009, 0.40000000000000013, 0.30000000000000004, 
+	  0.52359877559829882 },
+  { 0.74080517001084012, 0.40000000000000013, 0.30000000000000004, 
+	  0.69813170079773179 },
+  { 0.95496950509296574, 0.40000000000000013, 0.30000000000000004, 
+	  0.87266462599716477 },
+  { 1.1862627879844718, 0.40000000000000013, 0.30000000000000004, 
+	  1.0471975511965976 },
+  { 1.4346501803799458, 0.40000000000000013, 0.30000000000000004, 
+	  1.2217304763960306 },
+  { 1.6971744798077699, 0.40000000000000013, 0.30000000000000004, 
+	  1.3962634015954636 },
+  { 1.9677924132520139, 0.40000000000000013, 0.30000000000000004, 
+	  1.5707963267948966 },
+};
+const double toler134 = 2.5000000000000020e-13;
+
+// Test data for k=0.40000000000000013, nu=0.40000000000000002.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 8.3436329231972794e-16
+// mean(f - f_Boost): 2.3037127760972000e-16
+// variance(f - f_Boost): 2.9507053793392374e-31
+// stddev(f - f_Boost): 5.4320395611033958e-16
+const testcase_ellint_3<double>
+data135[10] =
+{
+  { 0.0000000000000000, 0.40000000000000013, 0.40000000000000002, 
+	  0.0000000000000000 },
+  { 0.17538490283034375, 0.40000000000000013, 0.40000000000000002, 
+	  0.17453292519943295 },
+  { 0.35591129064319948, 0.40000000000000013, 0.40000000000000002, 
+	  0.34906585039886590 },
+  { 0.54684250413264535, 0.40000000000000013, 0.40000000000000002, 
+	  0.52359877559829882 },
+  { 0.75355027742668290, 0.40000000000000013, 0.40000000000000002, 
+	  0.69813170079773179 },
+  { 0.98117935026780634, 0.40000000000000013, 0.40000000000000002, 
+	  0.87266462599716477 },
+  { 1.2337464222030736, 0.40000000000000013, 0.40000000000000002, 
+	  1.0471975511965976 },
+  { 1.5125183419289221, 0.40000000000000013, 0.40000000000000002, 
+	  1.2217304763960306 },
+  { 1.8140224451130313, 0.40000000000000013, 0.40000000000000002, 
+	  1.3962634015954636 },
+  { 2.1289968719280026, 0.40000000000000013, 0.40000000000000002, 
+	  1.5707963267948966 },
+};
+const double toler135 = 2.5000000000000020e-13;
+
+// Test data for k=0.40000000000000013, nu=0.50000000000000000.
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 5.7013794022122431e-16
+// mean(f - f_Boost): 2.3037127760972000e-16
+// variance(f - f_Boost): 1.4989821857033475e-31
+// stddev(f - f_Boost): 3.8716691306248618e-16
+const testcase_ellint_3<double>
+data136[10] =
+{
+  { 0.0000000000000000, 0.40000000000000013, 0.50000000000000000, 
+	  0.0000000000000000 },
+  { 0.17556422235224273, 0.40000000000000013, 0.50000000000000000, 
+	  0.17453292519943295 },
+  { 0.35739675341763921, 0.40000000000000013, 0.50000000000000000, 
+	  0.34906585039886590 },
+  { 0.55214655195037188, 0.40000000000000013, 0.50000000000000000, 
+	  0.52359877559829882 },
+  { 0.76709520942047438, 0.40000000000000013, 0.50000000000000000, 
+	  0.69813170079773179 },
+  { 1.0100278761577499, 0.40000000000000013, 0.50000000000000000, 
+	  0.87266462599716477 },
+  { 1.2882265661384342, 0.40000000000000013, 0.50000000000000000, 
+	  1.0471975511965976 },
+  { 1.6059059780051876, 0.40000000000000013, 0.50000000000000000, 
+	  1.2217304763960306 },
+  { 1.9600182740224081, 0.40000000000000013, 0.50000000000000000, 
+	  1.3962634015954636 },
+  { 2.3367461373176512, 0.40000000000000013, 0.50000000000000000, 
+	  1.5707963267948966 },
+};
+const double toler136 = 2.5000000000000020e-13;
+
+// Test data for k=0.40000000000000013, nu=0.60000000000000009.
+// max(|f - f_Boost|): 2.2204460492503131e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 8.4792115132836117e-16
+// mean(f - f_Boost): 2.3037127760972000e-16
+// variance(f - f_Boost): 4.8893797490374802e-31
+// stddev(f - f_Boost): 6.9924099915819294e-16
+const testcase_ellint_3<double>
+data137[10] =
+{
+  { 0.0000000000000000, 0.40000000000000013, 0.60000000000000009, 
+	  0.0000000000000000 },
+  { 0.17574420264267029, 0.40000000000000013, 0.60000000000000009, 
+	  0.17453292519943295 },
+  { 0.35890463689046265, 0.40000000000000013, 0.60000000000000009, 
+	  0.34906585039886590 },
+  { 0.55763773975194486, 0.40000000000000013, 0.60000000000000009, 
+	  0.52359877559829882 },
+  { 0.78153324227761267, 0.40000000000000013, 0.60000000000000009, 
+	  0.69813170079773179 },
+  { 1.0420205885765887, 0.40000000000000013, 0.60000000000000009, 
+	  0.87266462599716477 },
+  { 1.3517205230381770, 0.40000000000000013, 0.60000000000000009, 
+	  1.0471975511965976 },
+  { 1.7210360970313896, 0.40000000000000013, 0.60000000000000009, 
+	  1.2217304763960306 },
+  { 2.1500780510169246, 0.40000000000000013, 0.60000000000000009, 
+	  1.3962634015954636 },
+  { 2.6186940209850191, 0.40000000000000013, 0.60000000000000009, 
+	  1.5707963267948966 },
+};
+const double toler137 = 2.5000000000000020e-13;
+
+// Test data for k=0.40000000000000013, nu=0.70000000000000007.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 5.8573292020719759e-16
+// mean(f - f_Boost): 2.2759572004815707e-16
+// variance(f - f_Boost): 2.9613098824898137e-31
+// stddev(f - f_Boost): 5.4417918762938862e-16
+const testcase_ellint_3<double>
+data138[10] =
+{
+  { 0.0000000000000000, 0.40000000000000013, 0.70000000000000007, 
+	  0.0000000000000000 },
+  { 0.17592484806010436, 0.40000000000000013, 0.70000000000000007, 
+	  0.17453292519943295 },
+  { 0.36043555139631439, 0.40000000000000013, 0.70000000000000007, 
+	  0.34906585039886590 },
+  { 0.56332813669944881, 0.40000000000000013, 0.70000000000000007, 
+	  0.52359877559829882 },
+  { 0.79697424562157548, 0.40000000000000013, 0.70000000000000007, 
+	  0.69813170079773179 },
+  { 1.0778155987523672, 0.40000000000000013, 0.70000000000000007, 
+	  0.87266462599716477 },
+  { 1.4272018169896268, 0.40000000000000013, 0.70000000000000007, 
+	  1.0471975511965976 },
+  { 1.8684377907453382, 0.40000000000000013, 0.70000000000000007, 
+	  1.2217304763960306 },
+  { 2.4128677409207473, 0.40000000000000013, 0.70000000000000007, 
+	  1.3962634015954636 },
+  { 3.0327078743873246, 0.40000000000000013, 0.70000000000000007, 
+	  1.5707963267948966 },
+};
+const double toler138 = 2.5000000000000020e-13;
+
+// Test data for k=0.40000000000000013, nu=0.80000000000000004.
+// max(|f - f_Boost|): 3.5527136788005009e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 9.5273712585384737e-16
+// mean(f - f_Boost): 4.5241588253475131e-16
+// variance(f - f_Boost): 1.1866477068555882e-30
+// stddev(f - f_Boost): 1.0893336067778265e-15
+const testcase_ellint_3<double>
+data139[10] =
+{
+  { 0.0000000000000000, 0.40000000000000013, 0.80000000000000004, 
+	  0.0000000000000000 },
+  { 0.17610616300487833, 0.40000000000000013, 0.80000000000000004, 
+	  0.17453292519943295 },
+  { 0.36199013167171978, 0.40000000000000013, 0.80000000000000004, 
+	  0.34906585039886590 },
+  { 0.56923097361842434, 0.40000000000000013, 0.80000000000000004, 
+	  0.52359877559829882 },
+  { 0.81354878456624347, 0.40000000000000013, 0.80000000000000004, 
+	  0.69813170079773179 },
+  { 1.1182902719261825, 0.40000000000000013, 0.80000000000000004, 
+	  0.87266462599716477 },
+  { 1.5192950589409022, 0.40000000000000013, 0.80000000000000004, 
+	  1.0471975511965976 },
+  { 2.0678761710223981, 0.40000000000000013, 0.80000000000000004, 
+	  1.2217304763960306 },
+  { 2.8135222249879788, 0.40000000000000013, 0.80000000000000004, 
+	  1.3962634015954636 },
+  { 3.7289548002199902, 0.40000000000000013, 0.80000000000000004, 
+	  1.5707963267948966 },
+};
+const double toler139 = 2.5000000000000020e-13;
+
+// Test data for k=0.40000000000000013, nu=0.90000000000000002.
+// max(|f - f_Boost|): 6.2172489379008766e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 1.1718379478872251e-15
+// mean(f - f_Boost): 8.4099394115355610e-16
+// variance(f - f_Boost): 3.5684096037099424e-30
+// stddev(f - f_Boost): 1.8890234523980751e-15
+const testcase_ellint_3<double>
+data140[10] =
+{
+  { 0.0000000000000000, 0.40000000000000013, 0.90000000000000002, 
+	  0.0000000000000000 },
+  { 0.17628815191971123, 0.40000000000000013, 0.90000000000000002, 
+	  0.17453292519943295 },
+  { 0.36356903815378772, 0.40000000000000013, 0.90000000000000002, 
+	  0.34906585039886590 },
+  { 0.57536079447000310, 0.40000000000000013, 0.90000000000000002, 
+	  0.52359877559829882 },
+  { 0.83141355850172571, 0.40000000000000013, 0.90000000000000002, 
+	  0.69813170079773179 },
+  { 1.1646481598721361, 0.40000000000000013, 0.90000000000000002, 
+	  0.87266462599716477 },
+  { 1.6357275034001995, 0.40000000000000013, 0.90000000000000002, 
+	  1.0471975511965976 },
+  { 2.3628787566572402, 0.40000000000000013, 0.90000000000000002, 
+	  1.2217304763960306 },
+  { 3.5521010369134962, 0.40000000000000013, 0.90000000000000002, 
+	  1.3962634015954636 },
+  { 5.3055535102872513, 0.40000000000000013, 0.90000000000000002, 
+	  1.5707963267948966 },
+};
+const double toler140 = 2.5000000000000020e-13;
 
 // Test data for k=0.50000000000000000, nu=0.0000000000000000.
-testcase_ellint_3<double> data141[] = {
-  { -0.0000000000000000, 0.50000000000000000, 0.0000000000000000,
-          0.0000000000000000 },
-  { 0.17475385514035785, 0.50000000000000000, 0.0000000000000000,
-          0.17453292519943295 },
-  { 0.35081868470101585, 0.50000000000000000, 0.0000000000000000,
-          0.34906585039886590 },
-  { 0.52942862705190585, 0.50000000000000000, 0.0000000000000000,
-          0.52359877559829882 },
-  { 0.71164727562630326, 0.50000000000000000, 0.0000000000000000,
-          0.69813170079773179 },
-  { 0.89824523594227768, 0.50000000000000000, 0.0000000000000000,
-          0.87266462599716477 },
-  { 1.0895506700518851, 0.50000000000000000, 0.0000000000000000,
-          1.0471975511965976 },
-  { 1.2853005857432933, 0.50000000000000000, 0.0000000000000000,
-          1.2217304763960306 },
-  { 1.4845545520549484, 0.50000000000000000, 0.0000000000000000,
-          1.3962634015954636 },
-  { 1.6857503548125963, 0.50000000000000000, 0.0000000000000000,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.50000000000000000, nu=0.0000000000000000.
-template <typename Tp>
-void test141()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data141)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data141[i].k), Tp(data141[i].nu),
-                   Tp(data141[i].phi));
-      const Tp f0 = data141[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.4551389361831220e-16
+// mean(f - f_Boost): -1.3877787807814457e-17
+// variance(f - f_Boost): 2.5893058141206173e-32
+// stddev(f - f_Boost): 1.6091320064309879e-16
+const testcase_ellint_3<double>
+data141[10] =
+{
+  { 0.0000000000000000, 0.50000000000000000, 0.0000000000000000, 
+	  0.0000000000000000 },
+  { 0.17475385514035785, 0.50000000000000000, 0.0000000000000000, 
+	  0.17453292519943295 },
+  { 0.35081868470101579, 0.50000000000000000, 0.0000000000000000, 
+	  0.34906585039886590 },
+  { 0.52942862705190574, 0.50000000000000000, 0.0000000000000000, 
+	  0.52359877559829882 },
+  { 0.71164727562630326, 0.50000000000000000, 0.0000000000000000, 
+	  0.69813170079773179 },
+  { 0.89824523594227768, 0.50000000000000000, 0.0000000000000000, 
+	  0.87266462599716477 },
+  { 1.0895506700518853, 0.50000000000000000, 0.0000000000000000, 
+	  1.0471975511965976 },
+  { 1.2853005857432933, 0.50000000000000000, 0.0000000000000000, 
+	  1.2217304763960306 },
+  { 1.4845545520549488, 0.50000000000000000, 0.0000000000000000, 
+	  1.3962634015954636 },
+  { 1.6857503548125961, 0.50000000000000000, 0.0000000000000000, 
+	  1.5707963267948966 },
+};
+const double toler141 = 2.5000000000000020e-13;
 
 // Test data for k=0.50000000000000000, nu=0.10000000000000001.
-testcase_ellint_3<double> data142[] = {
-  { -0.0000000000000000, 0.50000000000000000, 0.10000000000000001,
-          0.0000000000000000 },
-  { 0.17457763120814676, 0.50000000000000000, 0.10000000000000001,
-          0.17453292519943295 },
-  { 0.34943246340849154, 0.50000000000000000, 0.10000000000000001,
-          0.34906585039886590 },
-  { 0.52487937869610801, 0.50000000000000000, 0.10000000000000001,
-          0.52359877559829882 },
-  { 0.70127785096388395, 0.50000000000000000, 0.10000000000000001,
-          0.69813170079773179 },
-  { 0.87898815988624479, 0.50000000000000000, 0.10000000000000001,
-          0.87266462599716477 },
-  { 1.0582764576094172, 0.50000000000000000, 0.10000000000000001,
-          1.0471975511965976 },
-  { 1.2391936844060207, 0.50000000000000000, 0.10000000000000001,
-          1.2217304763960306 },
-  { 1.4214793542995841, 0.50000000000000000, 0.10000000000000001,
-          1.3962634015954636 },
-  { 1.6045524936084892, 0.50000000000000000, 0.10000000000000001,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.50000000000000000, nu=0.10000000000000001.
-template <typename Tp>
-void test142()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data142)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data142[i].k), Tp(data142[i].nu),
-                   Tp(data142[i].phi));
-      const Tp f0 = data142[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.7416868347177582e-16
+// mean(f - f_Boost): 2.7755575615628915e-18
+// variance(f - f_Boost): 5.4326441655972001e-32
+// stddev(f - f_Boost): 2.3308033305273100e-16
+const testcase_ellint_3<double>
+data142[10] =
+{
+  { 0.0000000000000000, 0.50000000000000000, 0.10000000000000001, 
+	  0.0000000000000000 },
+  { 0.17493071928248824, 0.50000000000000000, 0.10000000000000001, 
+	  0.17453292519943295 },
+  { 0.35222467688034798, 0.50000000000000000, 0.10000000000000001, 
+	  0.34906585039886590 },
+  { 0.53411928652008112, 0.50000000000000000, 0.10000000000000001, 
+	  0.52359877559829882 },
+  { 0.72256398117177589, 0.50000000000000000, 0.10000000000000001, 
+	  0.69813170079773179 },
+  { 0.91899583232771009, 0.50000000000000000, 0.10000000000000001, 
+	  0.87266462599716477 },
+  { 1.1240549163055360, 0.50000000000000000, 0.10000000000000001, 
+	  1.0471975511965976 },
+  { 1.3372938086286021, 0.50000000000000000, 0.10000000000000001, 
+	  1.2217304763960306 },
+  { 1.5570024469132429, 0.50000000000000000, 0.10000000000000001, 
+	  1.3962634015954636 },
+  { 1.7803034946545480, 0.50000000000000000, 0.10000000000000001, 
+	  1.5707963267948966 },
+};
+const double toler142 = 2.5000000000000020e-13;
 
 // Test data for k=0.50000000000000000, nu=0.20000000000000001.
-testcase_ellint_3<double> data143[] = {
-  { -0.0000000000000000, 0.50000000000000000, 0.20000000000000001,
-          0.0000000000000000 },
-  { 0.17440204336345433, 0.50000000000000000, 0.20000000000000001,
-          0.17453292519943295 },
-  { 0.34806552388338824, 0.50000000000000000, 0.20000000000000001,
-          0.34906585039886590 },
-  { 0.52046416757129821, 0.50000000000000000, 0.20000000000000001,
-          0.52359877559829882 },
-  { 0.69140924550993876, 0.50000000000000000, 0.20000000000000001,
-          0.69813170079773179 },
-  { 0.86104678636125520, 0.50000000000000000, 0.20000000000000001,
-          0.87266462599716477 },
-  { 1.0297439459053981, 0.50000000000000000, 0.20000000000000001,
-          1.0471975511965976 },
-  { 1.1979214112912036, 0.50000000000000000, 0.20000000000000001,
-          1.2217304763960306 },
-  { 1.3659033858648930, 0.50000000000000000, 0.20000000000000001,
-          1.3962634015954636 },
-  { 1.5338490483665983, 0.50000000000000000, 0.20000000000000001,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.50000000000000000, nu=0.20000000000000001.
-template <typename Tp>
-void test143()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data143)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data143[i].k), Tp(data143[i].nu),
-                   Tp(data143[i].phi));
-      const Tp f0 = data143[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.50000000000000000, nu=0.29999999999999999.
-testcase_ellint_3<double> data144[] = {
-  { -0.0000000000000000, 0.50000000000000000, 0.29999999999999999,
-          0.0000000000000000 },
-  { 0.17422708752228896, 0.50000000000000000, 0.29999999999999999,
-          0.17453292519943295 },
-  { 0.34671739434855858, 0.50000000000000000, 0.29999999999999999,
-          0.34906585039886590 },
-  { 0.51617616305641889, 0.50000000000000000, 0.29999999999999999,
-          0.52359877559829882 },
-  { 0.68200047612545178, 0.50000000000000000, 0.29999999999999999,
-          0.69813170079773179 },
-  { 0.84427217869498372, 0.50000000000000000, 0.29999999999999999,
-          0.87266462599716477 },
-  { 1.0035637821389782, 0.50000000000000000, 0.29999999999999999,
-          1.0471975511965976 },
-  { 1.1606800483933113, 0.50000000000000000, 0.29999999999999999,
-          1.2217304763960306 },
-  { 1.3164407134643459, 0.50000000000000000, 0.29999999999999999,
-          1.3962634015954636 },
-  { 1.4715681939859637, 0.50000000000000000, 0.29999999999999999,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.50000000000000000, nu=0.29999999999999999.
-template <typename Tp>
-void test144()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data144)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data144[i].k), Tp(data144[i].nu),
-                   Tp(data144[i].phi));
-      const Tp f0 = data144[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.1198767993730867e-16
+// mean(f - f_Boost): 2.7755575615628914e-17
+// variance(f - f_Boost): 5.0311947683004831e-32
+// stddev(f - f_Boost): 2.2430324938128922e-16
+const testcase_ellint_3<double>
+data143[10] =
+{
+  { 0.0000000000000000, 0.50000000000000000, 0.20000000000000001, 
+	  0.0000000000000000 },
+  { 0.17510822779582402, 0.50000000000000000, 0.20000000000000001, 
+	  0.17453292519943295 },
+  { 0.35365094725531487, 0.50000000000000000, 0.20000000000000001, 
+	  0.34906585039886590 },
+  { 0.53895933237328697, 0.50000000000000000, 0.20000000000000001, 
+	  0.52359877559829882 },
+  { 0.73408090840070794, 0.50000000000000000, 0.20000000000000001, 
+	  0.69813170079773179 },
+  { 0.94145442818535396, 0.50000000000000000, 0.20000000000000001, 
+	  0.87266462599716477 },
+  { 1.1624120186296487, 0.50000000000000000, 0.20000000000000001, 
+	  1.0471975511965976 },
+  { 1.3965823372867114, 0.50000000000000000, 0.20000000000000001, 
+	  1.2217304763960306 },
+  { 1.6414308440430099, 0.50000000000000000, 0.20000000000000001, 
+	  1.3962634015954636 },
+  { 1.8922947612264018, 0.50000000000000000, 0.20000000000000001, 
+	  1.5707963267948966 },
+};
+const double toler143 = 2.5000000000000020e-13;
+
+// Test data for k=0.50000000000000000, nu=0.30000000000000004.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.3800262770228813e-16
+// mean(f - f_Boost): 5.8286708792820721e-17
+// variance(f - f_Boost): 8.5027191584278157e-32
+// stddev(f - f_Boost): 2.9159422419567599e-16
+const testcase_ellint_3<double>
+data144[10] =
+{
+  { 0.0000000000000000, 0.50000000000000000, 0.30000000000000004, 
+	  0.0000000000000000 },
+  { 0.17528638488102041, 0.50000000000000000, 0.30000000000000004, 
+	  0.17453292519943295 },
+  { 0.35509802222332720, 0.50000000000000000, 0.30000000000000004, 
+	  0.34906585039886590 },
+  { 0.54395740731866193, 0.50000000000000000, 0.30000000000000004, 
+	  0.52359877559829882 },
+  { 0.74625871438752667, 0.50000000000000000, 0.30000000000000004, 
+	  0.69813170079773179 },
+  { 0.96588271186092023, 0.50000000000000000, 0.30000000000000004, 
+	  0.87266462599716477 },
+  { 1.2054319584357329, 0.50000000000000000, 0.30000000000000004, 
+	  1.0471975511965976 },
+  { 1.4651077994832871, 0.50000000000000000, 0.30000000000000004, 
+	  1.2217304763960306 },
+  { 1.7416018368052644, 0.50000000000000000, 0.30000000000000004, 
+	  1.3962634015954636 },
+  { 2.0277924458111314, 0.50000000000000000, 0.30000000000000004, 
+	  1.5707963267948966 },
+};
+const double toler144 = 2.5000000000000020e-13;
 
 // Test data for k=0.50000000000000000, nu=0.40000000000000002.
-testcase_ellint_3<double> data145[] = {
-  { -0.0000000000000000, 0.50000000000000000, 0.40000000000000002,
-          0.0000000000000000 },
-  { 0.17405275963859917, 0.50000000000000000, 0.40000000000000002,
-          0.17453292519943295 },
-  { 0.34538761957029329, 0.50000000000000000, 0.40000000000000002,
-          0.34906585039886590 },
-  { 0.51200902646603919, 0.50000000000000000, 0.40000000000000002,
-          0.52359877559829882 },
-  { 0.67301522212868792, 0.50000000000000000, 0.40000000000000002,
-          0.69813170079773179 },
-  { 0.82853844466313320, 0.50000000000000000, 0.40000000000000002,
-          0.87266462599716477 },
-  { 0.97942097862681488, 0.50000000000000000, 0.40000000000000002,
-          1.0471975511965976 },
-  { 1.1268429801220616, 0.50000000000000000, 0.40000000000000002,
-          1.2217304763960306 },
-  { 1.2720406704533922, 0.50000000000000000, 0.40000000000000002,
-          1.3962634015954636 },
-  { 1.4161679518465340, 0.50000000000000000, 0.40000000000000002,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.50000000000000000, nu=0.40000000000000002.
-template <typename Tp>
-void test145()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data145)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data145[i].k), Tp(data145[i].nu),
-                   Tp(data145[i].phi));
-      const Tp f0 = data145[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.0439932918341581e-16
+// mean(f - f_Boost): 3.0531133177191807e-17
+// variance(f - f_Boost): 9.0809736800018602e-32
+// stddev(f - f_Boost): 3.0134653938616686e-16
+const testcase_ellint_3<double>
+data145[10] =
+{
+  { 0.0000000000000000, 0.50000000000000000, 0.40000000000000002, 
+	  0.0000000000000000 },
+  { 0.17546519477859268, 0.50000000000000000, 0.40000000000000002, 
+	  0.17453292519943295 },
+  { 0.35656644822531680, 0.50000000000000000, 0.40000000000000002, 
+	  0.34906585039886590 },
+  { 0.54912289677411319, 0.50000000000000000, 0.40000000000000002, 
+	  0.52359877559829882 },
+  { 0.75916731611690047, 0.50000000000000000, 0.40000000000000002, 
+	  0.69813170079773179 },
+  { 0.99260415631328214, 0.50000000000000000, 0.40000000000000002, 
+	  0.87266462599716477 },
+  { 1.2541925856918670, 0.50000000000000000, 0.40000000000000002, 
+	  1.0471975511965976 },
+  { 1.5456393705347609, 0.50000000000000000, 0.40000000000000002, 
+	  1.2217304763960306 },
+  { 1.8631904972952076, 0.50000000000000000, 0.40000000000000002, 
+	  1.3962634015954636 },
+  { 2.1962905366178065, 0.50000000000000000, 0.40000000000000002, 
+	  1.5707963267948966 },
+};
+const double toler145 = 2.5000000000000020e-13;
 
 // Test data for k=0.50000000000000000, nu=0.50000000000000000.
-testcase_ellint_3<double> data146[] = {
-  { -0.0000000000000000, 0.50000000000000000, 0.50000000000000000,
-          0.0000000000000000 },
-  { 0.17387905570381157, 0.50000000000000000, 0.50000000000000000,
-          0.17453292519943295 },
-  { 0.34407576010465207, 0.50000000000000000, 0.50000000000000000,
-          0.34906585039886590 },
-  { 0.50795686560160835, 0.50000000000000000, 0.50000000000000000,
-          0.52359877559829882 },
-  { 0.66442115453330175, 0.50000000000000000, 0.50000000000000000,
-          0.69813170079773179 },
-  { 0.81373829119355345, 0.50000000000000000, 0.50000000000000000,
-          0.87266462599716477 },
-  { 0.95705743313235825, 0.50000000000000000, 0.50000000000000000,
-          1.0471975511965976 },
-  { 1.0959131991362556, 0.50000000000000000, 0.50000000000000000,
-          1.2217304763960306 },
-  { 1.2318900529754597, 0.50000000000000000, 0.50000000000000000,
-          1.3962634015954636 },
-  { 1.3664739530045971, 0.50000000000000000, 0.50000000000000000,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.50000000000000000, nu=0.50000000000000000.
-template <typename Tp>
-void test146()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data146)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data146[i].k), Tp(data146[i].nu),
-                   Tp(data146[i].phi));
-      const Tp f0 = data146[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.50000000000000000, nu=0.59999999999999998.
-testcase_ellint_3<double> data147[] = {
-  { -0.0000000000000000, 0.50000000000000000, 0.59999999999999998,
-          0.0000000000000000 },
-  { 0.17370597174637581, 0.50000000000000000, 0.59999999999999998,
-          0.17453292519943295 },
-  { 0.34278139158591414, 0.50000000000000000, 0.59999999999999998,
-          0.34906585039886590 },
-  { 0.50401419439302719, 0.50000000000000000, 0.59999999999999998,
-          0.52359877559829882 },
-  { 0.65618938076167221, 0.50000000000000000, 0.59999999999999998,
-          0.69813170079773179 },
-  { 0.79977959248855424, 0.50000000000000000, 0.59999999999999998,
-          0.87266462599716477 },
-  { 0.93625925190753545, 0.50000000000000000, 0.59999999999999998,
-          1.0471975511965976 },
-  { 1.0674905658379710, 0.50000000000000000, 0.59999999999999998,
-          1.2217304763960306 },
-  { 1.1953481298023048, 0.50000000000000000, 0.59999999999999998,
-          1.3962634015954636 },
-  { 1.3215740290190876, 0.50000000000000000, 0.59999999999999998,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.50000000000000000, nu=0.59999999999999998.
-template <typename Tp>
-void test147()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data147)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data147[i].k), Tp(data147[i].nu),
-                   Tp(data147[i].phi));
-      const Tp f0 = data147[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.50000000000000000, nu=0.69999999999999996.
-testcase_ellint_3<double> data148[] = {
-  { -0.0000000000000000, 0.50000000000000000, 0.69999999999999996,
-          0.0000000000000000 },
-  { 0.17353350383131641, 0.50000000000000000, 0.69999999999999996,
-          0.17453292519943295 },
-  { 0.34150410405436771, 0.50000000000000000, 0.69999999999999996,
-          0.34906585039886590 },
-  { 0.50017589696443487, 0.50000000000000000, 0.69999999999999996,
-          0.52359877559829882 },
-  { 0.64829398188419962, 0.50000000000000000, 0.69999999999999996,
-          0.69813170079773179 },
-  { 0.78658270782402073, 0.50000000000000000, 0.69999999999999996,
-          0.87266462599716477 },
-  { 0.91684738336675053, 0.50000000000000000, 0.69999999999999996,
-          1.0471975511965976 },
-  { 1.0412486789555937, 0.50000000000000000, 0.69999999999999996,
-          1.2217304763960306 },
-  { 1.1619021847612001, 0.50000000000000000, 0.69999999999999996,
-          1.3962634015954636 },
-  { 1.2807475181182502, 0.50000000000000000, 0.69999999999999996,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.50000000000000000, nu=0.69999999999999996.
-template <typename Tp>
-void test148()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data148)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data148[i].k), Tp(data148[i].nu),
-                   Tp(data148[i].phi));
-      const Tp f0 = data148[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.6797816859260978e-16
+// mean(f - f_Boost): 9.4368957093138303e-17
+// variance(f - f_Boost): 7.7794254682023874e-32
+// stddev(f - f_Boost): 2.7891621444803792e-16
+const testcase_ellint_3<double>
+data146[10] =
+{
+  { 0.0000000000000000, 0.50000000000000000, 0.50000000000000000, 
+	  0.0000000000000000 },
+  { 0.17564466176941509, 0.50000000000000000, 0.50000000000000000, 
+	  0.17453292519943295 },
+  { 0.35805679276065394, 0.50000000000000000, 0.50000000000000000, 
+	  0.34906585039886590 },
+  { 0.55446601496200032, 0.50000000000000000, 0.50000000000000000, 
+	  0.52359877559829882 },
+  { 0.77288783578259013, 0.50000000000000000, 0.50000000000000000, 
+	  0.69813170079773179 },
+  { 1.0220246013918972, 0.50000000000000000, 0.50000000000000000, 
+	  0.87266462599716477 },
+  { 1.3101681612463965, 0.50000000000000000, 0.50000000000000000, 
+	  1.0471975511965976 },
+  { 1.6422994881851025, 0.50000000000000000, 0.50000000000000000, 
+	  1.2217304763960306 },
+  { 2.0152636030998816, 0.50000000000000000, 0.50000000000000000, 
+	  1.3962634015954636 },
+  { 2.4136715042011945, 0.50000000000000000, 0.50000000000000000, 
+	  1.5707963267948966 },
+};
+const double toler146 = 2.5000000000000020e-13;
+
+// Test data for k=0.50000000000000000, nu=0.60000000000000009.
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.9178421578645735e-16
+// mean(f - f_Boost): 1.3322676295501878e-16
+// variance(f - f_Boost): 1.7749370367472766e-31
+// stddev(f - f_Boost): 4.2130001622920411e-16
+const testcase_ellint_3<double>
+data147[10] =
+{
+  { 0.0000000000000000, 0.50000000000000000, 0.60000000000000009, 
+	  0.0000000000000000 },
+  { 0.17582479017522740, 0.50000000000000000, 0.60000000000000009, 
+	  0.17453292519943295 },
+  { 0.35956964546660036, 0.50000000000000000, 0.60000000000000009, 
+	  0.34906585039886590 },
+  { 0.55999790372984193, 0.50000000000000000, 0.60000000000000009, 
+	  0.52359877559829882 },
+  { 0.78751507911209895, 0.50000000000000000, 0.60000000000000009, 
+	  0.69813170079773179 },
+  { 1.0546620505035220, 0.50000000000000000, 0.60000000000000009, 
+	  0.87266462599716477 },
+  { 1.3754438357425935, 0.50000000000000000, 0.60000000000000009, 
+	  1.0471975511965976 },
+  { 1.7615727400820127, 0.50000000000000000, 0.60000000000000009, 
+	  1.2217304763960306 },
+  { 2.2134638067565242, 0.50000000000000000, 0.60000000000000009, 
+	  1.3962634015954636 },
+  { 2.7090491861753558, 0.50000000000000000, 0.60000000000000009, 
+	  1.5707963267948966 },
+};
+const double toler147 = 2.5000000000000020e-13;
+
+// Test data for k=0.50000000000000000, nu=0.70000000000000007.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.0745105182189226e-16
+// mean(f - f_Boost): 4.1633363423443370e-17
+// variance(f - f_Boost): 1.9996383743576116e-32
+// stddev(f - f_Boost): 1.4140857026211713e-16
+const testcase_ellint_3<double>
+data148[10] =
+{
+  { 0.0000000000000000, 0.50000000000000000, 0.70000000000000007, 
+	  0.0000000000000000 },
+  { 0.17600558435914915, 0.50000000000000000, 0.70000000000000007, 
+	  0.17453292519943295 },
+  { 0.36110561926726259, 0.50000000000000000, 0.70000000000000007, 
+	  0.34906585039886590 },
+  { 0.56573074641137111, 0.50000000000000000, 0.70000000000000007, 
+	  0.52359877559829882 },
+  { 0.80316073084237205, 0.50000000000000000, 0.70000000000000007, 
+	  0.69813170079773179 },
+  { 1.0911910688131461, 0.50000000000000000, 0.70000000000000007, 
+	  0.87266462599716477 },
+  { 1.4530946406380640, 0.50000000000000000, 0.70000000000000007, 
+	  1.0471975511965976 },
+  { 1.9144386536785372, 0.50000000000000000, 0.70000000000000007, 
+	  1.2217304763960306 },
+  { 2.4878788958234970, 0.50000000000000000, 0.70000000000000007, 
+	  1.3962634015954636 },
+  { 3.1433945297859225, 0.50000000000000000, 0.70000000000000007, 
+	  1.5707963267948966 },
+};
+const double toler148 = 2.5000000000000020e-13;
 
 // Test data for k=0.50000000000000000, nu=0.80000000000000004.
-testcase_ellint_3<double> data149[] = {
-  { -0.0000000000000000, 0.50000000000000000, 0.80000000000000004,
-          0.0000000000000000 },
-  { 0.17336164805979126, 0.50000000000000000, 0.80000000000000004,
-          0.17453292519943295 },
-  { 0.34024350132086773, 0.50000000000000000, 0.80000000000000004,
-          0.34906585039886590 },
-  { 0.49643719555734084, 0.50000000000000000, 0.80000000000000004,
-          0.52359877559829882 },
-  { 0.64071162456976150, 0.50000000000000000, 0.80000000000000004,
-          0.69813170079773179 },
-  { 0.77407836177211908, 0.50000000000000000, 0.80000000000000004,
-          0.87266462599716477 },
-  { 0.89867058251905652, 0.50000000000000000, 0.80000000000000004,
-          1.0471975511965976 },
-  { 1.0169181822134912, 0.50000000000000000, 0.80000000000000004,
-          1.2217304763960306 },
-  { 1.1311363312779448, 0.50000000000000000, 0.80000000000000004,
-          1.3962634015954636 },
-  { 1.2434165408189539, 0.50000000000000000, 0.80000000000000004,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.50000000000000000, nu=0.80000000000000004.
-template <typename Tp>
-void test149()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data149)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data149[i].k), Tp(data149[i].nu),
-                   Tp(data149[i].phi));
-      const Tp f0 = data149[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.4380477375534667e-16
+// mean(f - f_Boost): 2.3037127760972000e-16
+// variance(f - f_Boost): 1.4989821857033475e-31
+// stddev(f - f_Boost): 3.8716691306248618e-16
+const testcase_ellint_3<double>
+data149[10] =
+{
+  { 0.0000000000000000, 0.50000000000000000, 0.80000000000000004, 
+	  0.0000000000000000 },
+  { 0.17618704872620228, 0.50000000000000000, 0.80000000000000004, 
+	  0.17453292519943295 },
+  { 0.36266535159745827, 0.50000000000000000, 0.80000000000000004, 
+	  0.34906585039886590 },
+  { 0.57167789954529158, 0.50000000000000000, 0.80000000000000004, 
+	  0.52359877559829882 },
+  { 0.81995752984315018, 0.50000000000000000, 0.80000000000000004, 
+	  0.69813170079773179 },
+  { 1.1325112162158122, 0.50000000000000000, 0.80000000000000004, 
+	  0.87266462599716477 },
+  { 1.5479055930718042, 0.50000000000000000, 0.80000000000000004, 
+	  1.0471975511965976 },
+  { 2.1215243941010486, 0.50000000000000000, 0.80000000000000004, 
+	  1.2217304763960306 },
+  { 2.9069405767650132, 0.50000000000000000, 0.80000000000000004, 
+	  1.3962634015954636 },
+  { 3.8750701888108066, 0.50000000000000000, 0.80000000000000004, 
+	  1.5707963267948966 },
+};
+const double toler149 = 2.5000000000000020e-13;
 
 // Test data for k=0.50000000000000000, nu=0.90000000000000002.
-testcase_ellint_3<double> data150[] = {
-  { -0.0000000000000000, 0.50000000000000000, 0.90000000000000002,
-          0.0000000000000000 },
-  { 0.17319040056865681, 0.50000000000000000, 0.90000000000000002,
-          0.17453292519943295 },
-  { 0.33899920036578557, 0.50000000000000000, 0.90000000000000002,
-          0.34906585039886590 },
-  { 0.49279362182695186, 0.50000000000000000, 0.90000000000000002,
-          0.52359877559829882 },
-  { 0.63342123379746151, 0.50000000000000000, 0.90000000000000002,
-          0.69813170079773179 },
-  { 0.76220595179550321, 0.50000000000000000, 0.90000000000000002,
-          0.87266462599716477 },
-  { 0.88160004743532294, 0.50000000000000000, 0.90000000000000002,
-          1.0471975511965976 },
-  { 0.99427448642310134, 0.50000000000000000, 0.90000000000000002,
-          1.2217304763960306 },
-  { 1.1027091512470093, 0.50000000000000000, 0.90000000000000002,
-          1.3962634015954636 },
-  { 1.2091116095504744, 0.50000000000000000, 0.90000000000000002,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.50000000000000000, nu=0.90000000000000002.
-template <typename Tp>
-void test150()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data150)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data150[i].k), Tp(data150[i].nu),
-                   Tp(data150[i].phi));
-      const Tp f0 = data150[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.6192315188521289e-16
+// mean(f - f_Boost): 3.5249581031848718e-16
+// variance(f - f_Boost): 2.5029385557256515e-31
+// stddev(f - f_Boost): 5.0029376927217987e-16
+const testcase_ellint_3<double>
+data150[10] =
+{
+  { 0.0000000000000000, 0.50000000000000000, 0.90000000000000002, 
+	  0.0000000000000000 },
+  { 0.17636918772384180, 0.50000000000000000, 0.90000000000000002, 
+	  0.17453292519943295 },
+  { 0.36424950570740700, 0.50000000000000000, 0.90000000000000002, 
+	  0.34906585039886590 },
+  { 0.57785404590231426, 0.50000000000000000, 0.90000000000000002, 
+	  0.52359877559829882 },
+  { 0.83806480521716531, 0.50000000000000000, 0.90000000000000002, 
+	  0.69813170079773179 },
+  { 1.1798568683069752, 0.50000000000000000, 0.90000000000000002, 
+	  0.87266462599716477 },
+  { 1.6678766243739607, 0.50000000000000000, 0.90000000000000002, 
+	  1.0471975511965976 },
+  { 2.4282976450693483, 0.50000000000000000, 0.90000000000000002, 
+	  1.2217304763960306 },
+  { 3.6810787666126656, 0.50000000000000000, 0.90000000000000002, 
+	  1.3962634015954636 },
+  { 5.5355132096026454, 0.50000000000000000, 0.90000000000000002, 
+	  1.5707963267948966 },
+};
+const double toler150 = 2.5000000000000020e-13;
 
 // Test data for k=0.60000000000000009, nu=0.0000000000000000.
-testcase_ellint_3<double> data151[] = {
-  { -0.0000000000000000, 0.60000000000000009, 0.0000000000000000,
-          0.0000000000000000 },
-  { 0.17485154362988362, 0.60000000000000009, 0.0000000000000000,
-          0.17453292519943295 },
-  { 0.35160509865544326, 0.60000000000000009, 0.0000000000000000,
-          0.34906585039886590 },
-  { 0.53210652578446160, 0.60000000000000009, 0.0000000000000000,
-          0.52359877559829882 },
-  { 0.71805304664485670, 0.60000000000000009, 0.0000000000000000,
-          0.69813170079773179 },
-  { 0.91082759030195970, 0.60000000000000009, 0.0000000000000000,
-          0.87266462599716477 },
-  { 1.1112333229323366, 0.60000000000000009, 0.0000000000000000,
-          1.0471975511965976 },
-  { 1.3191461190365270, 0.60000000000000009, 0.0000000000000000,
-          1.2217304763960306 },
-  { 1.5332022105084775, 0.60000000000000009, 0.0000000000000000,
-          1.3962634015954636 },
-  { 1.7507538029157526, 0.60000000000000009, 0.0000000000000000,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.60000000000000009, nu=0.0000000000000000.
-template <typename Tp>
-void test151()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data151)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data151[i].k), Tp(data151[i].nu),
-                   Tp(data151[i].phi));
-      const Tp f0 = data151[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.3664899092028927e-16
+// mean(f - f_Boost): 3.0531133177191807e-17
+// variance(f - f_Boost): 7.8758646268991113e-33
+// stddev(f - f_Boost): 8.8746068233466605e-17
+const testcase_ellint_3<double>
+data151[10] =
+{
+  { 0.0000000000000000, 0.60000000000000009, 0.0000000000000000, 
+	  0.0000000000000000 },
+  { 0.17485154362988359, 0.60000000000000009, 0.0000000000000000, 
+	  0.17453292519943295 },
+  { 0.35160509865544320, 0.60000000000000009, 0.0000000000000000, 
+	  0.34906585039886590 },
+  { 0.53210652578446138, 0.60000000000000009, 0.0000000000000000, 
+	  0.52359877559829882 },
+  { 0.71805304664485659, 0.60000000000000009, 0.0000000000000000, 
+	  0.69813170079773179 },
+  { 0.91082759030195981, 0.60000000000000009, 0.0000000000000000, 
+	  0.87266462599716477 },
+  { 1.1112333229323361, 0.60000000000000009, 0.0000000000000000, 
+	  1.0471975511965976 },
+  { 1.3191461190365270, 0.60000000000000009, 0.0000000000000000, 
+	  1.2217304763960306 },
+  { 1.5332022105084779, 0.60000000000000009, 0.0000000000000000, 
+	  1.3962634015954636 },
+  { 1.7507538029157526, 0.60000000000000009, 0.0000000000000000, 
+	  1.5707963267948966 },
+};
+const double toler151 = 2.5000000000000020e-13;
 
 // Test data for k=0.60000000000000009, nu=0.10000000000000001.
-testcase_ellint_3<double> data152[] = {
-  { -0.0000000000000000, 0.60000000000000009, 0.10000000000000001,
-          0.0000000000000000 },
-  { 0.17467514275022014, 0.60000000000000009, 0.10000000000000001,
-          0.17453292519943295 },
-  { 0.35021333086258255, 0.60000000000000009, 0.10000000000000001,
-          0.34906585039886590 },
-  { 0.52751664092962713, 0.60000000000000009, 0.10000000000000001,
-          0.52359877559829882 },
-  { 0.70752126971957885, 0.60000000000000009, 0.10000000000000001,
-          0.69813170079773179 },
-  { 0.89111058756112871, 0.60000000000000009, 0.10000000000000001,
-          0.87266462599716477 },
-  { 1.0789241202877773, 0.60000000000000009, 0.10000000000000001,
-          1.0471975511965976 },
-  { 1.2710800210399946, 0.60000000000000009, 0.10000000000000001,
-          1.2217304763960306 },
-  { 1.4669060574440278, 0.60000000000000009, 0.10000000000000001,
-          1.3962634015954636 },
-  { 1.6648615773343014, 0.60000000000000009, 0.10000000000000001,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.60000000000000009, nu=0.10000000000000001.
-template <typename Tp>
-void test152()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data152)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data152[i].k), Tp(data152[i].nu),
-                   Tp(data152[i].phi));
-      const Tp f0 = data152[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.2335247010355137e-16
+// mean(f - f_Boost): 8.6042284408449634e-17
+// variance(f - f_Boost): 2.2835347143080263e-33
+// stddev(f - f_Boost): 4.7786344433405099e-17
+const testcase_ellint_3<double>
+data152[10] =
+{
+  { 0.0000000000000000, 0.60000000000000009, 0.10000000000000001, 
+	  0.0000000000000000 },
+  { 0.17502858548476194, 0.60000000000000009, 0.10000000000000001, 
+	  0.17453292519943295 },
+  { 0.35301673150537388, 0.60000000000000009, 0.10000000000000001, 
+	  0.34906585039886590 },
+  { 0.53683932476326812, 0.60000000000000009, 0.10000000000000001, 
+	  0.52359877559829882 },
+  { 0.72914228589586771, 0.60000000000000009, 0.10000000000000001, 
+	  0.69813170079773179 },
+  { 0.93208036718354692, 0.60000000000000009, 0.10000000000000001, 
+	  0.87266462599716477 },
+  { 1.1468984688863377, 0.60000000000000009, 0.10000000000000001, 
+	  1.0471975511965976 },
+  { 1.3733904977062528, 0.60000000000000009, 0.10000000000000001, 
+	  1.2217304763960306 },
+  { 1.6094225663372157, 0.60000000000000009, 0.10000000000000001, 
+	  1.3962634015954636 },
+  { 1.8508766487100685, 0.60000000000000009, 0.10000000000000001, 
+	  1.5707963267948966 },
+};
+const double toler152 = 2.5000000000000020e-13;
 
 // Test data for k=0.60000000000000009, nu=0.20000000000000001.
-testcase_ellint_3<double> data153[] = {
-  { -0.0000000000000000, 0.60000000000000009, 0.20000000000000001,
-          0.0000000000000000 },
-  { 0.17449937871800653, 0.60000000000000009, 0.20000000000000001,
-          0.17453292519943295 },
-  { 0.34884093647346553, 0.60000000000000009, 0.20000000000000001,
-          0.34906585039886590 },
-  { 0.52306221119844110, 0.60000000000000009, 0.20000000000000001,
-          0.52359877559829882 },
-  { 0.69749955678982223, 0.60000000000000009, 0.20000000000000001,
-          0.69813170079773179 },
-  { 0.87274610682416853, 0.60000000000000009, 0.20000000000000001,
-          0.87266462599716477 },
-  { 1.0494620540750796, 0.60000000000000009, 0.20000000000000001,
-          1.0471975511965976 },
-  { 1.2280847305507339, 0.60000000000000009, 0.20000000000000001,
-          1.2217304763960306 },
-  { 1.4085436279696888, 0.60000000000000009, 0.20000000000000001,
-          1.3962634015954636 },
-  { 1.5901418016279374, 0.60000000000000009, 0.20000000000000001,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.60000000000000009, nu=0.20000000000000001.
-template <typename Tp>
-void test153()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data153)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data153[i].k), Tp(data153[i].nu),
-                   Tp(data153[i].phi));
-      const Tp f0 = data153[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.60000000000000009, nu=0.29999999999999999.
-testcase_ellint_3<double> data154[] = {
-  { -0.0000000000000000, 0.60000000000000009, 0.29999999999999999,
-          0.0000000000000000 },
-  { 0.17432424744393935, 0.60000000000000009, 0.29999999999999999,
-          0.17453292519943295 },
-  { 0.34748744127146447, 0.60000000000000009, 0.29999999999999999,
-          0.34906585039886590 },
-  { 0.51873632743924847, 0.60000000000000009, 0.29999999999999999,
-          0.52359877559829882 },
-  { 0.68794610396313127, 0.60000000000000009, 0.29999999999999999,
-          0.69813170079773179 },
-  { 0.85558070175468726, 0.60000000000000009, 0.29999999999999999,
-          0.87266462599716477 },
-  { 1.0224416343605658, 0.60000000000000009, 0.29999999999999999,
-          1.0471975511965976 },
-  { 1.1893144457936788, 0.60000000000000009, 0.29999999999999999,
-          1.2217304763960306 },
-  { 1.3566435377982575, 0.60000000000000009, 0.29999999999999999,
-          1.3962634015954636 },
-  { 1.5243814243493585, 0.60000000000000009, 0.29999999999999999,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.60000000000000009, nu=0.29999999999999999.
-template <typename Tp>
-void test154()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data154)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data154[i].k), Tp(data154[i].nu),
-                   Tp(data154[i].phi));
-      const Tp f0 = data154[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 2.2547200163366559e-16
+// mean(f - f_Boost): -2.4980018054066023e-17
+// variance(f - f_Boost): 2.1685495635542404e-32
+// stddev(f - f_Boost): 1.4725995937641163e-16
+const testcase_ellint_3<double>
+data153[10] =
+{
+  { 0.0000000000000000, 0.60000000000000009, 0.20000000000000001, 
+	  0.0000000000000000 },
+  { 0.17520627248155893, 0.60000000000000009, 0.20000000000000001, 
+	  0.17453292519943295 },
+  { 0.35444873935437748, 0.60000000000000009, 0.20000000000000001, 
+	  0.34906585039886590 },
+  { 0.54172310557682524, 0.60000000000000009, 0.20000000000000001, 
+	  0.52359877559829882 },
+  { 0.74084300280734672, 0.60000000000000009, 0.20000000000000001, 
+	  0.69813170079773179 },
+  { 0.95509001527006121, 0.60000000000000009, 0.20000000000000001, 
+	  0.87266462599716477 },
+  { 1.1865688084431796, 0.60000000000000009, 0.20000000000000001, 
+	  1.0471975511965976 },
+  { 1.4352978868932600, 0.60000000000000009, 0.20000000000000001, 
+	  1.2217304763960306 },
+  { 1.6983400371331818, 0.60000000000000009, 0.20000000000000001, 
+	  1.3962634015954636 },
+  { 1.9695980282802217, 0.60000000000000009, 0.20000000000000001, 
+	  1.5707963267948966 },
+};
+const double toler153 = 2.5000000000000020e-13;
+
+// Test data for k=0.60000000000000009, nu=0.30000000000000004.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 2.9470074709717020e-16
+// mean(f - f_Boost): 3.0531133177191807e-17
+// variance(f - f_Boost): 1.1508025840536076e-34
+// stddev(f - f_Boost): 1.0727546709539920e-17
+const testcase_ellint_3<double>
+data154[10] =
+{
+  { 0.0000000000000000, 0.60000000000000009, 0.30000000000000004, 
+	  0.0000000000000000 },
+  { 0.17538460882640122, 0.60000000000000009, 0.30000000000000004, 
+	  0.17453292519943295 },
+  { 0.35590165133735557, 0.60000000000000009, 0.30000000000000004, 
+	  0.34906585039886590 },
+  { 0.54676661152254535, 0.60000000000000009, 0.30000000000000004, 
+	  0.52359877559829882 },
+  { 0.75321709418305305, 0.60000000000000009, 0.30000000000000004, 
+	  0.69813170079773179 },
+  { 0.98012637808992920, 0.60000000000000009, 0.30000000000000004, 
+	  0.87266462599716477 },
+  { 1.2310891277158875, 0.60000000000000009, 0.30000000000000004, 
+	  1.0471975511965976 },
+  { 1.5069157924585623, 0.60000000000000009, 0.30000000000000004, 
+	  1.2217304763960306 },
+  { 1.8039583598337940, 0.60000000000000009, 0.30000000000000004, 
+	  1.3962634015954636 },
+  { 2.1134154405060599, 0.60000000000000009, 0.30000000000000004, 
+	  1.5707963267948966 },
+};
+const double toler154 = 2.5000000000000020e-13;
 
 // Test data for k=0.60000000000000009, nu=0.40000000000000002.
-testcase_ellint_3<double> data155[] = {
-  { -0.0000000000000000, 0.60000000000000009, 0.40000000000000002,
-          0.0000000000000000 },
-  { 0.17414974487670720, 0.60000000000000009, 0.40000000000000002,
-          0.17453292519943295 },
-  { 0.34615238767335027, 0.60000000000000009, 0.40000000000000002,
-          0.34906585039886590 },
-  { 0.51453257838108579, 0.60000000000000009, 0.40000000000000002,
-          0.52359877559829882 },
-  { 0.67882386787534410, 0.60000000000000009, 0.40000000000000002,
-          0.69813170079773179 },
-  { 0.83948470233173578, 0.60000000000000009, 0.40000000000000002,
-          0.87266462599716477 },
-  { 0.99753496200074021, 0.60000000000000009, 0.40000000000000002,
-          1.0471975511965976 },
-  { 1.1541101404388487, 0.60000000000000009, 0.40000000000000002,
-          1.2217304763960306 },
-  { 1.3100911323398816, 0.60000000000000009, 0.40000000000000002,
-          1.3962634015954636 },
-  { 1.4659345278069984, 0.60000000000000009, 0.40000000000000002,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.60000000000000009, nu=0.40000000000000002.
-template <typename Tp>
-void test155()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data155)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data155[i].k), Tp(data155[i].nu),
-                   Tp(data155[i].phi));
-      const Tp f0 = data155[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 2.8974839914337670e-16
+// mean(f - f_Boost): -1.3877787807814457e-17
+// variance(f - f_Boost): 2.2849613290816465e-32
+// stddev(f - f_Boost): 1.5116088545260797e-16
+const testcase_ellint_3<double>
+data155[10] =
+{
+  { 0.0000000000000000, 0.60000000000000009, 0.40000000000000002, 
+	  0.0000000000000000 },
+  { 0.17556359876533037, 0.60000000000000009, 0.40000000000000002, 
+	  0.17453292519943295 },
+  { 0.35737601674244679, 0.60000000000000009, 0.40000000000000002, 
+	  0.34906585039886590 },
+  { 0.55197933771320218, 0.60000000000000009, 0.40000000000000002, 
+	  0.52359877559829882 },
+  { 0.76633591620002905, 0.60000000000000009, 0.40000000000000002, 
+	  0.69813170079773179 },
+  { 1.0075231136019616, 0.60000000000000009, 0.40000000000000002, 
+	  0.87266462599716477 },
+  { 1.2815842073813450, 0.60000000000000009, 0.40000000000000002, 
+	  1.0471975511965976 },
+  { 1.5911666941449827, 0.60000000000000009, 0.40000000000000002, 
+	  1.2217304763960306 },
+  { 1.9323227566025762, 0.60000000000000009, 0.40000000000000002, 
+	  1.3962634015954636 },
+  { 2.2925036420985130, 0.60000000000000009, 0.40000000000000002, 
+	  1.5707963267948966 },
+};
+const double toler155 = 2.5000000000000020e-13;
 
 // Test data for k=0.60000000000000009, nu=0.50000000000000000.
-testcase_ellint_3<double> data156[] = {
-  { -0.0000000000000000, 0.60000000000000009, 0.50000000000000000,
-          0.0000000000000000 },
-  { 0.17397586700252810, 0.60000000000000009, 0.50000000000000000,
-          0.17453292519943295 },
-  { 0.34483533397138516, 0.60000000000000009, 0.50000000000000000,
-          0.34906585039886590 },
-  { 0.51044500461706499, 0.60000000000000009, 0.50000000000000000,
-          0.52359877559829882 },
-  { 0.67009988034712675, 0.60000000000000009, 0.50000000000000000,
-          0.69813170079773179 },
-  { 0.82434762375735193, 0.60000000000000009, 0.50000000000000000,
-          0.87266462599716477 },
-  { 0.97447346702799043, 0.60000000000000009, 0.50000000000000000,
-          1.0471975511965976 },
-  { 1.1219494000522143, 0.60000000000000009, 0.50000000000000000,
-          1.2217304763960306 },
-  { 1.2680242605954488, 0.60000000000000009, 0.50000000000000000,
-          1.3962634015954636 },
-  { 1.4135484285693078, 0.60000000000000009, 0.50000000000000000,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.60000000000000009, nu=0.50000000000000000.
-template <typename Tp>
-void test156()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data156)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data156[i].k), Tp(data156[i].nu),
-                   Tp(data156[i].phi));
-      const Tp f0 = data156[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.60000000000000009, nu=0.59999999999999998.
-testcase_ellint_3<double> data157[] = {
-  { -0.0000000000000000, 0.60000000000000009, 0.59999999999999998,
-          0.0000000000000000 },
-  { 0.17380260984469356, 0.60000000000000009, 0.59999999999999998,
-          0.17453292519943295 },
-  { 0.34353585361777839, 0.60000000000000009, 0.59999999999999998,
-          0.34906585039886590 },
-  { 0.50646805774321402, 0.60000000000000009, 0.59999999999999998,
-          0.52359877559829882 },
-  { 0.66174468108625517, 0.60000000000000009, 0.59999999999999998,
-          0.69813170079773179 },
-  { 0.81007462280278408, 0.60000000000000009, 0.59999999999999998,
-          0.87266462599716477 },
-  { 0.95303466945718773, 0.60000000000000009, 0.59999999999999998,
-          1.0471975511965976 },
-  { 1.0924118588677503, 0.60000000000000009, 0.59999999999999998,
-          1.2217304763960306 },
-  { 1.2297640574847937, 0.60000000000000009, 0.59999999999999998,
-          1.3962634015954636 },
-  { 1.3662507535812816, 0.60000000000000009, 0.59999999999999998,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.60000000000000009, nu=0.59999999999999998.
-template <typename Tp>
-void test157()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data157)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data157[i].k), Tp(data157[i].nu),
-                   Tp(data157[i].phi));
-      const Tp f0 = data157[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.60000000000000009, nu=0.69999999999999996.
-testcase_ellint_3<double> data158[] = {
-  { -0.0000000000000000, 0.60000000000000009, 0.69999999999999996,
-          0.0000000000000000 },
-  { 0.17362996946312009, 0.60000000000000009, 0.69999999999999996,
-          0.17453292519943295 },
-  { 0.34225353454870588, 0.60000000000000009, 0.69999999999999996,
-          0.34906585039886590 },
-  { 0.50259656397799546, 0.60000000000000009, 0.69999999999999996,
-          0.52359877559829882 },
-  { 0.65373184496628944, 0.60000000000000009, 0.69999999999999996,
-          0.69813170079773179 },
-  { 0.79658372884056439, 0.60000000000000009, 0.69999999999999996,
-          0.87266462599716477 },
-  { 0.93303240100245466, 0.60000000000000009, 0.69999999999999996,
-          1.0471975511965976 },
-  { 1.0651547944716557, 0.60000000000000009, 0.69999999999999996,
-          1.2217304763960306 },
-  { 1.1947676204853441, 0.60000000000000009, 0.69999999999999996,
-          1.3962634015954636 },
-  { 1.3232737468822811, 0.60000000000000009, 0.69999999999999996,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.60000000000000009, nu=0.69999999999999996.
-template <typename Tp>
-void test158()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data158)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data158[i].k), Tp(data158[i].nu),
-                   Tp(data158[i].phi));
-      const Tp f0 = data158[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 2.1397785842303966e-16
+// mean(f - f_Boost): 9.1593399531575410e-17
+// variance(f - f_Boost): 1.5339913122479866e-32
+// stddev(f - f_Boost): 1.2385440291923362e-16
+const testcase_ellint_3<double>
+data156[10] =
+{
+  { 0.0000000000000000, 0.60000000000000009, 0.50000000000000000, 
+	  0.0000000000000000 },
+  { 0.17574324658480217, 0.60000000000000009, 0.50000000000000000, 
+	  0.17453292519943295 },
+  { 0.35887240603169313, 0.60000000000000009, 0.50000000000000000, 
+	  0.34906585039886590 },
+  { 0.55737161826345261, 0.60000000000000009, 0.50000000000000000, 
+	  0.52359877559829882 },
+  { 0.78028227313077458, 0.60000000000000009, 0.50000000000000000, 
+	  0.69813170079773179 },
+  { 1.0376989776486290, 0.60000000000000009, 0.50000000000000000, 
+	  0.87266462599716477 },
+  { 1.3395933991042928, 0.60000000000000009, 0.50000000000000000, 
+	  1.0471975511965976 },
+  { 1.6924049626591784, 0.60000000000000009, 0.50000000000000000, 
+	  1.2217304763960306 },
+  { 2.0931011856518920, 0.60000000000000009, 0.50000000000000000, 
+	  1.3962634015954636 },
+  { 2.5239007084492711, 0.60000000000000009, 0.50000000000000000, 
+	  1.5707963267948966 },
+};
+const double toler156 = 2.5000000000000020e-13;
+
+// Test data for k=0.60000000000000009, nu=0.60000000000000009.
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.6651378277398083e-16
+// mean(f - f_Boost): 1.1934897514720432e-16
+// variance(f - f_Boost): 1.7585404776158019e-33
+// stddev(f - f_Boost): 4.1934955319110598e-17
+const testcase_ellint_3<double>
+data157[10] =
+{
+  { 0.0000000000000000, 0.60000000000000009, 0.60000000000000009, 
+	  0.0000000000000000 },
+  { 0.17592355661219386, 0.60000000000000009, 0.60000000000000009, 
+	  0.17453292519943295 },
+  { 0.36039141192661606, 0.60000000000000009, 0.60000000000000009, 
+	  0.34906585039886590 },
+  { 0.56295472636903854, 0.60000000000000009, 0.60000000000000009, 
+	  0.52359877559829882 },
+  { 0.79515295130165986, 0.60000000000000009, 0.60000000000000009, 
+	  0.69813170079773179 },
+  { 1.0711886441942242, 0.60000000000000009, 0.60000000000000009, 
+	  0.87266462599716477 },
+  { 1.4072952835139891, 0.60000000000000009, 0.60000000000000009, 
+	  1.0471975511965976 },
+  { 1.8174863977376825, 0.60000000000000009, 0.60000000000000009, 
+	  1.2217304763960306 },
+  { 2.3029921578542232, 0.60000000000000009, 0.60000000000000009, 
+	  1.3962634015954636 },
+  { 2.8388723099514972, 0.60000000000000009, 0.60000000000000009, 
+	  1.5707963267948966 },
+};
+const double toler157 = 2.5000000000000020e-13;
+
+// Test data for k=0.60000000000000009, nu=0.70000000000000007.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 2.0027679235921772e-16
+// mean(f - f_Boost): -1.3877787807814457e-17
+// variance(f - f_Boost): 2.2849613290816465e-32
+// stddev(f - f_Boost): 1.5116088545260797e-16
+const testcase_ellint_3<double>
+data158[10] =
+{
+  { 0.0000000000000000, 0.60000000000000009, 0.70000000000000007, 
+	  0.0000000000000000 },
+  { 0.17610453321631936, 0.60000000000000009, 0.70000000000000007, 
+	  0.17453292519943295 },
+  { 0.36193365056369764, 0.60000000000000009, 0.70000000000000007, 
+	  0.34906585039886590 },
+  { 0.56874098962268527, 0.60000000000000009, 0.70000000000000007, 
+	  0.52359877559829882 },
+  { 0.81106198671477181, 0.60000000000000009, 0.70000000000000007, 
+	  0.69813170079773179 },
+  { 1.1086886419010082, 0.60000000000000009, 0.70000000000000007, 
+	  0.87266462599716477 },
+  { 1.4879048567239257, 0.60000000000000009, 0.70000000000000007, 
+	  1.0471975511965976 },
+  { 1.9780310073615925, 0.60000000000000009, 0.70000000000000007, 
+	  1.2217304763960306 },
+  { 2.5941545586772712, 0.60000000000000009, 0.70000000000000007, 
+	  1.3962634015954636 },
+  { 3.3029735898397159, 0.60000000000000009, 0.70000000000000007, 
+	  1.5707963267948966 },
+};
+const double toler158 = 2.5000000000000020e-13;
 
 // Test data for k=0.60000000000000009, nu=0.80000000000000004.
-testcase_ellint_3<double> data159[] = {
-  { -0.0000000000000000, 0.60000000000000009, 0.80000000000000004,
-          0.0000000000000000 },
-  { 0.17345794195390687, 0.60000000000000009, 0.80000000000000004,
-          0.17453292519943295 },
-  { 0.34098797854531027, 0.60000000000000009, 0.80000000000000004,
-          0.34906585039886590 },
-  { 0.49882569168826230, 0.60000000000000009, 0.80000000000000004,
-          0.52359877559829882 },
-  { 0.64603758566475511, 0.60000000000000009, 0.80000000000000004,
-          0.69813170079773179 },
-  { 0.78380365594769730, 0.60000000000000009, 0.80000000000000004,
-          0.87266462599716477 },
-  { 0.91430946255611223, 0.60000000000000009, 0.80000000000000004,
-          1.0471975511965976 },
-  { 1.0398955217270607, 0.60000000000000009, 0.80000000000000004,
-          1.2217304763960306 },
-  { 1.1625948314277679, 0.60000000000000009, 0.80000000000000004,
-          1.3962634015954636 },
-  { 1.2840021261752192, 0.60000000000000009, 0.80000000000000004,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.60000000000000009, nu=0.80000000000000004.
-template <typename Tp>
-void test159()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data159)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data159[i].k), Tp(data159[i].nu),
-                   Tp(data159[i].phi));
-      const Tp f0 = data159[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 2.2204460492503131e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 7.3044933435043190e-16
+// mean(f - f_Boost): 2.6367796834847468e-16
+// variance(f - f_Boost): 8.5834655546147173e-33
+// stddev(f - f_Boost): 9.2646994309662939e-17
+const testcase_ellint_3<double>
+data159[10] =
+{
+  { 0.0000000000000000, 0.60000000000000009, 0.80000000000000004, 
+	  0.0000000000000000 },
+  { 0.17628618080795252, 0.60000000000000009, 0.80000000000000004, 
+	  0.17453292519943295 },
+  { 0.36349976272521012, 0.60000000000000009, 0.80000000000000004, 
+	  0.34906585039886590 },
+  { 0.57474392342151914, 0.60000000000000009, 0.80000000000000004, 
+	  0.52359877559829882 },
+  { 0.82814493499158170, 0.60000000000000009, 0.80000000000000004, 
+	  0.69813170079773179 },
+  { 1.1511281795998280, 0.60000000000000009, 0.80000000000000004, 
+	  0.87266462599716477 },
+  { 1.5864286332503075, 0.60000000000000009, 0.80000000000000004, 
+	  1.0471975511965976 },
+  { 2.1958944866494527, 0.60000000000000009, 0.80000000000000004, 
+	  1.2217304763960306 },
+  { 3.0398358172574604, 0.60000000000000009, 0.80000000000000004, 
+	  1.3962634015954636 },
+  { 4.0867036409261832, 0.60000000000000009, 0.80000000000000004, 
+	  1.5707963267948966 },
+};
+const double toler159 = 2.5000000000000020e-13;
 
 // Test data for k=0.60000000000000009, nu=0.90000000000000002.
-testcase_ellint_3<double> data160[] = {
-  { -0.0000000000000000, 0.60000000000000009, 0.90000000000000002,
-          0.0000000000000000 },
-  { 0.17328652344890033, 0.60000000000000009, 0.90000000000000002,
-          0.17453292519943295 },
-  { 0.33973880062929018, 0.60000000000000009, 0.90000000000000002,
-          0.34906585039886590 },
-  { 0.49515092233122765, 0.60000000000000009, 0.90000000000000002,
-          0.52359877559829882 },
-  { 0.63864042139737043, 0.60000000000000009, 0.90000000000000002,
-          0.69813170079773179 },
-  { 0.77167205646538850, 0.60000000000000009, 0.90000000000000002,
-          0.87266462599716477 },
-  { 0.89673202848034428, 0.60000000000000009, 0.90000000000000002,
-          1.0471975511965976 },
-  { 1.0163984492661304, 0.60000000000000009, 0.90000000000000002,
-          1.2217304763960306 },
-  { 1.1328845785162431, 0.60000000000000009, 0.90000000000000002,
-          1.3962634015954636 },
-  { 1.2479362973851875, 0.60000000000000009, 0.90000000000000002,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.60000000000000009, nu=0.90000000000000002.
-template <typename Tp>
-void test160()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data160)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data160[i].k), Tp(data160[i].nu),
-                   Tp(data160[i].phi));
-      const Tp f0 = data160[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.69999999999999996, nu=0.0000000000000000.
-testcase_ellint_3<double> data161[] = {
-  { -0.0000000000000000, 0.69999999999999996, 0.0000000000000000,
-          0.0000000000000000 },
-  { 0.17496737466916720, 0.69999999999999996, 0.0000000000000000,
-          0.17453292519943295 },
-  { 0.35254687535677925, 0.69999999999999996, 0.0000000000000000,
-          0.34906585039886590 },
-  { 0.53536740275997130, 0.69999999999999996, 0.0000000000000000,
-          0.52359877559829882 },
-  { 0.72603797651684465, 0.69999999999999996, 0.0000000000000000,
-          0.69813170079773179 },
-  { 0.92698296348313458, 0.69999999999999996, 0.0000000000000000,
-          0.87266462599716477 },
-  { 1.1400447527693316, 0.69999999999999996, 0.0000000000000000,
-          1.0471975511965976 },
-  { 1.3657668117194071, 0.69999999999999996, 0.0000000000000000,
-          1.2217304763960306 },
-  { 1.6024686895959159, 0.69999999999999996, 0.0000000000000000,
-          1.3962634015954636 },
-  { 1.8456939983747236, 0.69999999999999996, 0.0000000000000000,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.69999999999999996, nu=0.0000000000000000.
-template <typename Tp>
-void test161()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data161)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data161[i].k), Tp(data161[i].nu),
-                   Tp(data161[i].phi));
-      const Tp f0 = data161[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.69999999999999996, nu=0.10000000000000001.
-testcase_ellint_3<double> data162[] = {
-  { -0.0000000000000000, 0.69999999999999996, 0.10000000000000001,
-          0.0000000000000000 },
-  { 0.17479076384884681, 0.69999999999999996, 0.10000000000000001,
-          0.17453292519943295 },
-  { 0.35114844900396364, 0.69999999999999996, 0.10000000000000001,
-          0.34906585039886590 },
-  { 0.53072776947527012, 0.69999999999999996, 0.10000000000000001,
-          0.52359877559829882 },
-  { 0.71530198262386246, 0.69999999999999996, 0.10000000000000001,
-          0.69813170079773179 },
-  { 0.90666760677828306, 0.69999999999999996, 0.10000000000000001,
-          0.87266462599716477 },
-  { 1.1063366517438080, 0.69999999999999996, 0.10000000000000001,
-          1.0471975511965976 },
-  { 1.3149477243092147, 0.69999999999999996, 0.10000000000000001,
-          1.2217304763960306 },
-  { 1.5314886725038925, 0.69999999999999996, 0.10000000000000001,
-          1.3962634015954636 },
-  { 1.7528050171757608, 0.69999999999999996, 0.10000000000000001,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.69999999999999996, nu=0.10000000000000001.
-template <typename Tp>
-void test162()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data162)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data162[i].k), Tp(data162[i].nu),
-                   Tp(data162[i].phi));
-      const Tp f0 = data162[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.69999999999999996, nu=0.20000000000000001.
-testcase_ellint_3<double> data163[] = {
-  { -0.0000000000000000, 0.69999999999999996, 0.20000000000000001,
-          0.0000000000000000 },
-  { 0.17461479077791472, 0.69999999999999996, 0.20000000000000001,
-          0.17453292519943295 },
-  { 0.34976950621407538, 0.69999999999999996, 0.20000000000000001,
-          0.34906585039886590 },
-  { 0.52622533231350188, 0.69999999999999996, 0.20000000000000001,
-          0.52359877559829882 },
-  { 0.70508774017895226, 0.69999999999999996, 0.20000000000000001,
-          0.69813170079773179 },
-  { 0.88775302531730294, 0.69999999999999996, 0.20000000000000001,
-          0.87266462599716477 },
-  { 1.0756195476149006, 0.69999999999999996, 0.20000000000000001,
-          1.0471975511965976 },
-  { 1.2695349716654372, 0.69999999999999996, 0.20000000000000001,
-          1.2217304763960306 },
-  { 1.4690814617070540, 0.69999999999999996, 0.20000000000000001,
-          1.3962634015954636 },
-  { 1.6721098780092147, 0.69999999999999996, 0.20000000000000001,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.69999999999999996, nu=0.20000000000000001.
-template <typename Tp>
-void test163()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data163)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data163[i].k), Tp(data163[i].nu),
-                   Tp(data163[i].phi));
-      const Tp f0 = data163[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.69999999999999996, nu=0.29999999999999999.
-testcase_ellint_3<double> data164[] = {
-  { -0.0000000000000000, 0.69999999999999996, 0.29999999999999999,
-          0.0000000000000000 },
-  { 0.17443945136076172, 0.69999999999999996, 0.29999999999999999,
-          0.17453292519943295 },
-  { 0.34840956983535287, 0.69999999999999996, 0.29999999999999999,
-          0.34906585039886590 },
-  { 0.52185308551329179, 0.69999999999999996, 0.29999999999999999,
-          0.52359877559829882 },
-  { 0.69535240431168266, 0.69999999999999996, 0.29999999999999999,
-          0.69813170079773179 },
-  { 0.87007983473964923, 0.69999999999999996, 0.29999999999999999,
-          0.87266462599716477 },
-  { 1.0474657975577066, 0.69999999999999996, 0.29999999999999999,
-          1.0471975511965976 },
-  { 1.2286225419931889, 0.69999999999999996, 0.29999999999999999,
-          1.2217304763960306 },
-  { 1.4136490671013271, 0.69999999999999996, 0.29999999999999999,
-          1.3962634015954636 },
-  { 1.6011813647733213, 0.69999999999999996, 0.29999999999999999,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.69999999999999996, nu=0.29999999999999999.
-template <typename Tp>
-void test164()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data164)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data164[i].k), Tp(data164[i].nu),
-                   Tp(data164[i].phi));
-      const Tp f0 = data164[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.69999999999999996, nu=0.40000000000000002.
-testcase_ellint_3<double> data165[] = {
-  { -0.0000000000000000, 0.69999999999999996, 0.40000000000000002,
-          0.0000000000000000 },
-  { 0.17426474153983226, 0.69999999999999996, 0.40000000000000002,
-          0.17453292519943295 },
-  { 0.34706817945773732, 0.69999999999999996, 0.40000000000000002,
-          0.34906585039886590 },
-  { 0.51760452851738159, 0.69999999999999996, 0.40000000000000002,
-          0.52359877559829882 },
-  { 0.68605801534722766, 0.69999999999999996, 0.40000000000000002,
-          0.69813170079773179 },
-  { 0.85351339387296532, 0.69999999999999996, 0.40000000000000002,
-          0.87266462599716477 },
-  { 1.0215297967969537, 0.69999999999999996, 0.40000000000000002,
-          1.0471975511965976 },
-  { 1.1915051074460528, 0.69999999999999996, 0.40000000000000002,
-          1.2217304763960306 },
-  { 1.3639821911744707, 0.69999999999999996, 0.40000000000000002,
-          1.3962634015954636 },
-  { 1.5382162002954762, 0.69999999999999996, 0.40000000000000002,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.69999999999999996, nu=0.40000000000000002.
-template <typename Tp>
-void test165()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data165)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data165[i].k), Tp(data165[i].nu),
-                   Tp(data165[i].phi));
-      const Tp f0 = data165[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.69999999999999996, nu=0.50000000000000000.
-testcase_ellint_3<double> data166[] = {
-  { -0.0000000000000000, 0.69999999999999996, 0.50000000000000000,
-          0.0000000000000000 },
-  { 0.17409065729516093, 0.69999999999999996, 0.50000000000000000,
-          0.17453292519943295 },
-  { 0.34574489064986091, 0.69999999999999996, 0.50000000000000000,
-          0.34906585039886590 },
-  { 0.51347361925579793, 0.69999999999999996, 0.50000000000000000,
-          0.52359877559829882 },
-  { 0.67717079489579290, 0.69999999999999996, 0.50000000000000000,
-          0.69813170079773179 },
-  { 0.83793902055292280, 0.69999999999999996, 0.50000000000000000,
-          0.87266462599716477 },
-  { 0.99752863545289705, 0.69999999999999996, 0.50000000000000000,
-          1.0471975511965976 },
-  { 1.1576240080401499, 0.69999999999999996, 0.50000000000000000,
-          1.2217304763960306 },
-  { 1.3191464023923762, 0.69999999999999996, 0.50000000000000000,
-          1.3962634015954636 },
-  { 1.4818433192178544, 0.69999999999999996, 0.50000000000000000,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.69999999999999996, nu=0.50000000000000000.
-template <typename Tp>
-void test166()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data166)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data166[i].k), Tp(data166[i].nu),
-                   Tp(data166[i].phi));
-      const Tp f0 = data166[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.69999999999999996, nu=0.59999999999999998.
-testcase_ellint_3<double> data167[] = {
-  { -0.0000000000000000, 0.69999999999999996, 0.59999999999999998,
-          0.0000000000000000 },
-  { 0.17391719464391611, 0.69999999999999996, 0.59999999999999998,
-          0.17453292519943295 },
-  { 0.34443927423869031, 0.69999999999999996, 0.59999999999999998,
-          0.34906585039886590 },
-  { 0.50945473266486074, 0.69999999999999996, 0.59999999999999998,
-          0.52359877559829882 },
-  { 0.66866056326513823, 0.69999999999999996, 0.59999999999999998,
-          0.69813170079773179 },
-  { 0.82325830002337352, 0.69999999999999996, 0.59999999999999998,
-          0.87266462599716477 },
-  { 0.97522808245669357, 0.69999999999999996, 0.59999999999999998,
-          1.0471975511965976 },
-  { 1.1265300613705282, 0.69999999999999996, 0.59999999999999998,
-          1.2217304763960306 },
-  { 1.2784066076152003, 0.69999999999999996, 0.59999999999999998,
-          1.3962634015954636 },
-  { 1.4309994736080540, 0.69999999999999996, 0.59999999999999998,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.69999999999999996, nu=0.59999999999999998.
-template <typename Tp>
-void test167()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data167)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data167[i].k), Tp(data167[i].nu),
-                   Tp(data167[i].phi));
-      const Tp f0 = data167[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.69999999999999996, nu=0.69999999999999996.
-testcase_ellint_3<double> data168[] = {
-  { -0.0000000000000000, 0.69999999999999996, 0.69999999999999996,
-          0.0000000000000000 },
-  { 0.17374434963995028, 0.69999999999999996, 0.69999999999999996,
-          0.17453292519943295 },
-  { 0.34315091562900674, 0.69999999999999996, 0.69999999999999996,
-          0.34906585039886590 },
-  { 0.50554262375653358, 0.69999999999999996, 0.69999999999999996,
-          0.52359877559829882 },
-  { 0.66050025406305812, 0.69999999999999996, 0.69999999999999996,
-          0.69813170079773179 },
-  { 0.80938620118847404, 0.69999999999999996, 0.69999999999999996,
-          0.87266462599716477 },
-  { 0.95443223855852144, 0.69999999999999996, 0.69999999999999996,
-          1.0471975511965976 },
-  { 1.0978573207128302, 0.69999999999999996, 0.69999999999999996,
-          1.2217304763960306 },
-  { 1.2411754575007123, 0.69999999999999996, 0.69999999999999996,
-          1.3962634015954636 },
-  { 1.3848459188329196, 0.69999999999999996, 0.69999999999999996,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.69999999999999996, nu=0.69999999999999996.
-template <typename Tp>
-void test168()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data168)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data168[i].k), Tp(data168[i].nu),
-                   Tp(data168[i].phi));
-      const Tp f0 = data168[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.69999999999999996, nu=0.80000000000000004.
-testcase_ellint_3<double> data169[] = {
-  { -0.0000000000000000, 0.69999999999999996, 0.80000000000000004,
-          0.0000000000000000 },
-  { 0.17357211837335737, 0.69999999999999996, 0.80000000000000004,
-          0.17453292519943295 },
-  { 0.34187941416012108, 0.69999999999999996, 0.80000000000000004,
-          0.34906585039886590 },
-  { 0.50173239465478270, 0.69999999999999996, 0.80000000000000004,
-          0.52359877559829882 },
-  { 0.65266550725988315, 0.69999999999999996, 0.80000000000000004,
-          0.69813170079773179 },
-  { 0.79624879865249298, 0.69999999999999996, 0.80000000000000004,
-          0.87266462599716477 },
-  { 0.93497577043296920, 0.69999999999999996, 0.80000000000000004,
-          1.0471975511965976 },
-  { 1.0713041566930748, 0.69999999999999996, 0.80000000000000004,
-          1.2217304763960306 },
-  { 1.2069772023255652, 0.69999999999999996, 0.80000000000000004,
-          1.3962634015954636 },
-  { 1.3427110650397533, 0.69999999999999996, 0.80000000000000004,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.69999999999999996, nu=0.80000000000000004.
-template <typename Tp>
-void test169()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data169)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data169[i].k), Tp(data169[i].nu),
-                   Tp(data169[i].phi));
-      const Tp f0 = data169[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.69999999999999996, nu=0.90000000000000002.
-testcase_ellint_3<double> data170[] = {
-  { -0.0000000000000000, 0.69999999999999996, 0.90000000000000002,
-          0.0000000000000000 },
-  { 0.17340049697003634, 0.69999999999999996, 0.90000000000000002,
-          0.17453292519943295 },
-  { 0.34062438249741556, 0.69999999999999996, 0.90000000000000002,
-          0.34906585039886590 },
-  { 0.49801946510076878, 0.69999999999999996, 0.90000000000000002,
-          0.52359877559829882 },
-  { 0.64513432604750487, 0.69999999999999996, 0.90000000000000002,
-          0.69813170079773179 },
-  { 0.78378145487573758, 0.69999999999999996, 0.90000000000000002,
-          0.87266462599716477 },
-  { 0.91671799500854634, 0.69999999999999996, 0.90000000000000002,
-          1.0471975511965976 },
-  { 1.0466193579463123, 0.69999999999999996, 0.90000000000000002,
-          1.2217304763960306 },
-  { 1.1754218079199146, 0.69999999999999996, 0.90000000000000002,
-          1.3962634015954636 },
-  { 1.3040500499695911, 0.69999999999999996, 0.90000000000000002,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.69999999999999996, nu=0.90000000000000002.
-template <typename Tp>
-void test170()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data170)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data170[i].k), Tp(data170[i].nu),
-                   Tp(data170[i].phi));
-      const Tp f0 = data170[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 4.5952142720718732e-16
+// mean(f - f_Boost): 4.6351811278100284e-16
+// variance(f - f_Boost): 2.1278339779151204e-31
+// stddev(f - f_Boost): 4.6128450851021651e-16
+const testcase_ellint_3<double>
+data160[10] =
+{
+  { 0.0000000000000000, 0.60000000000000009, 0.90000000000000002, 
+	  0.0000000000000000 },
+  { 0.17646850384035848, 0.60000000000000009, 0.90000000000000002, 
+	  0.17453292519943295 },
+  { 0.36509041515134105, 0.60000000000000009, 0.90000000000000002, 
+	  0.34906585039886590 },
+  { 0.58097838596260631, 0.60000000000000009, 0.90000000000000002, 
+	  0.52359877559829882 },
+  { 0.84656453396163722, 0.60000000000000009, 0.90000000000000002, 
+	  0.69813170079773179 },
+  { 1.1997828426963724, 0.60000000000000009, 0.90000000000000002, 
+	  0.87266462599716477 },
+  { 1.7112436789225605, 0.60000000000000009, 0.90000000000000002, 
+	  1.0471975511965976 },
+  { 2.5193168553672312, 0.60000000000000009, 0.90000000000000002, 
+	  1.2217304763960306 },
+  { 3.8656670488606690, 0.60000000000000009, 0.90000000000000002, 
+	  1.3962634015954636 },
+  { 5.8709993116265604, 0.60000000000000009, 0.90000000000000002, 
+	  1.5707963267948966 },
+};
+const double toler160 = 2.5000000000000020e-13;
+
+// Test data for k=0.70000000000000018, nu=0.0000000000000000.
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 4.1569224977685422e-16
+// mean(f - f_Boost): 7.7715611723760953e-17
+// variance(f - f_Boost): 1.6571557210371951e-32
+// stddev(f - f_Boost): 1.2873056051447903e-16
+const testcase_ellint_3<double>
+data161[10] =
+{
+  { 0.0000000000000000, 0.70000000000000018, 0.0000000000000000, 
+	  0.0000000000000000 },
+  { 0.17496737466916723, 0.70000000000000018, 0.0000000000000000, 
+	  0.17453292519943295 },
+  { 0.35254687535677931, 0.70000000000000018, 0.0000000000000000, 
+	  0.34906585039886590 },
+  { 0.53536740275997130, 0.70000000000000018, 0.0000000000000000, 
+	  0.52359877559829882 },
+  { 0.72603797651684454, 0.70000000000000018, 0.0000000000000000, 
+	  0.69813170079773179 },
+  { 0.92698296348313447, 0.70000000000000018, 0.0000000000000000, 
+	  0.87266462599716477 },
+  { 1.1400447527693318, 0.70000000000000018, 0.0000000000000000, 
+	  1.0471975511965976 },
+  { 1.3657668117194073, 0.70000000000000018, 0.0000000000000000, 
+	  1.2217304763960306 },
+  { 1.6024686895959164, 0.70000000000000018, 0.0000000000000000, 
+	  1.3962634015954636 },
+  { 1.8456939983747236, 0.70000000000000018, 0.0000000000000000, 
+	  1.5707963267948966 },
+};
+const double toler161 = 2.5000000000000020e-13;
+
+// Test data for k=0.70000000000000018, nu=0.10000000000000001.
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 3.9552278747527691e-16
+// mean(f - f_Boost): 1.1102230246251565e-16
+// variance(f - f_Boost): 1.3695501826753678e-32
+// stddev(f - f_Boost): 1.1702778228589004e-16
+const testcase_ellint_3<double>
+data162[10] =
+{
+  { 0.0000000000000000, 0.70000000000000018, 0.10000000000000001, 
+	  0.0000000000000000 },
+  { 0.17514462737300920, 0.70000000000000018, 0.10000000000000001, 
+	  0.17453292519943295 },
+  { 0.35396527997470451, 0.70000000000000018, 0.10000000000000001, 
+	  0.34906585039886590 },
+  { 0.54015179589433981, 0.70000000000000018, 0.10000000000000001, 
+	  0.52359877559829882 },
+  { 0.73734430854477728, 0.70000000000000018, 0.10000000000000001, 
+	  0.69813170079773179 },
+  { 0.94888950796697047, 0.70000000000000018, 0.10000000000000001, 
+	  0.87266462599716477 },
+  { 1.1772807959736322, 0.70000000000000018, 0.10000000000000001, 
+	  1.0471975511965976 },
+  { 1.4231796401075834, 0.70000000000000018, 0.10000000000000001, 
+	  1.2217304763960306 },
+  { 1.6841856799887471, 0.70000000000000018, 0.10000000000000001, 
+	  1.3962634015954636 },
+  { 1.9541347343119564, 0.70000000000000018, 0.10000000000000001, 
+	  1.5707963267948966 },
+};
+const double toler162 = 2.5000000000000020e-13;
+
+// Test data for k=0.70000000000000018, nu=0.20000000000000001.
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 3.7430437016285820e-16
+// mean(f - f_Boost): 3.3306690738754695e-17
+// variance(f - f_Boost): 1.3695501826753678e-34
+// stddev(f - f_Boost): 1.1702778228589003e-17
+const testcase_ellint_3<double>
+data163[10] =
+{
+  { 0.0000000000000000, 0.70000000000000018, 0.20000000000000001, 
+	  0.0000000000000000 },
+  { 0.17532252613350796, 0.70000000000000018, 0.20000000000000001, 
+	  0.17453292519943295 },
+  { 0.35540417596807522, 0.70000000000000018, 0.20000000000000001, 
+	  0.34906585039886590 },
+  { 0.54508913033361928, 0.70000000000000018, 0.20000000000000001, 
+	  0.52359877559829882 },
+  { 0.74927635777718415, 0.70000000000000018, 0.20000000000000001, 
+	  0.69813170079773179 },
+  { 0.97261706337936338, 0.70000000000000018, 0.20000000000000001, 
+	  0.87266462599716477 },
+  { 1.2187303976209327, 0.70000000000000018, 0.20000000000000001, 
+	  1.0471975511965976 },
+  { 1.4887796709222487, 0.70000000000000018, 0.20000000000000001, 
+	  1.2217304763960306 },
+  { 1.7796581281839214, 0.70000000000000018, 0.20000000000000001, 
+	  1.3962634015954636 },
+  { 2.0829290325820207, 0.70000000000000018, 0.20000000000000001, 
+	  1.5707963267948966 },
+};
+const double toler163 = 2.5000000000000020e-13;
+
+// Test data for k=0.70000000000000018, nu=0.30000000000000004.
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 4.2570807706941696e-16
+// mean(f - f_Boost): 8.8817841970012528e-17
+// variance(f - f_Boost): 1.5582437633995295e-32
+// stddev(f - f_Boost): 1.2482963443828271e-16
+const testcase_ellint_3<double>
+data164[10] =
+{
+  { 0.0000000000000000, 0.70000000000000018, 0.30000000000000004, 
+	  0.0000000000000000 },
+  { 0.17550107516328570, 0.70000000000000018, 0.30000000000000004, 
+	  0.17453292519943295 },
+  { 0.35686409576571965, 0.70000000000000018, 0.30000000000000004, 
+	  0.34906585039886590 },
+  { 0.55018827316513352, 0.70000000000000018, 0.30000000000000004, 
+	  0.52359877559829882 },
+  { 0.76189759494390275, 0.70000000000000018, 0.30000000000000004, 
+	  0.69813170079773179 },
+  { 0.99844623430885626, 0.70000000000000018, 0.30000000000000004, 
+	  0.87266462599716477 },
+  { 1.2652862989039833, 0.70000000000000018, 0.30000000000000004, 
+	  1.0471975511965976 },
+  { 1.5647666808691361, 0.70000000000000018, 0.30000000000000004, 
+	  1.2217304763960306 },
+  { 1.8932499694938165, 0.70000000000000018, 0.30000000000000004, 
+	  1.3962634015954636 },
+  { 2.2392290510988535, 0.70000000000000018, 0.30000000000000004, 
+	  1.5707963267948966 },
+};
+const double toler164 = 2.5000000000000020e-13;
+
+// Test data for k=0.70000000000000018, nu=0.40000000000000002.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 4.3719045096496910e-16
+// mean(f - f_Boost): 1.3600232051658169e-16
+// variance(f - f_Boost): 1.1718213750516114e-32
+// stddev(f - f_Boost): 1.0825069861444829e-16
+const testcase_ellint_3<double>
+data165[10] =
+{
+  { 0.0000000000000000, 0.70000000000000018, 0.40000000000000002, 
+	  0.0000000000000000 },
+  { 0.17568027871494424, 0.70000000000000018, 0.40000000000000002, 
+	  0.17453292519943295 },
+  { 0.35834559208180261, 0.70000000000000018, 0.40000000000000002, 
+	  0.34906585039886590 },
+  { 0.55545885451190613, 0.70000000000000018, 0.40000000000000002, 
+	  0.52359877559829882 },
+  { 0.77528120402568113, 0.70000000000000018, 0.40000000000000002, 
+	  0.69813170079773179 },
+  { 1.0267241287600322, 0.70000000000000018, 0.40000000000000002, 
+	  0.87266462599716477 },
+  { 1.3181380338980246, 0.70000000000000018, 0.40000000000000002, 
+	  1.0471975511965976 },
+  { 1.6542840785132087, 0.70000000000000018, 0.40000000000000002, 
+	  1.2217304763960306 },
+  { 2.0315595131131823, 0.70000000000000018, 0.40000000000000002, 
+	  1.3962634015954636 },
+  { 2.4342502915307880, 0.70000000000000018, 0.40000000000000002, 
+	  1.5707963267948966 },
+};
+const double toler165 = 2.5000000000000020e-13;
+
+// Test data for k=0.70000000000000018, nu=0.50000000000000000.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 4.0277361210295499e-16
+// mean(f - f_Boost): 1.6930901125533636e-16
+// variance(f - f_Boost): 6.3799163752809956e-32
+// stddev(f - f_Boost): 2.5258496343371268e-16
+const testcase_ellint_3<double>
+data166[10] =
+{
+  { 0.0000000000000000, 0.70000000000000018, 0.50000000000000000, 
+	  0.0000000000000000 },
+  { 0.17586014108156545, 0.70000000000000018, 0.50000000000000000, 
+	  0.17453292519943295 },
+  { 0.35984923894341653, 0.70000000000000018, 0.50000000000000000, 
+	  0.34906585039886590 },
+  { 0.56091135606739995, 0.70000000000000018, 0.50000000000000000, 
+	  0.52359877559829882 },
+  { 0.78951212635197054, 0.70000000000000018, 0.50000000000000000, 
+	  0.69813170079773179 },
+  { 1.0578865732938731, 0.70000000000000018, 0.50000000000000000, 
+	  0.87266462599716477 },
+  { 1.3789149005151722, 0.70000000000000018, 0.50000000000000000, 
+	  1.0471975511965976 },
+  { 1.7620212286086228, 0.70000000000000018, 0.50000000000000000, 
+	  1.2217304763960306 },
+  { 2.2051554347435589, 0.70000000000000018, 0.50000000000000000, 
+	  1.3962634015954636 },
+  { 2.6868019968236996, 0.70000000000000018, 0.50000000000000000, 
+	  1.5707963267948966 },
+};
+const double toler166 = 2.5000000000000020e-13;
+
+// Test data for k=0.70000000000000018, nu=0.60000000000000009.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 5.8597454441867134e-16
+// mean(f - f_Boost): 2.5535129566378598e-16
+// variance(f - f_Boost): 2.8561208198482198e-31
+// stddev(f - f_Boost): 5.3442687243889785e-16
+const testcase_ellint_3<double>
+data167[10] =
+{
+  { 0.0000000000000000, 0.70000000000000018, 0.60000000000000009, 
+	  0.0000000000000000 },
+  { 0.17604066659721918, 0.70000000000000018, 0.60000000000000009, 
+	  0.17453292519943295 },
+  { 0.36137563278353424, 0.70000000000000018, 0.60000000000000009, 
+	  0.34906585039886590 },
+  { 0.56655721272747606, 0.70000000000000018, 0.60000000000000009, 
+	  0.52359877559829882 },
+  { 0.80468966552978305, 0.70000000000000018, 0.60000000000000009, 
+	  0.69813170079773179 },
+  { 1.0924902943683852, 0.70000000000000018, 0.60000000000000009, 
+	  0.87266462599716477 },
+  { 1.4499247992499800, 0.70000000000000018, 0.60000000000000009, 
+	  1.0471975511965976 },
+  { 1.8953714382113818, 0.70000000000000018, 0.60000000000000009, 
+	  1.2217304763960306 },
+  { 2.4323229949248670, 0.70000000000000018, 0.60000000000000009, 
+	  1.3962634015954636 },
+  { 3.0314573496746746, 0.70000000000000018, 0.60000000000000009, 
+	  1.5707963267948966 },
+};
+const double toler167 = 2.5000000000000020e-13;
+
+// Test data for k=0.70000000000000018, nu=0.70000000000000007.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 3.2316852368580916e-16
+// mean(f - f_Boost): 7.7715611723760953e-17
+// variance(f - f_Boost): 7.4564398834547797e-34
+// stddev(f - f_Boost): 2.7306482533374340e-17
+const testcase_ellint_3<double>
+data168[10] =
+{
+  { 0.0000000000000000, 0.70000000000000018, 0.70000000000000007, 
+	  0.0000000000000000 },
+  { 0.17622185963747933, 0.70000000000000018, 0.70000000000000007, 
+	  0.17453292519943295 },
+  { 0.36292539360435261, 0.70000000000000018, 0.70000000000000007, 
+	  0.34906585039886590 },
+  { 0.57240892970150015, 0.70000000000000018, 0.70000000000000007, 
+	  0.52359877559829882 },
+  { 0.82093084713182629, 0.70000000000000018, 0.70000000000000007, 
+	  0.69813170079773179 },
+  { 1.1312609022179871, 0.70000000000000018, 0.70000000000000007, 
+	  0.87266462599716477 },
+  { 1.5345768067715795, 0.70000000000000018, 0.70000000000000007, 
+	  1.0471975511965976 },
+  { 2.0668847445934424, 0.70000000000000018, 0.70000000000000007, 
+	  1.2217304763960306 },
+  { 2.7483444537551245, 0.70000000000000018, 0.70000000000000007, 
+	  1.3962634015954636 },
+  { 3.5408408771788569, 0.70000000000000018, 0.70000000000000007, 
+	  1.5707963267948966 },
+};
+const double toler168 = 2.5000000000000020e-13;
+
+// Test data for k=0.70000000000000018, nu=0.80000000000000004.
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 4.1198716111867353e-16
+// mean(f - f_Boost): 2.2482016248659419e-16
+// variance(f - f_Boost): 5.4326441655972001e-32
+// stddev(f - f_Boost): 2.3308033305273100e-16
+const testcase_ellint_3<double>
+data169[10] =
+{
+  { 0.0000000000000000, 0.70000000000000018, 0.80000000000000004, 
+	  0.0000000000000000 },
+  { 0.17640372461994805, 0.70000000000000018, 0.80000000000000004, 
+	  0.17453292519943295 },
+  { 0.36449916621651091, 0.70000000000000018, 0.80000000000000004, 
+	  0.34906585039886590 },
+  { 0.57848021800372584, 0.70000000000000018, 0.80000000000000004, 
+	  0.52359877559829882 },
+  { 0.83837480968392586, 0.70000000000000018, 0.80000000000000004, 
+	  0.69813170079773179 },
+  { 1.1751669030061143, 0.70000000000000018, 0.80000000000000004, 
+	  0.87266462599716477 },
+  { 1.6381851899173603, 0.70000000000000018, 0.80000000000000004, 
+	  1.0471975511965976 },
+  { 2.3002065924302197, 0.70000000000000018, 0.80000000000000004, 
+	  1.2217304763960306 },
+  { 3.2337600665337871, 0.70000000000000018, 0.80000000000000004, 
+	  1.3962634015954636 },
+  { 4.4042405729076970, 0.70000000000000018, 0.80000000000000004, 
+	  1.5707963267948966 },
+};
+const double toler169 = 2.5000000000000020e-13;
+
+// Test data for k=0.70000000000000018, nu=0.90000000000000002.
+// max(|f - f_Boost|): 3.5527136788005009e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 8.5869439826269878e-16
+// mean(f - f_Boost): 7.4384942649885490e-16
+// variance(f - f_Boost): 9.7403930714297352e-31
+// stddev(f - f_Boost): 9.8693429727767263e-16
+const testcase_ellint_3<double>
+data170[10] =
+{
+  { 0.0000000000000000, 0.70000000000000018, 0.90000000000000002, 
+	  0.0000000000000000 },
+  { 0.17658626600478800, 0.70000000000000018, 0.90000000000000002, 
+	  0.17453292519943295 },
+  { 0.36609762156017206, 0.70000000000000018, 0.90000000000000002, 
+	  0.34906585039886590 },
+  { 0.58478615187842409, 0.70000000000000018, 0.90000000000000002, 
+	  0.52359877559829882 },
+  { 0.85718862878291846, 0.70000000000000018, 0.90000000000000002, 
+	  0.69813170079773179 },
+  { 1.2255385617397643, 0.70000000000000018, 0.90000000000000002, 
+	  0.87266462599716477 },
+  { 1.7696521899992941, 0.70000000000000018, 0.90000000000000002, 
+	  1.0471975511965976 },
+  { 2.6476314987883507, 0.70000000000000018, 0.90000000000000002, 
+	  1.2217304763960306 },
+  { 4.1373434902898083, 0.70000000000000018, 0.90000000000000002, 
+	  1.3962634015954636 },
+  { 6.3796094177887763, 0.70000000000000018, 0.90000000000000002, 
+	  1.5707963267948966 },
+};
+const double toler170 = 2.5000000000000020e-13;
 
 // Test data for k=0.80000000000000004, nu=0.0000000000000000.
-testcase_ellint_3<double> data171[] = {
-  { -0.0000000000000000, 0.80000000000000004, 0.0000000000000000,
-          0.0000000000000000 },
-  { 0.17510154241338902, 0.80000000000000004, 0.0000000000000000,
-          0.17453292519943295 },
-  { 0.35365068839779390, 0.80000000000000004, 0.0000000000000000,
-          0.34906585039886590 },
-  { 0.53926804409084561, 0.80000000000000004, 0.0000000000000000,
-          0.52359877559829882 },
-  { 0.73587926028070383, 0.80000000000000004, 0.0000000000000000,
-          0.69813170079773179 },
-  { 0.94770942970071170, 0.80000000000000004, 0.0000000000000000,
-          0.87266462599716477 },
-  { 1.1789022995388239, 0.80000000000000004, 0.0000000000000000,
-          1.0471975511965976 },
-  { 1.4323027881876009, 0.80000000000000004, 0.0000000000000000,
-          1.2217304763960306 },
-  { 1.7069629739121674, 0.80000000000000004, 0.0000000000000000,
-          1.3962634015954636 },
-  { 1.9953027776647296, 0.80000000000000004, 0.0000000000000000,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.80000000000000004, nu=0.0000000000000000.
-template <typename Tp>
-void test171()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data171)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data171[i].k), Tp(data171[i].nu),
-                   Tp(data171[i].phi));
-      const Tp f0 = data171[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 1.5543122344752192e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 7.7898565163847540e-16
+// mean(f - f_Boost): 2.3869795029440865e-16
+// variance(f - f_Boost): 2.1368406725192426e-31
+// stddev(f - f_Boost): 4.6225974002926564e-16
+const testcase_ellint_3<double>
+data171[10] =
+{
+  { 0.0000000000000000, 0.80000000000000004, 0.0000000000000000, 
+	  0.0000000000000000 },
+  { 0.17510154241338899, 0.80000000000000004, 0.0000000000000000, 
+	  0.17453292519943295 },
+  { 0.35365068839779396, 0.80000000000000004, 0.0000000000000000, 
+	  0.34906585039886590 },
+  { 0.53926804409084550, 0.80000000000000004, 0.0000000000000000, 
+	  0.52359877559829882 },
+  { 0.73587926028070372, 0.80000000000000004, 0.0000000000000000, 
+	  0.69813170079773179 },
+  { 0.94770942970071170, 0.80000000000000004, 0.0000000000000000, 
+	  0.87266462599716477 },
+  { 1.1789022995388236, 0.80000000000000004, 0.0000000000000000, 
+	  1.0471975511965976 },
+  { 1.4323027881876012, 0.80000000000000004, 0.0000000000000000, 
+	  1.2217304763960306 },
+  { 1.7069629739121677, 0.80000000000000004, 0.0000000000000000, 
+	  1.3962634015954636 },
+  { 1.9953027776647294, 0.80000000000000004, 0.0000000000000000, 
+	  1.5707963267948966 },
+};
+const double toler171 = 2.5000000000000020e-13;
 
 // Test data for k=0.80000000000000004, nu=0.10000000000000001.
-testcase_ellint_3<double> data172[] = {
-  { -0.0000000000000000, 0.80000000000000004, 0.10000000000000001,
-          0.0000000000000000 },
-  { 0.17492468824017166, 0.80000000000000004, 0.10000000000000001,
-          0.17453292519943295 },
-  { 0.35224443521476911, 0.80000000000000004, 0.10000000000000001,
-          0.34906585039886590 },
-  { 0.53456851853226961, 0.80000000000000004, 0.10000000000000001,
-          0.52359877559829882 },
-  { 0.72488875602364944, 0.80000000000000004, 0.10000000000000001,
-          0.69813170079773179 },
-  { 0.92661354274638952, 0.80000000000000004, 0.10000000000000001,
-          0.87266462599716477 },
-  { 1.1432651144499077, 0.80000000000000004, 0.10000000000000001,
-          1.0471975511965976 },
-  { 1.3774479927211429, 0.80000000000000004, 0.10000000000000001,
-          1.2217304763960306 },
-  { 1.6287092337196041, 0.80000000000000004, 0.10000000000000001,
-          1.3962634015954636 },
-  { 1.8910755418379521, 0.80000000000000004, 0.10000000000000001,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.80000000000000004, nu=0.10000000000000001.
-template <typename Tp>
-void test172()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data172)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data172[i].k), Tp(data172[i].nu),
-                   Tp(data172[i].phi));
-      const Tp f0 = data172[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 8.3898786942190374e-16
+// mean(f - f_Boost): 2.3869795029440865e-16
+// variance(f - f_Boost): 2.9190059990693968e-31
+// stddev(f - f_Boost): 5.4027826155319237e-16
+const testcase_ellint_3<double>
+data172[10] =
+{
+  { 0.0000000000000000, 0.80000000000000004, 0.10000000000000001, 
+	  0.0000000000000000 },
+  { 0.17527903952342144, 0.80000000000000004, 0.10000000000000001, 
+	  0.17453292519943295 },
+  { 0.35507705313548549, 0.80000000000000004, 0.10000000000000001, 
+	  0.34906585039886590 },
+  { 0.54411455987643553, 0.80000000000000004, 0.10000000000000001, 
+	  0.52359877559829882 },
+  { 0.74745625666804383, 0.80000000000000004, 0.10000000000000001, 
+	  0.69813170079773179 },
+  { 0.97046953684238557, 0.80000000000000004, 0.10000000000000001, 
+	  0.87266462599716477 },
+  { 1.2183080025184605, 0.80000000000000004, 0.10000000000000001, 
+	  1.0471975511965976 },
+  { 1.4943711151994405, 0.80000000000000004, 0.10000000000000001, 
+	  1.2217304763960306 },
+  { 1.7972401309544201, 0.80000000000000004, 0.10000000000000001, 
+	  1.3962634015954636 },
+  { 2.1172616484005085, 0.80000000000000004, 0.10000000000000001, 
+	  1.5707963267948966 },
+};
+const double toler172 = 2.5000000000000020e-13;
 
 // Test data for k=0.80000000000000004, nu=0.20000000000000001.
-testcase_ellint_3<double> data173[] = {
-  { -0.0000000000000000, 0.80000000000000004, 0.20000000000000001,
-          0.0000000000000000 },
-  { 0.17474847286224943, 0.80000000000000004, 0.20000000000000001,
-          0.17453292519943295 },
-  { 0.35085779529084682, 0.80000000000000004, 0.20000000000000001,
-          0.34906585039886590 },
-  { 0.53000829263059157, 0.80000000000000004, 0.20000000000000001,
-          0.52359877559829882 },
-  { 0.71443466027453406, 0.80000000000000004, 0.20000000000000001,
-          0.69813170079773179 },
-  { 0.90698196872715420, 0.80000000000000004, 0.20000000000000001,
-          0.87266462599716477 },
-  { 1.1108198200558581, 0.80000000000000004, 0.20000000000000001,
-          1.0471975511965976 },
-  { 1.3284988909963957, 0.80000000000000004, 0.20000000000000001,
-          1.2217304763960306 },
-  { 1.5600369318140328, 0.80000000000000004, 0.20000000000000001,
-          1.3962634015954636 },
-  { 1.8007226661734588, 0.80000000000000004, 0.20000000000000001,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.80000000000000004, nu=0.20000000000000001.
-template <typename Tp>
-void test173()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data173)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data173[i].k), Tp(data173[i].nu),
-                   Tp(data173[i].phi));
-      const Tp f0 = data173[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.80000000000000004, nu=0.29999999999999999.
-testcase_ellint_3<double> data174[] = {
-  { -0.0000000000000000, 0.80000000000000004, 0.29999999999999999,
-          0.0000000000000000 },
-  { 0.17457289217669891, 0.80000000000000004, 0.29999999999999999,
-          0.17453292519943295 },
-  { 0.34949028801501258, 0.80000000000000004, 0.29999999999999999,
-          0.34906585039886590 },
-  { 0.52558024362769318, 0.80000000000000004, 0.29999999999999999,
-          0.52359877559829882 },
-  { 0.70447281740094914, 0.80000000000000004, 0.29999999999999999,
-          0.69813170079773179 },
-  { 0.88864745641528986, 0.80000000000000004, 0.29999999999999999,
-          0.87266462599716477 },
-  { 1.0811075819341465, 0.80000000000000004, 0.29999999999999999,
-          1.0471975511965976 },
-  { 1.2844589654082377, 0.80000000000000004, 0.29999999999999999,
-          1.2217304763960306 },
-  { 1.4991461361277849, 0.80000000000000004, 0.29999999999999999,
-          1.3962634015954636 },
-  { 1.7214611048717301, 0.80000000000000004, 0.29999999999999999,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.80000000000000004, nu=0.29999999999999999.
-template <typename Tp>
-void test174()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data174)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data174[i].k), Tp(data174[i].nu),
-                   Tp(data174[i].phi));
-      const Tp f0 = data174[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 7.8513740186068518e-16
+// mean(f - f_Boost): 2.8310687127941490e-16
+// variance(f - f_Boost): 2.7528339102381189e-31
+// stddev(f - f_Boost): 5.2467455724840699e-16
+const testcase_ellint_3<double>
+data173[10] =
+{
+  { 0.0000000000000000, 0.80000000000000004, 0.20000000000000001, 
+	  0.0000000000000000 },
+  { 0.17545718375086419, 0.80000000000000004, 0.20000000000000001, 
+	  0.17453292519943295 },
+  { 0.35652404627248163, 0.80000000000000004, 0.20000000000000001, 
+	  0.34906585039886590 },
+  { 0.54911638512920913, 0.80000000000000004, 0.20000000000000001, 
+	  0.52359877559829882 },
+  { 0.75967684282131176, 0.80000000000000004, 0.20000000000000001, 
+	  0.69813170079773179 },
+  { 0.99513526893543769, 0.80000000000000004, 0.20000000000000001, 
+	  0.87266462599716477 },
+  { 1.2622192109995993, 0.80000000000000004, 0.20000000000000001, 
+	  1.0471975511965976 },
+  { 1.5654106676347741, 0.80000000000000004, 0.20000000000000001, 
+	  1.2217304763960306 },
+  { 1.9029531718534984, 0.80000000000000004, 0.20000000000000001, 
+	  1.3962634015954636 },
+  { 2.2624789434186798, 0.80000000000000004, 0.20000000000000001, 
+	  1.5707963267948966 },
+};
+const double toler173 = 2.5000000000000020e-13;
+
+// Test data for k=0.80000000000000004, nu=0.30000000000000004.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 7.2825261583337354e-16
+// mean(f - f_Boost): 2.6367796834847468e-16
+// variance(f - f_Boost): 2.8249350208968825e-31
+// stddev(f - f_Boost): 5.3150117788175054e-16
+const testcase_ellint_3<double>
+data174[10] =
+{
+  { 0.0000000000000000, 0.80000000000000004, 0.30000000000000004, 
+	  0.0000000000000000 },
+  { 0.17563597931587369, 0.80000000000000004, 0.30000000000000004, 
+	  0.17453292519943295 },
+  { 0.35799220412005128, 0.80000000000000004, 0.30000000000000004, 
+	  0.34906585039886590 },
+  { 0.55428253691111318, 0.80000000000000004, 0.30000000000000004, 
+	  0.52359877559829882 },
+  { 0.77260647376977365, 0.80000000000000004, 0.30000000000000004, 
+	  0.69813170079773179 },
+  { 1.0220015271210958, 0.80000000000000004, 0.30000000000000004, 
+	  0.87266462599716477 },
+  { 1.3115965312302671, 0.80000000000000004, 0.30000000000000004, 
+	  1.0471975511965976 },
+  { 1.6478518468813512, 0.80000000000000004, 0.30000000000000004, 
+	  1.2217304763960306 },
+  { 2.0290458414203481, 0.80000000000000004, 0.30000000000000004, 
+	  1.3962634015954636 },
+  { 2.4392042002725693, 0.80000000000000004, 0.30000000000000004, 
+	  1.5707963267948966 },
+};
+const double toler174 = 2.5000000000000020e-13;
 
 // Test data for k=0.80000000000000004, nu=0.40000000000000002.
-testcase_ellint_3<double> data175[] = {
-  { -0.0000000000000000, 0.80000000000000004, 0.40000000000000002,
-          0.0000000000000000 },
-  { 0.17439794211872178, 0.80000000000000004, 0.40000000000000002,
-          0.17453292519943295 },
-  { 0.34814144964568972, 0.80000000000000004, 0.40000000000000002,
-          0.34906585039886590 },
-  { 0.52127776285273075, 0.80000000000000004, 0.40000000000000002,
-          0.52359877559829882 },
-  { 0.69496411438966599, 0.80000000000000004, 0.40000000000000002,
-          0.69813170079773179 },
-  { 0.87146878427509589, 0.80000000000000004, 0.40000000000000002,
-          0.87266462599716477 },
-  { 1.0537579024937762, 0.80000000000000004, 0.40000000000000002,
-          1.0471975511965976 },
-  { 1.2445534387922637, 0.80000000000000004, 0.40000000000000002,
-          1.2217304763960306 },
-  { 1.4446769766361993, 0.80000000000000004, 0.40000000000000002,
-          1.3962634015954636 },
-  { 1.6512267838651289, 0.80000000000000004, 0.40000000000000002,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.80000000000000004, nu=0.40000000000000002.
-template <typename Tp>
-void test175()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data175)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data175[i].k), Tp(data175[i].nu),
-                   Tp(data175[i].phi));
-      const Tp f0 = data175[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 2.2204460492503131e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 8.3462748389836647e-16
+// mean(f - f_Boost): 3.3861802251067273e-16
+// variance(f - f_Boost): 4.3719465706454422e-31
+// stddev(f - f_Boost): 6.6120696991527871e-16
+const testcase_ellint_3<double>
+data175[10] =
+{
+  { 0.0000000000000000, 0.80000000000000004, 0.40000000000000002, 
+	  0.0000000000000000 },
+  { 0.17581543047866136, 0.80000000000000004, 0.40000000000000002, 
+	  0.17453292519943295 },
+  { 0.35948208343061633, 0.80000000000000004, 0.40000000000000002, 
+	  0.34906585039886590 },
+  { 0.55962280893702021, 0.80000000000000004, 0.40000000000000002, 
+	  0.52359877559829882 },
+  { 0.78632063889234116, 0.80000000000000004, 0.40000000000000002, 
+	  0.69813170079773179 },
+  { 1.0514333069550323, 0.80000000000000004, 0.40000000000000002, 
+	  0.87266462599716477 },
+  { 1.3677213138838757, 0.80000000000000004, 0.40000000000000002, 
+	  1.0471975511965976 },
+  { 1.7451736773665165, 0.80000000000000004, 0.40000000000000002, 
+	  1.2217304763960306 },
+  { 2.1830100424586831, 0.80000000000000004, 0.40000000000000002, 
+	  1.3962634015954636 },
+  { 2.6604037035529724, 0.80000000000000004, 0.40000000000000002, 
+	  1.5707963267948966 },
+};
+const double toler175 = 2.5000000000000020e-13;
 
 // Test data for k=0.80000000000000004, nu=0.50000000000000000.
-testcase_ellint_3<double> data176[] = {
-  { -0.0000000000000000, 0.80000000000000004, 0.50000000000000000,
-          0.0000000000000000 },
-  { 0.17422361866118047, 0.80000000000000004, 0.50000000000000000,
-          0.17453292519943295 },
-  { 0.34681083254170475, 0.80000000000000004, 0.50000000000000000,
-          0.34906585039886590 },
-  { 0.51709470815494440, 0.80000000000000004, 0.50000000000000000,
-          0.52359877559829882 },
-  { 0.68587375344080259, 0.80000000000000004, 0.50000000000000000,
-          0.69813170079773179 },
-  { 0.85532571852810624, 0.80000000000000004, 0.50000000000000000,
-          0.87266462599716477 },
-  { 1.0284677391874906, 0.80000000000000004, 0.50000000000000000,
-          1.0471975511965976 },
-  { 1.2081693942686225, 0.80000000000000004, 0.50000000000000000,
-          1.2217304763960306 },
-  { 1.3955803006426311, 0.80000000000000004, 0.50000000000000000,
-          1.3962634015954636 },
-  { 1.5884528947755532, 0.80000000000000004, 0.50000000000000000,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.80000000000000004, nu=0.50000000000000000.
-template <typename Tp>
-void test176()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data176)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data176[i].k), Tp(data176[i].nu),
-                   Tp(data176[i].phi));
-      const Tp f0 = data176[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.80000000000000004, nu=0.59999999999999998.
-testcase_ellint_3<double> data177[] = {
-  { -0.0000000000000000, 0.80000000000000004, 0.59999999999999998,
-          0.0000000000000000 },
-  { 0.17404991781414092, 0.80000000000000004, 0.59999999999999998,
-          0.17453292519943295 },
-  { 0.34549800443625167, 0.80000000000000004, 0.59999999999999998,
-          0.34906585039886590 },
-  { 0.51302536167001556, 0.80000000000000004, 0.59999999999999998,
-          0.52359877559829882 },
-  { 0.67717065003912258, 0.80000000000000004, 0.59999999999999998,
-          0.69813170079773179 },
-  { 0.84011512421134416, 0.80000000000000004, 0.59999999999999998,
-          0.87266462599716477 },
-  { 1.0049863847088742, 0.80000000000000004, 0.59999999999999998,
-          1.0471975511965976 },
-  { 1.1748145941898918, 0.80000000000000004, 0.59999999999999998,
-          1.2217304763960306 },
-  { 1.3510319699755071, 0.80000000000000004, 0.59999999999999998,
-          1.3962634015954636 },
-  { 1.5319262547427865, 0.80000000000000004, 0.59999999999999998,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.80000000000000004, nu=0.59999999999999998.
-template <typename Tp>
-void test177()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data177)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data177[i].k), Tp(data177[i].nu),
-                   Tp(data177[i].phi));
-      const Tp f0 = data177[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.80000000000000004, nu=0.69999999999999996.
-testcase_ellint_3<double> data178[] = {
-  { -0.0000000000000000, 0.80000000000000004, 0.69999999999999996,
-          0.0000000000000000 },
-  { 0.17387683562442202, 0.80000000000000004, 0.69999999999999996,
-          0.17453292519943295 },
-  { 0.34420254775101611, 0.80000000000000004, 0.69999999999999996,
-          0.34906585039886590 },
-  { 0.50906439222143685, 0.80000000000000004, 0.69999999999999996,
-          0.52359877559829882 },
-  { 0.66882693152688433, 0.80000000000000004, 0.69999999999999996,
-          0.69813170079773179 },
-  { 0.82574792844091316, 0.80000000000000004, 0.69999999999999996,
-          0.87266462599716477 },
-  { 0.98310431309490953, 0.80000000000000004, 0.69999999999999996,
-          1.0471975511965976 },
-  { 1.1440884535113258, 0.80000000000000004, 0.69999999999999996,
-          1.2217304763960306 },
-  { 1.3103743938952537, 0.80000000000000004, 0.69999999999999996,
-          1.3962634015954636 },
-  { 1.4806912324625332, 0.80000000000000004, 0.69999999999999996,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.80000000000000004, nu=0.69999999999999996.
-template <typename Tp>
-void test178()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data178)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data178[i].k), Tp(data178[i].nu),
-                   Tp(data178[i].phi));
-      const Tp f0 = data178[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 2.6645352591003757e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 9.0388243828581744e-16
+// mean(f - f_Boost): 3.8580250105724191e-16
+// variance(f - f_Boost): 6.4106456575047741e-31
+// stddev(f - f_Boost): 8.0066507713929764e-16
+const testcase_ellint_3<double>
+data176[10] =
+{
+  { 0.0000000000000000, 0.80000000000000004, 0.50000000000000000, 
+	  0.0000000000000000 },
+  { 0.17599554153999472, 0.80000000000000004, 0.50000000000000000, 
+	  0.17453292519943295 },
+  { 0.36099426243351540, 0.80000000000000004, 0.50000000000000000, 
+	  0.34906585039886590 },
+  { 0.56514786174780673, 0.80000000000000004, 0.50000000000000000, 
+	  0.52359877559829882 },
+  { 0.80090697622371010, 0.80000000000000004, 0.50000000000000000, 
+	  0.69813170079773179 },
+  { 1.0838891627679339, 0.80000000000000004, 0.50000000000000000, 
+	  0.87266462599716477 },
+  { 1.4323506654466280, 0.80000000000000004, 0.50000000000000000, 
+	  1.0471975511965976 },
+  { 1.8625761085390575, 0.80000000000000004, 0.50000000000000000, 
+	  1.2217304763960306 },
+  { 2.3768757305654766, 0.80000000000000004, 0.50000000000000000, 
+	  1.3962634015954636 },
+  { 2.9478781158239746, 0.80000000000000004, 0.50000000000000000, 
+	  1.5707963267948966 },
+};
+const double toler176 = 2.5000000000000020e-13;
+
+// Test data for k=0.80000000000000004, nu=0.60000000000000009.
+// max(|f - f_Boost|): 3.5527136788005009e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 1.0631099169042069e-15
+// mean(f - f_Boost): 4.8294701571194306e-16
+// variance(f - f_Boost): 1.1633910328160319e-30
+// stddev(f - f_Boost): 1.0786060600682865e-15
+const testcase_ellint_3<double>
+data177[10] =
+{
+  { 0.0000000000000000, 0.80000000000000004, 0.60000000000000009, 
+	  0.0000000000000000 },
+  { 0.17617631684170665, 0.80000000000000004, 0.60000000000000009, 
+	  0.17453292519943295 },
+  { 0.36252934193666231, 0.80000000000000004, 0.60000000000000009, 
+	  0.34906585039886590 },
+  { 0.57086932622945163, 0.80000000000000004, 0.60000000000000009, 
+	  0.52359877559829882 },
+  { 0.81646796740150973, 0.80000000000000004, 0.60000000000000009, 
+	  0.69813170079773179 },
+  { 1.1199552158519064, 0.80000000000000004, 0.60000000000000009, 
+	  0.87266462599716477 },
+  { 1.5079766673336394, 0.80000000000000004, 0.60000000000000009, 
+	  1.0471975511965976 },
+  { 2.0082747447038165, 0.80000000000000004, 0.60000000000000009, 
+	  1.2217304763960306 },
+  { 2.6315146066775523, 0.80000000000000004, 0.60000000000000009, 
+	  1.3962634015954636 },
+  { 3.3418121892288051, 0.80000000000000004, 0.60000000000000009, 
+	  1.5707963267948966 },
+};
+const double toler177 = 2.5000000000000020e-13;
+
+// Test data for k=0.80000000000000004, nu=0.70000000000000007.
+// max(|f - f_Boost|): 2.2204460492503131e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 5.6544679145741375e-16
+// mean(f - f_Boost): 3.2751579226442120e-16
+// variance(f - f_Boost): 4.4236851331020672e-31
+// stddev(f - f_Boost): 6.6510789599147505e-16
+const testcase_ellint_3<double>
+data178[10] =
+{
+  { 0.0000000000000000, 0.80000000000000004, 0.70000000000000007, 
+	  0.0000000000000000 },
+  { 0.17635776076721221, 0.80000000000000004, 0.70000000000000007, 
+	  0.17453292519943295 },
+  { 0.36408794649916976, 0.80000000000000004, 0.70000000000000007, 
+	  0.34906585039886590 },
+  { 0.57679992290624138, 0.80000000000000004, 0.70000000000000007, 
+	  0.52359877559829882 },
+  { 0.83312441418142813, 0.80000000000000004, 0.70000000000000007, 
+	  0.69813170079773179 },
+  { 1.1603958891464856, 0.80000000000000004, 0.70000000000000007, 
+	  0.87266462599716477 },
+  { 1.5982855143796213, 0.80000000000000004, 0.70000000000000007, 
+	  1.0471975511965976 },
+  { 2.1962484408371821, 0.80000000000000004, 0.70000000000000007, 
+	  1.2217304763960306 },
+  { 2.9873281786111869, 0.80000000000000004, 0.70000000000000007, 
+	  1.3962634015954636 },
+  { 3.9268876980046397, 0.80000000000000004, 0.70000000000000007, 
+	  1.5707963267948966 },
+};
+const double toler178 = 2.5000000000000020e-13;
 
 // Test data for k=0.80000000000000004, nu=0.80000000000000004.
-testcase_ellint_3<double> data179[] = {
-  { -0.0000000000000000, 0.80000000000000004, 0.80000000000000004,
-          0.0000000000000000 },
-  { 0.17370436817515206, 0.80000000000000004, 0.80000000000000004,
-          0.17453292519943295 },
-  { 0.34292405894783395, 0.80000000000000004, 0.80000000000000004,
-          0.34906585039886590 },
-  { 0.50520682176250087, 0.80000000000000004, 0.80000000000000004,
-          0.52359877559829882 },
-  { 0.66081751679736189, 0.80000000000000004, 0.80000000000000004,
-          0.69813170079773179 },
-  { 0.81214672249355102, 0.80000000000000004, 0.80000000000000004,
-          0.87266462599716477 },
-  { 0.96264481387685574, 0.80000000000000004, 0.80000000000000004,
-          1.0471975511965976 },
-  { 1.1156611352656258, 0.80000000000000004, 0.80000000000000004,
-          1.2217304763960306 },
-  { 1.2730756225143889, 0.80000000000000004, 0.80000000000000004,
-          1.3962634015954636 },
-  { 1.4339837018309474, 0.80000000000000004, 0.80000000000000004,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.80000000000000004, nu=0.80000000000000004.
-template <typename Tp>
-void test179()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data179)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data179[i].k), Tp(data179[i].nu),
-                   Tp(data179[i].phi));
-      const Tp f0 = data179[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 4.4408920985006262e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 9.0176949165011079e-16
+// mean(f - f_Boost): 7.0499162063697436e-16
+// variance(f - f_Boost): 1.7230805408026989e-30
+// stddev(f - f_Boost): 1.3126616246400665e-15
+const testcase_ellint_3<double>
+data179[10] =
+{
+  { 0.0000000000000000, 0.80000000000000004, 0.80000000000000004, 
+	  0.0000000000000000 },
+  { 0.17653987774203392, 0.80000000000000004, 0.80000000000000004, 
+	  0.17453292519943295 },
+  { 0.36567072568046877, 0.80000000000000004, 0.80000000000000004, 
+	  0.34906585039886590 },
+  { 0.58295359996558616, 0.80000000000000004, 0.80000000000000004, 
+	  0.52359877559829882 },
+  { 0.85101998309176108, 0.80000000000000004, 0.80000000000000004, 
+	  0.69813170079773179 },
+  { 1.2062322059736537, 0.80000000000000004, 0.80000000000000004, 
+	  0.87266462599716477 },
+  { 1.7090321420917429, 0.80000000000000004, 0.80000000000000004, 
+	  1.0471975511965976 },
+  { 2.4529058049405066, 0.80000000000000004, 0.80000000000000004, 
+	  1.2217304763960306 },
+  { 3.5368893360106948, 0.80000000000000004, 0.80000000000000004, 
+	  1.3962634015954636 },
+  { 4.9246422058196062, 0.80000000000000004, 0.80000000000000004, 
+	  1.5707963267948966 },
+};
+const double toler179 = 2.5000000000000020e-13;
 
 // Test data for k=0.80000000000000004, nu=0.90000000000000002.
-testcase_ellint_3<double> data180[] = {
-  { -0.0000000000000000, 0.80000000000000004, 0.90000000000000002,
-          0.0000000000000000 },
-  { 0.17353251158533153, 0.80000000000000004, 0.90000000000000002,
-          0.17453292519943295 },
-  { 0.34166214791545768, 0.80000000000000004, 0.90000000000000002,
-          0.34906585039886590 },
-  { 0.50144799535130580, 0.80000000000000004, 0.90000000000000002,
-          0.52359877559829882 },
-  { 0.65311976193814447, 0.80000000000000004, 0.90000000000000002,
-          0.69813170079773179 },
-  { 0.79924384892320866, 0.80000000000000004, 0.90000000000000002,
-          0.87266462599716477 },
-  { 0.94345762353365625, 0.80000000000000004, 0.90000000000000002,
-          1.0471975511965976 },
-  { 1.0892582069219159, 0.80000000000000004, 0.90000000000000002,
-          1.2217304763960306 },
-  { 1.2387000876610268, 0.80000000000000004, 0.90000000000000002,
-          1.3962634015954636 },
-  { 1.3911845406776222, 0.80000000000000004, 0.90000000000000002,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.80000000000000004, nu=0.90000000000000002.
-template <typename Tp>
-void test180()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data180)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data180[i].k), Tp(data180[i].nu),
-                   Tp(data180[i].phi));
-      const Tp f0 = data180[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.89999999999999991, nu=0.0000000000000000.
-testcase_ellint_3<double> data181[] = {
-  { -0.0000000000000000, 0.89999999999999991, 0.0000000000000000,
-          0.0000000000000000 },
-  { 0.17525427376115027, 0.89999999999999991, 0.0000000000000000,
-          0.17453292519943295 },
-  { 0.35492464591297446, 0.89999999999999991, 0.0000000000000000,
-          0.34906585039886590 },
-  { 0.54388221416157123, 0.89999999999999991, 0.0000000000000000,
-          0.52359877559829882 },
-  { 0.74797400423532501, 0.89999999999999991, 0.0000000000000000,
-          0.69813170079773179 },
-  { 0.97463898451966458, 0.89999999999999991, 0.0000000000000000,
-          0.87266462599716477 },
-  { 1.2334463254523438, 0.89999999999999991, 0.0000000000000000,
-          1.0471975511965976 },
-  { 1.5355247765594910, 0.89999999999999991, 0.0000000000000000,
-          1.2217304763960306 },
-  { 1.8882928567775117, 0.89999999999999991, 0.0000000000000000,
-          1.3962634015954636 },
-  { 2.2805491384227699, 0.89999999999999991, 0.0000000000000000,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.89999999999999991, nu=0.0000000000000000.
-template <typename Tp>
-void test181()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data181)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data181[i].k), Tp(data181[i].nu),
-                   Tp(data181[i].phi));
-      const Tp f0 = data181[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.89999999999999991, nu=0.10000000000000001.
-testcase_ellint_3<double> data182[] = {
-  { -0.0000000000000000, 0.89999999999999991, 0.10000000000000001,
-          0.0000000000000000 },
-  { 0.17507714233254659, 0.89999999999999991, 0.10000000000000001,
-          0.17453292519943295 },
-  { 0.35350932904326521, 0.89999999999999991, 0.10000000000000001,
-          0.34906585039886590 },
-  { 0.53911129989870987, 0.89999999999999991, 0.10000000000000001,
-          0.52359877559829882 },
-  { 0.73666644254508407, 0.89999999999999991, 0.10000000000000001,
-          0.69813170079773179 },
-  { 0.95250736612100184, 0.89999999999999991, 0.10000000000000001,
-          0.87266462599716477 },
-  { 1.1950199550905591, 0.89999999999999991, 0.10000000000000001,
-          1.0471975511965976 },
-  { 1.4741687286340848, 0.89999999999999991, 0.10000000000000001,
-          1.2217304763960306 },
-  { 1.7968678183506053, 0.89999999999999991, 0.10000000000000001,
-          1.3962634015954636 },
-  { 2.1537868513875282, 0.89999999999999991, 0.10000000000000001,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.89999999999999991, nu=0.10000000000000001.
-template <typename Tp>
-void test182()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data182)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data182[i].k), Tp(data182[i].nu),
-                   Tp(data182[i].phi));
-      const Tp f0 = data182[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.89999999999999991, nu=0.20000000000000001.
-testcase_ellint_3<double> data183[] = {
-  { -0.0000000000000000, 0.89999999999999991, 0.20000000000000001,
-          0.0000000000000000 },
-  { 0.17490065089140930, 0.89999999999999991, 0.20000000000000001,
-          0.17453292519943295 },
-  { 0.35211377590661436, 0.89999999999999991, 0.20000000000000001,
-          0.34906585039886590 },
-  { 0.53448220334204111, 0.89999999999999991, 0.20000000000000001,
-          0.52359877559829882 },
-  { 0.72591368943179591, 0.89999999999999991, 0.20000000000000001,
-          0.69813170079773179 },
-  { 0.93192539780038763, 0.89999999999999991, 0.20000000000000001,
-          0.87266462599716477 },
-  { 1.1600809679692681, 0.89999999999999991, 0.20000000000000001,
-          1.0471975511965976 },
-  { 1.4195407225882508, 0.89999999999999991, 0.20000000000000001,
-          1.2217304763960306 },
-  { 1.7168966476424521, 0.89999999999999991, 0.20000000000000001,
-          1.3962634015954636 },
-  { 2.0443194576468890, 0.89999999999999991, 0.20000000000000001,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.89999999999999991, nu=0.20000000000000001.
-template <typename Tp>
-void test183()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data183)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data183[i].k), Tp(data183[i].nu),
-                   Tp(data183[i].phi));
-      const Tp f0 = data183[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.89999999999999991, nu=0.29999999999999999.
-testcase_ellint_3<double> data184[] = {
-  { -0.0000000000000000, 0.89999999999999991, 0.29999999999999999,
-          0.0000000000000000 },
-  { 0.17472479532647534, 0.89999999999999991, 0.29999999999999999,
-          0.17453292519943295 },
-  { 0.35073750187374114, 0.89999999999999991, 0.29999999999999999,
-          0.34906585039886590 },
-  { 0.52998766129466968, 0.89999999999999991, 0.29999999999999999,
-          0.52359877559829882 },
-  { 0.71566993548699565, 0.89999999999999991, 0.29999999999999999,
-          0.69813170079773179 },
-  { 0.91271517762560195, 0.89999999999999991, 0.29999999999999999,
-          0.87266462599716477 },
-  { 1.1281241199843368, 0.89999999999999991, 0.29999999999999999,
-          1.0471975511965976 },
-  { 1.3704929576917448, 0.89999999999999991, 0.29999999999999999,
-          1.2217304763960306 },
-  { 1.6461981511487711, 0.89999999999999991, 0.29999999999999999,
-          1.3962634015954636 },
-  { 1.9486280260314424, 0.89999999999999991, 0.29999999999999999,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.89999999999999991, nu=0.29999999999999999.
-template <typename Tp>
-void test184()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data184)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data184[i].k), Tp(data184[i].nu),
-                   Tp(data184[i].phi));
-      const Tp f0 = data184[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.89999999999999991, nu=0.40000000000000002.
-testcase_ellint_3<double> data185[] = {
-  { -0.0000000000000000, 0.89999999999999991, 0.40000000000000002,
-          0.0000000000000000 },
-  { 0.17454957156468839, 0.89999999999999991, 0.40000000000000002,
-          0.17453292519943295 },
-  { 0.34938003933330430, 0.89999999999999991, 0.40000000000000002,
-          0.34906585039886590 },
-  { 0.52562093533067444, 0.89999999999999991, 0.40000000000000002,
-          0.52359877559829882 },
-  { 0.70589461324915681, 0.89999999999999991, 0.40000000000000002,
-          0.69813170079773179 },
-  { 0.89472658511942849, 0.89999999999999991, 0.40000000000000002,
-          0.87266462599716477 },
-  { 1.0987419542323438, 0.89999999999999991, 0.40000000000000002,
-          1.0471975511965976 },
-  { 1.3261349565496301, 0.89999999999999991, 0.40000000000000002,
-          1.2217304763960306 },
-  { 1.5831293909853761, 0.89999999999999991, 0.40000000000000002,
-          1.3962634015954636 },
-  { 1.8641114227238347, 0.89999999999999991, 0.40000000000000002,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.89999999999999991, nu=0.40000000000000002.
-template <typename Tp>
-void test185()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data185)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data185[i].k), Tp(data185[i].nu),
-                   Tp(data185[i].phi));
-      const Tp f0 = data185[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.89999999999999991, nu=0.50000000000000000.
-testcase_ellint_3<double> data186[] = {
-  { -0.0000000000000000, 0.89999999999999991, 0.50000000000000000,
-          0.0000000000000000 },
-  { 0.17437497557073336, 0.89999999999999991, 0.50000000000000000,
-          0.17453292519943295 },
-  { 0.34804093691586013, 0.89999999999999991, 0.50000000000000000,
-          0.34906585039886590 },
-  { 0.52137576320372903, 0.89999999999999991, 0.50000000000000000,
-          0.52359877559829882 },
-  { 0.69655163996912262, 0.89999999999999991, 0.50000000000000000,
-          0.69813170079773179 },
-  { 0.87783188683054236, 0.89999999999999991, 0.50000000000000000,
-          0.87266462599716477 },
-  { 1.0716015959755183, 0.89999999999999991, 0.50000000000000000,
-          1.0471975511965976 },
-  { 1.2857636916026749, 0.89999999999999991, 0.50000000000000000,
-          1.2217304763960306 },
-  { 1.5264263913252358, 0.89999999999999991, 0.50000000000000000,
-          1.3962634015954636 },
-  { 1.7888013241937859, 0.89999999999999991, 0.50000000000000000,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.89999999999999991, nu=0.50000000000000000.
-template <typename Tp>
-void test186()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data186)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data186[i].k), Tp(data186[i].nu),
-                   Tp(data186[i].phi));
-      const Tp f0 = data186[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.89999999999999991, nu=0.59999999999999998.
-testcase_ellint_3<double> data187[] = {
-  { -0.0000000000000000, 0.89999999999999991, 0.59999999999999998,
-          0.0000000000000000 },
-  { 0.17420100334657815, 0.89999999999999991, 0.59999999999999998,
-          0.17453292519943295 },
-  { 0.34671975876122157, 0.89999999999999991, 0.59999999999999998,
-          0.34906585039886590 },
-  { 0.51724631570707957, 0.89999999999999991, 0.59999999999999998,
-          0.52359877559829882 },
-  { 0.68760879113743034, 0.89999999999999991, 0.59999999999999998,
-          0.69813170079773179 },
-  { 0.86192157779698364, 0.89999999999999991, 0.59999999999999998,
-          0.87266462599716477 },
-  { 1.0464279696166352, 0.89999999999999991, 0.59999999999999998,
-          1.0471975511965976 },
-  { 1.2488156247094004, 0.89999999999999991, 0.59999999999999998,
-          1.2217304763960306 },
-  { 1.4750988777188470, 0.89999999999999991, 0.59999999999999998,
-          1.3962634015954636 },
-  { 1.7211781128919521, 0.89999999999999991, 0.59999999999999998,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.89999999999999991, nu=0.59999999999999998.
-template <typename Tp>
-void test187()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data187)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data187[i].k), Tp(data187[i].nu),
-                   Tp(data187[i].phi));
-      const Tp f0 = data187[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.89999999999999991, nu=0.69999999999999996.
-testcase_ellint_3<double> data188[] = {
-  { -0.0000000000000000, 0.89999999999999991, 0.69999999999999996,
-          0.0000000000000000 },
-  { 0.17402765093102210, 0.89999999999999991, 0.69999999999999996,
-          0.17453292519943295 },
-  { 0.34541608382635131, 0.89999999999999991, 0.69999999999999996,
-          0.34906585039886590 },
-  { 0.51322715827061693, 0.89999999999999991, 0.69999999999999996,
-          0.52359877559829882 },
-  { 0.67903717872440283, 0.89999999999999991, 0.69999999999999996,
-          0.69813170079773179 },
-  { 0.84690113601682671, 0.89999999999999991, 0.69999999999999996,
-          0.87266462599716477 },
-  { 1.0229914311548416, 0.89999999999999991, 0.69999999999999996,
-          1.0471975511965976 },
-  { 1.2148329639709381, 0.89999999999999991, 0.69999999999999996,
-          1.2217304763960306 },
-  { 1.4283586501307799, 0.89999999999999991, 0.69999999999999996,
-          1.3962634015954636 },
-  { 1.6600480747670936, 0.89999999999999991, 0.69999999999999996,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.89999999999999991, nu=0.69999999999999996.
-template <typename Tp>
-void test188()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data188)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data188[i].k), Tp(data188[i].nu),
-                   Tp(data188[i].phi));
-      const Tp f0 = data188[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.89999999999999991, nu=0.80000000000000004.
-testcase_ellint_3<double> data189[] = {
-  { -0.0000000000000000, 0.89999999999999991, 0.80000000000000004,
-          0.0000000000000000 },
-  { 0.17385491439925149, 0.89999999999999991, 0.80000000000000004,
-          0.17453292519943295 },
-  { 0.34412950523113928, 0.89999999999999991, 0.80000000000000004,
-          0.34906585039886590 },
-  { 0.50931321668729601, 0.89999999999999991, 0.80000000000000004,
-          0.52359877559829882 },
-  { 0.67081081392296327, 0.89999999999999991, 0.80000000000000004,
-          0.69813170079773179 },
-  { 0.83268846097293259, 0.89999999999999991, 0.80000000000000004,
-          0.87266462599716477 },
-  { 1.0010985015814025, 0.89999999999999991, 0.80000000000000004,
-          1.0471975511965976 },
-  { 1.1834394045489678, 0.89999999999999991, 0.80000000000000004,
-          1.2217304763960306 },
-  { 1.3855695891683182, 0.89999999999999991, 0.80000000000000004,
-          1.3962634015954636 },
-  { 1.6044591960982200, 0.89999999999999991, 0.80000000000000004,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.89999999999999991, nu=0.80000000000000004.
-template <typename Tp>
-void test189()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data189)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data189[i].k), Tp(data189[i].nu),
-                   Tp(data189[i].phi));
-      const Tp f0 = data189[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.89999999999999991, nu=0.90000000000000002.
-testcase_ellint_3<double> data190[] = {
-  { -0.0000000000000000, 0.89999999999999991, 0.90000000000000002,
-          0.0000000000000000 },
-  { 0.17368278986240138, 0.89999999999999991, 0.90000000000000002,
-          0.17453292519943295 },
-  { 0.34285962963961397, 0.89999999999999991, 0.90000000000000002,
-          0.34906585039886590 },
-  { 0.50549974644993312, 0.89999999999999991, 0.90000000000000002,
-          0.52359877559829882 },
-  { 0.66290623857720876, 0.89999999999999991, 0.90000000000000002,
-          0.69813170079773179 },
-  { 0.81921183128847164, 0.89999999999999991, 0.90000000000000002,
-          0.87266462599716477 },
-  { 0.98058481956066368, 0.89999999999999991, 0.90000000000000002,
-          1.0471975511965976 },
-  { 1.1543223520473569, 0.89999999999999991, 0.90000000000000002,
-          1.2217304763960306 },
-  { 1.3462119782292934, 0.89999999999999991, 0.90000000000000002,
-          1.3962634015954636 },
-  { 1.5536420236310944, 0.89999999999999991, 0.90000000000000002,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.89999999999999991, nu=0.90000000000000002.
-template <typename Tp>
-void test190()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data190)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data190[i].k), Tp(data190[i].nu),
-                   Tp(data190[i].phi));
-      const Tp f0 = data190[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 4.4408920985006262e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 7.7782721357365268e-16
+// mean(f - f_Boost): 8.9928064994637676e-16
+// variance(f - f_Boost): 1.5485199571025344e-30
+// stddev(f - f_Boost): 1.2443954183066307e-15
+const testcase_ellint_3<double>
+data180[10] =
+{
+  { 0.0000000000000000, 0.80000000000000004, 0.90000000000000002, 
+	  0.0000000000000000 },
+  { 0.17672267223433513, 0.80000000000000004, 0.90000000000000002, 
+	  0.17453292519943295 },
+  { 0.36727835537196063, 0.80000000000000004, 0.90000000000000002, 
+	  0.34906585039886590 },
+  { 0.58934569363716649, 0.80000000000000004, 0.90000000000000002, 
+	  0.52359877559829882 },
+  { 0.87032723471138851, 0.80000000000000004, 0.90000000000000002, 
+	  0.69813170079773179 },
+  { 1.2588676111323349, 0.80000000000000004, 0.90000000000000002, 
+	  0.87266462599716477 },
+  { 1.8498731900660019, 0.80000000000000004, 0.90000000000000002, 
+	  1.0471975511965976 },
+  { 2.8368381299300420, 0.80000000000000004, 0.90000000000000002, 
+	  1.2217304763960306 },
+  { 4.5674844191654058, 0.80000000000000004, 0.90000000000000002, 
+	  1.3962634015954636 },
+  { 7.2263259298637115, 0.80000000000000004, 0.90000000000000002, 
+	  1.5707963267948966 },
+};
+const double toler180 = 2.5000000000000020e-13;
+
+// Test data for k=0.90000000000000013, nu=0.0000000000000000.
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 4.3381508715713360e-16
+// mean(f - f_Boost): 5.8286708792820721e-17
+// variance(f - f_Boost): 4.1942474344433133e-34
+// stddev(f - f_Boost): 2.0479861900030756e-17
+const testcase_ellint_3<double>
+data181[10] =
+{
+  { 0.0000000000000000, 0.90000000000000013, 0.0000000000000000, 
+	  0.0000000000000000 },
+  { 0.17525427376115027, 0.90000000000000013, 0.0000000000000000, 
+	  0.17453292519943295 },
+  { 0.35492464591297446, 0.90000000000000013, 0.0000000000000000, 
+	  0.34906585039886590 },
+  { 0.54388221416157123, 0.90000000000000013, 0.0000000000000000, 
+	  0.52359877559829882 },
+  { 0.74797400423532512, 0.90000000000000013, 0.0000000000000000, 
+	  0.69813170079773179 },
+  { 0.97463898451966446, 0.90000000000000013, 0.0000000000000000, 
+	  0.87266462599716477 },
+  { 1.2334463254523440, 0.90000000000000013, 0.0000000000000000, 
+	  1.0471975511965976 },
+  { 1.5355247765594915, 0.90000000000000013, 0.0000000000000000, 
+	  1.2217304763960306 },
+  { 1.8882928567775128, 0.90000000000000013, 0.0000000000000000, 
+	  1.3962634015954636 },
+  { 2.2805491384227707, 0.90000000000000013, 0.0000000000000000, 
+	  1.5707963267948966 },
+};
+const double toler181 = 2.5000000000000020e-13;
+
+// Test data for k=0.90000000000000013, nu=0.10000000000000001.
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 4.1500594295134815e-16
+// mean(f - f_Boost): 9.1593399531575410e-17
+// variance(f - f_Boost): 1.0357223256482469e-33
+// stddev(f - f_Boost): 3.2182640128619758e-17
+const testcase_ellint_3<double>
+data182[10] =
+{
+  { 0.0000000000000000, 0.90000000000000013, 0.10000000000000001, 
+	  0.0000000000000000 },
+  { 0.17543204932716244, 0.90000000000000013, 0.10000000000000001, 
+	  0.17453292519943295 },
+  { 0.35636022898551184, 0.90000000000000013, 0.10000000000000001, 
+	  0.34906585039886590 },
+  { 0.54880278898382595, 0.90000000000000013, 0.10000000000000001, 
+	  0.52359877559829882 },
+  { 0.75988834774529268, 0.90000000000000013, 0.10000000000000001, 
+	  0.69813170079773179 },
+  { 0.99853303003568117, 0.90000000000000013, 0.10000000000000001, 
+	  0.87266462599716477 },
+  { 1.2759958823999022, 0.90000000000000013, 0.10000000000000001, 
+	  1.0471975511965976 },
+  { 1.6051187364639401, 0.90000000000000013, 0.10000000000000001, 
+	  1.2217304763960306 },
+  { 1.9941406879519474, 0.90000000000000013, 0.10000000000000001, 
+	  1.3962634015954636 },
+  { 2.4295011187834890, 0.90000000000000013, 0.10000000000000001, 
+	  1.5707963267948966 },
+};
+const double toler182 = 2.5000000000000020e-13;
+
+// Test data for k=0.90000000000000013, nu=0.20000000000000001.
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.9533518431433547e-16
+// mean(f - f_Boost): 1.0269562977782698e-16
+// variance(f - f_Boost): 1.4388836606733082e-32
+// stddev(f - f_Boost): 1.1995347684303728e-16
+const testcase_ellint_3<double>
+data183[10] =
+{
+  { 0.0000000000000000, 0.90000000000000013, 0.20000000000000001, 
+	  0.0000000000000000 },
+  { 0.17561047321968409, 0.90000000000000013, 0.20000000000000001, 
+	  0.17453292519943295 },
+  { 0.35781659944356109, 0.90000000000000013, 0.20000000000000001, 
+	  0.34906585039886590 },
+  { 0.55388150905215283, 0.90000000000000013, 0.20000000000000001, 
+	  0.52359877559829882 },
+  { 0.77246874123251441, 0.90000000000000013, 0.20000000000000001, 
+	  0.69813170079773179 },
+  { 1.0244466254771925, 0.90000000000000013, 0.20000000000000001, 
+	  0.87266462599716477 },
+  { 1.3234824077640801, 0.90000000000000013, 0.20000000000000001, 
+	  1.0471975511965976 },
+  { 1.6849848968804240, 0.90000000000000013, 0.20000000000000001, 
+	  1.2217304763960306 },
+  { 2.1185749045502278, 0.90000000000000013, 0.20000000000000001, 
+	  1.3962634015954636 },
+  { 2.6076835743348417, 0.90000000000000013, 0.20000000000000001, 
+	  1.5707963267948966 },
+};
+const double toler183 = 2.5000000000000020e-13;
+
+// Test data for k=0.90000000000000013, nu=0.30000000000000004.
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.9712691025502371e-16
+// mean(f - f_Boost): 6.9388939039072284e-17
+// variance(f - f_Boost): 5.9442282234173945e-34
+// stddev(f - f_Boost): 2.4380787976227090e-17
+const testcase_ellint_3<double>
+data184[10] =
+{
+  { 0.0000000000000000, 0.90000000000000013, 0.30000000000000004, 
+	  0.0000000000000000 },
+  { 0.17578954966746221, 0.90000000000000013, 0.30000000000000004, 
+	  0.17453292519943295 },
+  { 0.35929429810867447, 0.90000000000000013, 0.30000000000000004, 
+	  0.34906585039886590 },
+  { 0.55912757154240822, 0.90000000000000013, 0.30000000000000004, 
+	  0.52359877559829882 },
+  { 0.78578314722025389, 0.90000000000000013, 0.30000000000000004, 
+	  0.69813170079773179 },
+  { 1.0526941001131365, 0.90000000000000013, 0.30000000000000004, 
+	  0.87266462599716477 },
+  { 1.3769682234538601, 0.90000000000000013, 0.30000000000000004, 
+	  1.0471975511965976 },
+  { 1.7779437432911240, 0.90000000000000013, 0.30000000000000004, 
+	  1.2217304763960306 },
+  { 2.2676509341813635, 0.90000000000000013, 0.30000000000000004, 
+	  1.3962634015954636 },
+  { 2.8256506968858517, 0.90000000000000013, 0.30000000000000004, 
+	  1.5707963267948966 },
+};
+const double toler184 = 2.5000000000000020e-13;
+
+// Test data for k=0.90000000000000013, nu=0.40000000000000002.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 4.7042235432234642e-16
+// mean(f - f_Boost): 1.8041124150158794e-16
+// variance(f - f_Boost): 8.5834655546147173e-33
+// stddev(f - f_Boost): 9.2646994309662939e-17
+const testcase_ellint_3<double>
+data185[10] =
+{
+  { 0.0000000000000000, 0.90000000000000013, 0.40000000000000002, 
+	  0.0000000000000000 },
+  { 0.17596928293938452, 0.90000000000000013, 0.40000000000000002, 
+	  0.17453292519943295 },
+  { 0.36079388642472821, 0.90000000000000013, 0.40000000000000002, 
+	  0.34906585039886590 },
+  { 0.56455096667115612, 0.90000000000000013, 0.40000000000000002, 
+	  0.52359877559829882 },
+  { 0.79990996997869435, 0.90000000000000013, 0.40000000000000002, 
+	  0.69813170079773179 },
+  { 1.0836647913872215, 0.90000000000000013, 0.40000000000000002, 
+	  0.87266462599716477 },
+  { 1.4378726836091849, 0.90000000000000013, 0.40000000000000002, 
+	  1.0471975511965976 },
+  { 1.8880446720682853, 0.90000000000000013, 0.40000000000000002, 
+	  1.2217304763960306 },
+  { 2.4505848932025232, 0.90000000000000013, 0.40000000000000002, 
+	  1.3962634015954636 },
+  { 3.1000689868578624, 0.90000000000000013, 0.40000000000000002, 
+	  1.5707963267948966 },
+};
+const double toler185 = 2.5000000000000020e-13;
+
+// Test data for k=0.90000000000000013, nu=0.50000000000000000.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 4.3939646155354115e-16
+// mean(f - f_Boost): 1.5820678100908481e-16
+// variance(f - f_Boost): 1.0089970755557622e-32
+// stddev(f - f_Boost): 1.0044884646205561e-16
+const testcase_ellint_3<double>
+data186[10] =
+{
+  { 0.0000000000000000, 0.90000000000000013, 0.50000000000000000, 
+	  0.0000000000000000 },
+  { 0.17614967734498183, 0.90000000000000013, 0.50000000000000000, 
+	  0.17453292519943295 },
+  { 0.36231594750319435, 0.90000000000000013, 0.50000000000000000, 
+	  0.34906585039886590 },
+  { 0.57016256984349567, 0.90000000000000013, 0.50000000000000000, 
+	  0.52359877559829882 },
+  { 0.81494025918293422, 0.90000000000000013, 0.50000000000000000, 
+	  0.69813170079773179 },
+  { 1.1178482279283477, 0.90000000000000013, 0.50000000000000000, 
+	  0.87266462599716477 },
+  { 1.5081455873012106, 0.90000000000000013, 0.50000000000000000, 
+	  1.0471975511965976 },
+  { 2.0213599730863998, 0.90000000000000013, 0.50000000000000000, 
+	  1.2217304763960306 },
+  { 2.6822467012926832, 0.90000000000000013, 0.50000000000000000, 
+	  1.3962634015954636 },
+  { 3.4591069002104686, 0.90000000000000013, 0.50000000000000000, 
+	  1.5707963267948966 },
+};
+const double toler186 = 2.5000000000000020e-13;
+
+// Test data for k=0.90000000000000013, nu=0.60000000000000009.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.4914274070443813e-16
+// mean(f - f_Boost): 3.4694469519536142e-16
+// variance(f - f_Boost): 2.5224926888894056e-31
+// stddev(f - f_Boost): 5.0224423231027804e-16
+const testcase_ellint_3<double>
+data187[10] =
+{
+  { 0.0000000000000000, 0.90000000000000013, 0.60000000000000009, 
+	  0.0000000000000000 },
+  { 0.17633073723493825, 0.90000000000000013, 0.60000000000000009, 
+	  0.17453292519943295 },
+  { 0.36386108723492810, 0.90000000000000013, 0.60000000000000009, 
+	  0.34906585039886590 },
+  { 0.57597424744716241, 0.90000000000000013, 0.60000000000000009, 
+	  0.52359877559829882 },
+  { 0.83098051948501150, 0.90000000000000013, 0.60000000000000009, 
+	  0.69813170079773179 },
+  { 1.1558706545698916, 0.90000000000000013, 0.60000000000000009, 
+	  0.87266462599716477 },
+  { 1.5905576379415669, 0.90000000000000013, 0.60000000000000009, 
+	  1.0471975511965976 },
+  { 2.1875186010215084, 0.90000000000000013, 0.60000000000000009, 
+	  1.2217304763960306 },
+  { 2.9885767771316853, 0.90000000000000013, 0.60000000000000009, 
+	  1.3962634015954636 },
+  { 3.9549939883570238, 0.90000000000000013, 0.60000000000000009, 
+	  1.5707963267948966 },
+};
+const double toler187 = 2.5000000000000020e-13;
+
+// Test data for k=0.90000000000000013, nu=0.70000000000000007.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 5.5442489886293633e-16
+// mean(f - f_Boost): 4.3576253716537392e-16
+// variance(f - f_Boost): 2.2187568928205130e-31
+// stddev(f - f_Boost): 4.7103682370070737e-16
+const testcase_ellint_3<double>
+data188[10] =
+{
+  { 0.0000000000000000, 0.90000000000000013, 0.70000000000000007, 
+	  0.0000000000000000 },
+  { 0.17651246700160939, 0.90000000000000013, 0.70000000000000007, 
+	  0.17453292519943295 },
+  { 0.36542993547358982, 0.90000000000000013, 0.70000000000000007, 
+	  0.34906585039886590 },
+  { 0.58199897877674867, 0.90000000000000013, 0.70000000000000007, 
+	  0.52359877559829882 },
+  { 0.84815633587352857, 0.90000000000000013, 0.70000000000000007, 
+	  0.69813170079773179 },
+  { 1.1985495623872375, 0.90000000000000013, 0.70000000000000007, 
+	  0.87266462599716477 },
+  { 1.6892158134027691, 0.90000000000000013, 0.70000000000000007, 
+	  1.0471975511965976 },
+  { 2.4029722191094236, 0.90000000000000013, 0.70000000000000007, 
+	  1.2217304763960306 },
+  { 3.4201084941340061, 0.90000000000000013, 0.70000000000000007, 
+	  1.3962634015954636 },
+  { 4.6985482312992444, 0.90000000000000013, 0.70000000000000007, 
+	  1.5707963267948966 },
+};
+const double toler188 = 2.5000000000000020e-13;
+
+// Test data for k=0.90000000000000013, nu=0.80000000000000004.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 4.9362432595976420e-16
+// mean(f - f_Boost): 3.0531133177191805e-16
+// variance(f - f_Boost): 1.1508025840536076e-32
+// stddev(f - f_Boost): 1.0727546709539920e-16
+const testcase_ellint_3<double>
+data189[10] =
+{
+  { 0.0000000000000000, 0.90000000000000013, 0.80000000000000004, 
+	  0.0000000000000000 },
+  { 0.17669487107954862, 0.90000000000000013, 0.80000000000000004, 
+	  0.17453292519943295 },
+  { 0.36702314729628421, 0.90000000000000013, 0.80000000000000004, 
+	  0.34906585039886590 },
+  { 0.58825099711365492, 0.90000000000000013, 0.80000000000000004, 
+	  0.52359877559829882 },
+  { 0.86661711422209031, 0.90000000000000013, 0.80000000000000004, 
+	  0.69813170079773179 },
+  { 1.2469779109884802, 0.90000000000000013, 0.80000000000000004, 
+	  0.87266462599716477 },
+  { 1.8105469760531578, 0.90000000000000013, 0.80000000000000004, 
+	  1.0471975511965976 },
+  { 2.6989505165893752, 0.90000000000000013, 0.80000000000000004, 
+	  1.2217304763960306 },
+  { 4.0935213267757433, 0.90000000000000013, 0.80000000000000004, 
+	  1.3962634015954636 },
+  { 5.9820740813645727, 0.90000000000000013, 0.80000000000000004, 
+	  1.5707963267948966 },
+};
+const double toler189 = 2.5000000000000020e-13;
+
+// Test data for k=0.90000000000000013, nu=0.90000000000000002.
+// max(|f - f_Boost|): 2.6645352591003757e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 4.9577148062669782e-16
+// mean(f - f_Boost): 5.9119376061289588e-16
+// variance(f - f_Boost): 1.7340883003959522e-31
+// stddev(f - f_Boost): 4.1642385863395872e-16
+const testcase_ellint_3<double>
+data190[10] =
+{
+  { 0.0000000000000000, 0.90000000000000013, 0.90000000000000002, 
+	  0.0000000000000000 },
+  { 0.17687795394604169, 0.90000000000000013, 0.90000000000000002, 
+	  0.17453292519943295 },
+  { 0.36864140434751286, 0.90000000000000013, 0.90000000000000002, 
+	  0.34906585039886590 },
+  { 0.59474595366817051, 0.90000000000000013, 0.90000000000000002, 
+	  0.52359877559829882 },
+  { 0.88654237226056665, 0.90000000000000013, 0.90000000000000002, 
+	  0.69813170079773179 },
+  { 1.3026595810616726, 0.90000000000000013, 0.90000000000000002, 
+	  0.87266462599716477 },
+  { 1.9653635459278080, 0.90000000000000013, 0.90000000000000002, 
+	  1.0471975511965976 },
+  { 3.1451407527189468, 0.90000000000000013, 0.90000000000000002, 
+	  1.2217304763960306 },
+  { 5.3745230680316132, 0.90000000000000013, 0.90000000000000002, 
+	  1.3962634015954636 },
+  { 8.9942562031858717, 0.90000000000000013, 0.90000000000000002, 
+	  1.5707963267948966 },
+};
+const double toler190 = 2.5000000000000020e-13;
+
+template<typename Ret, unsigned int Num>
+  void
+  test(const testcase_ellint_3<Ret> (&data)[Num], Ret toler)
+  {
+    bool test __attribute__((unused)) = true;
+    const Ret eps = std::numeric_limits<Ret>::epsilon();
+    Ret max_abs_diff = -Ret(1);
+    Ret max_abs_frac = -Ret(1);
+    unsigned int num_datum = Num;
+    for (unsigned int i = 0; i < num_datum; ++i)
+  	 {
+	const Ret f = std::tr1::ellint_3(data[i].k, data[i].nu,
+		     data[i].phi);
+	const Ret f0 = data[i].f0;
+	const Ret diff = f - f0;
+	if (std::abs(diff) > max_abs_diff)
+	  max_abs_diff = std::abs(diff);
+	if (std::abs(f0) > Ret(10) * eps
+	 && std::abs(f) > Ret(10) * eps)
+	  {
+	    const Ret frac = diff / f0;
+	    if (std::abs(frac) > max_abs_frac)
+	      max_abs_frac = std::abs(frac);
+	  }
+      }
+    VERIFY(max_abs_frac < toler);
+  }
 
-int main(int, char**)
-{
-  test001<double>();
-  test002<double>();
-  test003<double>();
-  test004<double>();
-  test005<double>();
-  test006<double>();
-  test007<double>();
-  test008<double>();
-  test009<double>();
-  test010<double>();
-  test011<double>();
-  test012<double>();
-  test013<double>();
-  test014<double>();
-  test015<double>();
-  test016<double>();
-  test017<double>();
-  test018<double>();
-  test019<double>();
-  test020<double>();
-  test021<double>();
-  test022<double>();
-  test023<double>();
-  test024<double>();
-  test025<double>();
-  test026<double>();
-  test027<double>();
-  test028<double>();
-  test029<double>();
-  test030<double>();
-  test031<double>();
-  test032<double>();
-  test033<double>();
-  test034<double>();
-  test035<double>();
-  test036<double>();
-  test037<double>();
-  test038<double>();
-  test039<double>();
-  test040<double>();
-  test041<double>();
-  test042<double>();
-  test043<double>();
-  test044<double>();
-  test045<double>();
-  test046<double>();
-  test047<double>();
-  test048<double>();
-  test049<double>();
-  test050<double>();
-  test051<double>();
-  test052<double>();
-  test053<double>();
-  test054<double>();
-  test055<double>();
-  test056<double>();
-  test057<double>();
-  test058<double>();
-  test059<double>();
-  test060<double>();
-  test061<double>();
-  test062<double>();
-  test063<double>();
-  test064<double>();
-  test065<double>();
-  test066<double>();
-  test067<double>();
-  test068<double>();
-  test069<double>();
-  test070<double>();
-  test071<double>();
-  test072<double>();
-  test073<double>();
-  test074<double>();
-  test075<double>();
-  test076<double>();
-  test077<double>();
-  test078<double>();
-  test079<double>();
-  test080<double>();
-  test081<double>();
-  test082<double>();
-  test083<double>();
-  test084<double>();
-  test085<double>();
-  test086<double>();
-  test087<double>();
-  test088<double>();
-  test089<double>();
-  test090<double>();
-  test091<double>();
-  test092<double>();
-  test093<double>();
-  test094<double>();
-  test095<double>();
-  test096<double>();
-  test097<double>();
-  test098<double>();
-  test099<double>();
-  test100<double>();
-  test101<double>();
-  test102<double>();
-  test103<double>();
-  test104<double>();
-  test105<double>();
-  test106<double>();
-  test107<double>();
-  test108<double>();
-  test109<double>();
-  test110<double>();
-  test111<double>();
-  test112<double>();
-  test113<double>();
-  test114<double>();
-  test115<double>();
-  test116<double>();
-  test117<double>();
-  test118<double>();
-  test119<double>();
-  test120<double>();
-  test121<double>();
-  test122<double>();
-  test123<double>();
-  test124<double>();
-  test125<double>();
-  test126<double>();
-  test127<double>();
-  test128<double>();
-  test129<double>();
-  test130<double>();
-  test131<double>();
-  test132<double>();
-  test133<double>();
-  test134<double>();
-  test135<double>();
-  test136<double>();
-  test137<double>();
-  test138<double>();
-  test139<double>();
-  test140<double>();
-  test141<double>();
-  test142<double>();
-  test143<double>();
-  test144<double>();
-  test145<double>();
-  test146<double>();
-  test147<double>();
-  test148<double>();
-  test149<double>();
-  test150<double>();
-  test151<double>();
-  test152<double>();
-  test153<double>();
-  test154<double>();
-  test155<double>();
-  test156<double>();
-  test157<double>();
-  test158<double>();
-  test159<double>();
-  test160<double>();
-  test161<double>();
-  test162<double>();
-  test163<double>();
-  test164<double>();
-  test165<double>();
-  test166<double>();
-  test167<double>();
-  test168<double>();
-  test169<double>();
-  test170<double>();
-  test171<double>();
-  test172<double>();
-  test173<double>();
-  test174<double>();
-  test175<double>();
-  test176<double>();
-  test177<double>();
-  test178<double>();
-  test179<double>();
-  test180<double>();
-  test181<double>();
-  test182<double>();
-  test183<double>();
-  test184<double>();
-  test185<double>();
-  test186<double>();
-  test187<double>();
-  test188<double>();
-  test189<double>();
-  test190<double>();
+int
+main()
+{
+  test(data001, toler001);
+  test(data002, toler002);
+  test(data003, toler003);
+  test(data004, toler004);
+  test(data005, toler005);
+  test(data006, toler006);
+  test(data007, toler007);
+  test(data008, toler008);
+  test(data009, toler009);
+  test(data010, toler010);
+  test(data011, toler011);
+  test(data012, toler012);
+  test(data013, toler013);
+  test(data014, toler014);
+  test(data015, toler015);
+  test(data016, toler016);
+  test(data017, toler017);
+  test(data018, toler018);
+  test(data019, toler019);
+  test(data020, toler020);
+  test(data021, toler021);
+  test(data022, toler022);
+  test(data023, toler023);
+  test(data024, toler024);
+  test(data025, toler025);
+  test(data026, toler026);
+  test(data027, toler027);
+  test(data028, toler028);
+  test(data029, toler029);
+  test(data030, toler030);
+  test(data031, toler031);
+  test(data032, toler032);
+  test(data033, toler033);
+  test(data034, toler034);
+  test(data035, toler035);
+  test(data036, toler036);
+  test(data037, toler037);
+  test(data038, toler038);
+  test(data039, toler039);
+  test(data040, toler040);
+  test(data041, toler041);
+  test(data042, toler042);
+  test(data043, toler043);
+  test(data044, toler044);
+  test(data045, toler045);
+  test(data046, toler046);
+  test(data047, toler047);
+  test(data048, toler048);
+  test(data049, toler049);
+  test(data050, toler050);
+  test(data051, toler051);
+  test(data052, toler052);
+  test(data053, toler053);
+  test(data054, toler054);
+  test(data055, toler055);
+  test(data056, toler056);
+  test(data057, toler057);
+  test(data058, toler058);
+  test(data059, toler059);
+  test(data060, toler060);
+  test(data061, toler061);
+  test(data062, toler062);
+  test(data063, toler063);
+  test(data064, toler064);
+  test(data065, toler065);
+  test(data066, toler066);
+  test(data067, toler067);
+  test(data068, toler068);
+  test(data069, toler069);
+  test(data070, toler070);
+  test(data071, toler071);
+  test(data072, toler072);
+  test(data073, toler073);
+  test(data074, toler074);
+  test(data075, toler075);
+  test(data076, toler076);
+  test(data077, toler077);
+  test(data078, toler078);
+  test(data079, toler079);
+  test(data080, toler080);
+  test(data081, toler081);
+  test(data082, toler082);
+  test(data083, toler083);
+  test(data084, toler084);
+  test(data085, toler085);
+  test(data086, toler086);
+  test(data087, toler087);
+  test(data088, toler088);
+  test(data089, toler089);
+  test(data090, toler090);
+  test(data091, toler091);
+  test(data092, toler092);
+  test(data093, toler093);
+  test(data094, toler094);
+  test(data095, toler095);
+  test(data096, toler096);
+  test(data097, toler097);
+  test(data098, toler098);
+  test(data099, toler099);
+  test(data100, toler100);
+  test(data101, toler101);
+  test(data102, toler102);
+  test(data103, toler103);
+  test(data104, toler104);
+  test(data105, toler105);
+  test(data106, toler106);
+  test(data107, toler107);
+  test(data108, toler108);
+  test(data109, toler109);
+  test(data110, toler110);
+  test(data111, toler111);
+  test(data112, toler112);
+  test(data113, toler113);
+  test(data114, toler114);
+  test(data115, toler115);
+  test(data116, toler116);
+  test(data117, toler117);
+  test(data118, toler118);
+  test(data119, toler119);
+  test(data120, toler120);
+  test(data121, toler121);
+  test(data122, toler122);
+  test(data123, toler123);
+  test(data124, toler124);
+  test(data125, toler125);
+  test(data126, toler126);
+  test(data127, toler127);
+  test(data128, toler128);
+  test(data129, toler129);
+  test(data130, toler130);
+  test(data131, toler131);
+  test(data132, toler132);
+  test(data133, toler133);
+  test(data134, toler134);
+  test(data135, toler135);
+  test(data136, toler136);
+  test(data137, toler137);
+  test(data138, toler138);
+  test(data139, toler139);
+  test(data140, toler140);
+  test(data141, toler141);
+  test(data142, toler142);
+  test(data143, toler143);
+  test(data144, toler144);
+  test(data145, toler145);
+  test(data146, toler146);
+  test(data147, toler147);
+  test(data148, toler148);
+  test(data149, toler149);
+  test(data150, toler150);
+  test(data151, toler151);
+  test(data152, toler152);
+  test(data153, toler153);
+  test(data154, toler154);
+  test(data155, toler155);
+  test(data156, toler156);
+  test(data157, toler157);
+  test(data158, toler158);
+  test(data159, toler159);
+  test(data160, toler160);
+  test(data161, toler161);
+  test(data162, toler162);
+  test(data163, toler163);
+  test(data164, toler164);
+  test(data165, toler165);
+  test(data166, toler166);
+  test(data167, toler167);
+  test(data168, toler168);
+  test(data169, toler169);
+  test(data170, toler170);
+  test(data171, toler171);
+  test(data172, toler172);
+  test(data173, toler173);
+  test(data174, toler174);
+  test(data175, toler175);
+  test(data176, toler176);
+  test(data177, toler177);
+  test(data178, toler178);
+  test(data179, toler179);
+  test(data180, toler180);
+  test(data181, toler181);
+  test(data182, toler182);
+  test(data183, toler183);
+  test(data184, toler184);
+  test(data185, toler185);
+  test(data186, toler186);
+  test(data187, toler187);
+  test(data188, toler188);
+  test(data189, toler189);
+  test(data190, toler190);
   return 0;
 }
diff --git a/libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/14_ellint_3/pr66689.cc b/libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/14_ellint_3/pr66689.cc
new file mode 100644
index 00000000000..1ee5f4f07f4
--- /dev/null
+++ b/libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/14_ellint_3/pr66689.cc
@@ -0,0 +1,22 @@
+
+#include <tr1/cmath>
+#include <testsuite_hooks.h>
+
+void
+test01()
+{
+  const double pi = 3.141592654;
+
+  double Pi1 = std::tr1::ellint_3(0.75, 0.0, pi / 2.0);
+  VERIFY(std::abs(Pi1 - 1.91099) < 0.00001);
+
+  double Pi2 = std::tr1::ellint_3(0.75, 0.5, pi / 2.0);
+  VERIFY(std::abs(Pi2 - 2.80011) < 0.00001);
+}
+
+int
+main()
+{
+  test01();
+  return 0;
+}
diff --git a/libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/15_expint/pr68397.cc b/libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/15_expint/pr68397.cc
new file mode 100644
index 00000000000..60d0b68bad6
--- /dev/null
+++ b/libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/15_expint/pr68397.cc
@@ -0,0 +1,46 @@
+// Copyright (C) 2017 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// PR libstdc++/68397 -  std::tr1::expint fails in __expint_En_cont_frac
+// for some long double arguments due to low __max_iter value
+
+#include <tr1/cmath>
+#include <testsuite_hooks.h>
+
+void
+test01()
+{
+  // Answers from Wolfram Alpha.
+  long double ans_ok = -0.10001943365331651406888645149537315243646135979573L;
+  long double ans_bomb = -0.10777727809650077516264612749163100483995270163783L;
+
+  long double Ei_ok = std::tr1::expint(-1.500001L);
+  long double diff_ok = std::abs(Ei_ok - ans_ok);
+  VERIFY(diff_ok < 1.0e-15L);
+
+  long double Ei_bomb = std::tr1::expint(-1.450001L);
+  long double diff_bomb = std::abs(Ei_bomb - ans_bomb);
+  VERIFY(diff_bomb < 1.0e-15L);
+}
+
+int
+main()
+{
+  test01();
+  return 0;
+}
+
diff --git a/libstdc++-v3/testsuite/util/testsuite_allocator.h b/libstdc++-v3/testsuite/util/testsuite_allocator.h
index 813fc81088a..56c27089e84 100644
--- a/libstdc++-v3/testsuite/util/testsuite_allocator.h
+++ b/libstdc++-v3/testsuite/util/testsuite_allocator.h
@@ -570,6 +570,8 @@ namespace __gnu_test
 
       explicit PointerBase(T* p = nullptr) : value(p) { }
 
+      PointerBase(std::nullptr_t) : value(nullptr) { }
+
       template<typename D, typename U,
 	       typename = decltype(static_cast<T*>(std::declval<U*>()))>
 	PointerBase(const PointerBase<D, U>& p) : value(p.value) { }
@@ -603,7 +605,11 @@ namespace __gnu_test
       }
 
     private:
-      Derived& derived() { return static_cast<Derived&>(*this); }
+      Derived&
+      derived() { return static_cast<Derived&>(*this); }
+
+      const Derived&
+      derived() const { return static_cast<const Derived&>(*this); }
     };
 
     template<typename D, typename T>
diff --git a/libvtv/ChangeLog b/libvtv/ChangeLog
index 4f4d7e00de4..c77d1b3bdac 100644
--- a/libvtv/ChangeLog
+++ b/libvtv/ChangeLog
@@ -1,3 +1,15 @@
+2018-12-06  Release Manager
+
+	* GCC 7.4.0 released.
+
+2018-06-22  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-04-18  David Malcolm  <dmalcolm@redhat.com>
+
+	PR jit/85384
+	* configure: Regenerate.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
diff --git a/libvtv/configure b/libvtv/configure
index c3bed2dfc70..dfb9162c79f 100755
--- a/libvtv/configure
+++ b/libvtv/configure
@@ -15516,7 +15516,7 @@ fi
 # Check whether --with-gcc-major-version-only was given.
 if test "${with_gcc_major_version_only+set}" = set; then :
   withval=$with_gcc_major_version_only; if test x$with_gcc_major_version_only = xyes ; then
-        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*\$\$/\1/'"
+        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*/\1/'"
       fi
 
 fi
diff --git a/lto-plugin/ChangeLog b/lto-plugin/ChangeLog
index 954d7821cd0..64e4369b19c 100644
--- a/lto-plugin/ChangeLog
+++ b/lto-plugin/ChangeLog
@@ -1,3 +1,7 @@
+2018-12-06  Release Manager
+
+	* GCC 7.4.0 released.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
diff --git a/maintainer-scripts/ChangeLog b/maintainer-scripts/ChangeLog
index 656bdfa253b..96f7953d9e5 100644
--- a/maintainer-scripts/ChangeLog
+++ b/maintainer-scripts/ChangeLog
@@ -1,3 +1,7 @@
+2018-12-06  Release Manager
+
+	* GCC 7.4.0 released.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
diff --git a/zlib/ChangeLog b/zlib/ChangeLog
index 4d613481e75..a8de51f66e9 100644
--- a/zlib/ChangeLog
+++ b/zlib/ChangeLog
@@ -1,3 +1,7 @@
+2018-12-06  Release Manager
+
+	* GCC 7.4.0 released.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
